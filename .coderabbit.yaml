# yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json
reviews:
  suggested_labels: true
  auto_apply_labels: true
  labeling_instructions:
    - label: bug
      instructions: Apply when the PR fixes a bug or regression, includes test changes that verify a fix, or references a bug in the title or description.
    - label: feature
      instructions: Apply when the PR adds new functionality, features, or capabilities.
    - label: refactor
      instructions: Apply when the PR restructures code without changing external behavior, such as simplifying logic or improving readability.
    - label: test
      instructions: Apply when the PR adds or updates tests, especially in test directories or files with `.spec.` or `.test.` in the name.
    - label: docs
      instructions: Apply when the PR modifies markdown, READMEs, or documentation content.
    - label: chore
      instructions: Apply when the PR makes non-functional changes like build updates, dependency bumps, or CI tweaks.
  path_instructions:
    - path: "system-tests/**/*"
      instructions: >
        For Playwright system tests, make sure each test that triggers a backend mutation (e.g., clicking a save button)
        waits for a UI confirmation element that proves the request completed successfully before proceeding.
        Otherwise, the test might continue before the operation finishes.

        Also if someone navigates to a course page, and clicks continue on a dialog straight away, make sure its done with the
        `selectCourseInstanceIfPrompted` function.

        If someone write a tests that depends on a toast staying on the screen, make sure to use the `showNextToastsInfinitely`, and `showToastsNormally` functions. If those are used in conjunction with `expectScreenshotsToMatchSnapshots`, you should set its argument of `dontWaitForSpinnersToDisappear` to true.

        For dialog interactions, use the helper functions from `system-tests/src/utils/dialogs.ts`:
        - Use `dismissAlertDialog` for alert dialogs
        - Use `respondToConfirmDialog` for confirm dialogs (Yes/No)
        - Use `fillPromptDialog` for prompt dialogs with input fields

        NEVER select elements by auto-generated CSS classes (e.g., `.locator(".css-xknul2-TopBar")`). Instead, use semantic selectors like data-testid attributes, role selectors,
        text content, or accessible names. Use `page.getByTestId()`, `page.getByRole()`, `page.getByText()`,
        or `page.getByLabel()` instead.

    - path: "**/*.tsx"
      instructions: >
        Make sure to use the `useTranslation` hook for all text that is visible to the user.

        If a component uses colors, use colors from the theme if possible. Example: import { baseTheme } from "@/shared-module/common/styles" ... background: ${baseTheme.colors.clear[100]};

        If a component uses media queries, use the respondToOrLarger function. Example: import { respondToOrLarger } from "@/shared-module/common/styles/respond" ... ${respondToOrLarger.sm} { ... }

        If component sends requests to server, use either useQuery, or useToastMutation hooks, or use hooks wrapping those hooks.

        If there is a form of any kind, make sure it uses useForm from react-hook-form, and make sure the form is integrated with the useToastMutation and useQuery hooks.

        For loading and error states, use the Spinner and ErrorBanner components from the shared module.

        We have better replacements for window.confirm, window.alert, and window.prompt, use the DialogProvider and the useDialog hook from the shared module instead.

        For calling the React hooks useMemo and useEffect, don't use the React. prefix.

        If a component uses fonts, use fonts from the theme if possible. Example: import { primaryFont } from "@/shared-module/common/styles" ... font-family: ${primaryFont};

    - path: "services/headless-lms/models/src/**/*.rs"
      instructions: >
        All sql queries should be written with the macros from the sqlx crate. Macros end with an exclamation mark. Example good functions: query!, query_as!, query_scalar!, query_file!, etc. Example bad functions: query, query_as, query_scalar, query_file, etc.

        If a transaction is started it should be committed or rolled back before the transaction goes out of scope. Example: `let mut tx = conn.begin().await?; ... tx.commit().await?;`

        All UPDATE queries that set `deleted_at = now()` MUST include `AND deleted_at IS NULL` in the WHERE clause to prevent overwriting timestamps for already-deleted records.
        Example: `UPDATE table SET deleted_at = now() WHERE id = $1 AND deleted_at IS NULL`

    - path: "**/*.rs"
      instructions: >
        No unwraps at all in non-test code. Avoid also .expect() calls outside of tests, with the exception when the program is starting up so that it would crash immediately for example when an environment variable is not set.

        No sql queries in code that is not within the models crate. If one needs to fetch data from the database, instead add a new function to the models crate and call that one.
