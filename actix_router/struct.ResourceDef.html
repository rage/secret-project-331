<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Describes the set of paths that match to a resource."><title>ResourceDef in actix_router - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="actix_router" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.1 (e71f9a9a9 2025-01-27)" data-channel="1.84.1" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://actix.rs/favicon.ico"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../actix_router/index.html"><img src="https://actix.rs/img/logo.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../actix_router/index.html"><img src="https://actix.rs/img/logo.png" alt="logo"></a><h2><a href="../actix_router/index.html">actix_<wbr>router</a><span class="version">0.5.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Resource<wbr>Def</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#pattern-format-and-matching-behavior" title="Pattern Format and Matching Behavior">Pattern Format and Matching Behavior</a></li><li><a href="#static-resources" title="Static Resources">Static Resources</a><ul><li><a href="#examples" title="Examples">Examples</a></li></ul></li><li><a href="#dynamic-segments" title="Dynamic Segments">Dynamic Segments</a><ul><li><a href="#examples-1" title="Examples">Examples</a></li></ul></li><li><a href="#prefix-resources" title="Prefix Resources">Prefix Resources</a><ul><li><a href="#examples-2" title="Examples">Examples</a></li></ul></li><li><a href="#custom-regex-segments" title="Custom Regex Segments">Custom Regex Segments</a><ul><li><a href="#examples-3" title="Examples">Examples</a></li></ul></li><li><a href="#tail-segments" title="Tail Segments">Tail Segments</a><ul><li><a href="#examples-4" title="Examples">Examples</a></li></ul></li><li><a href="#multi-pattern-resources" title="Multi-Pattern Resources">Multi-Pattern Resources</a><ul><li><a href="#examples-5" title="Examples">Examples</a></li></ul></li><li><a href="#trailing-slashes" title="Trailing Slashes">Trailing Slashes</a><ul><li><a href="#examples-6" title="Examples">Examples</a></li></ul></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.capture_match_info" title="capture_match_info">capture_match_info</a></li><li><a href="#method.capture_match_info_fn" title="capture_match_info_fn">capture_match_info_fn</a></li><li><a href="#method.find_match" title="find_match">find_match</a></li><li><a href="#method.id" title="id">id</a></li><li><a href="#method.is_match" title="is_match">is_match</a></li><li><a href="#method.is_prefix" title="is_prefix">is_prefix</a></li><li><a href="#method.join" title="join">join</a></li><li><a href="#method.name" title="name">name</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.pattern" title="pattern">pattern</a></li><li><a href="#method.pattern_iter" title="pattern_iter">pattern_iter</a></li><li><a href="#method.prefix" title="prefix">prefix</a></li><li><a href="#method.resource_path_from_iter" title="resource_path_from_iter">resource_path_from_iter</a></li><li><a href="#method.resource_path_from_map" title="resource_path_from_map">resource_path_from_map</a></li><li><a href="#method.root_prefix" title="root_prefix">root_prefix</a></li><li><a href="#method.set_id" title="set_id">set_id</a></li><li><a href="#method.set_name" title="set_name">set_name</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-ResourceDef" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-ResourceDef" title="Debug">Debug</a></li><li><a href="#impl-Eq-for-ResourceDef" title="Eq">Eq</a></li><li><a href="#impl-From%3C%26str%3E-for-ResourceDef" title="From&#60;&#38;&#39;a str&#62;">From&#60;&#38;&#39;a str&#62;</a></li><li><a href="#impl-From%3CString%3E-for-ResourceDef" title="From&#60;String&#62;">From&#60;String&#62;</a></li><li><a href="#impl-Hash-for-ResourceDef" title="Hash">Hash</a></li><li><a href="#impl-PartialEq-for-ResourceDef" title="PartialEq">PartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-ResourceDef" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-ResourceDef" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-ResourceDef" title="Send">Send</a></li><li><a href="#impl-Sync-for-ResourceDef" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-ResourceDef" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-ResourceDef" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate actix_<wbr>router</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="index.html">actix_router</a></span><h1>Struct <span class="struct">ResourceDef</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/actix_router/resource.rs.html#212-228">Source</a> </span></div><pre class="rust item-decl"><code>pub struct ResourceDef { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Describes the set of paths that match to a resource.</p>
<p><code>ResourceDef</code>s are effectively a way to transform the a custom resource pattern syntax into
suitable regular expressions from which to check matches with paths and capture portions of a
matched path into variables. Common cases are on a fast path that avoids going through the
regex engine.</p>
<h2 id="pattern-format-and-matching-behavior"><a class="doc-anchor" href="#pattern-format-and-matching-behavior">§</a>Pattern Format and Matching Behavior</h2>
<p>Resource pattern is defined as a string of zero or more <em>segments</em> where each segment is
preceded by a slash <code>/</code>.</p>
<p>This means that pattern string <strong>must</strong> either be empty or begin with a slash (<code>/</code>). This also
implies that a trailing slash in pattern defines an empty segment. For example, the pattern
<code>"/user/"</code> has two segments: <code>["user", ""]</code></p>
<p>A key point to understand is that <code>ResourceDef</code> matches segments, not strings. Segments are
matched individually. For example, the pattern <code>/user/</code> is not considered a prefix for the path
<code>/user/123/456</code>, because the second segment doesn’t match: <code>["user", ""]</code>
vs <code>["user", "123", "456"]</code>.</p>
<p>This definition is consistent with the definition of absolute URL path in
<a href="https://datatracker.ietf.org/doc/html/rfc3986#section-3.3">RFC 3986 §3.3</a></p>
<h2 id="static-resources"><a class="doc-anchor" href="#static-resources">§</a>Static Resources</h2>
<p>A static resource is the most basic type of definition. Pass a pattern to <a href="struct.ResourceDef.html#method.new" title="associated function actix_router::ResourceDef::new">new</a>.
Conforming paths must match the pattern exactly.</p>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::new(<span class="string">"/home"</span>);

<span class="macro">assert!</span>(resource.is_match(<span class="string">"/home"</span>));

<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/home/"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/home/new"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/homes"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/search"</span>));</code></pre></div>
<h2 id="dynamic-segments"><a class="doc-anchor" href="#dynamic-segments">§</a>Dynamic Segments</h2>
<p>Also known as “path parameters”. Resources can define sections of a pattern that be extracted
from a conforming path, if it conforms to (one of) the resource pattern(s).</p>
<p>The marker for a dynamic segment is curly braces wrapping an identifier. For example,
<code>/user/{id}</code> would match paths like <code>/user/123</code> or <code>/user/james</code> and be able to extract the user
IDs “123” and “james”, respectively.</p>
<p>However, this resource pattern (<code>/user/{id}</code>) would, not cover <code>/user/123/stars</code> (unless
constructed as a prefix; see next section) since the default pattern for segments matches all
characters until it finds a <code>/</code> character (or the end of the path). Custom segment patterns are
covered further down.</p>
<p>Dynamic segments do not need to be delimited by <code>/</code> characters, they can be defined within a
path segment. For example, <code>/rust-is-{opinion}</code> can match the paths <code>/rust-is-cool</code> and
<code>/rust-is-hard</code>.</p>
<p>For information on capturing segment values from paths or other custom resource types,
see <a href="struct.ResourceDef.html#method.capture_match_info" title="method actix_router::ResourceDef::capture_match_info"><code>capture_match_info</code></a>
and <a href="struct.ResourceDef.html#method.capture_match_info_fn" title="method actix_router::ResourceDef::capture_match_info_fn"><code>capture_match_info_fn</code></a>.</p>
<p>A resource definition can contain at most 16 dynamic segments.</p>
<h3 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::{Path, ResourceDef};

<span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">"/user/{id}"</span>);

<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/user"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/user/"</span>));

<span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">"/user/123"</span>);
resource.capture_match_info(<span class="kw-2">&amp;mut </span>path);
<span class="macro">assert_eq!</span>(path.get(<span class="string">"id"</span>).unwrap(), <span class="string">"123"</span>);</code></pre></div>
<h2 id="prefix-resources"><a class="doc-anchor" href="#prefix-resources">§</a>Prefix Resources</h2>
<p>A prefix resource is defined as pattern that can match just the start of a path, up to a
segment boundary.</p>
<p>Prefix patterns with a trailing slash may have an unexpected, though correct, behavior.
They define and therefore require an empty segment in order to match. It is easier to understand
this behavior after reading the <a href="#pattern-format-and-matching-behavior">matching behavior section</a>. Examples are given below.</p>
<p>The empty pattern (<code>""</code>), as a prefix, matches any path.</p>
<p>Prefix resources can contain dynamic segments.</p>
<h3 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">"/home"</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/home"</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/home/new"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/homes"</span>));

<span class="comment">// prefix pattern with a trailing slash
</span><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">"/user/{id}/"</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123/"</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123//stars"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/user/123/stars"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/user/123"</span>));</code></pre></div>
<h2 id="custom-regex-segments"><a class="doc-anchor" href="#custom-regex-segments">§</a>Custom Regex Segments</h2>
<p>Dynamic segments can be customised to only match a specific regular expression. It can be
helpful to do this if resource definitions would otherwise conflict and cause one to
be inaccessible.</p>
<p>The regex used when capturing segment values can be specified explicitly using this syntax:
<code>{name:regex}</code>. For example, <code>/user/{id:\d+}</code> will only match paths where the user ID
is numeric.</p>
<p>The regex could potentially match multiple segments. If this is not wanted, then care must be
taken to avoid matching a slash <code>/</code>. It is guaranteed, however, that the match ends at a
segment boundary; the pattern <code>r"(/|$)</code> is always appended to the regex.</p>
<p>By default, dynamic segments use this regex: <code>[^/]+</code>. This shows why it is the case, as shown in
the earlier section, that segments capture a slice of the path up to the next <code>/</code> character.</p>
<p>Custom regex segments can be used in static and prefix resource definition variants.</p>
<h3 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::new(<span class="string">r"/user/{id:\d+}"</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123"</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/314159"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/user/abc"</span>));</code></pre></div>
<h2 id="tail-segments"><a class="doc-anchor" href="#tail-segments">§</a>Tail Segments</h2>
<p>As a shortcut to defining a custom regex for matching <em>all</em> remaining characters (not just those
up until a <code>/</code> character), there is a special pattern to match (and capture) the remaining
path portion.</p>
<p>To do this, use the segment pattern: <code>{name}*</code>. Since a tail segment also has a name, values are
extracted in the same way as non-tail dynamic segments.</p>
<h3 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::new(<span class="string">"/blob/{tail}*"</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/blob/HEAD/Cargo.toml"</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/blob/HEAD/README.md"</span>));

<span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">"/blob/main/LICENSE"</span>);
resource.capture_match_info(<span class="kw-2">&amp;mut </span>path);
<span class="macro">assert_eq!</span>(path.get(<span class="string">"tail"</span>).unwrap(), <span class="string">"main/LICENSE"</span>);</code></pre></div>
<h2 id="multi-pattern-resources"><a class="doc-anchor" href="#multi-pattern-resources">§</a>Multi-Pattern Resources</h2>
<p>For resources that can map to multiple distinct paths, it may be suitable to use
multi-pattern resources by passing an array/vec to <a href="struct.ResourceDef.html#method.new" title="associated function actix_router::ResourceDef::new"><code>new</code></a>. They will be combined
into a regex set which is usually quicker to check matches on than checking each
pattern individually.</p>
<p>Multi-pattern resources can contain dynamic segments just like single pattern ones.
However, take care to use consistent and semantically-equivalent segment names; it could affect
expectations in the router using these definitions and cause runtime panics.</p>
<h3 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::new([<span class="string">"/home"</span>, <span class="string">"/index"</span>]);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/home"</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/index"</span>));</code></pre></div>
<h2 id="trailing-slashes"><a class="doc-anchor" href="#trailing-slashes">§</a>Trailing Slashes</h2>
<p>It should be noted that this library takes no steps to normalize intra-path or trailing slashes.
As such, all resource definitions implicitly expect a pre-processing step to normalize paths if
you wish to accommodate “recoverable” path errors. Below are several examples of resource-path
pairs that would not be compatible.</p>
<h3 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(!ResourceDef::new(<span class="string">"/root"</span>).is_match(<span class="string">"/root/"</span>));
<span class="macro">assert!</span>(!ResourceDef::new(<span class="string">"/root/"</span>).is_match(<span class="string">"/root"</span>));
<span class="macro">assert!</span>(!ResourceDef::prefix(<span class="string">"/root/"</span>).is_match(<span class="string">"/root"</span>));</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-ResourceDef" class="impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#252-1079">Source</a><a href="#impl-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#276-278">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>&lt;T: <a class="trait" href="trait.IntoPatterns.html" title="trait actix_router::IntoPatterns">IntoPatterns</a>&gt;(paths: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new resource definition from patterns.</p>
<p>Multi-pattern resources can be constructed by providing a slice (or vec) of patterns.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if any path patterns are malformed.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="kw">let </span>resource = ResourceDef::new(<span class="string">"/user/{id}"</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/user/123/stars"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"user/1234"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/foo"</span>));

<span class="kw">let </span>resource = ResourceDef::new([<span class="string">"/profile"</span>, <span class="string">"/user/{id}"</span>]);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/profile"</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"user/123"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/foo"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prefix" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#303-305">Source</a><h4 class="code-header">pub fn <a href="#method.prefix" class="fn">prefix</a>&lt;T: <a class="trait" href="trait.IntoPatterns.html" title="trait actix_router::IntoPatterns">IntoPatterns</a>&gt;(paths: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new resource definition using a pattern that performs prefix matching.</p>
<p>More specifically, the regular expressions generated for matching are different when using
this method vs using <code>new</code>; they will not be appended with the <code>$</code> meta-character that
matches the end of an input.</p>
<p>Although it will compile and run correctly, it is meaningless to construct a prefix
resource definition with a tail segment; use <a href="struct.ResourceDef.html#method.new" title="associated function actix_router::ResourceDef::new"><code>new</code></a> in this case.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>Panics if path pattern is malformed.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">"/user/{id}"</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123"</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123/stars"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"user/123"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"user/123/stars"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/foo"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.root_prefix" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#327-329">Source</a><h4 class="code-header">pub fn <a href="#method.root_prefix" class="fn">root_prefix</a>(path: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new resource definition using a string pattern that performs prefix matching,
ensuring a leading <code>/</code> if pattern is not empty.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h5>
<p>Panics if path pattern is malformed.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="kw">let </span>resource = ResourceDef::root_prefix(<span class="string">"user/{id}"</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;</span>ResourceDef::prefix(<span class="string">"/user/{id}"</span>));
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;</span>ResourceDef::root_prefix(<span class="string">"/user/{id}"</span>));
<span class="macro">assert_ne!</span>(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;</span>ResourceDef::new(<span class="string">"user/{id}"</span>));
<span class="macro">assert_ne!</span>(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;</span>ResourceDef::new(<span class="string">"/user/{id}"</span>));

<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"user/123"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.id" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#344-346">Source</a><h4 class="code-header">pub fn <a href="#method.id" class="fn">id</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.u16.html">u16</a></h4></section></summary><div class="docblock"><p>Returns a numeric resource ID.</p>
<p>If not explicitly set using <a href="struct.ResourceDef.html#method.set_id" title="method actix_router::ResourceDef::set_id"><code>set_id</code></a>, this will return <code>0</code>.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">"/root"</span>);
<span class="macro">assert_eq!</span>(resource.id(), <span class="number">0</span>);

resource.set_id(<span class="number">42</span>);
<span class="macro">assert_eq!</span>(resource.id(), <span class="number">42</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_id" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#357-359">Source</a><h4 class="code-header">pub fn <a href="#method.set_id" class="fn">set_id</a>(&amp;mut self, id: <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.u16.html">u16</a>)</h4></section></summary><div class="docblock"><p>Set numeric resource ID.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">"/root"</span>);
resource.set_id(<span class="number">42</span>);
<span class="macro">assert_eq!</span>(resource.id(), <span class="number">42</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.name" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#371-373">Source</a><h4 class="code-header">pub fn <a href="#method.name" class="fn">name</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.84.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns resource definition name, if set.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">"/root"</span>);
<span class="macro">assert!</span>(resource.name().is_none());

resource.set_name(<span class="string">"root"</span>);
<span class="macro">assert_eq!</span>(resource.name().unwrap(), <span class="string">"root"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_name" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#387-393">Source</a><h4 class="code-header">pub fn <a href="#method.set_name" class="fn">set_name</a>(&amp;mut self, name: impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.84.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;)</h4></section></summary><div class="docblock"><p>Assigns a new name to the resource.</p>
<h5 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h5>
<p>Panics if <code>name</code> is an empty string.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">"/root"</span>);
resource.set_name(<span class="string">"root"</span>);
<span class="macro">assert_eq!</span>(resource.name().unwrap(), <span class="string">"root"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_prefix" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#403-405">Source</a><h4 class="code-header">pub fn <a href="#method.is_prefix" class="fn">is_prefix</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if pattern type is prefix.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(ResourceDef::prefix(<span class="string">"/user"</span>).is_prefix());
<span class="macro">assert!</span>(!ResourceDef::new(<span class="string">"/user"</span>).is_prefix());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#421-426">Source</a><h4 class="code-header">pub fn <a href="#method.pattern" class="fn">pattern</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.84.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the pattern string that generated the resource definition.</p>
<p>If definition is constructed with multiple patterns, the first pattern is returned. To get
all patterns, use <a href="struct.ResourceDef.html#method.pattern_iter" title="method actix_router::ResourceDef::pattern_iter"><code>patterns_iter</code></a>. If resource has 0 patterns,
returns <code>None</code>.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">"/user/{id}"</span>);
<span class="macro">assert_eq!</span>(resource.pattern().unwrap(), <span class="string">"/user/{id}"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new([<span class="string">"/profile"</span>, <span class="string">"/user/{id}"</span>]);
<span class="macro">assert_eq!</span>(resource.pattern(), <span class="prelude-val">Some</span>(<span class="string">"/profile"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_iter" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#443-491">Source</a><h4 class="code-header">pub fn <a href="#method.pattern_iter" class="fn">pattern_iter</a>(&amp;self) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = &amp;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns iterator of pattern strings that generated the resource definition.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">"/root"</span>);
<span class="kw">let </span><span class="kw-2">mut </span>iter = resource.pattern_iter();
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="string">"/root"</span>);
<span class="macro">assert!</span>(iter.next().is_none());

<span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new([<span class="string">"/root"</span>, <span class="string">"/backup"</span>]);
<span class="kw">let </span><span class="kw-2">mut </span>iter = resource.pattern_iter();
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="string">"/root"</span>);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="string">"/backup"</span>);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.join" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#503-519">Source</a><h4 class="code-header">pub fn <a href="#method.join" class="fn">join</a>(&amp;self, other: &amp;<a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a>) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h4></section></summary><div class="docblock"><p>Joins two resources.</p>
<p>Resulting resource is prefix if <code>other</code> is prefix.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>joined = ResourceDef::prefix(<span class="string">"/root"</span>).join(<span class="kw-2">&amp;</span>ResourceDef::prefix(<span class="string">"/seg"</span>));
<span class="macro">assert_eq!</span>(joined, ResourceDef::prefix(<span class="string">"/root/seg"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_match" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#555-565">Source</a><h4 class="code-header">pub fn <a href="#method.is_match" class="fn">is_match</a>(&amp;self, path: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>path</code> matches this resource.</p>
<p>The behavior of this method depends on how the <code>ResourceDef</code> was constructed. For example,
static resources will not be able to match as many paths as dynamic and prefix resources.
See <a href="struct.ResourceDef.html" title="struct actix_router::ResourceDef"><code>ResourceDef</code></a> struct docs for details on resource definition types.</p>
<p>This method will always agree with <a href="struct.ResourceDef.html#method.find_match" title="method actix_router::ResourceDef::find_match"><code>find_match</code></a> on whether the path
matches or not.</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="comment">// static resource
</span><span class="kw">let </span>resource = ResourceDef::new(<span class="string">"/user"</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/users"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/user/123"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/foo"</span>));

<span class="comment">// dynamic resource
</span><span class="kw">let </span>resource = ResourceDef::new(<span class="string">"/user/{user_id}"</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/user/123"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/user/123/stars"</span>));

<span class="comment">// prefix resource
</span><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">"/root"</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/root"</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">"/root/leaf"</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">"/roots"</span>));

<span class="comment">// more examples are shown in the `ResourceDef` struct docs</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_match" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#602-614">Source</a><h4 class="code-header">pub fn <a href="#method.find_match" class="fn">find_match</a>(&amp;self, path: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.84.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Tries to match <code>path</code> to this resource, returning the position in the path where the
match ends.</p>
<p>This method will always agree with <a href="struct.ResourceDef.html#method.is_match" title="method actix_router::ResourceDef::is_match"><code>is_match</code></a> on whether the path matches
or not.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="comment">// static resource
</span><span class="kw">let </span>resource = ResourceDef::new(<span class="string">"/user"</span>);
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">"/user"</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert!</span>(resource.find_match(<span class="string">"/user/"</span>).is_none());
<span class="macro">assert!</span>(resource.find_match(<span class="string">"/user/123"</span>).is_none());
<span class="macro">assert!</span>(resource.find_match(<span class="string">"/foo"</span>).is_none());

<span class="comment">// constant prefix resource
</span><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">"/user"</span>);
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">"/user"</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">"/user/"</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">"/user/123"</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));

<span class="comment">// dynamic prefix resource
</span><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">"/user/{id}"</span>);
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">"/user/123"</span>), <span class="prelude-val">Some</span>(<span class="number">9</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">"/user/1234/"</span>), <span class="prelude-val">Some</span>(<span class="number">10</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">"/user/12345/stars"</span>), <span class="prelude-val">Some</span>(<span class="number">11</span>));
<span class="macro">assert!</span>(resource.find_match(<span class="string">"/user/"</span>).is_none());

<span class="comment">// multi-pattern resource
</span><span class="kw">let </span>resource = ResourceDef::new([<span class="string">"/user/{id}"</span>, <span class="string">"/profile/{id}"</span>]);
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">"/user/123"</span>), <span class="prelude-val">Some</span>(<span class="number">9</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">"/profile/1234"</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capture_match_info" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#636-638">Source</a><h4 class="code-header">pub fn <a href="#method.capture_match_info" class="fn">capture_match_info</a>&lt;R: <a class="trait" href="trait.Resource.html" title="trait actix_router::Resource">Resource</a>&gt;(&amp;self, resource: <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.reference.html">&amp;mut R</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Collects dynamic segment values into <code>resource</code>.</p>
<p>Returns <code>true</code> if <code>path</code> matches this resource.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::{Path, ResourceDef};

<span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">"/user/{id}"</span>);
<span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">"/user/123/stars"</span>);
<span class="macro">assert!</span>(resource.capture_match_info(<span class="kw-2">&amp;mut </span>path));
<span class="macro">assert_eq!</span>(path.get(<span class="string">"id"</span>).unwrap(), <span class="string">"123"</span>);
<span class="macro">assert_eq!</span>(path.unprocessed(), <span class="string">"/stars"</span>);

<span class="kw">let </span>resource = ResourceDef::new(<span class="string">"/blob/{path}*"</span>);
<span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">"/blob/HEAD/Cargo.toml"</span>);
<span class="macro">assert!</span>(resource.capture_match_info(<span class="kw-2">&amp;mut </span>path));
<span class="macro">assert_eq!</span>(path.get(<span class="string">"path"</span>).unwrap(), <span class="string">"HEAD/Cargo.toml"</span>);
<span class="macro">assert_eq!</span>(path.unprocessed(), <span class="string">""</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capture_match_info_fn" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#677-751">Source</a><h4 class="code-header">pub fn <a href="#method.capture_match_info_fn" class="fn">capture_match_info_fn</a>&lt;R, F&gt;(&amp;self, resource: <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.reference.html">&amp;mut R</a>, check_fn: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.bool.html">bool</a><div class="where">where
    R: <a class="trait" href="trait.Resource.html" title="trait actix_router::Resource">Resource</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.reference.html">&amp;R</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Collects dynamic segment values into <code>resource</code> after matching paths and executing
check function.</p>
<p>The check function is given a reference to the passed resource and optional arbitrary data.
This is useful if you want to conditionally match on some non-path related aspect of the
resource type.</p>
<p>Returns <code>true</code> if resource path matches this resource definition <em>and</em> satisfies the
given check function.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::{Path, ResourceDef};

<span class="kw">fn </span>try_match(resource: <span class="kw-2">&amp;</span>ResourceDef, path: <span class="kw-2">&amp;mut </span>Path&lt;<span class="kw-2">&amp;</span>str&gt;) -&gt; bool {
    <span class="kw">let </span>admin_allowed = std::env::var(<span class="string">"ADMIN_ALLOWED"</span>).is_ok();

    resource.capture_match_info_fn(
        path,
        <span class="comment">// when env var is not set, reject when path contains "admin"
        </span>|path| !(!admin_allowed &amp;&amp; path.as_str().contains(<span class="string">"admin"</span>)),
    )
}

<span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">"/user/{id}"</span>);

<span class="comment">// path matches; segment values are collected into path
</span><span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">"/user/james/stars"</span>);
<span class="macro">assert!</span>(try_match(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;mut </span>path));
<span class="macro">assert_eq!</span>(path.get(<span class="string">"id"</span>).unwrap(), <span class="string">"james"</span>);
<span class="macro">assert_eq!</span>(path.unprocessed(), <span class="string">"/stars"</span>);

<span class="comment">// path matches but fails check function; no segments are collected
</span><span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">"/user/admin/stars"</span>);
<span class="macro">assert!</span>(!try_match(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;mut </span>path));
<span class="macro">assert_eq!</span>(path.unprocessed(), <span class="string">"/user/admin/stars"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resource_path_from_iter" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#788-795">Source</a><h4 class="code-header">pub fn <a href="#method.resource_path_from_iter" class="fn">resource_path_from_iter</a>&lt;I&gt;(&amp;self, path: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.84.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, values: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.bool.html">bool</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    I::<a class="associatedtype" href="https://doc.rust-lang.org/1.84.1/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Assembles full resource path from iterator of dynamic segment values.</p>
<p>Returns <code>true</code> on success.</p>
<p>For multi-pattern resources, the first pattern is used under the assumption that it would be
equivalent to any other choice.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::new();
<span class="kw">let </span>resource = ResourceDef::new(<span class="string">"/user/{id}/post/{title}"</span>);

<span class="macro">assert!</span>(resource.resource_path_from_iter(<span class="kw-2">&amp;mut </span>s, <span class="kw-2">&amp;</span>[<span class="string">"123"</span>, <span class="string">"my-post"</span>]));
<span class="macro">assert_eq!</span>(s, <span class="string">"/user/123/post/my-post"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resource_path_from_map" class="method"><a class="src rightside" href="../src/actix_router/resource.rs.html#818-829">Source</a><h4 class="code-header">pub fn <a href="#method.resource_path_from_map" class="fn">resource_path_from_map</a>&lt;K, V, S&gt;(
    &amp;self,
    path: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.84.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    values: &amp;<a class="struct" href="https://doc.rust-lang.org/1.84.1/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;K, V, S&gt;,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.bool.html">bool</a><div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    V: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>&gt;,
    S: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a>,</div></h4></section></summary><div class="docblock"><p>Assembles resource path from map of dynamic segment values.</p>
<p>Returns <code>true</code> on success.</p>
<p>For multi-pattern resources, the first pattern is used under the assumption that it would be
equivalent to any other choice.</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::new();
<span class="kw">let </span>resource = ResourceDef::new(<span class="string">"/user/{id}/post/{title}"</span>);

<span class="kw">let </span><span class="kw-2">mut </span>map = HashMap::new();
map.insert(<span class="string">"id"</span>, <span class="string">"123"</span>);
map.insert(<span class="string">"title"</span>, <span class="string">"my-post"</span>);

<span class="macro">assert!</span>(resource.resource_path_from_map(<span class="kw-2">&amp;mut </span>s, <span class="kw-2">&amp;</span>map));
<span class="macro">assert_eq!</span>(s, <span class="string">"/user/123/post/my-post"</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-ResourceDef" class="impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#211">Source</a><a href="#impl-Clone-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#211">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.84.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.84.1/src/core/clone.rs.html#174">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.84.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-ResourceDef" class="impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#211">Source</a><a href="#impl-Debug-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#211">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.84.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.84.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.84.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26str%3E-for-ResourceDef" class="impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#1095-1099">Source</a><a href="#impl-From%3C%26str%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#1096-1098">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(path: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CString%3E-for-ResourceDef" class="impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#1101-1105">Source</a><a href="#impl-From%3CString%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.84.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt; for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#1102-1104">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(path: <a class="struct" href="https://doc.rust-lang.org/1.84.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-ResourceDef" class="impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#1089-1093">Source</a><a href="#impl-Hash-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#1090-1092">Source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.reference.html">&amp;mut H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/1.84.1/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.84.1/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-ResourceDef" class="impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#1083-1087">Source</a><a href="#impl-PartialEq-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#1084-1086">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.84.1/src/core/cmp.rs.html#261">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-ResourceDef" class="impl"><a class="src rightside" href="../src/actix_router/resource.rs.html#1081">Source</a><a href="#impl-Eq-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-ResourceDef" class="impl"><a href="#impl-Freeze-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section><section id="impl-RefUnwindSafe-for-ResourceDef" class="impl"><a href="#impl-RefUnwindSafe-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section><section id="impl-Send-for-ResourceDef" class="impl"><a href="#impl-Send-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section><section id="impl-Sync-for-ResourceDef" class="impl"><a href="#impl-Sync-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section><section id="impl-Unpin-for-ResourceDef" class="impl"><a href="#impl-Unpin-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section><section id="impl-UnwindSafe-for-ResourceDef" class="impl"><a href="#impl-UnwindSafe-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_router::ResourceDef">ResourceDef</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.84.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.84.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.84.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.84.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.84.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.84.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.84.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/clone.rs.html#273">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/clone.rs.html#275">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.84.1/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dst: <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href="https://doc.rust-lang.org/1.84.1/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#765">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#768">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a class="src rightside" href="../src/tracing/instrument.rs.html#325">Source</a><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../tracing/instrument/trait.Instrument.html" title="trait tracing::instrument::Instrument">Instrument</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a class="src rightside" href="../src/tracing/instrument.rs.html#86">Source</a><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a href="../tracing/instrument/trait.Instrument.html#method.instrument" class="fn">instrument</a>(self, span: <a class="struct" href="../tracing/span/struct.Span.html" title="struct tracing::span::Span">Span</a>) -&gt; <a class="struct" href="../tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided <a href="../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="../tracing/instrument/trait.Instrument.html#method.instrument">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a class="src rightside" href="../src/tracing/instrument.rs.html#128">Source</a><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a href="../tracing/instrument/trait.Instrument.html#method.in_current_span" class="fn">in_current_span</a>(self) -&gt; <a class="struct" href="../tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="../tracing/span/struct.Span.html#method.current" title="associated function tracing::span::Span::current">current</a> <a href="../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="../tracing/instrument/trait.Instrument.html#method.in_current_span">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#748-750">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#758">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.84.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.84.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.84.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.84.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.84.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#805-807">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#809">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.84.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#812">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.84.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#790-792">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#794">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.84.1/src/core/convert/mod.rs.html#797">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.84.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a class="src rightside" href="../src/tracing/instrument.rs.html#393">Source</a><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../tracing/instrument/trait.WithSubscriber.html" title="trait tracing::instrument::WithSubscriber">WithSubscriber</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a class="src rightside" href="../src/tracing/instrument.rs.html#176-178">Source</a><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a href="../tracing/instrument/trait.WithSubscriber.html#method.with_subscriber" class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; <a class="struct" href="../tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch">WithDispatch</a>&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.84.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../tracing_core/dispatcher/struct.Dispatch.html" title="struct tracing_core::dispatcher::Dispatch">Dispatch</a>&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="../tracing_core/subscriber/trait.Subscriber.html" title="trait tracing_core::subscriber::Subscriber"><code>Subscriber</code></a> to this type, returning a
<a href="../tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch"><code>WithDispatch</code></a> wrapper. <a href="../tracing/instrument/trait.WithSubscriber.html#method.with_subscriber">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a class="src rightside" href="../src/tracing/instrument.rs.html#228">Source</a><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a href="../tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber" class="fn">with_current_subscriber</a>(self) -&gt; <a class="struct" href="../tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch">WithDispatch</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="../tracing/dispatcher/index.html#setting-the-default-subscriber" title="mod tracing::dispatcher">default</a> <a href="../tracing_core/subscriber/trait.Subscriber.html" title="trait tracing_core::subscriber::Subscriber"><code>Subscriber</code></a> to this type, returning a
<a href="../tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch"><code>WithDispatch</code></a> wrapper. <a href="../tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber">Read more</a></div></details></div></details></div></section></div></main></body></html>