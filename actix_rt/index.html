<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Tokio-based single-threaded async runtime for the Actix ecosystem."><title>actix_rt - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="actix_rt" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="icon" href="https://actix.rs/favicon.ico"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate actix_rt</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../actix_rt/index.html"><img src="https://actix.rs/img/logo.png" alt="logo"></a><h2><a href="../actix_rt/index.html">actix_<wbr>rt</a><span class="version">2.11.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li><li><a href="#io-uring-support" title="`io-uring` Support"><code>io-uring</code> Support</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>actix_<wbr>rt</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/actix_rt/lib.rs.html#1-215">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Tokio-based single-threaded async runtime for the Actix ecosystem.</p>
<p>In most parts of the the Actix ecosystem, it has been chosen to use !Send futures. For this
reason, a single-threaded runtime is appropriate since it is guaranteed that futures will not
be moved between threads. This can result in small performance improvements over cases where
atomics would otherwise be needed.</p>
<p>To achieve similar performance to multi-threaded, work-stealing runtimes, applications
using <code>actix-rt</code> will create multiple, mostly disconnected, single-threaded runtimes.
This approach has good performance characteristics for workloads where the majority of tasks
have similar runtime expense.</p>
<p>The disadvantage is that idle threads will not steal work from very busy, stuck or otherwise
backlogged threads. Tasks that are disproportionately expensive should be offloaded to the
blocking task thread-pool using <a href="task/fn.spawn_blocking.html" title="fn actix_rt::task::spawn_blocking"><code>task::spawn_blocking</code></a>.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::sync::mpsc;
<span class="kw">use </span>actix_rt::{Arbiter, System};

<span class="kw">let _ </span>= System::new();

<span class="kw">let </span>(tx, rx) = mpsc::channel::&lt;u32&gt;();

<span class="kw">let </span>arbiter = Arbiter::new();
arbiter.spawn_fn(<span class="kw">move </span>|| tx.send(<span class="number">42</span>).unwrap());

<span class="kw">let </span>num = rx.recv().unwrap();
<span class="macro">assert_eq!</span>(num, <span class="number">42</span>);

arbiter.stop();
arbiter.join().unwrap();</code></pre></div><h2 id="io-uring-support"><a class="doc-anchor" href="#io-uring-support">§</a><code>io-uring</code> Support</h2>
<p>There is experimental support for using io-uring with this crate by enabling the
<code>io-uring</code> feature. For now, it is semver exempt.</p>
<p>Note that there are currently some unimplemented parts of using <code>actix-rt</code> with <code>io-uring</code>.
In particular, when running a <code>System</code>, only <code>System::block_on</code> is supported.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="net/index.html" title="mod actix_rt::net">net</a></dt><dd>TCP/UDP/Unix bindings (mostly Tokio re-exports).</dd><dt><a class="mod" href="signal/index.html" title="mod actix_rt::signal">signal</a></dt><dd>Asynchronous signal handling (Tokio re-exports).</dd><dt><a class="mod" href="task/index.html" title="mod actix_rt::task">task</a></dt><dd>Task management (Tokio re-exports).</dd><dt><a class="mod" href="time/index.html" title="mod actix_rt::time">time</a></dt><dd>Utilities for tracking time (Tokio re-exports).</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.pin.html" title="macro actix_rt::pin">pin</a></dt><dd>Pins a value on the stack.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Arbiter.html" title="struct actix_rt::Arbiter">Arbiter</a></dt><dd>An Arbiter represents a thread that provides an asynchronous execution environment for futures
and functions.</dd><dt><a class="struct" href="struct.ArbiterHandle.html" title="struct actix_rt::ArbiterHandle">Arbiter<wbr>Handle</a></dt><dd>A handle for sending spawn and stop messages to an <a href="struct.Arbiter.html" title="struct actix_rt::Arbiter">Arbiter</a>.</dd><dt><a class="struct" href="struct.Runtime.html" title="struct actix_rt::Runtime">Runtime</a></dt><dd>A Tokio-based runtime proxy.</dd><dt><a class="struct" href="struct.System.html" title="struct actix_rt::System">System</a></dt><dd>A manager for a per-thread distributed async runtime.</dd><dt><a class="struct" href="struct.SystemRunner.html" title="struct actix_rt::SystemRunner">System<wbr>Runner</a></dt><dd>Runner that keeps a <a href="struct.System.html" title="struct actix_rt::System">System</a>’s event loop alive until stop message is received.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.spawn.html" title="fn actix_rt::spawn">spawn</a></dt><dd>Spawns a future on the current thread as a new task.</dd></dl></section></div></main></body></html>