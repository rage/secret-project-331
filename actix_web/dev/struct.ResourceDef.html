<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Describes the set of paths that match to a resource."><title>ResourceDef in actix_web::dev - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="actix_web" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="icon" href="https://actix.rs/favicon.ico"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../actix_web/index.html"><img src="https://actix.rs/img/logo.png" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../actix_web/index.html"><img src="https://actix.rs/img/logo.png" alt="logo"></a><h2 class="location"><a href="#">ResourceDef</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.capture_match_info">capture_match_info</a></li><li><a href="#method.capture_match_info_fn">capture_match_info_fn</a></li><li><a href="#method.find_match">find_match</a></li><li><a href="#method.id">id</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.is_prefix">is_prefix</a></li><li><a href="#method.join">join</a></li><li><a href="#method.name">name</a></li><li><a href="#method.new">new</a></li><li><a href="#method.pattern">pattern</a></li><li><a href="#method.pattern_iter">pattern_iter</a></li><li><a href="#method.prefix">prefix</a></li><li><a href="#method.resource_path_from_iter">resource_path_from_iter</a></li><li><a href="#method.resource_path_from_map">resource_path_from_map</a></li><li><a href="#method.root_prefix">root_prefix</a></li><li><a href="#method.set_id">set_id</a></li><li><a href="#method.set_name">set_name</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Clone-for-ResourceDef">Clone</a></li><li><a href="#impl-Debug-for-ResourceDef">Debug</a></li><li><a href="#impl-Eq-for-ResourceDef">Eq</a></li><li><a href="#impl-From%3C%26'a+str%3E-for-ResourceDef">From&lt;&amp;&#x27;a str&gt;</a></li><li><a href="#impl-From%3CString%3E-for-ResourceDef">From&lt;String&gt;</a></li><li><a href="#impl-Hash-for-ResourceDef">Hash</a></li><li><a href="#impl-PartialEq%3CResourceDef%3E-for-ResourceDef">PartialEq&lt;ResourceDef&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-ResourceDef">RefUnwindSafe</a></li><li><a href="#impl-Send-for-ResourceDef">Send</a></li><li><a href="#impl-Sync-for-ResourceDef">Sync</a></li><li><a href="#impl-Unpin-for-ResourceDef">Unpin</a></li><li><a href="#impl-UnwindSafe-for-ResourceDef">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-ResourceDef">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-ResourceDef">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-ResourceDef">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-Equivalent%3CK%3E-for-ResourceDef">Equivalent&lt;K&gt;</a></li><li><a href="#impl-From%3CT%3E-for-ResourceDef">From&lt;T&gt;</a></li><li><a href="#impl-Instrument-for-ResourceDef">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-ResourceDef">Into&lt;U&gt;</a></li><li><a href="#impl-Same%3CT%3E-for-ResourceDef">Same&lt;T&gt;</a></li><li><a href="#impl-ToOwned-for-ResourceDef">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-ResourceDef">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-ResourceDef">TryInto&lt;U&gt;</a></li><li><a href="#impl-VZip%3CV%3E-for-ResourceDef">VZip&lt;V&gt;</a></li><li><a href="#impl-WithSubscriber-for-ResourceDef">WithSubscriber</a></li></ul></section><h2><a href="index.html">In actix_web::dev</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">actix_web</a>::<wbr><a href="index.html">dev</a>::<wbr><a class="struct" href="#">ResourceDef</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/actix_router/resource.rs.html#209">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct ResourceDef { /* private fields */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Describes the set of paths that match to a resource.</p>
<p><code>ResourceDef</code>s are effectively a way to transform the a custom resource pattern syntax into
suitable regular expressions from which to check matches with paths and capture portions of a
matched path into variables. Common cases are on a fast path that avoids going through the
regex engine.</p>
<h2 id="pattern-format-and-matching-behavior"><a href="#pattern-format-and-matching-behavior">Pattern Format and Matching Behavior</a></h2>
<p>Resource pattern is defined as a string of zero or more <em>segments</em> where each segment is
preceded by a slash <code>/</code>.</p>
<p>This means that pattern string <strong>must</strong> either be empty or begin with a slash (<code>/</code>). This also
implies that a trailing slash in pattern defines an empty segment. For example, the pattern
<code>&quot;/user/&quot;</code> has two segments: <code>[&quot;user&quot;, &quot;&quot;]</code></p>
<p>A key point to understand is that <code>ResourceDef</code> matches segments, not strings. Segments are
matched individually. For example, the pattern <code>/user/</code> is not considered a prefix for the path
<code>/user/123/456</code>, because the second segment doesn’t match: <code>[&quot;user&quot;, &quot;&quot;]</code>
vs <code>[&quot;user&quot;, &quot;123&quot;, &quot;456&quot;]</code>.</p>
<p>This definition is consistent with the definition of absolute URL path in
<a href="https://datatracker.ietf.org/doc/html/rfc3986#section-3.3">RFC 3986 §3.3</a></p>
<h2 id="static-resources"><a href="#static-resources">Static Resources</a></h2>
<p>A static resource is the most basic type of definition. Pass a pattern to <a href="struct.ResourceDef.html#method.new" title="associated function actix_web::dev::ResourceDef::new">new</a>.
Conforming paths must match the pattern exactly.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::new(<span class="string">&quot;/home&quot;</span>);

<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/home&quot;</span>));

<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/home/&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/home/new&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/homes&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/search&quot;</span>));</code></pre></div>
<h2 id="dynamic-segments"><a href="#dynamic-segments">Dynamic Segments</a></h2>
<p>Also known as “path parameters”. Resources can define sections of a pattern that be extracted
from a conforming path, if it conforms to (one of) the resource pattern(s).</p>
<p>The marker for a dynamic segment is curly braces wrapping an identifier. For example,
<code>/user/{id}</code> would match paths like <code>/user/123</code> or <code>/user/james</code> and be able to extract the user
IDs “123” and “james”, respectively.</p>
<p>However, this resource pattern (<code>/user/{id}</code>) would, not cover <code>/user/123/stars</code> (unless
constructed as a prefix; see next section) since the default pattern for segments matches all
characters until it finds a <code>/</code> character (or the end of the path). Custom segment patterns are
covered further down.</p>
<p>Dynamic segments do not need to be delimited by <code>/</code> characters, they can be defined within a
path segment. For example, <code>/rust-is-{opinion}</code> can match the paths <code>/rust-is-cool</code> and
<code>/rust-is-hard</code>.</p>
<p>For information on capturing segment values from paths or other custom resource types,
see <a href="struct.ResourceDef.html#method.capture_match_info" title="method actix_web::dev::ResourceDef::capture_match_info"><code>capture_match_info</code></a>
and <a href="struct.ResourceDef.html#method.capture_match_info_fn" title="method actix_web::dev::ResourceDef::capture_match_info_fn"><code>capture_match_info_fn</code></a>.</p>
<p>A resource definition can contain at most 16 dynamic segments.</p>
<h3 id="examples-1"><a href="#examples-1">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::{Path, ResourceDef};

<span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">&quot;/user/{id}&quot;</span>);

<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/user&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/user/&quot;</span>));

<span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">&quot;/user/123&quot;</span>);
resource.capture_match_info(<span class="kw-2">&amp;mut </span>path);
<span class="macro">assert_eq!</span>(path.get(<span class="string">&quot;id&quot;</span>).unwrap(), <span class="string">&quot;123&quot;</span>);</code></pre></div>
<h2 id="prefix-resources"><a href="#prefix-resources">Prefix Resources</a></h2>
<p>A prefix resource is defined as pattern that can match just the start of a path, up to a
segment boundary.</p>
<p>Prefix patterns with a trailing slash may have an unexpected, though correct, behavior.
They define and therefore require an empty segment in order to match. It is easier to understand
this behavior after reading the <a href="#pattern-format-and-matching-behavior">matching behavior section</a>. Examples are given below.</p>
<p>The empty pattern (<code>&quot;&quot;</code>), as a prefix, matches any path.</p>
<p>Prefix resources can contain dynamic segments.</p>
<h3 id="examples-2"><a href="#examples-2">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">&quot;/home&quot;</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/home&quot;</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/home/new&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/homes&quot;</span>));

<span class="comment">// prefix pattern with a trailing slash
</span><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">&quot;/user/{id}/&quot;</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123/&quot;</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123//stars&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/user/123/stars&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/user/123&quot;</span>));</code></pre></div>
<h2 id="custom-regex-segments"><a href="#custom-regex-segments">Custom Regex Segments</a></h2>
<p>Dynamic segments can be customised to only match a specific regular expression. It can be
helpful to do this if resource definitions would otherwise conflict and cause one to
be inaccessible.</p>
<p>The regex used when capturing segment values can be specified explicitly using this syntax:
<code>{name:regex}</code>. For example, <code>/user/{id:\d+}</code> will only match paths where the user ID
is numeric.</p>
<p>The regex could potentially match multiple segments. If this is not wanted, then care must be
taken to avoid matching a slash <code>/</code>. It is guaranteed, however, that the match ends at a
segment boundary; the pattern <code>r&quot;(/|$)</code> is always appended to the regex.</p>
<p>By default, dynamic segments use this regex: <code>[^/]+</code>. This shows why it is the case, as shown in
the earlier section, that segments capture a slice of the path up to the next <code>/</code> character.</p>
<p>Custom regex segments can be used in static and prefix resource definition variants.</p>
<h3 id="examples-3"><a href="#examples-3">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::new(<span class="string">r&quot;/user/{id:\d+}&quot;</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123&quot;</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/314159&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/user/abc&quot;</span>));</code></pre></div>
<h2 id="tail-segments"><a href="#tail-segments">Tail Segments</a></h2>
<p>As a shortcut to defining a custom regex for matching <em>all</em> remaining characters (not just those
up until a <code>/</code> character), there is a special pattern to match (and capture) the remaining
path portion.</p>
<p>To do this, use the segment pattern: <code>{name}*</code>. Since a tail segment also has a name, values are
extracted in the same way as non-tail dynamic segments.</p>
<h3 id="examples-4"><a href="#examples-4">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::new(<span class="string">&quot;/blob/{tail}*&quot;</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/blob/HEAD/Cargo.toml&quot;</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/blob/HEAD/README.md&quot;</span>));

<span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">&quot;/blob/main/LICENSE&quot;</span>);
resource.capture_match_info(<span class="kw-2">&amp;mut </span>path);
<span class="macro">assert_eq!</span>(path.get(<span class="string">&quot;tail&quot;</span>).unwrap(), <span class="string">&quot;main/LICENSE&quot;</span>);</code></pre></div>
<h2 id="multi-pattern-resources"><a href="#multi-pattern-resources">Multi-Pattern Resources</a></h2>
<p>For resources that can map to multiple distinct paths, it may be suitable to use
multi-pattern resources by passing an array/vec to <a href="struct.ResourceDef.html#method.new" title="associated function actix_web::dev::ResourceDef::new"><code>new</code></a>. They will be combined
into a regex set which is usually quicker to check matches on than checking each
pattern individually.</p>
<p>Multi-pattern resources can contain dynamic segments just like single pattern ones.
However, take care to use consistent and semantically-equivalent segment names; it could affect
expectations in the router using these definitions and cause runtime panics.</p>
<h3 id="examples-5"><a href="#examples-5">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resource = ResourceDef::new([<span class="string">&quot;/home&quot;</span>, <span class="string">&quot;/index&quot;</span>]);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/home&quot;</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/index&quot;</span>));</code></pre></div>
<h2 id="trailing-slashes"><a href="#trailing-slashes">Trailing Slashes</a></h2>
<p>It should be noted that this library takes no steps to normalize intra-path or trailing slashes.
As such, all resource definitions implicitly expect a pre-processing step to normalize paths if
they you wish to accommodate “recoverable” path errors. Below are several examples of
resource-path pairs that would not be compatible.</p>
<h3 id="examples-6"><a href="#examples-6">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(!ResourceDef::new(<span class="string">&quot;/root&quot;</span>).is_match(<span class="string">&quot;/root/&quot;</span>));
<span class="macro">assert!</span>(!ResourceDef::new(<span class="string">&quot;/root/&quot;</span>).is_match(<span class="string">&quot;/root&quot;</span>));
<span class="macro">assert!</span>(!ResourceDef::prefix(<span class="string">&quot;/root/&quot;</span>).is_match(<span class="string">&quot;/root&quot;</span>));</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-ResourceDef" class="impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#249">source</a><a href="#impl-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#273">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>&lt;T&gt;(paths: T) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a><span class="where fmt-newline">where
    T: <a class="trait" href="../../actix_router/pattern/trait.IntoPatterns.html" title="trait actix_router::pattern::IntoPatterns">IntoPatterns</a>,</span></h4></section></summary><div class="docblock"><p>Constructs a new resource definition from patterns.</p>
<p>Multi-pattern resources can be constructed by providing a slice (or vec) of patterns.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>Panics if path pattern is malformed.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="kw">let </span>resource = ResourceDef::new(<span class="string">&quot;/user/{id}&quot;</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/user/123/stars&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;user/1234&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/foo&quot;</span>));

<span class="kw">let </span>resource = ResourceDef::new([<span class="string">&quot;/profile&quot;</span>, <span class="string">&quot;/user/{id}&quot;</span>]);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/profile&quot;</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;user/123&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/foo&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prefix" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#300">source</a><h4 class="code-header">pub fn <a href="#method.prefix" class="fn">prefix</a>&lt;T&gt;(paths: T) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a><span class="where fmt-newline">where
    T: <a class="trait" href="../../actix_router/pattern/trait.IntoPatterns.html" title="trait actix_router::pattern::IntoPatterns">IntoPatterns</a>,</span></h4></section></summary><div class="docblock"><p>Constructs a new resource definition using a pattern that performs prefix matching.</p>
<p>More specifically, the regular expressions generated for matching are different when using
this method vs using <code>new</code>; they will not be appended with the <code>$</code> meta-character that
matches the end of an input.</p>
<p>Although it will compile and run correctly, it is meaningless to construct a prefix
resource definition with a tail segment; use <a href="struct.ResourceDef.html#method.new" title="associated function actix_web::dev::ResourceDef::new"><code>new</code></a> in this case.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>Panics if path pattern is malformed.</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">&quot;/user/{id}&quot;</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123&quot;</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123/stars&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;user/123&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;user/123/stars&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/foo&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.root_prefix" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#324">source</a><h4 class="code-header">pub fn <a href="#method.root_prefix" class="fn">root_prefix</a>(path: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h4></section></summary><div class="docblock"><p>Constructs a new resource definition using a string pattern that performs prefix matching,
ensuring a leading <code>/</code> if pattern is not empty.</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>Panics if path pattern is malformed.</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="kw">let </span>resource = ResourceDef::root_prefix(<span class="string">&quot;user/{id}&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;</span>ResourceDef::prefix(<span class="string">&quot;/user/{id}&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;</span>ResourceDef::root_prefix(<span class="string">&quot;/user/{id}&quot;</span>));
<span class="macro">assert_ne!</span>(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;</span>ResourceDef::new(<span class="string">&quot;user/{id}&quot;</span>));
<span class="macro">assert_ne!</span>(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;</span>ResourceDef::new(<span class="string">&quot;/user/{id}&quot;</span>));

<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;user/123&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.id" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#341">source</a><h4 class="code-header">pub fn <a href="#method.id" class="fn">id</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.u16.html">u16</a></h4></section></summary><div class="docblock"><p>Returns a numeric resource ID.</p>
<p>If not explicitly set using <a href="struct.ResourceDef.html#method.set_id" title="method actix_web::dev::ResourceDef::set_id"><code>set_id</code></a>, this will return <code>0</code>.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">&quot;/root&quot;</span>);
<span class="macro">assert_eq!</span>(resource.id(), <span class="number">0</span>);

resource.set_id(<span class="number">42</span>);
<span class="macro">assert_eq!</span>(resource.id(), <span class="number">42</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_id" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#354">source</a><h4 class="code-header">pub fn <a href="#method.set_id" class="fn">set_id</a>(&amp;mut self, id: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.u16.html">u16</a>)</h4></section></summary><div class="docblock"><p>Set numeric resource ID.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">&quot;/root&quot;</span>);
resource.set_id(<span class="number">42</span>);
<span class="macro">assert_eq!</span>(resource.id(), <span class="number">42</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.name" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#368">source</a><h4 class="code-header">pub fn <a href="#method.name" class="fn">name</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns resource definition name, if set.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">&quot;/root&quot;</span>);
<span class="macro">assert!</span>(resource.name().is_none());

resource.set_name(<span class="string">&quot;root&quot;</span>);
<span class="macro">assert_eq!</span>(resource.name().unwrap(), <span class="string">&quot;root&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_name" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#384">source</a><h4 class="code-header">pub fn <a href="#method.set_name" class="fn">set_name</a>(&amp;mut self, name: impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;)</h4></section></summary><div class="docblock"><p>Assigns a new name to the resource.</p>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>Panics if <code>name</code> is an empty string.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">&quot;/root&quot;</span>);
resource.set_name(<span class="string">&quot;root&quot;</span>);
<span class="macro">assert_eq!</span>(resource.name().unwrap(), <span class="string">&quot;root&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_prefix" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#400">source</a><h4 class="code-header">pub fn <a href="#method.is_prefix" class="fn">is_prefix</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if pattern type is prefix.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(ResourceDef::prefix(<span class="string">&quot;/user&quot;</span>).is_prefix());
<span class="macro">assert!</span>(!ResourceDef::new(<span class="string">&quot;/user&quot;</span>).is_prefix());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#418">source</a><h4 class="code-header">pub fn <a href="#method.pattern" class="fn">pattern</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the pattern string that generated the resource definition.</p>
<p>If definition is constructed with multiple patterns, the first pattern is returned. To get
all patterns, use <a href="struct.ResourceDef.html#method.pattern_iter" title="method actix_web::dev::ResourceDef::pattern_iter"><code>patterns_iter</code></a>. If resource has 0 patterns,
returns <code>None</code>.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">&quot;/user/{id}&quot;</span>);
<span class="macro">assert_eq!</span>(resource.pattern().unwrap(), <span class="string">&quot;/user/{id}&quot;</span>);

<span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new([<span class="string">&quot;/profile&quot;</span>, <span class="string">&quot;/user/{id}&quot;</span>]);
<span class="macro">assert_eq!</span>(resource.pattern(), <span class="prelude-val">Some</span>(<span class="string">&quot;/profile&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_iter" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#440">source</a><h4 class="code-header">pub fn <a href="#method.pattern_iter" class="fn">pattern_iter</a>(&amp;self) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = &amp;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns iterator of pattern strings that generated the resource definition.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new(<span class="string">&quot;/root&quot;</span>);
<span class="kw">let </span><span class="kw-2">mut </span>iter = resource.pattern_iter();
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="string">&quot;/root&quot;</span>);
<span class="macro">assert!</span>(iter.next().is_none());

<span class="kw">let </span><span class="kw-2">mut </span>resource = ResourceDef::new([<span class="string">&quot;/root&quot;</span>, <span class="string">&quot;/backup&quot;</span>]);
<span class="kw">let </span><span class="kw-2">mut </span>iter = resource.pattern_iter();
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="string">&quot;/root&quot;</span>);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="string">&quot;/backup&quot;</span>);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.join" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#500">source</a><h4 class="code-header">pub fn <a href="#method.join" class="fn">join</a>(&amp;self, other: &amp;<a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a>) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h4></section></summary><div class="docblock"><p>Joins two resources.</p>
<p>Resulting resource is prefix if <code>other</code> is prefix.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>joined = ResourceDef::prefix(<span class="string">&quot;/root&quot;</span>).join(<span class="kw-2">&amp;</span>ResourceDef::prefix(<span class="string">&quot;/seg&quot;</span>));
<span class="macro">assert_eq!</span>(joined, ResourceDef::prefix(<span class="string">&quot;/root/seg&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_match" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#547">source</a><h4 class="code-header">pub fn <a href="#method.is_match" class="fn">is_match</a>(&amp;self, path: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>path</code> matches this resource.</p>
<p>The behavior of this method depends on how the <code>ResourceDef</code> was constructed. For example,
static resources will not be able to match as many paths as dynamic and prefix resources.
See <a href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef"><code>ResourceDef</code></a> struct docs for details on resource definition types.</p>
<p>This method will always agree with <a href="struct.ResourceDef.html#method.find_match" title="method actix_web::dev::ResourceDef::find_match"><code>find_match</code></a> on whether the path
matches or not.</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="comment">// static resource
</span><span class="kw">let </span>resource = ResourceDef::new(<span class="string">&quot;/user&quot;</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/users&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/user/123&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/foo&quot;</span>));

<span class="comment">// dynamic resource
</span><span class="kw">let </span>resource = ResourceDef::new(<span class="string">&quot;/user/{user_id}&quot;</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/user/123&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/user/123/stars&quot;</span>));

<span class="comment">// prefix resource
</span><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">&quot;/root&quot;</span>);
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/root&quot;</span>));
<span class="macro">assert!</span>(resource.is_match(<span class="string">&quot;/root/leaf&quot;</span>));
<span class="macro">assert!</span>(!resource.is_match(<span class="string">&quot;/roots&quot;</span>));

<span class="comment">// more examples are shown in the `ResourceDef` struct docs</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_match" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#594">source</a><h4 class="code-header">pub fn <a href="#method.find_match" class="fn">find_match</a>(&amp;self, path: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Tries to match <code>path</code> to this resource, returning the position in the path where the
match ends.</p>
<p>This method will always agree with <a href="struct.ResourceDef.html#method.is_match" title="method actix_web::dev::ResourceDef::is_match"><code>is_match</code></a> on whether the path matches
or not.</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::ResourceDef;

<span class="comment">// static resource
</span><span class="kw">let </span>resource = ResourceDef::new(<span class="string">&quot;/user&quot;</span>);
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">&quot;/user&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert!</span>(resource.find_match(<span class="string">&quot;/user/&quot;</span>).is_none());
<span class="macro">assert!</span>(resource.find_match(<span class="string">&quot;/user/123&quot;</span>).is_none());
<span class="macro">assert!</span>(resource.find_match(<span class="string">&quot;/foo&quot;</span>).is_none());

<span class="comment">// constant prefix resource
</span><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">&quot;/user&quot;</span>);
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">&quot;/user&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">&quot;/user/&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">&quot;/user/123&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));

<span class="comment">// dynamic prefix resource
</span><span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">&quot;/user/{id}&quot;</span>);
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">&quot;/user/123&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">9</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">&quot;/user/1234/&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">10</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">&quot;/user/12345/stars&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">11</span>));
<span class="macro">assert!</span>(resource.find_match(<span class="string">&quot;/user/&quot;</span>).is_none());

<span class="comment">// multi-pattern resource
</span><span class="kw">let </span>resource = ResourceDef::new([<span class="string">&quot;/user/{id}&quot;</span>, <span class="string">&quot;/profile/{id}&quot;</span>]);
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">&quot;/user/123&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">9</span>));
<span class="macro">assert_eq!</span>(resource.find_match(<span class="string">&quot;/profile/1234&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capture_match_info" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#628">source</a><h4 class="code-header">pub fn <a href="#method.capture_match_info" class="fn">capture_match_info</a>&lt;R&gt;(&amp;self, resource: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;mut R</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    R: <a class="trait" href="../../actix_router/resource_path/trait.Resource.html" title="trait actix_router::resource_path::Resource">Resource</a>,</span></h4></section></summary><div class="docblock"><p>Collects dynamic segment values into <code>resource</code>.</p>
<p>Returns <code>true</code> if <code>path</code> matches this resource.</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::{Path, ResourceDef};

<span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">&quot;/user/{id}&quot;</span>);
<span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">&quot;/user/123/stars&quot;</span>);
<span class="macro">assert!</span>(resource.capture_match_info(<span class="kw-2">&amp;mut </span>path));
<span class="macro">assert_eq!</span>(path.get(<span class="string">&quot;id&quot;</span>).unwrap(), <span class="string">&quot;123&quot;</span>);
<span class="macro">assert_eq!</span>(path.unprocessed(), <span class="string">&quot;/stars&quot;</span>);

<span class="kw">let </span>resource = ResourceDef::new(<span class="string">&quot;/blob/{path}*&quot;</span>);
<span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">&quot;/blob/HEAD/Cargo.toml&quot;</span>);
<span class="macro">assert!</span>(resource.capture_match_info(<span class="kw-2">&amp;mut </span>path));
<span class="macro">assert_eq!</span>(path.get(<span class="string">&quot;path&quot;</span>).unwrap(), <span class="string">&quot;HEAD/Cargo.toml&quot;</span>);
<span class="macro">assert_eq!</span>(path.unprocessed(), <span class="string">&quot;&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capture_match_info_fn" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#669-672">source</a><h4 class="code-header">pub fn <a href="#method.capture_match_info_fn" class="fn">capture_match_info_fn</a>&lt;R, F&gt;(&amp;self, resource: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;mut R</a>, check_fn: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    R: <a class="trait" href="../../actix_router/resource_path/trait.Resource.html" title="trait actix_router::resource_path::Resource">Resource</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;R</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Collects dynamic segment values into <code>resource</code> after matching paths and executing
check function.</p>
<p>The check function is given a reference to the passed resource and optional arbitrary data.
This is useful if you want to conditionally match on some non-path related aspect of the
resource type.</p>
<p>Returns <code>true</code> if resource path matches this resource definition <em>and</em> satisfies the
given check function.</p>
<h5 id="examples-21"><a href="#examples-21">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>actix_router::{Path, ResourceDef};

<span class="kw">fn </span>try_match(resource: <span class="kw-2">&amp;</span>ResourceDef, path: <span class="kw-2">&amp;mut </span>Path&lt;<span class="kw-2">&amp;</span>str&gt;) -&gt; bool {
    <span class="kw">let </span>admin_allowed = std::env::var(<span class="string">&quot;ADMIN_ALLOWED&quot;</span>).is_ok();

    resource.capture_match_info_fn(
        path,
        <span class="comment">// when env var is not set, reject when path contains &quot;admin&quot;
        </span>|path| !(!admin_allowed &amp;&amp; path.as_str().contains(<span class="string">&quot;admin&quot;</span>)),
    )
}

<span class="kw">let </span>resource = ResourceDef::prefix(<span class="string">&quot;/user/{id}&quot;</span>);

<span class="comment">// path matches; segment values are collected into path
</span><span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">&quot;/user/james/stars&quot;</span>);
<span class="macro">assert!</span>(try_match(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;mut </span>path));
<span class="macro">assert_eq!</span>(path.get(<span class="string">&quot;id&quot;</span>).unwrap(), <span class="string">&quot;james&quot;</span>);
<span class="macro">assert_eq!</span>(path.unprocessed(), <span class="string">&quot;/stars&quot;</span>);

<span class="comment">// path matches but fails check function; no segments are collected
</span><span class="kw">let </span><span class="kw-2">mut </span>path = Path::new(<span class="string">&quot;/user/admin/stars&quot;</span>);
<span class="macro">assert!</span>(!try_match(<span class="kw-2">&amp;</span>resource, <span class="kw-2">&amp;mut </span>path));
<span class="macro">assert_eq!</span>(path.unprocessed(), <span class="string">&quot;/user/admin/stars&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resource_path_from_iter" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#780-783">source</a><h4 class="code-header">pub fn <a href="#method.resource_path_from_iter" class="fn">resource_path_from_iter</a>&lt;I&gt;(&amp;self, path: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, values: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    &lt;I as <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.73.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Assembles full resource path from iterator of dynamic segment values.</p>
<p>Returns <code>true</code> on success.</p>
<p>For multi-pattern resources, the first pattern is used under the assumption that it would be
equivalent to any other choice.</p>
<h5 id="examples-22"><a href="#examples-22">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::new();
<span class="kw">let </span>resource = ResourceDef::new(<span class="string">&quot;/user/{id}/post/{title}&quot;</span>);

<span class="macro">assert!</span>(resource.resource_path_from_iter(<span class="kw-2">&amp;mut </span>s, <span class="kw-2">&amp;</span>[<span class="string">&quot;123&quot;</span>, <span class="string">&quot;my-post&quot;</span>]));
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;/user/123/post/my-post&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resource_path_from_map" class="method"><a class="src rightside" href="../../src/actix_router/resource.rs.html#810-818">source</a><h4 class="code-header">pub fn <a href="#method.resource_path_from_map" class="fn">resource_path_from_map</a>&lt;K, V, S&gt;(
    &amp;self,
    path: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    values: &amp;<a class="struct" href="https://doc.rust-lang.org/1.73.0/std/collections/hash/map/struct.HashMap.html" title="struct std::collections::hash::map::HashMap">HashMap</a>&lt;K, V, S&gt;
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a>,
    V: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>&gt;,
    S: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a>,</span></h4></section></summary><div class="docblock"><p>Assembles resource path from map of dynamic segment values.</p>
<p>Returns <code>true</code> on success.</p>
<p>For multi-pattern resources, the first pattern is used under the assumption that it would be
equivalent to any other choice.</p>
<h5 id="examples-23"><a href="#examples-23">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = String::new();
<span class="kw">let </span>resource = ResourceDef::new(<span class="string">&quot;/user/{id}/post/{title}&quot;</span>);

<span class="kw">let </span><span class="kw-2">mut </span>map = HashMap::new();
map.insert(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;123&quot;</span>);
map.insert(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;my-post&quot;</span>);

<span class="macro">assert!</span>(resource.resource_path_from_map(<span class="kw-2">&amp;mut </span>s, <span class="kw-2">&amp;</span>map));
<span class="macro">assert_eq!</span>(s, <span class="string">&quot;/user/123/post/my-post&quot;</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#208">source</a><a href="#impl-Clone-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#208">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.73.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.73.0/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.73.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#208">source</a><a href="#impl-Debug-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#208">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.73.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.73.0/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.73.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26'a+str%3E-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#1086">source</a><a href="#impl-From%3C%26'a+str%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#1087">source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(path: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CString%3E-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#1092">source</a><a href="#impl-From%3CString%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt; for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#1093">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(path: <a class="struct" href="https://doc.rust-lang.org/1.73.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#1080">source</a><a href="#impl-Hash-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#1081">source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;mut H</a>)<span class="where fmt-newline">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,</span></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/1.73.0/src/core/hash/mod.rs.html#237-239">source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.slice.html">[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;mut H</a>)<span class="where fmt-newline">where
    H: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.73.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CResourceDef%3E-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#1074">source</a><a href="#impl-PartialEq%3CResourceDef%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a>&gt; for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#1075">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.73.0/src/core/cmp.rs.html#226">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/actix_router/resource.rs.html#1072">source</a><a href="#impl-Eq-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-ResourceDef" class="impl"><a href="#impl-RefUnwindSafe-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section><section id="impl-Send-for-ResourceDef" class="impl"><a href="#impl-Send-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section><section id="impl-Sync-for-ResourceDef" class="impl"><a href="#impl-Sync-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section><section id="impl-Unpin-for-ResourceDef" class="impl"><a href="#impl-Unpin-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section><section id="impl-UnwindSafe-for-ResourceDef" class="impl"><a href="#impl-UnwindSafe-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.ResourceDef.html" title="struct actix_web::dev::ResourceDef">ResourceDef</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-ResourceDef" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/any.rs.html#135">source</a><a href="#impl-Any-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/any.rs.html#136">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.73.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.73.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-ResourceDef" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-ResourceDef" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/indexmap/equivalent.rs.html#18">source</a><a href="#impl-Equivalent%3CK%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; <a class="trait" href="../../indexmap/equivalent/trait.Equivalent.html" title="trait indexmap::equivalent::Equivalent">Equivalent</a>&lt;K&gt; for Q<span class="where fmt-newline">where
    Q: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    K: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="https://doc.rust-lang.org/1.73.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent" class="method trait-impl"><a class="src rightside" href="../../src/indexmap/equivalent.rs.html#24">source</a><a href="#method.equivalent" class="anchor">§</a><h4 class="code-header">fn <a href="../../indexmap/equivalent/trait.Equivalent.html#tymethod.equivalent" class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return <code>true</code> if they are equal.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-ResourceDef" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#722">source</a><a href="#impl-From%3CT%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#725">source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#276">source</a><a href="#impl-Instrument-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tracing/instrument/trait.Instrument.html" title="trait tracing::instrument::Instrument">Instrument</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#82">source</a><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a href="../../tracing/instrument/trait.Instrument.html#method.instrument" class="fn">instrument</a>(self, span: <a class="struct" href="../../tracing/span/struct.Span.html" title="struct tracing::span::Span">Span</a>) -&gt; <a class="struct" href="../../tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided <a href="../../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="../../tracing/instrument/trait.Instrument.html#method.instrument">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#121">source</a><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a href="../../tracing/instrument/trait.Instrument.html#method.in_current_span" class="fn">in_current_span</a>(self) -&gt; <a class="struct" href="../../tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="../../tracing/span/struct.Span.html#method.current" title="associated function tracing::span::Span::current">current</a> <a href="../../tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="../../tracing/instrument/trait.Instrument.html#method.in_current_span">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-ResourceDef" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#706">source</a><a href="#impl-Into%3CU%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#715">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same%3CT%3E-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/typenum/type_operators.rs.html#34">source</a><a href="#impl-Same%3CT%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="../../typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-ResourceDef" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/alloc/borrow.rs.html#82">source</a><a href="#impl-ToOwned-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.73.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/alloc/borrow.rs.html#87">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.73.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/alloc/borrow.rs.html#91">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.73.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.73.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-ResourceDef" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#762">source</a><a href="#impl-TryFrom%3CU%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#769">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-ResourceDef" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#747">source</a><a href="#impl-TryInto%3CU%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.73.0/src/core/convert/mod.rs.html#754">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.73.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/ppv_lite86/types.rs.html#221">source</a><a href="#impl-VZip%3CV%3E-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; <a class="trait" href="../../ppv_lite86/types/trait.VZip.html" title="trait ppv_lite86::types::VZip">VZip</a>&lt;V&gt; for T<span class="where fmt-newline">where
    V: <a class="trait" href="../../ppv_lite86/types/trait.MultiLane.html" title="trait ppv_lite86::types::MultiLane">MultiLane</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a class="src rightside" href="../../src/ppv_lite86/types.rs.html#226">source</a><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a href="../../ppv_lite86/types/trait.VZip.html#tymethod.vzip" class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-ResourceDef" class="impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#334">source</a><a href="#impl-WithSubscriber-for-ResourceDef" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../tracing/instrument/trait.WithSubscriber.html" title="trait tracing::instrument::WithSubscriber">WithSubscriber</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#169-171">source</a><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a href="../../tracing/instrument/trait.WithSubscriber.html#method.with_subscriber" class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; <a class="struct" href="../../tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch">WithDispatch</a>&lt;Self&gt;<span class="where fmt-newline">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.73.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../tracing_core/dispatcher/struct.Dispatch.html" title="struct tracing_core::dispatcher::Dispatch">Dispatch</a>&gt;,</span></h4></section></summary><div class='docblock'>Attaches the provided <a href="../../tracing_core/subscriber/trait.Subscriber.html" title="trait tracing_core::subscriber::Subscriber"><code>Subscriber</code></a> to this type, returning a
<a href="../../tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch"><code>WithDispatch</code></a> wrapper. <a href="../../tracing/instrument/trait.WithSubscriber.html#method.with_subscriber">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a class="src rightside" href="../../src/tracing/instrument.rs.html#221">source</a><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a href="../../tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber" class="fn">with_current_subscriber</a>(self) -&gt; <a class="struct" href="../../tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch">WithDispatch</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="../../tracing/dispatcher/index.html#setting-the-default-subscriber" title="mod tracing::dispatcher">default</a> <a href="../../tracing_core/subscriber/trait.Subscriber.html" title="trait tracing_core::subscriber::Subscriber"><code>Subscriber</code></a> to this type, returning a
<a href="../../tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch"><code>WithDispatch</code></a> wrapper. <a href="../../tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber">Read more</a></div></details></div></details></div></section></div></main></body></html>