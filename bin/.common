#!/bin/bash

set -euo pipefail

export BLUE='\033[0;34m'
export RED='\033[0;31m'
export GREEN='\033[0;32m'
export BOLD='\e[1m'
export CURSIVE='\e[3m'
export RESET_EVERYTHING='\e[0m'

function run_command() {
  command=$1
  shift
  args=("$@")
  echo -e "${CURSIVE}> $command" "$(printf "%q " "${args[@]}" )${RESET_EVERYTHING}"
  "$command" "${args[@]}"
}

function eval_command() {
  command=$1
  arguments=$2
  echo -e "${CURSIVE}> $command" "$(printf "%s " "$arguments")${RESET_EVERYTHING}"
  eval "$command $arguments"
}

function ensure_program_in_path() {
  PROGRAM="$1"
  if ! command -v "$PROGRAM" &> /dev/null; then
      echo "$PROGRAM is not installed or it is not in your \$PATH. Aborting."
      exit 1
  fi
}

function ensure_common_programs_in_path() {
  ensure_program_in_path bc
  ensure_program_in_path jq
  ensure_program_in_path find
  ensure_program_in_path sponge
}

function enforce_inotify_watches_limit_sufficient() {
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    INOTIFY_WATCHES=$(cat /proc/sys/fs/inotify/max_user_watches)
    MIN_INOTIFY_WATCHES=500000
    if [ "$MIN_INOTIFY_WATCHES" -gt "$INOTIFY_WATCHES" ]; then
      echo "You need to increase your inotify watches limit. The limit need to be at least $MIN_INOTIFY_WATCHES and your current limit is $INOTIFY_WATCHES. Aborting."
      echo ""
      echo "See https://github.com/guard/listen/blob/master/README.md#increasing-the-amount-of-inotify-watchers for instructions."
      exit 255
    fi
  fi
}

function check_minikube_version() {
  # just to be sure
  ensure_program_in_path minikube
  MINIKUBE_VERSION_STRING=$(minikube version | grep 'version' | cut -d ' ' -f 3 | cut -d 'v' -f 2)
  MINIKUBE_VERSION_MAJOR=$(echo "$MINIKUBE_VERSION_STRING" | cut -d . -f 1)
  MINIKUBE_VERSION_MINOR=$(echo "$MINIKUBE_VERSION_STRING" | cut -d . -f 2)
  MINIKUBE_VERSION_PATCH=$(echo "$MINIKUBE_VERSION_STRING" | cut -d . -f 3)
  if [ "$MINIKUBE_VERSION_MAJOR" -lt "1" ]; then
    fail_minikube_version
  fi
  if [ "$MINIKUBE_VERSION_MAJOR" -lt "2" ] && [ "$MINIKUBE_VERSION_MINOR" -lt "23" ]; then
    fail_minikube_version
  fi
  if [ "$MINIKUBE_VERSION_MAJOR" -lt "2" ] && [ "$MINIKUBE_VERSION_MINOR" -lt "24" ] && [ "$MINIKUBE_VERSION_PATCH" -lt "2" ]; then
    fail_minikube_version
  fi
}

function fail_minikube_version() {
  echo "Please run bin/minikube-delete and after that upgrade minikube to its latest version."
  exit 255
}

function check_sqlx_cli_version() {
  # just to be sure
  MINIMUM_ACCEPTABLE_VERSION="0.7.1"
  REQUIRED_VERSION_MAJOR=$(echo "$MINIMUM_ACCEPTABLE_VERSION" | cut -d . -f 1)
  REQUIRED_VERSION_MINOR=$(echo "$MINIMUM_ACCEPTABLE_VERSION" | cut -d . -f 2)
  REQUIRED_VERSION_PATCH=$(echo "$MINIMUM_ACCEPTABLE_VERSION" | cut -d . -f 3)
  ensure_program_in_path cargo
  ensure_program_in_path cargo-sqlx
  FULL_INSTALLED_VERSION=$(cargo sqlx --version | cut -d ' ' -f 2)
  INSTALLED_VERSION_MAJOR=$(echo "$FULL_INSTALLED_VERSION" | cut -d . -f 1)
  INSTALLED_VERSION_MINOR=$(echo "$FULL_INSTALLED_VERSION" | cut -d . -f 2)
  INSTALLED_VERSION_PATCH=$(echo "$FULL_INSTALLED_VERSION" | cut -d . -f 3)
  if [ "$INSTALLED_VERSION_MAJOR" -gt "$REQUIRED_VERSION_MAJOR" ]; then
    return
  fi
  if [ "$INSTALLED_VERSION_MAJOR" -lt "$REQUIRED_VERSION_MAJOR" ]; then
    fail_sqlx_cli_version "$FULL_INSTALLED_VERSION" "$MINIMUM_ACCEPTABLE_VERSION"
  fi

  if [ "$INSTALLED_VERSION_MINOR" -gt "$REQUIRED_VERSION_MINOR" ]; then
    return
  fi
  if [ "$INSTALLED_VERSION_MINOR" -lt "$REQUIRED_VERSION_MINOR" ]; then
    fail_sqlx_cli_version "$FULL_INSTALLED_VERSION" "$MINIMUM_ACCEPTABLE_VERSION"
  fi
  if [ "$INSTALLED_VERSION_PATCH" -gt "$REQUIRED_VERSION_PATCH" ]; then
    return
  fi
  if [ "$INSTALLED_VERSION_PATCH" -lt "$REQUIRED_VERSION_PATCH" ]; then
    fail_sqlx_cli_version "$FULL_INSTALLED_VERSION" "$MINIMUM_ACCEPTABLE_VERSION"
  fi
}

function fail_sqlx_cli_version() {
  echo "Your sqlx-cli needs to be updated. Minimum acceptable version: $2, installed: $1. Please run: cargo install sqlx-cli --force"
  exit 255
}

function disallow_running_as_root() {
  if [[ "$OSTYPE" == "cygwin" || "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
    # Windows: NOP
    true
  else
    if [ "$(id -u)" = "0" ]; then
      echo "Please don't try to run this command as root."
      exit 255
    fi
  fi
}

# Makes the command work no matter which directory it's called from. Converts a path that is relative to the bin folder to be relative to the current directory the script caller is in.
function relativize_path() {
  local basedir
  local path_to_target
  local relative_path
  basedir="$(dirname "${BASH_SOURCE[0]}")"
  path_to_target="$basedir/$1"
  relative_path=$(realpath --relative-to="$(pwd)" "$path_to_target")
  echo "$relative_path"
}

function point_docker_cli_to_minikube_docker() {
  echo "Making docker cli to use the minikube docker"
  echo "> eval \"\$(minikube -p minikube docker-env --shell bash)\""
  eval "$(minikube -p minikube docker-env --shell bash)"
  echo ""
}

function ensure_tmc_langs_cli_downloaded() {
  path_to_tmc=$(relativize_path "../services/tmc")
  path_to_tmc_version="$path_to_tmc"/tmc-langs-version
  tmc_version=$(< "$path_to_tmc_version" tr -d '[:space:]')
  if [ -f "$path_to_tmc"/tmc-langs-cli-x86_64-unknown-linux-gnu-"$tmc_version" ];
  then
      echo "Found tmc-langs-cli"
  else
      echo "Downloading tmc-langs-cli"
      path_to_downloader=$(relativize_path "./tmc-langs-setup")
      run_command "$path_to_downloader"
  fi
}


function make_sure_skaffold_local_env_patch_files_exists() {
  file_contents=$(cat <<EOF
# ðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸ
# ðŸŒŸ                                                                     ðŸŒŸ
# ðŸŒŸ  NOTE: This file is for patching environment variables during       ðŸŒŸ
# ðŸŒŸ  local development only. Do NOT commit any changes made to this     ðŸŒŸ
# ðŸŒŸ  file.                                                              ðŸŒŸ
# ðŸŒŸ                                                                     ðŸŒŸ
# ðŸŒŸ If this file does not exist, it is automatically created in         ðŸŒŸ
# ðŸŒŸ bin/common                                                          ðŸŒŸ
# ðŸŒŸ                                                                     ðŸŒŸ
# ðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸ

apiVersion: v1
kind: Secret
metadata:
  name: headless-lms-secrets
type: Opaque
data:
  # Add here the env values you want to change only on your local environment.
  # Use bin/base64-encode to encode the values.
  EXAMPLE_PATCHED_SECRET: "d2F0"
EOF
)
  files_to_create=(
    "$(relativize_path "../kubernetes/dev/headless-lms/env-local-patch.secret.yml")"
    "$(relativize_path "../kubernetes/test/headless-lms/env-local-patch.secret.yml")"
  )
  for file in "${files_to_create[@]}"; do
    if [ ! -f "$file" ]; then
      echo "$file_contents" > "$file"
    fi
  done
}
