<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Common interface for memory regions."><meta name="keywords" content="rust, rustlang, rust-lang, BitStore"><title>BitStore in bitvec::store - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../bitvec/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Trait BitStore</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#associated-types">Associated Types</a><div class="sidebar-links"><a href="#associatedtype.Access">Access</a><a href="#associatedtype.Alias">Alias</a><a href="#associatedtype.Mem">Mem</a></div><a class="sidebar-title" href="#required-methods">Required Methods</a><div class="sidebar-links"><a href="#tymethod.load_value">load_value</a></div><a class="sidebar-title" href="#provided-methods">Provided Methods</a><div class="sidebar-links"><a href="#method.get_bit">get_bit</a><a href="#method.get_bits">get_bits</a></div><a class="sidebar-title" href="#foreign-impls">Implementations on Foreign Types</a><div class="sidebar-links"><a href="#impl-BitStore-for-Cell%3CR%3E">Cell&lt;R&gt;</a><a href="#impl-BitStore-for-u16">u16</a><a href="#impl-BitStore-for-u32">u32</a><a href="#impl-BitStore-for-u64">u64</a><a href="#impl-BitStore-for-u8">u8</a><a href="#impl-BitStore-for-usize">usize</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class="location"><a href="../index.html">bitvec</a>::<wbr><a href="index.html">store</a></p><div id="sidebar-vars" data-name="BitStore" data-ty="trait" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Trait <a href="../index.html">bitvec</a>::<wbr><a href="index.html">store</a>::<wbr><a class="trait" href="">BitStore</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/bitvec/store.rs.html#82-170" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust trait">pub trait BitStore: Sealed + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> {
    type <a href="#associatedtype.Mem" class="type">Mem</a>: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Self&gt;;
    type <a href="#associatedtype.Access" class="type">Access</a>: BitAccess&lt;Item = Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;;
    type <a href="#associatedtype.Alias" class="type">Alias</a>: <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>&lt;Item = Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;;
    fn <a href="#tymethod.load_value" class="fnname">load_value</a>(&amp;self) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>;

    fn <a href="#method.get_bit" class="fnname">get_bit</a>&lt;O&gt;(&amp;self, index: <a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a></span>,
    { ... }
<div class="item-spacer"></div>    fn <a href="#method.get_bits" class="fnname">get_bits</a>(&amp;self, mask: <a class="struct" href="../index/struct.BitMask.html" title="struct bitvec::index::BitMask">BitMask</a>&lt;Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a> { ... }
}</pre></div><div class="docblock"><p>Common interface for memory regions.</p>
<p>This trait is implemented on the fundamental integers no wider than the target
processor word size, their <code>Cell</code> wrappers, and (if present) their <code>Atomic</code>
variants. Users provide this type as a parameter to their data structures in
order to inform the structure of how it may access the memory it describes.</p>
<p>Currently, <code>bitvec</code> is only tested on 32- and 64- bit architectures. This means
that <code>u8</code>, <code>u16</code>, <code>u32</code>, and <code>usize</code> unconditionally implement <code>BitStore</code>, but
<code>u64</code> will only do so on 64-bit targets, and will be unavailable on 32-bit
targets. This is a necessary restriction of <code>bitvec</code> internals. Please comment
on <a href="https://github.com/myrrlyn/bitvec/issues/76">Issue #76</a> if this affects you.</p>
<p>Specifically, this has the davantage that a <code>BitSlice&lt;_, Cell&lt;_&gt;&gt;</code> knows that it
has a view of memory that will not undergo concurrent modification. As such, it
can forego atomic accesses, and just use ordinary load/store instructions
without fear of causing observable race conditions.</p>
<p>The associated types <code>Mem</code> and <code>Alias</code> allow implementors to know the register
width of the memory they describe (<code>Mem</code>) and to know the aliasing status of the
region.</p>
<h1 id="generic-programming" class="section-header"><a href="#generic-programming">Generic Programming</a></h1>
<p>Generic programming with associated types is <em>hard</em>, especially when using them,
as in this trait, to implement a closed graph of relationships between types.</p>
<p>For example, this trait is implemented such that for any given type <code>T</code>,
<code>T::Alias::Mem</code> == <code>T::Mem</code> == <code>T::NoAlias::Mem</code>, <code>T::Alias::Alias == T::Alias</code>,
and <code>T::NoAlias::NoAlias == T::NoAlias</code>. Unfortunately, the Rust type system
does not allow these relationships to be described, so generic programming that
performs type transitions will <em>rapidly</em> become uncomfortable to use.</p>
<p>Internally, <code>bitvec</code> makes use of type-manipulation functions that are known to
be correct with respect to the implementations of <code>BitStore</code> in order to ease
implementation of library methods.</p>
<p>You are not expected to do significant programming that is generic over the
<code>BitStore</code> memory parameter. When using a concrete type, the compiler will
gladly reduce the abstract type associations into their instantiated selections,
allowing monomorphized code to be <em>much</em> more convenient than generic.</p>
<p>If you have a use case that involves generic programming over this trait, and
you are encountering difficulties dealing with the type associations, please
file an issue asking for support in this area.</p>
<h1 id="supertraits" class="section-header"><a href="#supertraits">Supertraits</a></h1>
<p>This trait has trait requirements that better express its behavior:</p>
<ul>
<li><code>Sealed</code> prevents it from being implemented by downstream libraries (<code>Sealed</code>
is a public trait in a private module, that only this crate can name).</li>
<li><code>Sized</code> instructs the compiler that values of this type can be used as
immediates.</li>
<li><code>Debug</code> informs the compiler that other structures using this trait bound can
correctly derive <code>Debug</code>.
<ul>
<li></li>
</ul>
</li>
</ul>
</div><h2 id="associated-types" class="small-section-header">Associated Types<a href="#associated-types" class="anchor"></a></h2><div class="methods"><h3 id="associatedtype.Mem" class="method"><code>type <a href="#associatedtype.Mem" class="type">Mem</a>: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Self&gt;</code><a class="srclink" href="../../src/bitvec/store.rs.html#84" title="goto source code">[src]</a></h3><div class="docblock"><p>The register type that the implementor describes.</p>
</div><h3 id="associatedtype.Access" class="method"><code>type <a href="#associatedtype.Access" class="type">Access</a>: BitAccess&lt;Item = Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;</code><a class="srclink" href="../../src/bitvec/store.rs.html#87" title="goto source code">[src]</a></h3><div class="docblock"><p>The modifier type over <code>Self::Mem</code> used to perform memory access.</p>
</div><h3 id="associatedtype.Alias" class="method"><code>type <a href="#associatedtype.Alias" class="type">Alias</a>: <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>&lt;Item = Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;</code><a class="srclink" href="../../src/bitvec/store.rs.html#100" title="goto source code">[src]</a></h3><div class="docblock"><p>A sibling <code>BitStore</code> implementor that performs alias-aware memory
access.</p>
<p>While the associated type always has the same <code>Mem</code> concrete type as
<code>Self</code>, attempting to encode this requirement as `&lt;Mem = Self::Mem&gt;
causes Rust to enter an infinite recursion in the trait solver.</p>
<p>Instead, the two <code>Radium</code> bounds inform the compiler that the <code>Alias</code> is
irradiant over both the current memory and the destination memory types,
allowing generic type algebra to resolve correctly even though the fact
that <code>Radium</code> is only implemented once is not guaranteed.</p>
</div></div><span class="loading-content">Loading content...</span><h2 id="required-methods" class="small-section-header">Required methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><h3 id="tymethod.load_value" class="method"><code>fn <a href="#tymethod.load_value" class="fnname">load_value</a>(&amp;self) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></code><a class="srclink" href="../../src/bitvec/store.rs.html#128" title="goto source code">[src]</a></h3><div class="docblock"><p>Copies a memory element into the caller’s local context.</p>
<h1 id="parameters" class="section-header"><a href="#parameters">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns" class="section-header"><a href="#returns">Returns</a></h1>
<p>A copy of the value at <code>*self</code>.</p>
</div></div><span class="loading-content">Loading content...</span><h2 id="provided-methods" class="small-section-header">Provided methods<a href="#provided-methods" class="anchor"></a></h2><div class="methods"><h3 id="method.get_bit" class="method"><code>fn <a href="#method.get_bit" class="fnname">get_bit</a>&lt;O&gt;(&amp;self, index: <a class="struct" href="../index/struct.BitIdx.html" title="struct bitvec::index::BitIdx">BitIdx</a>&lt;Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/store.rs.html#144-147" title="goto source code">[src]</a></h3><div class="docblock"><p>Fetches the value of one bit in a memory element.</p>
<h1 id="type-parameters" class="section-header"><a href="#type-parameters">Type Parameters</a></h1>
<ul>
<li><code>O</code>: A bit ordering.</li>
</ul>
<h1 id="parameters-1" class="section-header"><a href="#parameters-1">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>index</code>: The semantic index of the bit in <code>*self</code> to read.</li>
</ul>
<h1 id="returns-1" class="section-header"><a href="#returns-1">Returns</a></h1>
<p>The value of the bit in <code>*self</code> corresponding to <code>index</code>.</p>
</div><h3 id="method.get_bits" class="method"><code>fn <a href="#method.get_bits" class="fnname">get_bits</a>(&amp;self, mask: <a class="struct" href="../index/struct.BitMask.html" title="struct bitvec::index::BitMask">BitMask</a>&lt;Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></code><a class="srclink" href="../../src/bitvec/store.rs.html#167-169" title="goto source code">[src]</a></h3><div class="docblock"><p>Fetches any number of bits from a memory element.</p>
<p>The mask provided to this method must be constructed from indices that
are valid in the caller’s context. As the mask is already computed by
the caller, this does not take an ordering type parameter.</p>
<h1 id="parameters-2" class="section-header"><a href="#parameters-2">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>mask</code>: A mask of any number of bits. This is a selection mask of bits
to read.</li>
</ul>
<h1 id="returns-2" class="section-header"><a href="#returns-2">Returns</a></h1>
<p>A copy of the memory element at <code>*self</code>, with all bits not selected (set
to <code>0</code>) in <code>mask</code> erased and all bits selected (set to <code>1</code>) in <code>mask</code>
preserved.</p>
</div></div><span class="loading-content">Loading content...</span><h2 id="foreign-impls" class="small-section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-BitStore-for-u8" class="impl"><code class="in-band">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></code><a href="#impl-BitStore-for-u8" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#236-240" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Access-1" class="type trait-impl"><code>type <a href="#associatedtype.Access" class="type">Access</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Access-1" class="anchor"></a></h4><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div><h4 id="associatedtype.Alias-1" class="type trait-impl"><code>type <a href="#associatedtype.Alias" class="type">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Alias-1" class="anchor"></a></h4><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div><h4 id="associatedtype.Mem-1" class="type trait-impl"><code>type <a href="#associatedtype.Mem" class="type">Mem</a> = Self</code><a href="#associatedtype.Mem-1" class="anchor"></a></h4><h4 id="method.load_value" class="method hidden trait-impl"><code>fn <a href="#tymethod.load_value" class="fnname">load_value</a>(&amp;self) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></code><a href="#method.load_value" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#236-240" title="goto source code">[src]</a></h4></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-BitStore-for-u16" class="impl"><code class="in-band">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a></code><a href="#impl-BitStore-for-u16" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#236-240" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Access-2" class="type trait-impl"><code>type <a href="#associatedtype.Access" class="type">Access</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Access-2" class="anchor"></a></h4><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div><h4 id="associatedtype.Alias-2" class="type trait-impl"><code>type <a href="#associatedtype.Alias" class="type">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Alias-2" class="anchor"></a></h4><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div><h4 id="associatedtype.Mem-2" class="type trait-impl"><code>type <a href="#associatedtype.Mem" class="type">Mem</a> = Self</code><a href="#associatedtype.Mem-2" class="anchor"></a></h4><h4 id="method.load_value-1" class="method hidden trait-impl"><code>fn <a href="#tymethod.load_value" class="fnname">load_value</a>(&amp;self) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></code><a href="#method.load_value-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#236-240" title="goto source code">[src]</a></h4></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-BitStore-for-u32" class="impl"><code class="in-band">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a href="#impl-BitStore-for-u32" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#236-240" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Access-3" class="type trait-impl"><code>type <a href="#associatedtype.Access" class="type">Access</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Access-3" class="anchor"></a></h4><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div><h4 id="associatedtype.Alias-3" class="type trait-impl"><code>type <a href="#associatedtype.Alias" class="type">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Alias-3" class="anchor"></a></h4><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div><h4 id="associatedtype.Mem-3" class="type trait-impl"><code>type <a href="#associatedtype.Mem" class="type">Mem</a> = Self</code><a href="#associatedtype.Mem-3" class="anchor"></a></h4><h4 id="method.load_value-2" class="method hidden trait-impl"><code>fn <a href="#tymethod.load_value" class="fnname">load_value</a>(&amp;self) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></code><a href="#method.load_value-2" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#236-240" title="goto source code">[src]</a></h4></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-BitStore-for-u64" class="impl"><code class="in-band">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></code><a href="#impl-BitStore-for-u64" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#243" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Access-4" class="type trait-impl"><code>type <a href="#associatedtype.Access" class="type">Access</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Access-4" class="anchor"></a></h4><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div><h4 id="associatedtype.Alias-4" class="type trait-impl"><code>type <a href="#associatedtype.Alias" class="type">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Alias-4" class="anchor"></a></h4><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div><h4 id="associatedtype.Mem-4" class="type trait-impl"><code>type <a href="#associatedtype.Mem" class="type">Mem</a> = Self</code><a href="#associatedtype.Mem-4" class="anchor"></a></h4><h4 id="method.load_value-3" class="method hidden trait-impl"><code>fn <a href="#tymethod.load_value" class="fnname">load_value</a>(&amp;self) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></code><a href="#method.load_value-3" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#243" title="goto source code">[src]</a></h4></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-BitStore-for-usize" class="impl"><code class="in-band">impl <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a href="#impl-BitStore-for-usize" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#245" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Access-5" class="type trait-impl"><code>type <a href="#associatedtype.Access" class="type">Access</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Access-5" class="anchor"></a></h4><div class="docblock"><p>The unsigned integers will only be <code>BitStore</code> type parameters
for handles to unaliased memory, following the normal Rust
reference rules.</p>
</div><h4 id="associatedtype.Alias-5" class="type trait-impl"><code>type <a href="#associatedtype.Alias" class="type">Alias</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;Self&gt;</code><a href="#associatedtype.Alias-5" class="anchor"></a></h4><div class="docblock"><p>In non-atomic builds, use cell wrappers for aliased access.</p>
</div><h4 id="associatedtype.Mem-5" class="type trait-impl"><code>type <a href="#associatedtype.Mem" class="type">Mem</a> = Self</code><a href="#associatedtype.Mem-5" class="anchor"></a></h4><h4 id="method.load_value-4" class="method hidden trait-impl"><code>fn <a href="#tymethod.load_value" class="fnname">load_value</a>(&amp;self) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></code><a href="#method.load_value-4" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#245" title="goto source code">[src]</a></h4></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-BitStore-for-Cell%3CR%3E" class="impl"><code class="in-band">impl&lt;R&gt; <a class="trait" href="trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> for <a class="struct" href="https://doc.rust-lang.org/nightly/core/cell/struct.Cell.html" title="struct core::cell::Cell">Cell</a>&lt;R&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>&lt;Item = R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../index/trait.BitRegister.html" title="trait bitvec::index::BitRegister">BitRegister</a>,&nbsp;</span></code><a href="#impl-BitStore-for-Cell%3CR%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#247-271" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Access-6" class="type trait-impl"><code>type <a href="#associatedtype.Access" class="type">Access</a> = Self</code><a href="#associatedtype.Access-6" class="anchor"></a></h4><h4 id="associatedtype.Alias-6" class="type trait-impl"><code>type <a href="#associatedtype.Alias" class="type">Alias</a> = Self</code><a href="#associatedtype.Alias-6" class="anchor"></a></h4><h4 id="associatedtype.Mem-6" class="type trait-impl"><code>type <a href="#associatedtype.Mem" class="type">Mem</a> = R</code><a href="#associatedtype.Mem-6" class="anchor"></a></h4><h4 id="method.load_value-5" class="method hidden trait-impl"><code>fn <a href="#tymethod.load_value" class="fnname">load_value</a>(&amp;self) -&gt; Self::<a class="type" href="trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a></code><a href="#method.load_value-5" class="anchor"></a><a class="srclink" href="../../src/bitvec/store.rs.html#268-270" title="goto source code">[src]</a></h4></div></details><span class="loading-content">Loading content...</span><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div class="item-list" id="implementors-list"></div><span class="loading-content">Loading content...</span><script type="text/javascript" src="../../implementors/bitvec/store/trait.BitStore.js" async></script></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script></body></html>