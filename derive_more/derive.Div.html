<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="What `#[derive(Mul)]` generates"><title>Div in derive_more - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="derive_more" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Div</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../derive_more/index.html">derive_<wbr>more</a><span class="version">2.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Div</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#what-derivemul-generates" title="What `#[derive(Mul)]` generates">What <code>#[derive(Mul)]</code> generates</a><ul><li><a href="#scalar-implementation" title="Scalar implementation">Scalar implementation</a></li><li><a href="#structural-implementation" title="Structural implementation">Structural implementation</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate derive_<wbr>more</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">derive_more</a></div><h1>Derive Macro <span class="derive">Div</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/derive_more_impl/lib.rs.html#95">Source</a> </span></div><pre class="rust item-decl"><code>#[derive(Div)]
{
    <span class="comment">// Attributes available to this derive:</span>
    #[div]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="what-derivemul-generates"><a class="doc-anchor" href="#what-derivemul-generates">§</a>What <code>#[derive(Mul)]</code> generates</h2>
<blockquote>
<p><strong>NOTE</strong>: <code>Div</code>, <code>Rem</code>, <code>Shr</code> and <code>Shl</code> derives are fully equivalent
to the <code>Mul</code> derive described below.</p>
</blockquote>
<p>In contrast with deriving <code>Add</code>, there are two ways to derive <code>Mul</code>: scalar and structural.</p>
<h3 id="scalar-implementation"><a class="doc-anchor" href="#scalar-implementation">§</a>Scalar implementation</h3>
<p>By default, deriving <code>Mul</code> is quite different from deriving <code>Add</code>. It is not used
to multiply two structs together. Instead, it will normally multiply a struct,
which can have multiple fields, with a single primitive type (e.g. a <code>u64</code>).
A new struct is then created with all the fields from the previous struct
multiplied by this other value.</p>
<p>A simple way of explaining the reasoning behind this difference between <code>Add</code>
and <code>Mul</code> deriving, is looking at arithmetic on meters. One meter can be added
to one meter, to get two meters. Also, one meter times two would be two meters,
but one meter times one meter would be one square meter. As this second case
clearly requires more knowledge about the meaning of the type in question
deriving for this is not implemented.</p>
<h4 id="structs"><a class="doc-anchor" href="#structs">§</a>Structs</h4>
<p>Deriving <code>Mul</code> for a struct with a single field multiplies its field with
anything <code>Mul</code>tiplicable, producing the resulting struct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Mul)]
</span><span class="kw">struct </span>MyInt(i32);

<span class="attr">#[derive(Mul)]
</span><span class="kw">struct </span>Point1D {
    x: i32,
}</code></pre></div>
<p>This generates code equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;Rhs&gt; Mul&lt;Rhs&gt; <span class="kw">for </span>MyInt
<span class="kw">where
    </span>i32: Mul&lt;Rhs, Output = i32&gt;
{
    <span class="kw">type </span>Output = <span class="self">Self</span>;

    <span class="kw">fn </span>mul(<span class="self">self</span>, rhs: Rhs) -&gt; <span class="self">Self</span>::Output {
        <span class="kw">match </span><span class="self">self </span>{
            <span class="self">Self</span>(self_0) =&gt; <span class="self">Self</span>(Mul::mul(self_0, rhs)),
        }
    }
}

<span class="kw">impl</span>&lt;Rhs&gt; Mul&lt;Rhs&gt; <span class="kw">for </span>Point1D
<span class="kw">where
    </span>i32: Mul&lt;Rhs, Output = i32&gt;
{
    <span class="kw">type </span>Output = <span class="self">Self</span>;

    <span class="kw">fn </span>mul(<span class="self">self</span>, rhs: Rhs) -&gt; <span class="self">Self</span>::Output {
        <span class="kw">match </span><span class="self">self </span>{
            <span class="self">Self </span>{ x: self_0 } =&gt; <span class="self">Self </span>{ x: Mul::mul(self_0, rhs) },
        }
    }
}</code></pre></div>
<p>The behaviour is slightly different for multiple fields, since the right hand
side of the multiplication now needs the <code>Copy</code> trait.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Mul)]
</span><span class="kw">struct </span>MyInts(i32, i32);

<span class="attr">#[derive(Mul)]
</span><span class="kw">struct </span>Point2D {
    x: i32,
    y: i32,
}</code></pre></div>
<p>This generates code equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;Rhs: Copy&gt; Mul&lt;Rhs&gt; <span class="kw">for </span>MyInts
<span class="kw">where
    </span>i32: Mul&lt;Rhs, Output = i32&gt;
{
    <span class="kw">type </span>Output = <span class="self">Self</span>;

    <span class="kw">fn </span>mul(<span class="self">self</span>, rhs: Rhs) -&gt; <span class="self">Self</span>::Output {
        <span class="kw">match </span><span class="self">self </span>{
            <span class="self">Self</span>(self_0, self_1) =&gt; {
                <span class="self">Self</span>(Mul::mul(self_0, rhs), Mul::mul(self_1, rhs))
            }
        }
    }
}

<span class="kw">impl</span>&lt;Rhs: Copy&gt; Mul&lt;Rhs&gt; <span class="kw">for </span>Point2D
<span class="kw">where
    </span>i32: Mul&lt;Rhs, Output = i32&gt;
{
    <span class="kw">type </span>Output = <span class="self">Self</span>;

    <span class="kw">fn </span>mul(<span class="self">self</span>, rhs: Rhs) -&gt; <span class="self">Self</span>::Output {
        <span class="kw">match </span><span class="self">self </span>{
            <span class="self">Self </span>{ x: self_0, y: self_1 } =&gt; <span class="self">Self </span>{
                x: Mul::mul(self_0, rhs),
                y: Mul::mul(self_1, rhs),
            },
        }
    }
}</code></pre></div><h5 id="ignoring"><a class="doc-anchor" href="#ignoring">§</a>Ignoring</h5>
<p>Sometimes a struct needs to hold a field (most commonly <code>PhantomData</code>) that doesn’t
participate in a scalar <code>Mul</code> implementation. Such field could be ignored using
the <code>#[mul(skip)]</code> attribute.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Mul)]
</span><span class="kw">struct </span>TupleWithZst&lt;T&gt;(i32, <span class="attr">#[mul(skip)] </span>PhantomData&lt;T&gt;);

<span class="attr">#[derive(Mul)]
</span><span class="kw">struct </span>StructWithZst&lt;T&gt; {
    x: i32,
    <span class="attr">#[mul(skip)] </span><span class="comment">// or #[mul(ignore)]
    </span>_marker: PhantomData&lt;T&gt;,
}</code></pre></div><h4 id="enums"><a class="doc-anchor" href="#enums">§</a>Enums</h4>
<p>Deriving scalar <code>Mul</code> implementation for enums is not (yet) supported.</p>
<p>Although it shouldn’t be impossible no effort has been put into this yet.</p>
<h3 id="structural-implementation"><a class="doc-anchor" href="#structural-implementation">§</a>Structural implementation</h3>
<p>Specifying the <code>#[mul(forward)]</code> attribute generates a structural <code>Mul</code>
implementation with the same semantics as <code>Add</code>: <code>Mul</code>tiplying respective
fields together and producing a new value with these fields.</p>
<h4 id="structs-1"><a class="doc-anchor" href="#structs-1">§</a>Structs</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Mul)]
#[mul(forward)]
</span><span class="kw">struct </span>MyInts(i32, i32);

<span class="attr">#[derive(Mul)]
#[mul(forward)]
</span><span class="kw">struct </span>Point2D {
    x: i32,
    y: i32,
}</code></pre></div>
<p>This generates code equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>Mul <span class="kw">for </span>MyInts {
    <span class="kw">type </span>Output = <span class="self">Self</span>;

    <span class="kw">fn </span>mul(<span class="self">self</span>, rhs: <span class="self">Self</span>) -&gt; <span class="self">Self</span>::Output {
        <span class="kw">match </span>(<span class="self">self</span>, rhs) {
            (<span class="self">Self</span>(self_0, self_1), <span class="self">Self</span>(rhs_0, rhs_1)) =&gt; {
                <span class="self">Self</span>(Mul::mul(self_0, rhs_0), Mul::mul(self_1, rhs_1))
            }
        }
    }
}

<span class="kw">impl </span>Mul <span class="kw">for </span>Point2D {
    <span class="kw">type </span>Output = <span class="self">Self</span>;

    <span class="kw">fn </span>mul(<span class="self">self</span>, rhs: <span class="self">Self</span>) -&gt; <span class="self">Self</span>::Output {
        <span class="kw">match </span>(<span class="self">self</span>, rhs) {
            (<span class="self">Self </span>{ x: self_0, y: self_1 }, <span class="self">Self </span>{ x: rhs_0, y: rhs_1 }) =&gt; {
                <span class="self">Self </span>{ x: Mul::mul(self_0, rhs_0), y: Mul::mul(self_1, rhs_1) }
            }
        }
    }
}</code></pre></div>
<p>The behaviour is similar with more or less fields.</p>
<h5 id="ignoring-1"><a class="doc-anchor" href="#ignoring-1">§</a>Ignoring</h5>
<p>Sometimes a struct needs to hold a field (most commonly <code>PhantomData</code>) that doesn’t
participate in a structural <code>Mul</code> implementation. Such field could be ignored using
the <code>#[mul(skip)]</code> attribute.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Mul)]
#[mul(forward)]
</span><span class="kw">struct </span>TupleWithZst&lt;T&gt;(i32, <span class="attr">#[mul(skip)] </span>PhantomData&lt;T&gt;);

<span class="attr">#[derive(Mul)]
#[mul(forward)]
</span><span class="kw">struct </span>StructWithZst&lt;T&gt; {
    x: i32,
    <span class="attr">#[mul(skip)] </span><span class="comment">// or #[mul(ignore)]
    </span>_marker: PhantomData&lt;T&gt;,
}</code></pre></div><h4 id="enums-1"><a class="doc-anchor" href="#enums-1">§</a>Enums</h4>
<p>For enums each variant can be <code>Mul</code>tiplied structurally in a similar way to another
instance of the same variant. There’s one big difference however: it returns
a <code>Result&lt;EnumType&gt;</code>, because an error is returned when two different variants are
<code>Mul</code>tiplied together.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Mul)]
#[mul(forward)]
</span><span class="kw">enum </span>MixedInts {
    BigInt(i64),
    NamedSmallInts { x: i32, y: i32 },
    Unit,
}</code></pre></div>
<p>This generates code equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>Mul <span class="kw">for </span>MixedInts {
    <span class="kw">type </span>Output = <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, derive_more::BinaryError&gt;;

    <span class="kw">fn </span>mul(<span class="self">self</span>, rhs: <span class="self">Self</span>) -&gt; <span class="self">Self</span>::Output {
        <span class="kw">match </span>(<span class="self">self</span>, rhs) {
            (<span class="self">Self</span>::BigInt(self_0), <span class="self">Self</span>::BigInt(rhs_0)) =&gt; {
                <span class="prelude-val">Ok</span>(<span class="self">Self</span>::BigInt(Mul::mul(self_0, rhs_0)))
            }
            (<span class="self">Self</span>::NamedSmallInts { x: self_0, y: self_1 },
             <span class="self">Self</span>::NamedSmallInts { x: rhs_0, y: rhs_1 }) =&gt; {
                <span class="prelude-val">Ok</span>(<span class="self">Self</span>::NamedSmallInts {
                    x: Mul::mul(self_0, rhs_0),
                    y: Mul::mul(self_1, rhs_1),
                })
            }
            (<span class="self">Self</span>::Unit, <span class="self">Self</span>::Unit) =&gt; <span class="prelude-val">Err</span>(derive_more::BinaryError::Unit(
                derive_more::UnitError::new(<span class="string">"add"</span>),
            )),
            <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(derive_more::BinaryError::Mismatch(
                derive_more::WrongVariantError::new(<span class="string">"add"</span>),
            )),
        }
    }
}</code></pre></div>
<p>Also note the <code>Unit</code> variant that throws a <code>derive_more::UnitError</code> when <code>Mul</code>tiplying it
to itself.</p>
<h5 id="ignoring-2"><a class="doc-anchor" href="#ignoring-2">§</a>Ignoring</h5>
<p>Similarly to structs, enum fields could be ignored using the <code>#[add(skip)]</code> attribute.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>I32(i32); <span class="comment">// doesn't implement `Mul`

</span><span class="attr">#[derive(Mul)]
#[mul(forward)]
</span><span class="kw">enum </span>MixedInts {
    TwoSmallInts(i32, <span class="attr">#[mul(skip)] </span>I32),
    NamedSmallInts {
        <span class="attr">#[mul(skip)] </span><span class="comment">// or #[mul(ignore)]
        </span>x: I32,
        y: i32,
    },
}</code></pre></div>
<blockquote>
<p><strong>NOTE</strong>: Ignoring all the fields of a variant or ignoring the variant itself is not allowed
(results in a compilation error).</p>
</blockquote>
</div></details></section></div></main></body></html>