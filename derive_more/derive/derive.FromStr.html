<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="What `#[derive(FromStr)]` generates"><title>FromStr in derive_more::derive - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="derive_more" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">FromStr</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../derive_more/index.html">derive_<wbr>more</a><span class="version">2.1.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">FromStr</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#what-derivefromstr-generates" title="What `#[derive(FromStr)]` generates">What <code>#[derive(FromStr)]</code> generates</a><ul><li><a href="#forwarding" title="Forwarding">Forwarding</a></li><li><a href="#flat-representation" title="Flat representation">Flat representation</a></li><li><a href="#custom-error" title="Custom error">Custom error</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In derive_<wbr>more::<wbr>derive</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">derive_more</a>::<wbr><a href="index.html">derive</a></div><h1>Derive Macro <span class="derive">FromStr</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/derive_more_impl/lib.rs.html#95">Source</a> </span></div><pre class="rust item-decl"><code>#[derive(FromStr)]
{
    <span class="comment">// Attributes available to this derive:</span>
    #[from_str]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="what-derivefromstr-generates"><a class="doc-anchor" href="#what-derivefromstr-generates">§</a>What <code>#[derive(FromStr)]</code> generates</h2>
<p>Deriving <code>FromStr</code> only works for enums/structs with no fields
or newtypes (structs with only a single field). The result is
that you will be able to call the <code>parse()</code> method on a string
to convert it to your newtype. This only works when the wrapped
type implements <code>FromStr</code> itself.</p>
<h3 id="forwarding"><a class="doc-anchor" href="#forwarding">§</a>Forwarding</h3>
<p>Deriving forwarding implementation is only supported for newtypes
(structs with only a single field).</p>
<h4 id="tuple-structs"><a class="doc-anchor" href="#tuple-structs">§</a>Tuple structs</h4>
<p>When deriving <code>FromStr</code> for a tuple struct with one field:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
</span><span class="kw">struct </span>MyInt(i32);

<span class="macro">assert_eq!</span>(<span class="string">"5"</span>.parse::&lt;MyInt&gt;().unwrap(), MyInt(<span class="number">5</span>));</code></pre></div>
<p>Code like this is generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::core::str::FromStr <span class="kw">for </span>MyInt {
    <span class="kw">type </span><span class="prelude-val">Err </span>= &lt;i32 <span class="kw">as </span>derive_more::core::str::FromStr&gt;::Err;
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        <span class="prelude-val">Ok</span>(<span class="self">Self</span>(i32::from_str(s)<span class="question-mark">?</span>))
    }
}</code></pre></div><h4 id="regular-structs"><a class="doc-anchor" href="#regular-structs">§</a>Regular structs</h4>
<p>When deriving <code>FromStr</code> for a regular struct with one field:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
</span><span class="kw">struct </span>Point1D {
    x: i32,
}

<span class="macro">assert_eq!</span>(<span class="string">"100"</span>.parse::&lt;Point1D&gt;().unwrap(), Point1D { x: <span class="number">100 </span>});</code></pre></div>
<p>Code like this is generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::core::str::FromStr <span class="kw">for </span>Point1D {
    <span class="kw">type </span><span class="prelude-val">Err </span>= &lt;i32 <span class="kw">as </span>derive_more::core::str::FromStr&gt;::Err;
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        <span class="prelude-val">Ok</span>(<span class="self">Self </span>{
            x: i32::from_str(s)<span class="question-mark">?</span>,
        })
    }
}</code></pre></div><h3 id="flat-representation"><a class="doc-anchor" href="#flat-representation">§</a>Flat representation</h3>
<p>Deriving flat string representation is only supported for empty enums and
structs (with no fields).</p>
<h4 id="empty-enums"><a class="doc-anchor" href="#empty-enums">§</a>Empty enums</h4>
<p>When deriving <code>FromStr</code> for enums with empty variants, it will generate a
<code>from_str()</code> method converting strings matching the variant name to the variant.
If using a case-insensitive match would give a unique variant (i.e. you don’t have
both <code>MyEnum::Foo</code> and <code>MyEnum::foo</code> variants), then case-insensitive matching will
be used, otherwise it will fall back to exact string matching.</p>
<p>Since the string may not match any variants an error type is needed, so the
<code>derive_more::FromStrError</code> is used for that purpose.</p>
<p>Given the following enum:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
</span><span class="kw">enum </span>EnumNoFields {
    Foo,
    Bar,
    Baz,
    BaZ,
}

<span class="macro">assert_eq!</span>(<span class="string">"foo"</span>.parse::&lt;EnumNoFields&gt;().unwrap(), EnumNoFields::Foo);
<span class="macro">assert_eq!</span>(<span class="string">"Foo"</span>.parse::&lt;EnumNoFields&gt;().unwrap(), EnumNoFields::Foo);
<span class="macro">assert_eq!</span>(<span class="string">"FOO"</span>.parse::&lt;EnumNoFields&gt;().unwrap(), EnumNoFields::Foo);

<span class="macro">assert_eq!</span>(<span class="string">"Bar"</span>.parse::&lt;EnumNoFields&gt;().unwrap(), EnumNoFields::Bar);
<span class="macro">assert_eq!</span>(<span class="string">"bar"</span>.parse::&lt;EnumNoFields&gt;().unwrap(), EnumNoFields::Bar);

<span class="macro">assert_eq!</span>(<span class="string">"Baz"</span>.parse::&lt;EnumNoFields&gt;().unwrap(), EnumNoFields::Baz);
<span class="macro">assert_eq!</span>(<span class="string">"BaZ"</span>.parse::&lt;EnumNoFields&gt;().unwrap(), EnumNoFields::BaZ);
<span class="macro">assert_eq!</span>(
    <span class="string">"other"</span>.parse::&lt;EnumNoFields&gt;().unwrap_err().to_string(),
    <span class="string">"Invalid `EnumNoFields` string representation"</span>,
);</code></pre></div>
<p>Code like this is generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::core::str::FromStr <span class="kw">for </span>EnumNoFields {
    <span class="kw">type </span><span class="prelude-val">Err </span>= derive_more::FromStrError;
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, &lt;<span class="self">Self </span><span class="kw">as </span>FromStr&gt;::Err&gt; {
        <span class="prelude-val">Ok</span>(<span class="kw">match </span>s.to_lowercase().as_str() {
            <span class="string">"foo" </span>=&gt; <span class="self">Self</span>::Foo,
            <span class="string">"bar" </span>=&gt; <span class="self">Self</span>::Bar,
            <span class="string">"baz" </span><span class="kw">if </span>s == <span class="string">"Baz" </span>=&gt; <span class="self">Self</span>::Baz,
            <span class="string">"baz" </span><span class="kw">if </span>s == <span class="string">"BaZ" </span>=&gt; <span class="self">Self</span>::BaZ,
            <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(derive_more::FromStrError::new(<span class="string">"EnumNoFields"</span>)),
        })
    }
}</code></pre></div><h4 id="empty-structs"><a class="doc-anchor" href="#empty-structs">§</a>Empty structs</h4>
<p>Deriving <code>FromStr</code> for structs with no fields is similar to enums,
but involves only case-insensitive matching by now.</p>
<p>Given the following struct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
</span><span class="kw">struct </span>Foo;

<span class="macro">assert_eq!</span>(<span class="string">"foo"</span>.parse::&lt;Foo&gt;().unwrap(), Foo);
<span class="macro">assert_eq!</span>(<span class="string">"Foo"</span>.parse::&lt;Foo&gt;().unwrap(), Foo);
<span class="macro">assert_eq!</span>(<span class="string">"FOO"</span>.parse::&lt;Foo&gt;().unwrap(), Foo);</code></pre></div>
<p>Code like this is generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::core::str::FromStr <span class="kw">for </span>Foo {
    <span class="kw">type </span><span class="prelude-val">Err </span>= derive_more::FromStrError;
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, &lt;<span class="self">Self </span><span class="kw">as </span>FromStr&gt;::Err&gt; {
        <span class="prelude-val">Ok</span>(<span class="kw">match </span>s.to_lowercase().as_str() {
            <span class="string">"foo" </span>=&gt; <span class="self">Self</span>,
            <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(derive_more::FromStrError::new(<span class="string">"Foo"</span>)),
        })
    }
}</code></pre></div><h4 id="the-rename_all-attribute"><a class="doc-anchor" href="#the-rename_all-attribute">§</a>The <code>rename_all</code> attribute</h4>
<p>To control the concrete string representation of the name verbatim,
the <code>#[from_str(rename_all = "...")]</code> attribute can be placed on structs,
enums and variants.</p>
<p>The available casings are:</p>
<ul>
<li><code>lowercase</code></li>
<li><code>UPPERCASE</code></li>
<li><code>PascalCase</code></li>
<li><code>camelCase</code></li>
<li><code>snake_case</code></li>
<li><code>SCREAMING_SNAKE_CASE</code></li>
<li><code>kebab-case</code></li>
<li><code>SCREAMING-KEBAB-CASE</code></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
#[from_str(rename_all = <span class="string">"lowercase"</span>)]
</span><span class="kw">enum </span>Enum {
    VariantOne,
    <span class="attr">#[from_str(rename_all = <span class="string">"kebab-case"</span>)] </span><span class="comment">// overrides the top-level one
    </span>VariantTwo
}

<span class="macro">assert_eq!</span>(<span class="string">"variantone"</span>.parse::&lt;Enum&gt;().unwrap(), Enum::VariantOne);
<span class="macro">assert_eq!</span>(<span class="string">"variant-two"</span>.parse::&lt;Enum&gt;().unwrap(), Enum::VariantTwo);</code></pre></div>
<blockquote>
<p><strong>NOTE</strong>: Using <code>#[from_str(rename_all = "...")]</code> attribute disables
any case-insensitivity where applied. This is also true for any enum
variant whose name or string representation is similar to the variant
being marked:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
</span><span class="kw">enum </span>Enum {
   Foo,  <span class="comment">// case-insensitive
   </span><span class="attr">#[from_str(rename_all = <span class="string">"SCREAMING_SNAKE_CASE"</span>)]
   </span>BaR,  <span class="comment">// case-sensitive (marked with attribute)
   </span>Bar,  <span class="comment">// case-sensitive (name is similar to the marked `BaR` variant)
   </span>Ba_R, <span class="comment">// case-sensitive (string representation is similar to the marked `BaR` variant)
</span>}</code></pre></div></blockquote>
<h3 id="custom-error"><a class="doc-anchor" href="#custom-error">§</a>Custom error</h3>
<p>The <code>#[from_str(error(&lt;ty&gt;[, &lt;conv&gt;]))]</code> attribute can be used to convert the <code>FromStr</code>’ <code>Err</code> type
into a custom error type.</p>
<p>If the conversion function is not provided, the custom error type must implement <code>From&lt;FromStr::Err&gt;</code>.
The conversion function could be provided in the following forms:</p>
<ul>
<li>function (like <code>CustomError::new</code>);</li>
<li>closure (like <code>|e| CustomError::new(e)</code>);</li>
<li>function call (like <code>CustomError::factory()</code>).</li>
</ul>
<h4 id="forwarding-1"><a class="doc-anchor" href="#forwarding-1">§</a>Forwarding</h4>
<p>Given the following struct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(From)]
</span><span class="kw">struct </span>CustomError(core::num::ParseIntError);

<span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
#[from_str(error(CustomError))]
</span><span class="kw">struct </span>MyInt(i32);</code></pre></div>
<p>Code like this is generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::core::str::FromStr <span class="kw">for </span>MyInt {
    <span class="kw">type </span><span class="prelude-val">Err </span>= CustomError;
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        FromStr::from_str(s)
            .map(|v| <span class="self">Self</span>(v))
            .map_err(Into::into)
    }
}</code></pre></div>
<p>For the explicitly specified error conversion:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>CustomError(core::num::ParseIntError);

<span class="kw">impl </span>CustomError {
    <span class="kw">fn </span>new(err: core::num::ParseIntError) -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>(err)
    }
}

<span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
#[from_str(error(CustomError, CustomError::new))]
</span><span class="kw">struct </span>MyInt(i32);</code></pre></div>
<p>Code like this is generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::core::str::FromStr <span class="kw">for </span>MyInt {
    <span class="kw">type </span><span class="prelude-val">Err </span>= CustomError;
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        FromStr::from_str(s)
            .map(|v| <span class="self">Self</span>(v))
            .map_err(CustomError::new)
    }
}</code></pre></div>
<p>Custom error for a newtype struct with one named field, <em>e.g</em>,</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(From)]
</span><span class="kw">struct </span>CustomError(core::num::ParseIntError);

<span class="attr">#[derive(FromStr)]
#[from_str(error(CustomError))]
</span><span class="kw">struct </span>Point1D {
    x: i32,
}</code></pre></div>
<p>works similarly.</p>
<h4 id="flat-representation-1"><a class="doc-anchor" href="#flat-representation-1">§</a>Flat representation</h4>
<p>Custom error type is also supported for empty enums and unit structs.</p>
<p>Given the following enum:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(From)]
</span><span class="kw">struct </span>CustomError(derive_more::FromStrError);

<span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
#[from_str(error(CustomError))]
</span><span class="kw">enum </span>EnumNoFields {
    Foo,
    Bar,
    Baz,
}</code></pre></div>
<p>Code like this is generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::core::str::FromStr <span class="kw">for </span>EnumNoFields {
    <span class="kw">type </span><span class="prelude-val">Err </span>= CustomError;
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, &lt;<span class="self">Self </span><span class="kw">as </span>FromStr&gt;::Err&gt; {
        <span class="prelude-val">Ok</span>(<span class="kw">match </span>s.to_lowercase().as_str() {
            <span class="string">"foo" </span>=&gt; <span class="self">Self</span>::Foo,
            <span class="string">"bar" </span>=&gt; <span class="self">Self</span>::Bar,
            <span class="string">"baz" </span>=&gt; <span class="self">Self</span>::Baz,
            <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(derive_more::FromStrError::new(<span class="string">"EnumNoFields"</span>).into()),
        })
    }
}</code></pre></div>
<p>For the explicitly specified error conversion:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>CustomError(derive_more::FromStrError);

<span class="kw">impl </span>CustomError {
   <span class="kw">pub fn </span>new(err: derive_more::FromStrError) -&gt; <span class="self">Self </span>{
       <span class="self">Self</span>(err)
   }
}

<span class="attr">#[derive(FromStr, Debug, Eq, PartialEq)]
#[from_str(error(CustomError, CustomError::new))]
</span><span class="kw">enum </span>EnumNoFields {
    Foo,
    Bar,
    Baz,
}</code></pre></div>
<p>Code like this is generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>derive_more::core::str::FromStr <span class="kw">for </span>EnumNoFields {
    <span class="kw">type </span><span class="prelude-val">Err </span>= CustomError;
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, &lt;<span class="self">Self </span><span class="kw">as </span>FromStr&gt;::Err&gt; {
        <span class="prelude-val">Ok</span>(<span class="kw">match </span>s.to_lowercase().as_str() {
            <span class="string">"foo" </span>=&gt; <span class="self">Self</span>::Foo,
            <span class="string">"bar" </span>=&gt; <span class="self">Self</span>::Bar,
            <span class="string">"baz" </span>=&gt; <span class="self">Self</span>::Baz,
            <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(CustomError::new(derive_more::FromStrError::new(<span class="string">"EnumNoFields"</span>))),
        })
    }
}</code></pre></div>
<p>Custom error type for unit structs, <em>e.g</em>,</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(From)]
</span><span class="kw">struct </span>CustomError(derive_more::FromStrError);

<span class="attr">#[derive(FromStr)]
#[from_str(error(CustomError))]
</span><span class="kw">struct </span>Foo;</code></pre></div>
<p>works similarly.</p>
</div></details></section></div></main></body></html>