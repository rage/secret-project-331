<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The SMTP transport sends emails using the SMTP protocol."><title>lettre::transport::smtp - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="lettre" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../../static.files/storage-82c7156e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://lettre.rs/favicon.ico"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../lettre/index.html"><img src="https://avatars0.githubusercontent.com/u/15113230?v=4" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../lettre/index.html"><img src="https://avatars0.githubusercontent.com/u/15113230?v=4" alt="logo"></a><h2><a href="../../../lettre/index.html">lettre</a><span class="version">0.11.18</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module smtp</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#smtp-transport" title="SMTP Transport">SMTP Transport</a></li><li><a href="#simple-example-with-authentication" title="Simple example with authentication">Simple example with authentication</a></li><li><a href="#shortening-configuration" title="Shortening configuration">Shortening configuration</a></li><li><a href="#advanced-configuration-with-custom-tls-settings" title="Advanced configuration with custom TLS settings">Advanced configuration with custom TLS settings</a></li><li><a href="#connection-pooling" title="Connection pooling">Connection pooling</a></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In lettre::<wbr>transport</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">lettre</a>::<wbr><a href="../index.html">transport</a></div><h1>Module <span>smtp</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/lettre/transport/smtp/mod.rs.html#1-272">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The SMTP transport sends emails using the SMTP protocol.</p>
<p>This SMTP client follows <a href="https://tools.ietf.org/html/rfc5321">RFC
5321</a>, and is designed to efficiently send emails from an
application to a relay email server, as it relies as much as possible on the relay server
for sanity and RFC compliance checks.</p>
<p>It implements the following extensions:</p>
<ul>
<li>8BITMIME (<a href="https://tools.ietf.org/html/rfc6152">RFC 6152</a>)</li>
<li>AUTH (<a href="https://tools.ietf.org/html/rfc4954">RFC 4954</a>) with PLAIN, LOGIN and XOAUTH2 mechanisms</li>
<li>STARTTLS (<a href="https://tools.ietf.org/html/rfc2487">RFC 2487</a>)</li>
</ul>
<h5 id="smtp-transport"><a class="doc-anchor" href="#smtp-transport">ยง</a>SMTP Transport</h5>
<p>This transport uses the SMTP protocol to send emails over the network (locally or remotely).</p>
<p>It is designed to be:</p>
<ul>
<li>Secured: connections are encrypted by default</li>
<li>Modern: unicode support for email contents and sender/recipient addresses when compatible</li>
<li>Fast: supports connection reuse and pooling</li>
</ul>
<p>This client is designed to send emails to a relay server, and should <em>not</em> be used to send
emails directly to the destination server.</p>
<p>The relay server can be the local email server, a specific host or a third-party service.</p>
<h5 id="simple-example-with-authentication"><a class="doc-anchor" href="#simple-example-with-authentication">ยง</a>Simple example with authentication</h5>
<p>A good starting point for sending emails via SMTP relay is to
do the following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lettre::{
    message::header::ContentType,
    transport::smtp::authentication::{Credentials, Mechanism},
    Message, SmtpTransport, Transport,
};

<span class="kw">let </span>email = Message::builder()
    .from(<span class="string">"NoBody &lt;nobody@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
    .reply_to(<span class="string">"Yuin &lt;yuin@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
    .to(<span class="string">"Hei &lt;hei@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
    .subject(<span class="string">"Happy new year"</span>)
    .header(ContentType::TEXT_PLAIN)
    .body(String::from(<span class="string">"Be happy!"</span>))<span class="question-mark">?</span>;

<span class="comment">// Create the SMTPS transport
</span><span class="kw">let </span>sender = SmtpTransport::relay(<span class="string">"smtp.example.com"</span>)<span class="question-mark">?
    </span><span class="comment">// Add credentials for authentication
    </span>.credentials(Credentials::new(
        <span class="string">"username"</span>.to_owned(),
        <span class="string">"password"</span>.to_owned(),
    ))
    <span class="comment">// Optionally configure expected authentication mechanism
    </span>.authentication(<span class="macro">vec!</span>[Mechanism::Plain])
    .build();

<span class="comment">// Send the email via remote relay
</span>sender.send(<span class="kw-2">&amp;</span>email)<span class="question-mark">?</span>;</code></pre></div>
<h5 id="shortening-configuration"><a class="doc-anchor" href="#shortening-configuration">ยง</a>Shortening configuration</h5>
<p>It can be very repetitive to ask the user for every SMTP connection parameter.
In some cases this can be simplified by using a connection URI instead.</p>
<p>For more information take a look at <a href="struct.SmtpTransport.html#method.from_url" title="associated function lettre::transport::smtp::SmtpTransport::from_url"><code>SmtpTransport::from_url</code></a> or [<code>AsyncSmtpTransport::from_url</code>].</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lettre::{
    message::header::ContentType,
    transport::smtp::authentication::{Credentials, Mechanism},
    Message, SmtpTransport, Transport,
};

<span class="kw">let </span>email = Message::builder()
    .from(<span class="string">"NoBody &lt;nobody@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
    .reply_to(<span class="string">"Yuin &lt;yuin@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
    .to(<span class="string">"Hei &lt;hei@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
    .subject(<span class="string">"Happy new year"</span>)
    .header(ContentType::TEXT_PLAIN)
    .body(String::from(<span class="string">"Be happy!"</span>))<span class="question-mark">?</span>;

<span class="comment">// Create the SMTPS transport
</span><span class="kw">let </span>sender = SmtpTransport::from_url(<span class="string">"smtps://username:password@smtp.example.com"</span>)<span class="question-mark">?</span>.build();

<span class="comment">// Send the email via remote relay
</span>sender.send(<span class="kw-2">&amp;</span>email)<span class="question-mark">?</span>;</code></pre></div>
<h5 id="advanced-configuration-with-custom-tls-settings"><a class="doc-anchor" href="#advanced-configuration-with-custom-tls-settings">ยง</a>Advanced configuration with custom TLS settings</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs;

<span class="kw">use </span>lettre::{
    message::header::ContentType,
    transport::smtp::client::{Certificate, Tls, TlsParameters},
    Message, SmtpTransport, Transport,
};

<span class="kw">let </span>email = Message::builder()
    .from(<span class="string">"NoBody &lt;nobody@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
    .reply_to(<span class="string">"Yuin &lt;yuin@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
    .to(<span class="string">"Hei &lt;hei@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
    .subject(<span class="string">"Happy new year"</span>)
    .header(ContentType::TEXT_PLAIN)
    .body(String::from(<span class="string">"Be happy!"</span>))<span class="question-mark">?</span>;

<span class="comment">// Custom TLS configuration - Use a self signed certificate
</span><span class="kw">let </span>cert = fs::read(<span class="string">"self-signed.crt"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>cert = Certificate::from_pem(<span class="kw-2">&amp;</span>cert)<span class="question-mark">?</span>;
<span class="kw">let </span>tls = TlsParameters::builder(<span class="comment">/* TLS SNI value */ </span><span class="string">"smtp.example.com"</span>.to_owned())
    .add_root_certificate(cert)
    .build()<span class="question-mark">?</span>;

<span class="comment">// Create the SMTPS transport
</span><span class="kw">let </span>sender = SmtpTransport::relay(<span class="string">"smtp.example.com"</span>)<span class="question-mark">?
    </span>.tls(Tls::Wrapper(tls))
    .build();

<span class="comment">// Send the email via remote relay
</span>sender.send(<span class="kw-2">&amp;</span>email)<span class="question-mark">?</span>;</code></pre></div>
<h5 id="connection-pooling"><a class="doc-anchor" href="#connection-pooling">ยง</a>Connection pooling</h5>
<p><a href="struct.SmtpTransport.html" title="struct lettre::transport::smtp::SmtpTransport"><code>SmtpTransport</code></a> and [<code>AsyncSmtpTransport</code>] store connections in
a connection pool by default. This avoids connecting and disconnecting
from the relay server for every message the application tries to send. For the connection pool
to work the instance of the transport <strong>must</strong> be reused.
In a webserver context it may go about this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>lettre::{
    message::header::ContentType,
    transport::smtp::{authentication::Credentials, PoolConfig},
    Message, SmtpTransport, Transport,
};

<span class="doccomment">/// The global application state
</span><span class="attr">#[derive(Debug)]
</span><span class="kw">struct </span>AppState {
    smtp: SmtpTransport,
    <span class="comment">// ... other global application parameters
</span>}

<span class="kw">impl </span>AppState {
    <span class="kw">pub fn </span>new(smtp_url: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>&gt; {
        <span class="kw">let </span>smtp = SmtpTransport::from_url(smtp_url)<span class="question-mark">?</span>.build();
        <span class="prelude-val">Ok</span>(<span class="self">Self </span>{ smtp })
    }
}

<span class="kw">fn </span>handle_request(app_state: <span class="kw-2">&amp;</span>AppState) -&gt; <span class="prelude-ty">Result</span>&lt;String&gt; {
    <span class="kw">let </span>email = Message::builder()
        .from(<span class="string">"NoBody &lt;nobody@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
        .reply_to(<span class="string">"Yuin &lt;yuin@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
        .to(<span class="string">"Hei &lt;hei@domain.tld&gt;"</span>.parse()<span class="question-mark">?</span>)
        .subject(<span class="string">"Happy new year"</span>)
        .header(ContentType::TEXT_PLAIN)
        .body(String::from(<span class="string">"Be happy!"</span>))<span class="question-mark">?</span>;

    <span class="comment">// Send the email via remote relay
    </span>app_state.smtp.send(<span class="kw-2">&amp;</span>email)<span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(<span class="string">"The email has successfully been sent!"</span>.to_owned())
}</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="mod" href="authentication/index.html" title="mod lettre::transport::smtp::authentication">authentication</a></dt><dd>Provides limited SASL authentication mechanisms</dd><dt><a class="mod" href="client/index.html" title="mod lettre::transport::smtp::client">client</a></dt><dd>SMTP client</dd><dt><a class="mod" href="commands/index.html" title="mod lettre::transport::smtp::commands">commands</a></dt><dd>SMTP commands</dd><dt><a class="mod" href="extension/index.html" title="mod lettre::transport::smtp::extension">extension</a></dt><dd>ESMTP features</dd><dt><a class="mod" href="response/index.html" title="mod lettre::transport::smtp::response">response</a></dt><dd>SMTP response, containing a mandatory return code and an optional text
message</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Error.html" title="struct lettre::transport::smtp::Error">Error</a></dt><dd>The Errors that may occur when sending an email over SMTP</dd><dt><a class="struct" href="struct.PoolConfig.html" title="struct lettre::transport::smtp::PoolConfig">Pool<wbr>Config</a></dt><dd>Configuration for a connection pool</dd><dt><a class="struct" href="struct.SmtpTransport.html" title="struct lettre::transport::smtp::SmtpTransport">Smtp<wbr>Transport</a></dt><dd>Synchronously send emails using the SMTP protocol</dd><dt><a class="struct" href="struct.SmtpTransportBuilder.html" title="struct lettre::transport::smtp::SmtpTransportBuilder">Smtp<wbr>Transport<wbr>Builder</a></dt><dd>Contains client configuration.
Instances of this struct can be created using functions of <a href="struct.SmtpTransport.html" title="struct lettre::transport::smtp::SmtpTransport"><code>SmtpTransport</code></a>.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="constant" href="constant.SMTP_PORT.html" title="constant lettre::transport::smtp::SMTP_PORT">SMTP_<wbr>PORT</a></dt><dd>Default smtp port</dd><dt><a class="constant" href="constant.SUBMISSIONS_PORT.html" title="constant lettre::transport::smtp::SUBMISSIONS_PORT">SUBMISSIONS_<wbr>PORT</a></dt><dd>Default submission over TLS port</dd><dt><a class="constant" href="constant.SUBMISSION_PORT.html" title="constant lettre::transport::smtp::SUBMISSION_PORT">SUBMISSION_<wbr>PORT</a></dt><dd>Default submission port</dd></dl></section></div></main></body></html>