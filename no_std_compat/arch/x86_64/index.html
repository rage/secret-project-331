<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Platform-specific intrinsics for the `x86_64` platform."><meta name="keywords" content="rust, rustlang, rust-lang, x86_64"><title>no_std_compat::arch::x86_64 - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../no_std_compat/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../no_std_compat/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Module x86_64</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section><div id="sidebar-vars" data-name="x86_64" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../no_std_compat/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Module <a href="../../index.html">no_std_compat</a>::<wbr><a href="../index.html">arch</a>::<wbr><a class="mod" href="#">x86_64</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/up/up/stdarch/crates/core_arch/src/mod.rs.html#31-36">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="item-info"><div class="stab portability">This is supported on <strong>x86-64</strong> only.</div></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Platform-specific intrinsics for the <code>x86_64</code> platform.</p>
<p>See the <a href="../index.html">module documentation</a> for more details.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.__m128bh.html" title="no_std_compat::arch::x86_64::__m128bh struct">__m128bh</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>128-bit wide set of eight ‘u16’ types, x86-specific</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.__m256bh.html" title="no_std_compat::arch::x86_64::__m256bh struct">__m256bh</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>256-bit wide set of 16 ‘u16’ types, x86-specific</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.__m512.html" title="no_std_compat::arch::x86_64::__m512 struct">__m512</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>512-bit wide set of sixteen <code>f32</code> types, x86-specific</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.__m512bh.html" title="no_std_compat::arch::x86_64::__m512bh struct">__m512bh</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>512-bit wide set of 32 ‘u16’ types, x86-specific</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.__m512d.html" title="no_std_compat::arch::x86_64::__m512d struct">__m512d</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>512-bit wide set of eight <code>f64</code> types, x86-specific</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.__m512i.html" title="no_std_compat::arch::x86_64::__m512i struct">__m512i</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>512-bit wide integer vector type, x86-specific</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.CpuidResult.html" title="no_std_compat::arch::x86_64::CpuidResult struct">CpuidResult</a></div><div class="item-right docblock-short"><p>Result of the <code>cpuid</code> instruction.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.__m128.html" title="no_std_compat::arch::x86_64::__m128 struct">__m128</a></div><div class="item-right docblock-short"><p>128-bit wide set of four <code>f32</code> types, x86-specific</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.__m128d.html" title="no_std_compat::arch::x86_64::__m128d struct">__m128d</a></div><div class="item-right docblock-short"><p>128-bit wide set of two <code>f64</code> types, x86-specific</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.__m128i.html" title="no_std_compat::arch::x86_64::__m128i struct">__m128i</a></div><div class="item-right docblock-short"><p>128-bit wide integer vector type, x86-specific</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.__m256.html" title="no_std_compat::arch::x86_64::__m256 struct">__m256</a></div><div class="item-right docblock-short"><p>256-bit wide set of eight <code>f32</code> types, x86-specific</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.__m256d.html" title="no_std_compat::arch::x86_64::__m256d struct">__m256d</a></div><div class="item-right docblock-short"><p>256-bit wide set of four <code>f64</code> types, x86-specific</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.__m256i.html" title="no_std_compat::arch::x86_64::__m256i struct">__m256i</a></div><div class="item-right docblock-short"><p>256-bit wide integer vector type, x86-specific</p>
</div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_CMPINT_EQ.html" title="no_std_compat::arch::x86_64::_MM_CMPINT_EQ constant">_MM_CMPINT_EQ</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Equal</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_CMPINT_FALSE.html" title="no_std_compat::arch::x86_64::_MM_CMPINT_FALSE constant">_MM_CMPINT_FALSE</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>False</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_CMPINT_LE.html" title="no_std_compat::arch::x86_64::_MM_CMPINT_LE constant">_MM_CMPINT_LE</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Less-than-or-equal</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_CMPINT_LT.html" title="no_std_compat::arch::x86_64::_MM_CMPINT_LT constant">_MM_CMPINT_LT</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Less-than</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_CMPINT_NE.html" title="no_std_compat::arch::x86_64::_MM_CMPINT_NE constant">_MM_CMPINT_NE</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Not-equal</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_CMPINT_NLE.html" title="no_std_compat::arch::x86_64::_MM_CMPINT_NLE constant">_MM_CMPINT_NLE</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Not less-than-or-equal</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_CMPINT_NLT.html" title="no_std_compat::arch::x86_64::_MM_CMPINT_NLT constant">_MM_CMPINT_NLT</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Not less-than</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_CMPINT_TRUE.html" title="no_std_compat::arch::x86_64::_MM_CMPINT_TRUE constant">_MM_CMPINT_TRUE</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>True</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_MANT_NORM_1_2.html" title="no_std_compat::arch::x86_64::_MM_MANT_NORM_1_2 constant">_MM_MANT_NORM_1_2</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>interval [1, 2)</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_MANT_NORM_P5_1.html" title="no_std_compat::arch::x86_64::_MM_MANT_NORM_P5_1 constant">_MM_MANT_NORM_P5_1</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>interval [0.5, 1)</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_MANT_NORM_P5_2.html" title="no_std_compat::arch::x86_64::_MM_MANT_NORM_P5_2 constant">_MM_MANT_NORM_P5_2</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>interval [0.5, 2)</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_MANT_NORM_P75_1P5.html" title="no_std_compat::arch::x86_64::_MM_MANT_NORM_P75_1P5 constant">_MM_MANT_NORM_P75_1P5</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>interval [0.75, 1.5)</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_MANT_SIGN_NAN.html" title="no_std_compat::arch::x86_64::_MM_MANT_SIGN_NAN constant">_MM_MANT_SIGN_NAN</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>DEST = NaN if sign(SRC) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_MANT_SIGN_SRC.html" title="no_std_compat::arch::x86_64::_MM_MANT_SIGN_SRC constant">_MM_MANT_SIGN_SRC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>sign = sign(SRC)</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_MANT_SIGN_ZERO.html" title="no_std_compat::arch::x86_64::_MM_MANT_SIGN_ZERO constant">_MM_MANT_SIGN_ZERO</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>sign = 0</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AAAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_AAAA constant">_MM_PERM_AAAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AAAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_AAAB constant">_MM_PERM_AAAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AAAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_AAAC constant">_MM_PERM_AAAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AAAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_AAAD constant">_MM_PERM_AAAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AABA.html" title="no_std_compat::arch::x86_64::_MM_PERM_AABA constant">_MM_PERM_AABA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AABB.html" title="no_std_compat::arch::x86_64::_MM_PERM_AABB constant">_MM_PERM_AABB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AABC.html" title="no_std_compat::arch::x86_64::_MM_PERM_AABC constant">_MM_PERM_AABC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AABD.html" title="no_std_compat::arch::x86_64::_MM_PERM_AABD constant">_MM_PERM_AABD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AACA.html" title="no_std_compat::arch::x86_64::_MM_PERM_AACA constant">_MM_PERM_AACA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AACB.html" title="no_std_compat::arch::x86_64::_MM_PERM_AACB constant">_MM_PERM_AACB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AACC.html" title="no_std_compat::arch::x86_64::_MM_PERM_AACC constant">_MM_PERM_AACC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AACD.html" title="no_std_compat::arch::x86_64::_MM_PERM_AACD constant">_MM_PERM_AACD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AADA.html" title="no_std_compat::arch::x86_64::_MM_PERM_AADA constant">_MM_PERM_AADA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AADB.html" title="no_std_compat::arch::x86_64::_MM_PERM_AADB constant">_MM_PERM_AADB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AADC.html" title="no_std_compat::arch::x86_64::_MM_PERM_AADC constant">_MM_PERM_AADC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_AADD.html" title="no_std_compat::arch::x86_64::_MM_PERM_AADD constant">_MM_PERM_AADD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABAA constant">_MM_PERM_ABAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABAB constant">_MM_PERM_ABAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABAC constant">_MM_PERM_ABAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABAD constant">_MM_PERM_ABAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABBA constant">_MM_PERM_ABBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABBB constant">_MM_PERM_ABBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABBC constant">_MM_PERM_ABBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABBD constant">_MM_PERM_ABBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABCA constant">_MM_PERM_ABCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABCB constant">_MM_PERM_ABCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABCC constant">_MM_PERM_ABCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABCD constant">_MM_PERM_ABCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABDA constant">_MM_PERM_ABDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABDB constant">_MM_PERM_ABDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABDC constant">_MM_PERM_ABDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ABDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ABDD constant">_MM_PERM_ABDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACAA constant">_MM_PERM_ACAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACAB constant">_MM_PERM_ACAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACAC constant">_MM_PERM_ACAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACAD constant">_MM_PERM_ACAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACBA constant">_MM_PERM_ACBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACBB constant">_MM_PERM_ACBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACBC constant">_MM_PERM_ACBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACBD constant">_MM_PERM_ACBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACCA constant">_MM_PERM_ACCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACCB constant">_MM_PERM_ACCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACCC constant">_MM_PERM_ACCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACCD constant">_MM_PERM_ACCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACDA constant">_MM_PERM_ACDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACDB constant">_MM_PERM_ACDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACDC constant">_MM_PERM_ACDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ACDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ACDD constant">_MM_PERM_ACDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADAA constant">_MM_PERM_ADAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADAB constant">_MM_PERM_ADAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADAC constant">_MM_PERM_ADAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADAD constant">_MM_PERM_ADAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADBA constant">_MM_PERM_ADBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADBB constant">_MM_PERM_ADBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADBC constant">_MM_PERM_ADBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADBD constant">_MM_PERM_ADBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADCA constant">_MM_PERM_ADCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADCB constant">_MM_PERM_ADCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADCC constant">_MM_PERM_ADCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADCD constant">_MM_PERM_ADCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADDA constant">_MM_PERM_ADDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADDB constant">_MM_PERM_ADDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADDC constant">_MM_PERM_ADDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_ADDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_ADDD constant">_MM_PERM_ADDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BAAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BAAA constant">_MM_PERM_BAAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BAAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BAAB constant">_MM_PERM_BAAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BAAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BAAC constant">_MM_PERM_BAAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BAAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BAAD constant">_MM_PERM_BAAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BABA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BABA constant">_MM_PERM_BABA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BABB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BABB constant">_MM_PERM_BABB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BABC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BABC constant">_MM_PERM_BABC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BABD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BABD constant">_MM_PERM_BABD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BACA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BACA constant">_MM_PERM_BACA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BACB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BACB constant">_MM_PERM_BACB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BACC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BACC constant">_MM_PERM_BACC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BACD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BACD constant">_MM_PERM_BACD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BADA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BADA constant">_MM_PERM_BADA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BADB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BADB constant">_MM_PERM_BADB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BADC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BADC constant">_MM_PERM_BADC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BADD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BADD constant">_MM_PERM_BADD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBAA constant">_MM_PERM_BBAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBAB constant">_MM_PERM_BBAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBAC constant">_MM_PERM_BBAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBAD constant">_MM_PERM_BBAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBBA constant">_MM_PERM_BBBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBBB constant">_MM_PERM_BBBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBBC constant">_MM_PERM_BBBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBBD constant">_MM_PERM_BBBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBCA constant">_MM_PERM_BBCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBCB constant">_MM_PERM_BBCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBCC constant">_MM_PERM_BBCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBCD constant">_MM_PERM_BBCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBDA constant">_MM_PERM_BBDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBDB constant">_MM_PERM_BBDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBDC constant">_MM_PERM_BBDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BBDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BBDD constant">_MM_PERM_BBDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCAA constant">_MM_PERM_BCAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCAB constant">_MM_PERM_BCAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCAC constant">_MM_PERM_BCAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCAD constant">_MM_PERM_BCAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCBA constant">_MM_PERM_BCBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCBB constant">_MM_PERM_BCBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCBC constant">_MM_PERM_BCBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCBD constant">_MM_PERM_BCBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCCA constant">_MM_PERM_BCCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCCB constant">_MM_PERM_BCCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCCC constant">_MM_PERM_BCCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCCD constant">_MM_PERM_BCCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCDA constant">_MM_PERM_BCDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCDB constant">_MM_PERM_BCDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCDC constant">_MM_PERM_BCDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BCDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BCDD constant">_MM_PERM_BCDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDAA constant">_MM_PERM_BDAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDAB constant">_MM_PERM_BDAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDAC constant">_MM_PERM_BDAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDAD constant">_MM_PERM_BDAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDBA constant">_MM_PERM_BDBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDBB constant">_MM_PERM_BDBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDBC constant">_MM_PERM_BDBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDBD constant">_MM_PERM_BDBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDCA constant">_MM_PERM_BDCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDCB constant">_MM_PERM_BDCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDCC constant">_MM_PERM_BDCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDCD constant">_MM_PERM_BDCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDDA constant">_MM_PERM_BDDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDDB constant">_MM_PERM_BDDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDDC constant">_MM_PERM_BDDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_BDDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_BDDD constant">_MM_PERM_BDDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CAAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CAAA constant">_MM_PERM_CAAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CAAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CAAB constant">_MM_PERM_CAAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CAAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CAAC constant">_MM_PERM_CAAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CAAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CAAD constant">_MM_PERM_CAAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CABA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CABA constant">_MM_PERM_CABA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CABB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CABB constant">_MM_PERM_CABB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CABC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CABC constant">_MM_PERM_CABC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CABD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CABD constant">_MM_PERM_CABD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CACA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CACA constant">_MM_PERM_CACA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CACB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CACB constant">_MM_PERM_CACB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CACC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CACC constant">_MM_PERM_CACC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CACD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CACD constant">_MM_PERM_CACD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CADA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CADA constant">_MM_PERM_CADA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CADB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CADB constant">_MM_PERM_CADB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CADC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CADC constant">_MM_PERM_CADC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CADD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CADD constant">_MM_PERM_CADD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBAA constant">_MM_PERM_CBAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBAB constant">_MM_PERM_CBAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBAC constant">_MM_PERM_CBAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBAD constant">_MM_PERM_CBAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBBA constant">_MM_PERM_CBBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBBB constant">_MM_PERM_CBBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBBC constant">_MM_PERM_CBBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBBD constant">_MM_PERM_CBBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBCA constant">_MM_PERM_CBCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBCB constant">_MM_PERM_CBCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBCC constant">_MM_PERM_CBCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBCD constant">_MM_PERM_CBCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBDA constant">_MM_PERM_CBDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBDB constant">_MM_PERM_CBDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBDC constant">_MM_PERM_CBDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CBDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CBDD constant">_MM_PERM_CBDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCAA constant">_MM_PERM_CCAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCAB constant">_MM_PERM_CCAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCAC constant">_MM_PERM_CCAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCAD constant">_MM_PERM_CCAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCBA constant">_MM_PERM_CCBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCBB constant">_MM_PERM_CCBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCBC constant">_MM_PERM_CCBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCBD constant">_MM_PERM_CCBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCCA constant">_MM_PERM_CCCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCCB constant">_MM_PERM_CCCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCCC constant">_MM_PERM_CCCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCCD constant">_MM_PERM_CCCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCDA constant">_MM_PERM_CCDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCDB constant">_MM_PERM_CCDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCDC constant">_MM_PERM_CCDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CCDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CCDD constant">_MM_PERM_CCDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDAA constant">_MM_PERM_CDAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDAB constant">_MM_PERM_CDAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDAC constant">_MM_PERM_CDAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDAD constant">_MM_PERM_CDAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDBA constant">_MM_PERM_CDBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDBB constant">_MM_PERM_CDBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDBC constant">_MM_PERM_CDBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDBD constant">_MM_PERM_CDBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDCA constant">_MM_PERM_CDCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDCB constant">_MM_PERM_CDCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDCC constant">_MM_PERM_CDCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDCD constant">_MM_PERM_CDCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDDA constant">_MM_PERM_CDDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDDB constant">_MM_PERM_CDDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDDC constant">_MM_PERM_CDDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_CDDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_CDDD constant">_MM_PERM_CDDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DAAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DAAA constant">_MM_PERM_DAAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DAAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DAAB constant">_MM_PERM_DAAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DAAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DAAC constant">_MM_PERM_DAAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DAAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DAAD constant">_MM_PERM_DAAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DABA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DABA constant">_MM_PERM_DABA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DABB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DABB constant">_MM_PERM_DABB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DABC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DABC constant">_MM_PERM_DABC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DABD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DABD constant">_MM_PERM_DABD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DACA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DACA constant">_MM_PERM_DACA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DACB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DACB constant">_MM_PERM_DACB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DACC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DACC constant">_MM_PERM_DACC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DACD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DACD constant">_MM_PERM_DACD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DADA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DADA constant">_MM_PERM_DADA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DADB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DADB constant">_MM_PERM_DADB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DADC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DADC constant">_MM_PERM_DADC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DADD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DADD constant">_MM_PERM_DADD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBAA constant">_MM_PERM_DBAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBAB constant">_MM_PERM_DBAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBAC constant">_MM_PERM_DBAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBAD constant">_MM_PERM_DBAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBBA constant">_MM_PERM_DBBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBBB constant">_MM_PERM_DBBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBBC constant">_MM_PERM_DBBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBBD constant">_MM_PERM_DBBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBCA constant">_MM_PERM_DBCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBCB constant">_MM_PERM_DBCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBCC constant">_MM_PERM_DBCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBCD constant">_MM_PERM_DBCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBDA constant">_MM_PERM_DBDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBDB constant">_MM_PERM_DBDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBDC constant">_MM_PERM_DBDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DBDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DBDD constant">_MM_PERM_DBDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCAA constant">_MM_PERM_DCAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCAB constant">_MM_PERM_DCAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCAC constant">_MM_PERM_DCAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCAD constant">_MM_PERM_DCAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCBA constant">_MM_PERM_DCBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCBB constant">_MM_PERM_DCBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCBC constant">_MM_PERM_DCBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCBD constant">_MM_PERM_DCBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCCA constant">_MM_PERM_DCCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCCB constant">_MM_PERM_DCCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCCC constant">_MM_PERM_DCCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCCD constant">_MM_PERM_DCCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCDA constant">_MM_PERM_DCDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCDB constant">_MM_PERM_DCDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCDC constant">_MM_PERM_DCDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DCDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DCDD constant">_MM_PERM_DCDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDAA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDAA constant">_MM_PERM_DDAA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDAB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDAB constant">_MM_PERM_DDAB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDAC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDAC constant">_MM_PERM_DDAC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDAD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDAD constant">_MM_PERM_DDAD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDBA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDBA constant">_MM_PERM_DDBA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDBB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDBB constant">_MM_PERM_DDBB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDBC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDBC constant">_MM_PERM_DDBC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDBD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDBD constant">_MM_PERM_DDBD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDCA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDCA constant">_MM_PERM_DDCA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDCB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDCB constant">_MM_PERM_DDCB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDCC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDCC constant">_MM_PERM_DDCC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDCD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDCD constant">_MM_PERM_DDCD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDDA.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDDA constant">_MM_PERM_DDDA</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDDB.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDDB constant">_MM_PERM_DDDB</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDDC.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDDC constant">_MM_PERM_DDDC</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._MM_PERM_DDDD.html" title="no_std_compat::arch::x86_64::_MM_PERM_DDDD constant">_MM_PERM_DDDD</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._XABORT_CAPACITY.html" title="no_std_compat::arch::x86_64::_XABORT_CAPACITY constant">_XABORT_CAPACITY</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Transaction abort due to the transaction using too much memory.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._XABORT_CONFLICT.html" title="no_std_compat::arch::x86_64::_XABORT_CONFLICT constant">_XABORT_CONFLICT</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Transaction abort due to a memory conflict with another thread.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._XABORT_DEBUG.html" title="no_std_compat::arch::x86_64::_XABORT_DEBUG constant">_XABORT_DEBUG</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Transaction abort due to a debug trap.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._XABORT_EXPLICIT.html" title="no_std_compat::arch::x86_64::_XABORT_EXPLICIT constant">_XABORT_EXPLICIT</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Transaction explicitly aborted with xabort. The parameter passed to xabort is available with
<code>_xabort_code(status)</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._XABORT_NESTED.html" title="no_std_compat::arch::x86_64::_XABORT_NESTED constant">_XABORT_NESTED</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Transaction abort in a inner nested transaction.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._XABORT_RETRY.html" title="no_std_compat::arch::x86_64::_XABORT_RETRY constant">_XABORT_RETRY</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Transaction retry is possible.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="constant" href="constant._XBEGIN_STARTED.html" title="no_std_compat::arch::x86_64::_XBEGIN_STARTED constant">_XBEGIN_STARTED</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Transaction successfully started.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_EQ_OQ.html" title="no_std_compat::arch::x86_64::_CMP_EQ_OQ constant">_CMP_EQ_OQ</a></div><div class="item-right docblock-short"><p>Equal (ordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_EQ_OS.html" title="no_std_compat::arch::x86_64::_CMP_EQ_OS constant">_CMP_EQ_OS</a></div><div class="item-right docblock-short"><p>Equal (ordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_EQ_UQ.html" title="no_std_compat::arch::x86_64::_CMP_EQ_UQ constant">_CMP_EQ_UQ</a></div><div class="item-right docblock-short"><p>Equal (unordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_EQ_US.html" title="no_std_compat::arch::x86_64::_CMP_EQ_US constant">_CMP_EQ_US</a></div><div class="item-right docblock-short"><p>Equal (unordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_FALSE_OQ.html" title="no_std_compat::arch::x86_64::_CMP_FALSE_OQ constant">_CMP_FALSE_OQ</a></div><div class="item-right docblock-short"><p>False (ordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_FALSE_OS.html" title="no_std_compat::arch::x86_64::_CMP_FALSE_OS constant">_CMP_FALSE_OS</a></div><div class="item-right docblock-short"><p>False (ordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_GE_OQ.html" title="no_std_compat::arch::x86_64::_CMP_GE_OQ constant">_CMP_GE_OQ</a></div><div class="item-right docblock-short"><p>Greater-than-or-equal (ordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_GE_OS.html" title="no_std_compat::arch::x86_64::_CMP_GE_OS constant">_CMP_GE_OS</a></div><div class="item-right docblock-short"><p>Greater-than-or-equal (ordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_GT_OQ.html" title="no_std_compat::arch::x86_64::_CMP_GT_OQ constant">_CMP_GT_OQ</a></div><div class="item-right docblock-short"><p>Greater-than (ordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_GT_OS.html" title="no_std_compat::arch::x86_64::_CMP_GT_OS constant">_CMP_GT_OS</a></div><div class="item-right docblock-short"><p>Greater-than (ordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_LE_OQ.html" title="no_std_compat::arch::x86_64::_CMP_LE_OQ constant">_CMP_LE_OQ</a></div><div class="item-right docblock-short"><p>Less-than-or-equal (ordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_LE_OS.html" title="no_std_compat::arch::x86_64::_CMP_LE_OS constant">_CMP_LE_OS</a></div><div class="item-right docblock-short"><p>Less-than-or-equal (ordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_LT_OQ.html" title="no_std_compat::arch::x86_64::_CMP_LT_OQ constant">_CMP_LT_OQ</a></div><div class="item-right docblock-short"><p>Less-than (ordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_LT_OS.html" title="no_std_compat::arch::x86_64::_CMP_LT_OS constant">_CMP_LT_OS</a></div><div class="item-right docblock-short"><p>Less-than (ordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NEQ_OQ.html" title="no_std_compat::arch::x86_64::_CMP_NEQ_OQ constant">_CMP_NEQ_OQ</a></div><div class="item-right docblock-short"><p>Not-equal (ordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NEQ_OS.html" title="no_std_compat::arch::x86_64::_CMP_NEQ_OS constant">_CMP_NEQ_OS</a></div><div class="item-right docblock-short"><p>Not-equal (ordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NEQ_UQ.html" title="no_std_compat::arch::x86_64::_CMP_NEQ_UQ constant">_CMP_NEQ_UQ</a></div><div class="item-right docblock-short"><p>Not-equal (unordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NEQ_US.html" title="no_std_compat::arch::x86_64::_CMP_NEQ_US constant">_CMP_NEQ_US</a></div><div class="item-right docblock-short"><p>Not-equal (unordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NGE_UQ.html" title="no_std_compat::arch::x86_64::_CMP_NGE_UQ constant">_CMP_NGE_UQ</a></div><div class="item-right docblock-short"><p>Not-greater-than-or-equal (unordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NGE_US.html" title="no_std_compat::arch::x86_64::_CMP_NGE_US constant">_CMP_NGE_US</a></div><div class="item-right docblock-short"><p>Not-greater-than-or-equal (unordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NGT_UQ.html" title="no_std_compat::arch::x86_64::_CMP_NGT_UQ constant">_CMP_NGT_UQ</a></div><div class="item-right docblock-short"><p>Not-greater-than (unordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NGT_US.html" title="no_std_compat::arch::x86_64::_CMP_NGT_US constant">_CMP_NGT_US</a></div><div class="item-right docblock-short"><p>Not-greater-than (unordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NLE_UQ.html" title="no_std_compat::arch::x86_64::_CMP_NLE_UQ constant">_CMP_NLE_UQ</a></div><div class="item-right docblock-short"><p>Not-less-than-or-equal (unordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NLE_US.html" title="no_std_compat::arch::x86_64::_CMP_NLE_US constant">_CMP_NLE_US</a></div><div class="item-right docblock-short"><p>Not-less-than-or-equal (unordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NLT_UQ.html" title="no_std_compat::arch::x86_64::_CMP_NLT_UQ constant">_CMP_NLT_UQ</a></div><div class="item-right docblock-short"><p>Not-less-than (unordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_NLT_US.html" title="no_std_compat::arch::x86_64::_CMP_NLT_US constant">_CMP_NLT_US</a></div><div class="item-right docblock-short"><p>Not-less-than (unordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_ORD_Q.html" title="no_std_compat::arch::x86_64::_CMP_ORD_Q constant">_CMP_ORD_Q</a></div><div class="item-right docblock-short"><p>Ordered (non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_ORD_S.html" title="no_std_compat::arch::x86_64::_CMP_ORD_S constant">_CMP_ORD_S</a></div><div class="item-right docblock-short"><p>Ordered (signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_TRUE_UQ.html" title="no_std_compat::arch::x86_64::_CMP_TRUE_UQ constant">_CMP_TRUE_UQ</a></div><div class="item-right docblock-short"><p>True (unordered, non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_TRUE_US.html" title="no_std_compat::arch::x86_64::_CMP_TRUE_US constant">_CMP_TRUE_US</a></div><div class="item-right docblock-short"><p>True (unordered, signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_UNORD_Q.html" title="no_std_compat::arch::x86_64::_CMP_UNORD_Q constant">_CMP_UNORD_Q</a></div><div class="item-right docblock-short"><p>Unordered (non-signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._CMP_UNORD_S.html" title="no_std_compat::arch::x86_64::_CMP_UNORD_S constant">_CMP_UNORD_S</a></div><div class="item-right docblock-short"><p>Unordered (signaling)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_EXCEPT_DENORM.html" title="no_std_compat::arch::x86_64::_MM_EXCEPT_DENORM constant">_MM_EXCEPT_DENORM</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_EXCEPT_DIV_ZERO.html" title="no_std_compat::arch::x86_64::_MM_EXCEPT_DIV_ZERO constant">_MM_EXCEPT_DIV_ZERO</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_EXCEPT_INEXACT.html" title="no_std_compat::arch::x86_64::_MM_EXCEPT_INEXACT constant">_MM_EXCEPT_INEXACT</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_EXCEPT_INVALID.html" title="no_std_compat::arch::x86_64::_MM_EXCEPT_INVALID constant">_MM_EXCEPT_INVALID</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_EXCEPT_MASK.html" title="no_std_compat::arch::x86_64::_MM_EXCEPT_MASK constant">_MM_EXCEPT_MASK</a></div><div class="item-right docblock-short"><p>See <a href="fn._MM_GET_EXCEPTION_STATE.html"><code>_MM_GET_EXCEPTION_STATE</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_EXCEPT_OVERFLOW.html" title="no_std_compat::arch::x86_64::_MM_EXCEPT_OVERFLOW constant">_MM_EXCEPT_OVERFLOW</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_EXCEPT_UNDERFLOW.html" title="no_std_compat::arch::x86_64::_MM_EXCEPT_UNDERFLOW constant">_MM_EXCEPT_UNDERFLOW</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FLUSH_ZERO_MASK.html" title="no_std_compat::arch::x86_64::_MM_FLUSH_ZERO_MASK constant">_MM_FLUSH_ZERO_MASK</a></div><div class="item-right docblock-short"><p>See <a href="fn._MM_GET_FLUSH_ZERO_MODE.html"><code>_MM_GET_FLUSH_ZERO_MODE</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FLUSH_ZERO_OFF.html" title="no_std_compat::arch::x86_64::_MM_FLUSH_ZERO_OFF constant">_MM_FLUSH_ZERO_OFF</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FLUSH_ZERO_ON.html" title="no_std_compat::arch::x86_64::_MM_FLUSH_ZERO_ON constant">_MM_FLUSH_ZERO_ON</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_CEIL.html" title="no_std_compat::arch::x86_64::_MM_FROUND_CEIL constant">_MM_FROUND_CEIL</a></div><div class="item-right docblock-short"><p>round up and do not suppress exceptions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_CUR_DIRECTION.html" title="no_std_compat::arch::x86_64::_MM_FROUND_CUR_DIRECTION constant">_MM_FROUND_CUR_DIRECTION</a></div><div class="item-right docblock-short"><p>use MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_FLOOR.html" title="no_std_compat::arch::x86_64::_MM_FROUND_FLOOR constant">_MM_FROUND_FLOOR</a></div><div class="item-right docblock-short"><p>round down and do not suppress exceptions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_NEARBYINT.html" title="no_std_compat::arch::x86_64::_MM_FROUND_NEARBYINT constant">_MM_FROUND_NEARBYINT</a></div><div class="item-right docblock-short"><p>use MXCSR.RC and suppress exceptions; see <code>vendor::_MM_SET_ROUNDING_MODE</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_NINT.html" title="no_std_compat::arch::x86_64::_MM_FROUND_NINT constant">_MM_FROUND_NINT</a></div><div class="item-right docblock-short"><p>round to nearest and do not suppress exceptions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_NO_EXC.html" title="no_std_compat::arch::x86_64::_MM_FROUND_NO_EXC constant">_MM_FROUND_NO_EXC</a></div><div class="item-right docblock-short"><p>suppress exceptions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_RAISE_EXC.html" title="no_std_compat::arch::x86_64::_MM_FROUND_RAISE_EXC constant">_MM_FROUND_RAISE_EXC</a></div><div class="item-right docblock-short"><p>do not suppress exceptions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_RINT.html" title="no_std_compat::arch::x86_64::_MM_FROUND_RINT constant">_MM_FROUND_RINT</a></div><div class="item-right docblock-short"><p>use MXCSR.RC and do not suppress exceptions; see
<code>vendor::_MM_SET_ROUNDING_MODE</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_TO_NEAREST_INT.html" title="no_std_compat::arch::x86_64::_MM_FROUND_TO_NEAREST_INT constant">_MM_FROUND_TO_NEAREST_INT</a></div><div class="item-right docblock-short"><p>round to nearest</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_TO_NEG_INF.html" title="no_std_compat::arch::x86_64::_MM_FROUND_TO_NEG_INF constant">_MM_FROUND_TO_NEG_INF</a></div><div class="item-right docblock-short"><p>round down</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_TO_POS_INF.html" title="no_std_compat::arch::x86_64::_MM_FROUND_TO_POS_INF constant">_MM_FROUND_TO_POS_INF</a></div><div class="item-right docblock-short"><p>round up</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_TO_ZERO.html" title="no_std_compat::arch::x86_64::_MM_FROUND_TO_ZERO constant">_MM_FROUND_TO_ZERO</a></div><div class="item-right docblock-short"><p>truncate</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_FROUND_TRUNC.html" title="no_std_compat::arch::x86_64::_MM_FROUND_TRUNC constant">_MM_FROUND_TRUNC</a></div><div class="item-right docblock-short"><p>truncate and do not suppress exceptions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_HINT_ET0.html" title="no_std_compat::arch::x86_64::_MM_HINT_ET0 constant">_MM_HINT_ET0</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_HINT_ET1.html" title="no_std_compat::arch::x86_64::_MM_HINT_ET1 constant">_MM_HINT_ET1</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_HINT_NTA.html" title="no_std_compat::arch::x86_64::_MM_HINT_NTA constant">_MM_HINT_NTA</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_HINT_T0.html" title="no_std_compat::arch::x86_64::_MM_HINT_T0 constant">_MM_HINT_T0</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_HINT_T1.html" title="no_std_compat::arch::x86_64::_MM_HINT_T1 constant">_MM_HINT_T1</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_HINT_T2.html" title="no_std_compat::arch::x86_64::_MM_HINT_T2 constant">_MM_HINT_T2</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_MASK_DENORM.html" title="no_std_compat::arch::x86_64::_MM_MASK_DENORM constant">_MM_MASK_DENORM</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_MASK_DIV_ZERO.html" title="no_std_compat::arch::x86_64::_MM_MASK_DIV_ZERO constant">_MM_MASK_DIV_ZERO</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_MASK_INEXACT.html" title="no_std_compat::arch::x86_64::_MM_MASK_INEXACT constant">_MM_MASK_INEXACT</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_MASK_INVALID.html" title="no_std_compat::arch::x86_64::_MM_MASK_INVALID constant">_MM_MASK_INVALID</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_MASK_MASK.html" title="no_std_compat::arch::x86_64::_MM_MASK_MASK constant">_MM_MASK_MASK</a></div><div class="item-right docblock-short"><p>See <a href="fn._MM_GET_EXCEPTION_MASK.html"><code>_MM_GET_EXCEPTION_MASK</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_MASK_OVERFLOW.html" title="no_std_compat::arch::x86_64::_MM_MASK_OVERFLOW constant">_MM_MASK_OVERFLOW</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_MASK_UNDERFLOW.html" title="no_std_compat::arch::x86_64::_MM_MASK_UNDERFLOW constant">_MM_MASK_UNDERFLOW</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_ROUND_DOWN.html" title="no_std_compat::arch::x86_64::_MM_ROUND_DOWN constant">_MM_ROUND_DOWN</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_ROUND_MASK.html" title="no_std_compat::arch::x86_64::_MM_ROUND_MASK constant">_MM_ROUND_MASK</a></div><div class="item-right docblock-short"><p>See <a href="fn._MM_GET_ROUNDING_MODE.html"><code>_MM_GET_ROUNDING_MODE</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_ROUND_NEAREST.html" title="no_std_compat::arch::x86_64::_MM_ROUND_NEAREST constant">_MM_ROUND_NEAREST</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_ROUND_TOWARD_ZERO.html" title="no_std_compat::arch::x86_64::_MM_ROUND_TOWARD_ZERO constant">_MM_ROUND_TOWARD_ZERO</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._MM_ROUND_UP.html" title="no_std_compat::arch::x86_64::_MM_ROUND_UP constant">_MM_ROUND_UP</a></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_BIT_MASK.html" title="no_std_compat::arch::x86_64::_SIDD_BIT_MASK constant">_SIDD_BIT_MASK</a></div><div class="item-right docblock-short"><p><strong>Mask only</strong>: return the bit mask</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_CMP_EQUAL_ANY.html" title="no_std_compat::arch::x86_64::_SIDD_CMP_EQUAL_ANY constant">_SIDD_CMP_EQUAL_ANY</a></div><div class="item-right docblock-short"><p>For each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_CMP_EQUAL_EACH.html" title="no_std_compat::arch::x86_64::_SIDD_CMP_EQUAL_EACH constant">_SIDD_CMP_EQUAL_EACH</a></div><div class="item-right docblock-short"><p>The strings defined by <code>a</code> and <code>b</code> are equal</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_CMP_EQUAL_ORDERED.html" title="no_std_compat::arch::x86_64::_SIDD_CMP_EQUAL_ORDERED constant">_SIDD_CMP_EQUAL_ORDERED</a></div><div class="item-right docblock-short"><p>Search for the defined substring in the target</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_CMP_RANGES.html" title="no_std_compat::arch::x86_64::_SIDD_CMP_RANGES constant">_SIDD_CMP_RANGES</a></div><div class="item-right docblock-short"><p>For each character in <code>a</code>, determine if
<code>b[0] &lt;= c &lt;= b[1] or b[1] &lt;= c &lt;= b[2]...</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_LEAST_SIGNIFICANT.html" title="no_std_compat::arch::x86_64::_SIDD_LEAST_SIGNIFICANT constant">_SIDD_LEAST_SIGNIFICANT</a></div><div class="item-right docblock-short"><p><strong>Index only</strong>: return the least significant bit <em>(Default)</em></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_MASKED_NEGATIVE_POLARITY.html" title="no_std_compat::arch::x86_64::_SIDD_MASKED_NEGATIVE_POLARITY constant">_SIDD_MASKED_NEGATIVE_POLARITY</a></div><div class="item-right docblock-short"><p>Negates results only before the end of the string</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_MASKED_POSITIVE_POLARITY.html" title="no_std_compat::arch::x86_64::_SIDD_MASKED_POSITIVE_POLARITY constant">_SIDD_MASKED_POSITIVE_POLARITY</a></div><div class="item-right docblock-short"><p>Do not negate results before the end of the string</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_MOST_SIGNIFICANT.html" title="no_std_compat::arch::x86_64::_SIDD_MOST_SIGNIFICANT constant">_SIDD_MOST_SIGNIFICANT</a></div><div class="item-right docblock-short"><p><strong>Index only</strong>: return the most significant bit</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_NEGATIVE_POLARITY.html" title="no_std_compat::arch::x86_64::_SIDD_NEGATIVE_POLARITY constant">_SIDD_NEGATIVE_POLARITY</a></div><div class="item-right docblock-short"><p>Negates results</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_POSITIVE_POLARITY.html" title="no_std_compat::arch::x86_64::_SIDD_POSITIVE_POLARITY constant">_SIDD_POSITIVE_POLARITY</a></div><div class="item-right docblock-short"><p>Do not negate results <em>(Default)</em></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_SBYTE_OPS.html" title="no_std_compat::arch::x86_64::_SIDD_SBYTE_OPS constant">_SIDD_SBYTE_OPS</a></div><div class="item-right docblock-short"><p>String contains signed 8-bit characters</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_SWORD_OPS.html" title="no_std_compat::arch::x86_64::_SIDD_SWORD_OPS constant">_SIDD_SWORD_OPS</a></div><div class="item-right docblock-short"><p>String contains unsigned 16-bit characters</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_UBYTE_OPS.html" title="no_std_compat::arch::x86_64::_SIDD_UBYTE_OPS constant">_SIDD_UBYTE_OPS</a></div><div class="item-right docblock-short"><p>String contains unsigned 8-bit characters <em>(Default)</em></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_UNIT_MASK.html" title="no_std_compat::arch::x86_64::_SIDD_UNIT_MASK constant">_SIDD_UNIT_MASK</a></div><div class="item-right docblock-short"><p><strong>Mask only</strong>: return the byte mask</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._SIDD_UWORD_OPS.html" title="no_std_compat::arch::x86_64::_SIDD_UWORD_OPS constant">_SIDD_UWORD_OPS</a></div><div class="item-right docblock-short"><p>String contains unsigned 16-bit characters</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant._XCR_XFEATURE_ENABLED_MASK.html" title="no_std_compat::arch::x86_64::_XCR_XFEATURE_ENABLED_MASK constant">_XCR_XFEATURE_ENABLED_MASK</a></div><div class="item-right docblock-short"><p><code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code></p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._MM_SHUFFLE.html" title="no_std_compat::arch::x86_64::_MM_SHUFFLE fn">_MM_SHUFFLE</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>A utility function for creating masks to use with Intel shuffle and
permute intrinsics.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kadd_mask32.html" title="no_std_compat::arch::x86_64::_kadd_mask32 fn">_kadd_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add 32-bit masks in a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kadd_mask64.html" title="no_std_compat::arch::x86_64::_kadd_mask64 fn">_kadd_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add 64-bit masks in a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kand_mask16.html" title="no_std_compat::arch::x86_64::_kand_mask16 fn">_kand_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of 16-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kand_mask32.html" title="no_std_compat::arch::x86_64::_kand_mask32 fn">_kand_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of 32-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kand_mask64.html" title="no_std_compat::arch::x86_64::_kand_mask64 fn">_kand_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of 64-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kandn_mask16.html" title="no_std_compat::arch::x86_64::_kandn_mask16 fn">_kandn_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 16-bit masks a and then AND with b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kandn_mask32.html" title="no_std_compat::arch::x86_64::_kandn_mask32 fn">_kandn_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 32-bit masks a and then AND with b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kandn_mask64.html" title="no_std_compat::arch::x86_64::_kandn_mask64 fn">_kandn_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 64-bit masks a and then AND with b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._knot_mask16.html" title="no_std_compat::arch::x86_64::_knot_mask16 fn">_knot_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 16-bit mask a, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._knot_mask32.html" title="no_std_compat::arch::x86_64::_knot_mask32 fn">_knot_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 32-bit mask a, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._knot_mask64.html" title="no_std_compat::arch::x86_64::_knot_mask64 fn">_knot_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 64-bit mask a, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kor_mask16.html" title="no_std_compat::arch::x86_64::_kor_mask16 fn">_kor_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of 16-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kor_mask32.html" title="no_std_compat::arch::x86_64::_kor_mask32 fn">_kor_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of 32-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kor_mask64.html" title="no_std_compat::arch::x86_64::_kor_mask64 fn">_kor_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of 64-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kxnor_mask16.html" title="no_std_compat::arch::x86_64::_kxnor_mask16 fn">_kxnor_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XNOR of 16-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kxnor_mask32.html" title="no_std_compat::arch::x86_64::_kxnor_mask32 fn">_kxnor_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XNOR of 32-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kxnor_mask64.html" title="no_std_compat::arch::x86_64::_kxnor_mask64 fn">_kxnor_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XNOR of 64-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kxor_mask16.html" title="no_std_compat::arch::x86_64::_kxor_mask16 fn">_kxor_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of 16-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kxor_mask32.html" title="no_std_compat::arch::x86_64::_kxor_mask32 fn">_kxor_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of 32-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._kxor_mask64.html" title="no_std_compat::arch::x86_64::_kxor_mask64 fn">_kxor_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of 64-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._load_mask32.html" title="no_std_compat::arch::x86_64::_load_mask32 fn">_load_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Load 32-bit mask from memory into k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._load_mask64.html" title="no_std_compat::arch::x86_64::_load_mask64 fn">_load_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Load 64-bit mask from memory into k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_abs_epi64.html" title="no_std_compat::arch::x86_64::_mm256_abs_epi64 fn">_mm256_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_aesdec_epi128.html" title="no_std_compat::arch::x86_64::_mm256_aesdec_epi128 fn">_mm256_aesdec_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512vl` only"><code>avx512vaes,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs one round of an AES decryption flow on each 128-bit word (state) in <code>a</code> using
the corresponding 128-bit word (key) in <code>round_key</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_aesdeclast_epi128.html" title="no_std_compat::arch::x86_64::_mm256_aesdeclast_epi128 fn">_mm256_aesdeclast_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512vl` only"><code>avx512vaes,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs the last round of an AES decryption flow on each 128-bit word (state) in <code>a</code> using
the corresponding 128-bit word (key) in <code>round_key</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_aesenc_epi128.html" title="no_std_compat::arch::x86_64::_mm256_aesenc_epi128 fn">_mm256_aesenc_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512vl` only"><code>avx512vaes,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs one round of an AES encryption flow on each 128-bit word (state) in <code>a</code> using
the corresponding 128-bit word (key) in <code>round_key</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_aesenclast_epi128.html" title="no_std_compat::arch::x86_64::_mm256_aesenclast_epi128 fn">_mm256_aesenclast_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512vl` only"><code>avx512vaes,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs the last round of an AES encryption flow on each 128-bit word (state) in <code>a</code> using
the corresponding 128-bit word (key) in <code>round_key</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_alignr_epi32.html" title="no_std_compat::arch::x86_64::_mm256_alignr_epi32 fn">_mm256_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_alignr_epi64.html" title="no_std_compat::arch::x86_64::_mm256_alignr_epi64 fn">_mm256_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_bitshuffle_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_bitshuffle_epi64_mask fn">_mm256_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.
Then groups 8 8-bit values from <code>c</code>as indices into the the bits of the corresponding 64-bit integer.
It then selects these bits and packs them into the output.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_broadcast_f32x4.html" title="no_std_compat::arch::x86_64::_mm256_broadcast_f32x4 fn">_mm256_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_broadcast_i32x4.html" title="no_std_compat::arch::x86_64::_mm256_broadcast_i32x4 fn">_mm256_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed 32-bit integers from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_broadcastmb_epi64.html" title="no_std_compat::arch::x86_64::_mm256_broadcastmb_epi64 fn">_mm256_broadcastmb_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low 8-bits from input mask k to all 64-bit elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_broadcastmw_epi32.html" title="no_std_compat::arch::x86_64::_mm256_broadcastmw_epi32 fn">_mm256_broadcastmw_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low 16-bits from input mask k to all 32-bit elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_clmulepi64_epi128.html" title="no_std_compat::arch::x86_64::_mm256_clmulepi64_epi128 fn">_mm256_clmulepi64_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpclmulqdq,avx512vl` only"><code>avx512vpclmulqdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs a carry-less multiplication of two 64-bit polynomials over the
finite field GF(2^k) - in each of the 2 128-bit lanes.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_epi8_mask fn">_mm256_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_epi16_mask fn">_mm256_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_epi32_mask fn">_mm256_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_epi64_mask fn">_mm256_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_epu8_mask fn">_mm256_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_epu16_mask fn">_mm256_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_epu32_mask fn">_mm256_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_epu64_mask fn">_mm256_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_pd_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_pd_mask fn">_mm256_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmp_ps_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmp_ps_mask fn">_mm256_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpeq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epi8_mask fn">_mm256_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpeq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epi16_mask fn">_mm256_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpeq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epi32_mask fn">_mm256_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpeq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epi64_mask fn">_mm256_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpeq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epu8_mask fn">_mm256_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpeq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epu16_mask fn">_mm256_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpeq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epu32_mask fn">_mm256_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpeq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epu64_mask fn">_mm256_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpge_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpge_epi8_mask fn">_mm256_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpge_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpge_epi16_mask fn">_mm256_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpge_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpge_epi32_mask fn">_mm256_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpge_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpge_epi64_mask fn">_mm256_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpge_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpge_epu8_mask fn">_mm256_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpge_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpge_epu16_mask fn">_mm256_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpge_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpge_epu32_mask fn">_mm256_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpge_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpge_epu64_mask fn">_mm256_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpgt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epi8_mask fn">_mm256_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpgt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epi16_mask fn">_mm256_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpgt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epi32_mask fn">_mm256_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpgt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epi64_mask fn">_mm256_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpgt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epu8_mask fn">_mm256_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpgt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epu16_mask fn">_mm256_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpgt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epu32_mask fn">_mm256_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpgt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epu64_mask fn">_mm256_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmple_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmple_epi8_mask fn">_mm256_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmple_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmple_epi16_mask fn">_mm256_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmple_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmple_epi32_mask fn">_mm256_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmple_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmple_epi64_mask fn">_mm256_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmple_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmple_epu8_mask fn">_mm256_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmple_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmple_epu16_mask fn">_mm256_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmple_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmple_epu32_mask fn">_mm256_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmple_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmple_epu64_mask fn">_mm256_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmplt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmplt_epi8_mask fn">_mm256_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmplt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmplt_epi16_mask fn">_mm256_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmplt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmplt_epi32_mask fn">_mm256_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmplt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmplt_epi64_mask fn">_mm256_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmplt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmplt_epu8_mask fn">_mm256_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmplt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmplt_epu16_mask fn">_mm256_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmplt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmplt_epu32_mask fn">_mm256_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmplt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmplt_epu64_mask fn">_mm256_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpneq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpneq_epi8_mask fn">_mm256_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpneq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpneq_epi16_mask fn">_mm256_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpneq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpneq_epi32_mask fn">_mm256_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpneq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpneq_epi64_mask fn">_mm256_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpneq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpneq_epu8_mask fn">_mm256_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpneq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpneq_epu16_mask fn">_mm256_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpneq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpneq_epu32_mask fn">_mm256_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cmpneq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_cmpneq_epu64_mask fn">_mm256_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_conflict_epi32.html" title="no_std_compat::arch::x86_64::_mm256_conflict_epi32 fn">_mm256_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_conflict_epi64.html" title="no_std_compat::arch::x86_64::_mm256_conflict_epi64 fn">_mm256_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi16_epi8 fn">_mm256_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi32_epi8 fn">_mm256_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi32_epi16 fn">_mm256_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi64_epi8 fn">_mm256_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi64_epi16 fn">_mm256_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi64_epi32 fn">_mm256_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtepu32_pd.html" title="no_std_compat::arch::x86_64::_mm256_cvtepu32_pd fn">_mm256_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtne2ps_pbh.html" title="no_std_compat::arch::x86_64::_mm256_cvtne2ps_pbh fn">_mm256_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in two 256-bit vectors
a and b to packed BF16 (16-bit) floating-point elements, and store the results in a
256-bit wide vector.
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654&amp;avx512techs=AVX512_BF16&amp;text=_mm256_cvtne2ps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtneps_pbh.html" title="no_std_compat::arch::x86_64::_mm256_cvtneps_pbh fn">_mm256_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)
floating-point elements, and store the results in dst.
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_cvtneps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtpd_epu32.html" title="no_std_compat::arch::x86_64::_mm256_cvtpd_epu32 fn">_mm256_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtph_ps.html" title="no_std_compat::arch::x86_64::_mm256_cvtph_ps fn">_mm256_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `f16c` only"><code>f16c</code></span></div><div class="item-right docblock-short"><p>Converts the 8 x 16-bit half-precision float values in the 128-bit vector
<code>a</code> into 8 x 32-bit float values stored in a 256-bit wide vector.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtps_epu32.html" title="no_std_compat::arch::x86_64::_mm256_cvtps_epu32 fn">_mm256_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtps_ph.html" title="no_std_compat::arch::x86_64::_mm256_cvtps_ph fn">_mm256_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `f16c` only"><code>f16c</code></span></div><div class="item-right docblock-short"><p>Converts the 8 x 32-bit float values in the 256-bit vector <code>a</code> into 8 x
16-bit half-precision float values stored in a 128-bit wide vector.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtsepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cvtsepi16_epi8 fn">_mm256_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtsepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cvtsepi32_epi8 fn">_mm256_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtsepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cvtsepi32_epi16 fn">_mm256_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtsepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cvtsepi64_epi8 fn">_mm256_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtsepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cvtsepi64_epi16 fn">_mm256_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtsepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvtsepi64_epi32 fn">_mm256_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvttpd_epu32.html" title="no_std_compat::arch::x86_64::_mm256_cvttpd_epu32 fn">_mm256_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvttps_epu32.html" title="no_std_compat::arch::x86_64::_mm256_cvttps_epu32 fn">_mm256_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtusepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cvtusepi16_epi8 fn">_mm256_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtusepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cvtusepi32_epi8 fn">_mm256_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtusepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cvtusepi32_epi16 fn">_mm256_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtusepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cvtusepi64_epi8 fn">_mm256_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtusepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cvtusepi64_epi16 fn">_mm256_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_cvtusepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvtusepi64_epi32 fn">_mm256_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_dbsad_epu8.html" title="no_std_compat::arch::x86_64::_mm256_dbsad_epu8 fn">_mm256_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst. Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_dpbf16_ps.html" title="no_std_compat::arch::x86_64::_mm256_dpbf16_ps fn">_mm256_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,
accumulating the intermediate single-precision (32-bit) floating-point elements
with elements in src, and store the results in dst.
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_dpbf16_ps">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_dpbusd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_dpbusd_epi32 fn">_mm256_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_dpbusds_epi32.html" title="no_std_compat::arch::x86_64::_mm256_dpbusds_epi32 fn">_mm256_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_dpwssd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_dpwssd_epi32 fn">_mm256_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_dpwssds_epi32.html" title="no_std_compat::arch::x86_64::_mm256_dpwssds_epi32 fn">_mm256_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_extractf32x4_ps.html" title="no_std_compat::arch::x86_64::_mm256_extractf32x4_ps fn">_mm256_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_extracti32x4_epi32.html" title="no_std_compat::arch::x86_64::_mm256_extracti32x4_epi32 fn">_mm256_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_fixupimm_pd.html" title="no_std_compat::arch::x86_64::_mm256_fixupimm_pd fn">_mm256_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_fixupimm_ps.html" title="no_std_compat::arch::x86_64::_mm256_fixupimm_ps fn">_mm256_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_getexp_pd.html" title="no_std_compat::arch::x86_64::_mm256_getexp_pd fn">_mm256_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_getexp_ps.html" title="no_std_compat::arch::x86_64::_mm256_getexp_ps fn">_mm256_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_getmant_pd.html" title="no_std_compat::arch::x86_64::_mm256_getmant_pd fn">_mm256_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_getmant_ps.html" title="no_std_compat::arch::x86_64::_mm256_getmant_ps fn">_mm256_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.
The mantissa is normalized to the interval specified by interv, which can take the following values:
_MM_MANT_NORM_1_2     // interval [1, 2)
_MM_MANT_NORM_p5_2    // interval [0.5, 2)
_MM_MANT_NORM_p5_1    // interval [0.5, 1)
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)
The sign is determined by sc which can take the following values:
_MM_MANT_SIGN_src     // sign = sign(src)
_MM_MANT_SIGN_zero    // sign = 0
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_gf2p8affine_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_gf2p8affine_epi64_epi8 fn">_mm256_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the packed bytes in x.
That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_gf2p8affineinv_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_gf2p8affineinv_epi64_epi8 fn">_mm256_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the inverted packed bytes in x.
That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.
The inverse of 0 is 0.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_gf2p8mul_epi8.html" title="no_std_compat::arch::x86_64::_mm256_gf2p8mul_epi8 fn">_mm256_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs a multiplication in GF(2^8) on the packed bytes.
The field is in polynomial representation with the reduction polynomial
x^8 + x^4 + x^3 + x + 1.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_insertf32x4.html" title="no_std_compat::arch::x86_64::_mm256_insertf32x4 fn">_mm256_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Copy a to dst, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into dst at the location specified by imm8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_inserti32x4.html" title="no_std_compat::arch::x86_64::_mm256_inserti32x4 fn">_mm256_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Copy a to dst, then insert 128 bits (composed of 4 packed 32-bit integers) from b into dst at the location specified by imm8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_load_epi32.html" title="no_std_compat::arch::x86_64::_mm256_load_epi32 fn">_mm256_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 256-bits (composed of 8 packed 32-bit integers) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_load_epi64.html" title="no_std_compat::arch::x86_64::_mm256_load_epi64 fn">_mm256_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 256-bits (composed of 4 packed 64-bit integers) from memory into dst. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_loadu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_loadu_epi8 fn">_mm256_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 256-bits (composed of 32 packed 8-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_loadu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_loadu_epi16 fn">_mm256_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 256-bits (composed of 16 packed 16-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_loadu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_loadu_epi32 fn">_mm256_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 256-bits (composed of 8 packed 32-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_loadu_epi64.html" title="no_std_compat::arch::x86_64::_mm256_loadu_epi64 fn">_mm256_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 256-bits (composed of 4 packed 64-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_lzcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm256_lzcnt_epi32 fn">_mm256_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_lzcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm256_lzcnt_epi64 fn">_mm256_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_madd52hi_epu64.html" title="no_std_compat::arch::x86_64::_mm256_madd52hi_epu64 fn">_mm256_madd52hi_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma,avx512vl` only"><code>avx512ifma,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 52-bit integers in each 64-bit element of
<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the high 52-bit
unsigned integer from the intermediate result with the
corresponding unsigned 64-bit integer in <code>a</code>, and store the
results in <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_madd52lo_epu64.html" title="no_std_compat::arch::x86_64::_mm256_madd52lo_epu64 fn">_mm256_madd52lo_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma,avx512vl` only"><code>avx512ifma,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 52-bit integers in each 64-bit element of
<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the low 52-bit
unsigned integer from the intermediate result with the
corresponding unsigned 64-bit integer in <code>a</code>, and store the
results in <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask2_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask2_permutex2var_epi8 fn">_mm256_mask2_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask2_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask2_permutex2var_epi16 fn">_mm256_mask2_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask2_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask2_permutex2var_epi32 fn">_mm256_mask2_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask2_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask2_permutex2var_epi64 fn">_mm256_mask2_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask2_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask2_permutex2var_pd fn">_mm256_mask2_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask2_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask2_permutex2var_ps fn">_mm256_mask2_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fmadd_pd fn">_mm256_mask3_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fmadd_ps fn">_mm256_mask3_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fmaddsub_pd fn">_mm256_mask3_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fmaddsub_ps fn">_mm256_mask3_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fmsub_pd fn">_mm256_mask3_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fmsub_ps fn">_mm256_mask3_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fmsubadd_pd fn">_mm256_mask3_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fmsubadd_ps fn">_mm256_mask3_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fnmadd_pd fn">_mm256_mask3_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fnmadd_ps fn">_mm256_mask3_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fnmsub_pd fn">_mm256_mask3_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask3_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask3_fnmsub_ps fn">_mm256_mask3_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_abs_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_abs_epi8 fn">_mm256_mask_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_abs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_abs_epi16 fn">_mm256_mask_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_abs_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_abs_epi32 fn">_mm256_mask_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_abs_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_abs_epi64 fn">_mm256_mask_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_add_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_add_epi8 fn">_mm256_mask_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_add_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_add_epi16 fn">_mm256_mask_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_add_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_add_epi32 fn">_mm256_mask_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_add_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_add_epi64 fn">_mm256_mask_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_add_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_add_pd fn">_mm256_mask_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_add_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_add_ps fn">_mm256_mask_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_adds_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_adds_epi8 fn">_mm256_mask_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_adds_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_adds_epi16 fn">_mm256_mask_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_adds_epu8.html" title="no_std_compat::arch::x86_64::_mm256_mask_adds_epu8 fn">_mm256_mask_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_adds_epu16.html" title="no_std_compat::arch::x86_64::_mm256_mask_adds_epu16 fn">_mm256_mask_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_alignr_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_alignr_epi8 fn">_mm256_mask_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_alignr_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_alignr_epi32 fn">_mm256_mask_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_alignr_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_alignr_epi64 fn">_mm256_mask_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_and_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_and_epi32 fn">_mm256_mask_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_and_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_and_epi64 fn">_mm256_mask_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_andnot_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_andnot_epi32 fn">_mm256_mask_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_andnot_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_andnot_epi64 fn">_mm256_mask_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_avg_epu8.html" title="no_std_compat::arch::x86_64::_mm256_mask_avg_epu8 fn">_mm256_mask_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_avg_epu16.html" title="no_std_compat::arch::x86_64::_mm256_mask_avg_epu16 fn">_mm256_mask_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_bitshuffle_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_bitshuffle_epi64_mask fn">_mm256_mask_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.
Then groups 8 8-bit values from <code>c</code>as indices into the the bits of the corresponding 64-bit integer.
It then selects these bits and packs them into the output.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_blend_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_blend_epi8 fn">_mm256_mask_blend_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed 8-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_blend_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_blend_epi16 fn">_mm256_mask_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed 16-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_blend_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_blend_epi32 fn">_mm256_mask_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_blend_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_blend_epi64 fn">_mm256_mask_blend_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_blend_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_blend_pd fn">_mm256_mask_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_blend_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_blend_ps fn">_mm256_mask_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_broadcast_f32x4.html" title="no_std_compat::arch::x86_64::_mm256_mask_broadcast_f32x4 fn">_mm256_mask_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_broadcast_i32x4.html" title="no_std_compat::arch::x86_64::_mm256_mask_broadcast_i32x4 fn">_mm256_mask_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed 32-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_broadcastb_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_broadcastb_epi8 fn">_mm256_mask_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 8-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_broadcastd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_broadcastd_epi32 fn">_mm256_mask_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_broadcastq_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_broadcastq_epi64 fn">_mm256_mask_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_broadcastsd_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_broadcastsd_pd fn">_mm256_mask_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_broadcastss_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_broadcastss_ps fn">_mm256_mask_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_broadcastw_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_broadcastw_epi16 fn">_mm256_mask_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_epi8_mask fn">_mm256_mask_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_epi16_mask fn">_mm256_mask_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_epi32_mask fn">_mm256_mask_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_epi64_mask fn">_mm256_mask_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_epu8_mask fn">_mm256_mask_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_epu16_mask fn">_mm256_mask_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_epu32_mask fn">_mm256_mask_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_epu64_mask fn">_mm256_mask_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_pd_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_pd_mask fn">_mm256_mask_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmp_ps_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmp_ps_mask fn">_mm256_mask_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpeq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpeq_epi8_mask fn">_mm256_mask_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpeq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpeq_epi16_mask fn">_mm256_mask_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpeq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpeq_epi32_mask fn">_mm256_mask_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpeq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpeq_epi64_mask fn">_mm256_mask_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpeq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpeq_epu8_mask fn">_mm256_mask_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpeq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpeq_epu16_mask fn">_mm256_mask_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpeq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpeq_epu32_mask fn">_mm256_mask_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpeq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpeq_epu64_mask fn">_mm256_mask_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpge_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpge_epi8_mask fn">_mm256_mask_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpge_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpge_epi16_mask fn">_mm256_mask_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpge_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpge_epi32_mask fn">_mm256_mask_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpge_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpge_epi64_mask fn">_mm256_mask_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpge_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpge_epu8_mask fn">_mm256_mask_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpge_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpge_epu16_mask fn">_mm256_mask_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpge_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpge_epu32_mask fn">_mm256_mask_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpge_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpge_epu64_mask fn">_mm256_mask_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpgt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpgt_epi8_mask fn">_mm256_mask_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpgt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpgt_epi16_mask fn">_mm256_mask_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpgt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpgt_epi32_mask fn">_mm256_mask_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpgt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpgt_epi64_mask fn">_mm256_mask_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpgt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpgt_epu8_mask fn">_mm256_mask_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpgt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpgt_epu16_mask fn">_mm256_mask_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpgt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpgt_epu32_mask fn">_mm256_mask_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpgt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpgt_epu64_mask fn">_mm256_mask_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmple_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmple_epi8_mask fn">_mm256_mask_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmple_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmple_epi16_mask fn">_mm256_mask_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmple_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmple_epi32_mask fn">_mm256_mask_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmple_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmple_epi64_mask fn">_mm256_mask_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmple_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmple_epu8_mask fn">_mm256_mask_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmple_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmple_epu16_mask fn">_mm256_mask_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmple_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmple_epu32_mask fn">_mm256_mask_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmple_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmple_epu64_mask fn">_mm256_mask_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmplt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmplt_epi8_mask fn">_mm256_mask_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmplt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmplt_epi16_mask fn">_mm256_mask_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmplt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmplt_epi32_mask fn">_mm256_mask_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmplt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmplt_epi64_mask fn">_mm256_mask_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmplt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmplt_epu8_mask fn">_mm256_mask_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmplt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmplt_epu16_mask fn">_mm256_mask_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmplt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmplt_epu32_mask fn">_mm256_mask_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmplt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmplt_epu64_mask fn">_mm256_mask_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpneq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpneq_epi8_mask fn">_mm256_mask_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpneq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpneq_epi16_mask fn">_mm256_mask_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpneq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpneq_epi32_mask fn">_mm256_mask_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpneq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpneq_epi64_mask fn">_mm256_mask_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpneq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpneq_epu8_mask fn">_mm256_mask_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpneq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpneq_epu16_mask fn">_mm256_mask_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpneq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpneq_epu32_mask fn">_mm256_mask_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cmpneq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_cmpneq_epu64_mask fn">_mm256_mask_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compress_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_compress_epi8 fn">_mm256_mask_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compress_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_compress_epi16 fn">_mm256_mask_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compress_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_compress_epi32 fn">_mm256_mask_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compress_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_compress_epi64 fn">_mm256_mask_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compress_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_compress_pd fn">_mm256_mask_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compress_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_compress_ps fn">_mm256_mask_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compressstoreu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_compressstoreu_epi8 fn">_mm256_mask_compressstoreu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compressstoreu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_compressstoreu_epi16 fn">_mm256_mask_compressstoreu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compressstoreu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_compressstoreu_epi32 fn">_mm256_mask_compressstoreu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compressstoreu_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_compressstoreu_epi64 fn">_mm256_mask_compressstoreu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compressstoreu_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_compressstoreu_pd fn">_mm256_mask_compressstoreu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_compressstoreu_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_compressstoreu_ps fn">_mm256_mask_compressstoreu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_conflict_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_conflict_epi32 fn">_mm256_mask_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_conflict_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_conflict_epi64 fn">_mm256_mask_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvt_roundps_ph.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvt_roundps_ph fn">_mm256_mask_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi8_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi8_epi16 fn">_mm256_mask_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi8_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi8_epi32 fn">_mm256_mask_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi8_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi8_epi64 fn">_mm256_mask_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi16_epi8 fn">_mm256_mask_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi16_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi16_epi32 fn">_mm256_mask_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi16_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi16_epi64 fn">_mm256_mask_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi16_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi16_storeu_epi8 fn">_mm256_mask_cvtepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi32_epi8 fn">_mm256_mask_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi32_epi16 fn">_mm256_mask_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi32_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi32_epi64 fn">_mm256_mask_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi32_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi32_pd fn">_mm256_mask_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi32_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi32_ps fn">_mm256_mask_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi32_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi32_storeu_epi8 fn">_mm256_mask_cvtepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi32_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi32_storeu_epi16 fn">_mm256_mask_cvtepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi64_epi8 fn">_mm256_mask_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi64_epi16 fn">_mm256_mask_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi64_epi32 fn">_mm256_mask_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi64_storeu_epi8 fn">_mm256_mask_cvtepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi64_storeu_epi16 fn">_mm256_mask_cvtepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepi64_storeu_epi32 fn">_mm256_mask_cvtepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepu8_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepu8_epi16 fn">_mm256_mask_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepu8_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepu8_epi32 fn">_mm256_mask_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepu8_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepu8_epi64 fn">_mm256_mask_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepu16_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepu16_epi32 fn">_mm256_mask_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepu16_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepu16_epi64 fn">_mm256_mask_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepu32_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepu32_epi64 fn">_mm256_mask_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtepu32_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtepu32_pd fn">_mm256_mask_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtne2ps_pbh.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtne2ps_pbh fn">_mm256_mask_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in two vectors a and b
to packed BF16 (16-bit) floating-point elements and and store the results in single vector
dst using writemask k (elements are copied from src when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654&amp;avx512techs=AVX512_BF16&amp;text=_mm256_mask_cvtne2ps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtneps_pbh.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtneps_pbh fn">_mm256_mask_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)
floating-point elements, and store the results in dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_mask_cvtneps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtpd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtpd_epi32 fn">_mm256_mask_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtpd_epu32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtpd_epu32 fn">_mm256_mask_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtpd_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtpd_ps fn">_mm256_mask_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtph_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtph_ps fn">_mm256_mask_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtps_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtps_epi32 fn">_mm256_mask_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtps_epu32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtps_epu32 fn">_mm256_mask_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtps_ph.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtps_ph fn">_mm256_mask_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi16_epi8 fn">_mm256_mask_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi16_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi16_storeu_epi8 fn">_mm256_mask_cvtsepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi32_epi8 fn">_mm256_mask_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi32_epi16 fn">_mm256_mask_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi32_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi32_storeu_epi8 fn">_mm256_mask_cvtsepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi32_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi32_storeu_epi16 fn">_mm256_mask_cvtsepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi64_epi8 fn">_mm256_mask_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi64_epi16 fn">_mm256_mask_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi64_epi32 fn">_mm256_mask_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi64_storeu_epi8 fn">_mm256_mask_cvtsepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi64_storeu_epi16 fn">_mm256_mask_cvtsepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtsepi64_storeu_epi32 fn">_mm256_mask_cvtsepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvttpd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvttpd_epi32 fn">_mm256_mask_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvttpd_epu32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvttpd_epu32 fn">_mm256_mask_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvttps_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvttps_epi32 fn">_mm256_mask_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvttps_epu32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvttps_epu32 fn">_mm256_mask_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi16_epi8 fn">_mm256_mask_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi16_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi16_storeu_epi8 fn">_mm256_mask_cvtusepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi32_epi8 fn">_mm256_mask_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi32_epi16 fn">_mm256_mask_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi32_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi32_storeu_epi8 fn">_mm256_mask_cvtusepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi32_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi32_storeu_epi16 fn">_mm256_mask_cvtusepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi64_epi8 fn">_mm256_mask_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi64_epi16 fn">_mm256_mask_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi64_epi32 fn">_mm256_mask_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi64_storeu_epi8 fn">_mm256_mask_cvtusepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi64_storeu_epi16 fn">_mm256_mask_cvtusepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_cvtusepi64_storeu_epi32 fn">_mm256_mask_cvtusepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_dbsad_epu8.html" title="no_std_compat::arch::x86_64::_mm256_mask_dbsad_epu8 fn">_mm256_mask_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_div_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_div_pd fn">_mm256_mask_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_div_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_div_ps fn">_mm256_mask_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_dpbf16_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_dpbf16_ps fn">_mm256_mask_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,
accumulating the intermediate single-precision (32-bit) floating-point elements
with elements in src, and store the results in dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_mask_dpbf16_ps">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_dpbusd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_dpbusd_epi32 fn">_mm256_mask_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_dpbusds_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_dpbusds_epi32 fn">_mm256_mask_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_dpwssd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_dpwssd_epi32 fn">_mm256_mask_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_dpwssds_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_dpwssds_epi32 fn">_mm256_mask_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expand_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_expand_epi8 fn">_mm256_mask_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expand_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_expand_epi16 fn">_mm256_mask_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expand_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_expand_epi32 fn">_mm256_mask_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expand_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_expand_epi64 fn">_mm256_mask_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expand_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_expand_pd fn">_mm256_mask_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expand_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_expand_ps fn">_mm256_mask_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expandloadu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_expandloadu_epi8 fn">_mm256_mask_expandloadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vbmi2,avx512vl,avx` only"><code>avx512f,avx512bw,avx512vbmi2,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expandloadu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_expandloadu_epi16 fn">_mm256_mask_expandloadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vbmi2,avx512vl,avx` only"><code>avx512f,avx512vbmi2,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expandloadu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_expandloadu_epi32 fn">_mm256_mask_expandloadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expandloadu_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_expandloadu_epi64 fn">_mm256_mask_expandloadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expandloadu_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_expandloadu_pd fn">_mm256_mask_expandloadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_expandloadu_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_expandloadu_ps fn">_mm256_mask_expandloadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_extractf32x4_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_extractf32x4_ps fn">_mm256_mask_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_extracti32x4_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_extracti32x4_epi32 fn">_mm256_mask_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fixupimm_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_fixupimm_pd fn">_mm256_mask_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fixupimm_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_fixupimm_ps fn">_mm256_mask_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_fmadd_pd fn">_mm256_mask_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_fmadd_ps fn">_mm256_mask_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_fmaddsub_pd fn">_mm256_mask_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_fmaddsub_ps fn">_mm256_mask_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_fmsub_pd fn">_mm256_mask_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_fmsub_ps fn">_mm256_mask_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_fmsubadd_pd fn">_mm256_mask_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_fmsubadd_ps fn">_mm256_mask_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_fnmadd_pd fn">_mm256_mask_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_fnmadd_ps fn">_mm256_mask_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_fnmsub_pd fn">_mm256_mask_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_fnmsub_ps fn">_mm256_mask_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_getexp_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_getexp_pd fn">_mm256_mask_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_getexp_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_getexp_ps fn">_mm256_mask_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_getmant_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_getmant_pd fn">_mm256_mask_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_getmant_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_getmant_ps fn">_mm256_mask_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_gf2p8affine_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_gf2p8affine_epi64_epi8 fn">_mm256_mask_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the packed bytes in x.
That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_gf2p8affineinv_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_gf2p8affineinv_epi64_epi8 fn">_mm256_mask_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the inverted packed bytes in x.
That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.
The inverse of 0 is 0.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_gf2p8mul_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_gf2p8mul_epi8 fn">_mm256_mask_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs a multiplication in GF(2^8) on the packed bytes.
The field is in polynomial representation with the reduction polynomial
x^8 + x^4 + x^3 + x + 1.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_insertf32x4.html" title="no_std_compat::arch::x86_64::_mm256_mask_insertf32x4 fn">_mm256_mask_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_inserti32x4.html" title="no_std_compat::arch::x86_64::_mm256_mask_inserti32x4 fn">_mm256_mask_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_load_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_load_epi32 fn">_mm256_mask_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_load_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_load_epi64 fn">_mm256_mask_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_load_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_load_pd fn">_mm256_mask_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_load_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_load_ps fn">_mm256_mask_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_loadu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_loadu_epi8 fn">_mm256_mask_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx` only"><code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 8-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_loadu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_loadu_epi16 fn">_mm256_mask_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx` only"><code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 16-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_loadu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_loadu_epi32 fn">_mm256_mask_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_loadu_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_loadu_epi64 fn">_mm256_mask_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_loadu_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_loadu_pd fn">_mm256_mask_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_loadu_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_loadu_ps fn">_mm256_mask_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_lzcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_lzcnt_epi32 fn">_mm256_mask_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_lzcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_lzcnt_epi64 fn">_mm256_mask_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_madd_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_madd_epi16 fn">_mm256_mask_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_maddubs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_maddubs_epi16 fn">_mm256_mask_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_epi8 fn">_mm256_mask_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_epi16 fn">_mm256_mask_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_epi32 fn">_mm256_mask_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_epi64 fn">_mm256_mask_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_epu8.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_epu8 fn">_mm256_mask_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_epu16.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_epu16 fn">_mm256_mask_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_epu32.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_epu32 fn">_mm256_mask_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_epu64.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_epu64 fn">_mm256_mask_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_pd fn">_mm256_mask_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_max_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_max_ps fn">_mm256_mask_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_epi8 fn">_mm256_mask_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_epi16 fn">_mm256_mask_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_epi32 fn">_mm256_mask_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_epi64 fn">_mm256_mask_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_epu8.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_epu8 fn">_mm256_mask_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_epu16.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_epu16 fn">_mm256_mask_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_epu32.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_epu32 fn">_mm256_mask_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_epu64.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_epu64 fn">_mm256_mask_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_pd fn">_mm256_mask_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_min_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_min_ps fn">_mm256_mask_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mov_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_mov_epi8 fn">_mm256_mask_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 8-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mov_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_mov_epi16 fn">_mm256_mask_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 16-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mov_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_mov_epi32 fn">_mm256_mask_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mov_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_mov_epi64 fn">_mm256_mask_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mov_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_mov_pd fn">_mm256_mask_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mov_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_mov_ps fn">_mm256_mask_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_movedup_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_movedup_pd fn">_mm256_mask_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_movehdup_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_movehdup_ps fn">_mm256_mask_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_moveldup_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_moveldup_ps fn">_mm256_mask_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_mul_epi32 fn">_mm256_mask_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mul_epu32.html" title="no_std_compat::arch::x86_64::_mm256_mask_mul_epu32 fn">_mm256_mask_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mul_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_mul_pd fn">_mm256_mask_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mul_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_mul_ps fn">_mm256_mask_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mulhi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_mulhi_epi16 fn">_mm256_mask_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mulhi_epu16.html" title="no_std_compat::arch::x86_64::_mm256_mask_mulhi_epu16 fn">_mm256_mask_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mulhrs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_mulhrs_epi16 fn">_mm256_mask_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mullo_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_mullo_epi16 fn">_mm256_mask_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_mullo_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_mullo_epi32 fn">_mm256_mask_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_multishift_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_multishift_epi64_epi8 fn">_mm256_mask_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_or_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_or_epi32 fn">_mm256_mask_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_or_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_or_epi64 fn">_mm256_mask_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_packs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_packs_epi16 fn">_mm256_mask_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_packs_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_packs_epi32 fn">_mm256_mask_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_packus_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_packus_epi16 fn">_mm256_mask_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_packus_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_packus_epi32 fn">_mm256_mask_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permute_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_permute_pd fn">_mm256_mask_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permute_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_permute_ps fn">_mm256_mask_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutevar_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutevar_pd fn">_mm256_mask_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutevar_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutevar_ps fn">_mm256_mask_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutex2var_epi8 fn">_mm256_mask_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutex2var_epi16 fn">_mm256_mask_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutex2var_epi32 fn">_mm256_mask_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutex2var_epi64 fn">_mm256_mask_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutex2var_pd fn">_mm256_mask_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutex2var_ps fn">_mm256_mask_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutex_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutex_epi64 fn">_mm256_mask_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutex_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutex_pd fn">_mm256_mask_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutexvar_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutexvar_epi8 fn">_mm256_mask_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutexvar_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutexvar_epi16 fn">_mm256_mask_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutexvar_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutexvar_epi32 fn">_mm256_mask_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutexvar_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutexvar_epi64 fn">_mm256_mask_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutexvar_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutexvar_pd fn">_mm256_mask_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_permutexvar_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_permutexvar_ps fn">_mm256_mask_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_popcnt_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_popcnt_epi8 fn">_mm256_mask_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 8-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_popcnt_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_popcnt_epi16 fn">_mm256_mask_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 16-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_popcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_popcnt_epi32 fn">_mm256_mask_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 32-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_popcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_popcnt_epi64 fn">_mm256_mask_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 64-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rcp14_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_rcp14_pd fn">_mm256_mask_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rcp14_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_rcp14_ps fn">_mm256_mask_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rol_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_rol_epi32 fn">_mm256_mask_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rol_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_rol_epi64 fn">_mm256_mask_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rolv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_rolv_epi32 fn">_mm256_mask_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rolv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_rolv_epi64 fn">_mm256_mask_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_ror_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_ror_epi32 fn">_mm256_mask_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_ror_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_ror_epi64 fn">_mm256_mask_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rorv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_rorv_epi32 fn">_mm256_mask_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rorv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_rorv_epi64 fn">_mm256_mask_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_roundscale_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_roundscale_pd fn">_mm256_mask_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_roundscale_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_roundscale_ps fn">_mm256_mask_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rsqrt14_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_rsqrt14_pd fn">_mm256_mask_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_rsqrt14_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_rsqrt14_ps fn">_mm256_mask_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_scalef_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_scalef_pd fn">_mm256_mask_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_scalef_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_scalef_ps fn">_mm256_mask_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_set1_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_set1_epi8 fn">_mm256_mask_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 8-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_set1_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_set1_epi16 fn">_mm256_mask_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 16-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_set1_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_set1_epi32 fn">_mm256_mask_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_set1_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_set1_epi64 fn">_mm256_mask_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shldi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_shldi_epi16 fn">_mm256_mask_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shldi_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_shldi_epi32 fn">_mm256_mask_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shldi_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_shldi_epi64 fn">_mm256_mask_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shldv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_shldv_epi16 fn">_mm256_mask_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shldv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_shldv_epi32 fn">_mm256_mask_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shldv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_shldv_epi64 fn">_mm256_mask_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shrdi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_shrdi_epi16 fn">_mm256_mask_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shrdi_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_shrdi_epi32 fn">_mm256_mask_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shrdi_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_shrdi_epi64 fn">_mm256_mask_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src“ when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shrdv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_shrdv_epi16 fn">_mm256_mask_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shrdv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_shrdv_epi32 fn">_mm256_mask_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shrdv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_shrdv_epi64 fn">_mm256_mask_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shuffle_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_shuffle_epi8 fn">_mm256_mask_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a within 128-bit lanes using the control in the corresponding 8-bit element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shuffle_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_shuffle_epi32 fn">_mm256_mask_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shuffle_f32x4.html" title="no_std_compat::arch::x86_64::_mm256_mask_shuffle_f32x4 fn">_mm256_mask_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shuffle_f64x2.html" title="no_std_compat::arch::x86_64::_mm256_mask_shuffle_f64x2 fn">_mm256_mask_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shuffle_i32x4.html" title="no_std_compat::arch::x86_64::_mm256_mask_shuffle_i32x4 fn">_mm256_mask_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shuffle_i64x2.html" title="no_std_compat::arch::x86_64::_mm256_mask_shuffle_i64x2 fn">_mm256_mask_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shuffle_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_shuffle_pd fn">_mm256_mask_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shuffle_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_shuffle_ps fn">_mm256_mask_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shufflehi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_shufflehi_epi16 fn">_mm256_mask_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_shufflelo_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_shufflelo_epi16 fn">_mm256_mask_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sll_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_sll_epi16 fn">_mm256_mask_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sll_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_sll_epi32 fn">_mm256_mask_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sll_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_sll_epi64 fn">_mm256_mask_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_slli_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_slli_epi16 fn">_mm256_mask_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_slli_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_slli_epi32 fn">_mm256_mask_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_slli_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_slli_epi64 fn">_mm256_mask_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sllv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_sllv_epi16 fn">_mm256_mask_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sllv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_sllv_epi32 fn">_mm256_mask_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sllv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_sllv_epi64 fn">_mm256_mask_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sqrt_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_sqrt_pd fn">_mm256_mask_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sqrt_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_sqrt_ps fn">_mm256_mask_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sra_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_sra_epi16 fn">_mm256_mask_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sra_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_sra_epi32 fn">_mm256_mask_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sra_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_sra_epi64 fn">_mm256_mask_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srai_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_srai_epi16 fn">_mm256_mask_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srai_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_srai_epi32 fn">_mm256_mask_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srai_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_srai_epi64 fn">_mm256_mask_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srav_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_srav_epi16 fn">_mm256_mask_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srav_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_srav_epi32 fn">_mm256_mask_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srav_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_srav_epi64 fn">_mm256_mask_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srl_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_srl_epi16 fn">_mm256_mask_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srl_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_srl_epi32 fn">_mm256_mask_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srl_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_srl_epi64 fn">_mm256_mask_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srli_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_srli_epi16 fn">_mm256_mask_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srli_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_srli_epi32 fn">_mm256_mask_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srli_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_srli_epi64 fn">_mm256_mask_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srlv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_srlv_epi16 fn">_mm256_mask_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srlv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_srlv_epi32 fn">_mm256_mask_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_srlv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_srlv_epi64 fn">_mm256_mask_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_store_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_store_epi32 fn">_mm256_mask_store_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed 32-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_store_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_store_epi64 fn">_mm256_mask_store_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed 64-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_store_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_store_pd fn">_mm256_mask_store_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_store_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_store_ps fn">_mm256_mask_store_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_storeu_epi8 fn">_mm256_mask_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx` only"><code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed 8-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_storeu_epi16 fn">_mm256_mask_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx` only"><code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed 16-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_storeu_epi32 fn">_mm256_mask_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed 32-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_storeu_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_storeu_epi64 fn">_mm256_mask_storeu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed 64-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_storeu_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_storeu_pd fn">_mm256_mask_storeu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_storeu_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_storeu_ps fn">_mm256_mask_storeu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sub_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_sub_epi8 fn">_mm256_mask_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sub_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_sub_epi16 fn">_mm256_mask_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sub_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_sub_epi32 fn">_mm256_mask_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sub_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_sub_epi64 fn">_mm256_mask_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sub_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_sub_pd fn">_mm256_mask_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_sub_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_sub_ps fn">_mm256_mask_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_subs_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_subs_epi8 fn">_mm256_mask_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_subs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_subs_epi16 fn">_mm256_mask_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_subs_epu8.html" title="no_std_compat::arch::x86_64::_mm256_mask_subs_epu8 fn">_mm256_mask_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_subs_epu16.html" title="no_std_compat::arch::x86_64::_mm256_mask_subs_epu16 fn">_mm256_mask_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_ternarylogic_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_ternarylogic_epi32 fn">_mm256_mask_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_ternarylogic_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_ternarylogic_epi64 fn">_mm256_mask_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_test_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_test_epi8_mask fn">_mm256_mask_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_test_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_test_epi16_mask fn">_mm256_mask_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_test_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_test_epi32_mask fn">_mm256_mask_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_test_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_test_epi64_mask fn">_mm256_mask_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_testn_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_testn_epi8_mask fn">_mm256_mask_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_testn_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_testn_epi16_mask fn">_mm256_mask_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_testn_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_testn_epi32_mask fn">_mm256_mask_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_testn_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_mask_testn_epi64_mask fn">_mm256_mask_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpackhi_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpackhi_epi8 fn">_mm256_mask_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpackhi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpackhi_epi16 fn">_mm256_mask_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpackhi_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpackhi_epi32 fn">_mm256_mask_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpackhi_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpackhi_epi64 fn">_mm256_mask_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpackhi_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpackhi_pd fn">_mm256_mask_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpackhi_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpackhi_ps fn">_mm256_mask_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpacklo_epi8.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpacklo_epi8 fn">_mm256_mask_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpacklo_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpacklo_epi16 fn">_mm256_mask_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpacklo_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpacklo_epi32 fn">_mm256_mask_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpacklo_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpacklo_epi64 fn">_mm256_mask_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpacklo_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpacklo_pd fn">_mm256_mask_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_unpacklo_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_unpacklo_ps fn">_mm256_mask_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_xor_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_xor_epi32 fn">_mm256_mask_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_mask_xor_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_xor_epi64 fn">_mm256_mask_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_abs_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_abs_epi8 fn">_mm256_maskz_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_abs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_abs_epi16 fn">_mm256_maskz_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_abs_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_abs_epi32 fn">_mm256_maskz_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_abs_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_abs_epi64 fn">_mm256_maskz_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_add_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_add_epi8 fn">_mm256_maskz_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_add_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_add_epi16 fn">_mm256_maskz_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_add_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_add_epi32 fn">_mm256_maskz_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_add_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_add_epi64 fn">_mm256_maskz_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_add_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_add_pd fn">_mm256_maskz_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_add_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_add_ps fn">_mm256_maskz_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_adds_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_adds_epi8 fn">_mm256_maskz_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_adds_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_adds_epi16 fn">_mm256_maskz_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_adds_epu8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_adds_epu8 fn">_mm256_maskz_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_adds_epu16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_adds_epu16 fn">_mm256_maskz_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_alignr_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_alignr_epi8 fn">_mm256_maskz_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_alignr_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_alignr_epi32 fn">_mm256_maskz_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 32 bytes (8 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_alignr_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_alignr_epi64 fn">_mm256_maskz_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 64-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 32 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_and_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_and_epi32 fn">_mm256_maskz_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_and_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_and_epi64 fn">_mm256_maskz_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_andnot_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_andnot_epi32 fn">_mm256_maskz_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_andnot_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_andnot_epi64 fn">_mm256_maskz_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_avg_epu8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_avg_epu8 fn">_mm256_maskz_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_avg_epu16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_avg_epu16 fn">_mm256_maskz_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_broadcast_f32x4.html" title="no_std_compat::arch::x86_64::_mm256_maskz_broadcast_f32x4 fn">_mm256_maskz_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_broadcast_i32x4.html" title="no_std_compat::arch::x86_64::_mm256_maskz_broadcast_i32x4 fn">_mm256_maskz_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed 32-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_broadcastb_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_broadcastb_epi8 fn">_mm256_maskz_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 8-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_broadcastd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_broadcastd_epi32 fn">_mm256_maskz_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_broadcastq_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_broadcastq_epi64 fn">_mm256_maskz_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_broadcastsd_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_broadcastsd_pd fn">_mm256_maskz_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_broadcastss_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_broadcastss_ps fn">_mm256_maskz_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_broadcastw_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_broadcastw_epi16 fn">_mm256_maskz_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_compress_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_compress_epi8 fn">_mm256_maskz_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_compress_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_compress_epi16 fn">_mm256_maskz_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_compress_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_compress_epi32 fn">_mm256_maskz_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_compress_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_compress_epi64 fn">_mm256_maskz_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_compress_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_compress_pd fn">_mm256_maskz_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_compress_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_compress_ps fn">_mm256_maskz_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_conflict_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_conflict_epi32 fn">_mm256_maskz_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_conflict_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_conflict_epi64 fn">_mm256_maskz_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvt_roundps_ph.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvt_roundps_ph fn">_mm256_maskz_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi8_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi8_epi16 fn">_mm256_maskz_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi8_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi8_epi32 fn">_mm256_maskz_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi8_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi8_epi64 fn">_mm256_maskz_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi16_epi8 fn">_mm256_maskz_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi16_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi16_epi32 fn">_mm256_maskz_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi16_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi16_epi64 fn">_mm256_maskz_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi32_epi8 fn">_mm256_maskz_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi32_epi16 fn">_mm256_maskz_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi32_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi32_epi64 fn">_mm256_maskz_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi32_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi32_pd fn">_mm256_maskz_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi32_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi32_ps fn">_mm256_maskz_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi64_epi8 fn">_mm256_maskz_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi64_epi16 fn">_mm256_maskz_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepi64_epi32 fn">_mm256_maskz_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepu8_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepu8_epi16 fn">_mm256_maskz_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepu8_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepu8_epi32 fn">_mm256_maskz_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepu8_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepu8_epi64 fn">_mm256_maskz_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepu16_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepu16_epi32 fn">_mm256_maskz_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepu16_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepu16_epi64 fn">_mm256_maskz_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepu32_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepu32_epi64 fn">_mm256_maskz_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtepu32_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtepu32_pd fn">_mm256_maskz_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtne2ps_pbh.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtne2ps_pbh fn">_mm256_maskz_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in two vectors a and b
to packed BF16 (16-bit) floating-point elements, and store the results in single vector
dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654&amp;avx512techs=AVX512_BF16&amp;text=_mm256_maskz_cvtne2ps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtneps_pbh.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtneps_pbh fn">_mm256_maskz_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)
floating-point elements, and store the results in dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_maskz_cvtneps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtpd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtpd_epi32 fn">_mm256_maskz_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtpd_epu32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtpd_epu32 fn">_mm256_maskz_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtpd_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtpd_ps fn">_mm256_maskz_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtph_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtph_ps fn">_mm256_maskz_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtps_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtps_epi32 fn">_mm256_maskz_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtps_epu32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtps_epu32 fn">_mm256_maskz_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtps_ph.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtps_ph fn">_mm256_maskz_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtsepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtsepi16_epi8 fn">_mm256_maskz_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtsepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtsepi32_epi8 fn">_mm256_maskz_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtsepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtsepi32_epi16 fn">_mm256_maskz_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtsepi64_epi8 fn">_mm256_maskz_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtsepi64_epi16 fn">_mm256_maskz_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtsepi64_epi32 fn">_mm256_maskz_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvttpd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvttpd_epi32 fn">_mm256_maskz_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvttpd_epu32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvttpd_epu32 fn">_mm256_maskz_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvttps_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvttps_epi32 fn">_mm256_maskz_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvttps_epu32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvttps_epu32 fn">_mm256_maskz_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtusepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtusepi16_epi8 fn">_mm256_maskz_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtusepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtusepi32_epi8 fn">_mm256_maskz_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtusepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtusepi32_epi16 fn">_mm256_maskz_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtusepi64_epi8 fn">_mm256_maskz_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtusepi64_epi16 fn">_mm256_maskz_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_cvtusepi64_epi32 fn">_mm256_maskz_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_dbsad_epu8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_dbsad_epu8 fn">_mm256_maskz_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_div_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_div_pd fn">_mm256_maskz_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_div_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_div_ps fn">_mm256_maskz_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_dpbf16_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_dpbf16_ps fn">_mm256_maskz_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,
accumulating the intermediate single-precision (32-bit) floating-point elements
with elements in src, and store the results in dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_maskz_dpbf16_ps">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_dpbusd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_dpbusd_epi32 fn">_mm256_maskz_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_dpbusds_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_dpbusds_epi32 fn">_mm256_maskz_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_dpwssd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_dpwssd_epi32 fn">_mm256_maskz_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_dpwssds_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_dpwssds_epi32 fn">_mm256_maskz_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expand_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expand_epi8 fn">_mm256_maskz_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expand_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expand_epi16 fn">_mm256_maskz_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expand_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expand_epi32 fn">_mm256_maskz_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expand_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expand_epi64 fn">_mm256_maskz_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expand_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expand_pd fn">_mm256_maskz_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expand_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expand_ps fn">_mm256_maskz_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expandloadu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expandloadu_epi8 fn">_mm256_maskz_expandloadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vbmi2,avx512vl,avx` only"><code>avx512f,avx512bw,avx512vbmi2,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expandloadu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expandloadu_epi16 fn">_mm256_maskz_expandloadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vbmi2,avx512vl,avx` only"><code>avx512f,avx512vbmi2,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expandloadu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expandloadu_epi32 fn">_mm256_maskz_expandloadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expandloadu_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expandloadu_epi64 fn">_mm256_maskz_expandloadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expandloadu_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expandloadu_pd fn">_mm256_maskz_expandloadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_expandloadu_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_expandloadu_ps fn">_mm256_maskz_expandloadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_extractf32x4_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_extractf32x4_ps fn">_mm256_maskz_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_extracti32x4_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_extracti32x4_epi32 fn">_mm256_maskz_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM1, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fixupimm_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fixupimm_pd fn">_mm256_maskz_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fixupimm_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fixupimm_ps fn">_mm256_maskz_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fmadd_pd fn">_mm256_maskz_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fmadd_ps fn">_mm256_maskz_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fmaddsub_pd fn">_mm256_maskz_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fmaddsub_ps fn">_mm256_maskz_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fmsub_pd fn">_mm256_maskz_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fmsub_ps fn">_mm256_maskz_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fmsubadd_pd fn">_mm256_maskz_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fmsubadd_ps fn">_mm256_maskz_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fnmadd_pd fn">_mm256_maskz_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fnmadd_ps fn">_mm256_maskz_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fnmsub_pd fn">_mm256_maskz_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_fnmsub_ps fn">_mm256_maskz_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_getexp_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_getexp_pd fn">_mm256_maskz_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_getexp_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_getexp_ps fn">_mm256_maskz_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_getmant_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_getmant_pd fn">_mm256_maskz_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_getmant_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_getmant_ps fn">_mm256_maskz_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_gf2p8affine_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_gf2p8affine_epi64_epi8 fn">_mm256_maskz_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the packed bytes in x.
That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_gf2p8affineinv_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_gf2p8affineinv_epi64_epi8 fn">_mm256_maskz_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the inverted packed bytes in x.
That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.
The inverse of 0 is 0.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_gf2p8mul_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_gf2p8mul_epi8 fn">_mm256_maskz_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs a multiplication in GF(2^8) on the packed bytes.
The field is in polynomial representation with the reduction polynomial
x^8 + x^4 + x^3 + x + 1.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_insertf32x4.html" title="no_std_compat::arch::x86_64::_mm256_maskz_insertf32x4 fn">_mm256_maskz_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_inserti32x4.html" title="no_std_compat::arch::x86_64::_mm256_maskz_inserti32x4 fn">_mm256_maskz_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_load_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_load_epi32 fn">_mm256_maskz_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_load_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_load_epi64 fn">_mm256_maskz_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_load_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_load_pd fn">_mm256_maskz_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_load_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_load_ps fn">_mm256_maskz_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_loadu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_loadu_epi8 fn">_mm256_maskz_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx` only"><code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 8-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_loadu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_loadu_epi16 fn">_mm256_maskz_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx` only"><code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 16-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_loadu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_loadu_epi32 fn">_mm256_maskz_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_loadu_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_loadu_epi64 fn">_mm256_maskz_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_loadu_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_loadu_pd fn">_mm256_maskz_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_loadu_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_loadu_ps fn">_mm256_maskz_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx` only"><code>avx512f,avx512vl,avx</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_lzcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_lzcnt_epi32 fn">_mm256_maskz_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_lzcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_lzcnt_epi64 fn">_mm256_maskz_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_madd_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_madd_epi16 fn">_mm256_maskz_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_maddubs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_maddubs_epi16 fn">_mm256_maskz_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_epi8 fn">_mm256_maskz_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_epi16 fn">_mm256_maskz_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_epi32 fn">_mm256_maskz_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_epi64 fn">_mm256_maskz_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_epu8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_epu8 fn">_mm256_maskz_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_epu16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_epu16 fn">_mm256_maskz_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_epu32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_epu32 fn">_mm256_maskz_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_epu64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_epu64 fn">_mm256_maskz_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_pd fn">_mm256_maskz_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_max_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_max_ps fn">_mm256_maskz_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_epi8 fn">_mm256_maskz_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_epi16 fn">_mm256_maskz_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_epi32 fn">_mm256_maskz_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_epi64 fn">_mm256_maskz_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_epu8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_epu8 fn">_mm256_maskz_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_epu16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_epu16 fn">_mm256_maskz_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_epu32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_epu32 fn">_mm256_maskz_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_epu64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_epu64 fn">_mm256_maskz_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_pd fn">_mm256_maskz_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_min_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_min_ps fn">_mm256_maskz_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mov_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mov_epi8 fn">_mm256_maskz_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 8-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mov_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mov_epi16 fn">_mm256_maskz_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 16-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mov_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mov_epi32 fn">_mm256_maskz_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mov_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mov_epi64 fn">_mm256_maskz_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mov_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mov_pd fn">_mm256_maskz_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mov_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mov_ps fn">_mm256_maskz_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_movedup_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_movedup_pd fn">_mm256_maskz_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_movehdup_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_movehdup_ps fn">_mm256_maskz_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_moveldup_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_moveldup_ps fn">_mm256_maskz_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mul_epi32 fn">_mm256_maskz_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mul_epu32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mul_epu32 fn">_mm256_maskz_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mul_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mul_pd fn">_mm256_maskz_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mul_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mul_ps fn">_mm256_maskz_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mulhi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mulhi_epi16 fn">_mm256_maskz_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mulhi_epu16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mulhi_epu16 fn">_mm256_maskz_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mulhrs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mulhrs_epi16 fn">_mm256_maskz_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mullo_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mullo_epi16 fn">_mm256_maskz_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_mullo_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_mullo_epi32 fn">_mm256_maskz_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_multishift_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_multishift_epi64_epi8 fn">_mm256_maskz_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_or_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_or_epi32 fn">_mm256_maskz_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_or_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_or_epi64 fn">_mm256_maskz_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_packs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_packs_epi16 fn">_mm256_maskz_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_packs_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_packs_epi32 fn">_mm256_maskz_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_packus_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_packus_epi16 fn">_mm256_maskz_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_packus_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_packus_epi32 fn">_mm256_maskz_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permute_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permute_pd fn">_mm256_maskz_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permute_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permute_ps fn">_mm256_maskz_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutevar_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutevar_pd fn">_mm256_maskz_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutevar_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutevar_ps fn">_mm256_maskz_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutex2var_epi8 fn">_mm256_maskz_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutex2var_epi16 fn">_mm256_maskz_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutex2var_epi32 fn">_mm256_maskz_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutex2var_epi64 fn">_mm256_maskz_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutex2var_pd fn">_mm256_maskz_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutex2var_ps fn">_mm256_maskz_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutex_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutex_epi64 fn">_mm256_maskz_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutex_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutex_pd fn">_mm256_maskz_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutexvar_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutexvar_epi8 fn">_mm256_maskz_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutexvar_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutexvar_epi16 fn">_mm256_maskz_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutexvar_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutexvar_epi32 fn">_mm256_maskz_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutexvar_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutexvar_epi64 fn">_mm256_maskz_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutexvar_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutexvar_pd fn">_mm256_maskz_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_permutexvar_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_permutexvar_ps fn">_mm256_maskz_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_popcnt_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_popcnt_epi8 fn">_mm256_maskz_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 8-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_popcnt_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_popcnt_epi16 fn">_mm256_maskz_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 16-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_popcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_popcnt_epi32 fn">_mm256_maskz_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 32-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_popcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_popcnt_epi64 fn">_mm256_maskz_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 64-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rcp14_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rcp14_pd fn">_mm256_maskz_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rcp14_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rcp14_ps fn">_mm256_maskz_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rol_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rol_epi32 fn">_mm256_maskz_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rol_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rol_epi64 fn">_mm256_maskz_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rolv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rolv_epi32 fn">_mm256_maskz_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rolv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rolv_epi64 fn">_mm256_maskz_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_ror_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_ror_epi32 fn">_mm256_maskz_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_ror_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_ror_epi64 fn">_mm256_maskz_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rorv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rorv_epi32 fn">_mm256_maskz_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rorv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rorv_epi64 fn">_mm256_maskz_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_roundscale_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_roundscale_pd fn">_mm256_maskz_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_roundscale_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_roundscale_ps fn">_mm256_maskz_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rsqrt14_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rsqrt14_pd fn">_mm256_maskz_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_rsqrt14_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_rsqrt14_ps fn">_mm256_maskz_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_scalef_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_scalef_pd fn">_mm256_maskz_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_scalef_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_scalef_ps fn">_mm256_maskz_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_set1_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_set1_epi8 fn">_mm256_maskz_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 8-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_set1_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_set1_epi16 fn">_mm256_maskz_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_set1_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_set1_epi32 fn">_mm256_maskz_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_set1_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_set1_epi64 fn">_mm256_maskz_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shldi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shldi_epi16 fn">_mm256_maskz_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shldi_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shldi_epi32 fn">_mm256_maskz_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shldi_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shldi_epi64 fn">_mm256_maskz_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shldv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shldv_epi16 fn">_mm256_maskz_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shldv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shldv_epi32 fn">_mm256_maskz_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shldv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shldv_epi64 fn">_mm256_maskz_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shrdi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shrdi_epi16 fn">_mm256_maskz_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shrdi_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shrdi_epi32 fn">_mm256_maskz_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shrdi_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shrdi_epi64 fn">_mm256_maskz_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shrdv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shrdv_epi16 fn">_mm256_maskz_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shrdv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shrdv_epi32 fn">_mm256_maskz_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shrdv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shrdv_epi64 fn">_mm256_maskz_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shuffle_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shuffle_epi8 fn">_mm256_maskz_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shuffle_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shuffle_epi32 fn">_mm256_maskz_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shuffle_f32x4.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shuffle_f32x4 fn">_mm256_maskz_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shuffle_f64x2.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shuffle_f64x2 fn">_mm256_maskz_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shuffle_i32x4.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shuffle_i32x4 fn">_mm256_maskz_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shuffle_i64x2.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shuffle_i64x2 fn">_mm256_maskz_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shuffle_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shuffle_pd fn">_mm256_maskz_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shuffle_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shuffle_ps fn">_mm256_maskz_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shufflehi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shufflehi_epi16 fn">_mm256_maskz_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_shufflelo_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_shufflelo_epi16 fn">_mm256_maskz_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sll_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sll_epi16 fn">_mm256_maskz_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sll_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sll_epi32 fn">_mm256_maskz_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sll_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sll_epi64 fn">_mm256_maskz_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_slli_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_slli_epi16 fn">_mm256_maskz_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_slli_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_slli_epi32 fn">_mm256_maskz_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_slli_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_slli_epi64 fn">_mm256_maskz_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sllv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sllv_epi16 fn">_mm256_maskz_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sllv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sllv_epi32 fn">_mm256_maskz_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sllv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sllv_epi64 fn">_mm256_maskz_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sqrt_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sqrt_pd fn">_mm256_maskz_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sqrt_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sqrt_ps fn">_mm256_maskz_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sra_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sra_epi16 fn">_mm256_maskz_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sra_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sra_epi32 fn">_mm256_maskz_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sra_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sra_epi64 fn">_mm256_maskz_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srai_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srai_epi16 fn">_mm256_maskz_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srai_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srai_epi32 fn">_mm256_maskz_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srai_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srai_epi64 fn">_mm256_maskz_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srav_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srav_epi16 fn">_mm256_maskz_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srav_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srav_epi32 fn">_mm256_maskz_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srav_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srav_epi64 fn">_mm256_maskz_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srl_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srl_epi16 fn">_mm256_maskz_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srl_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srl_epi32 fn">_mm256_maskz_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srl_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srl_epi64 fn">_mm256_maskz_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srli_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srli_epi16 fn">_mm256_maskz_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srli_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srli_epi32 fn">_mm256_maskz_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srli_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srli_epi64 fn">_mm256_maskz_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srlv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srlv_epi16 fn">_mm256_maskz_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srlv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srlv_epi32 fn">_mm256_maskz_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_srlv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_srlv_epi64 fn">_mm256_maskz_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sub_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sub_epi8 fn">_mm256_maskz_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sub_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sub_epi16 fn">_mm256_maskz_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sub_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sub_epi32 fn">_mm256_maskz_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sub_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sub_epi64 fn">_mm256_maskz_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sub_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sub_pd fn">_mm256_maskz_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_sub_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_sub_ps fn">_mm256_maskz_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_subs_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_subs_epi8 fn">_mm256_maskz_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_subs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_subs_epi16 fn">_mm256_maskz_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_subs_epu8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_subs_epu8 fn">_mm256_maskz_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_subs_epu16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_subs_epu16 fn">_mm256_maskz_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_ternarylogic_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_ternarylogic_epi32 fn">_mm256_maskz_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_ternarylogic_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_ternarylogic_epi64 fn">_mm256_maskz_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpackhi_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpackhi_epi8 fn">_mm256_maskz_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpackhi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpackhi_epi16 fn">_mm256_maskz_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpackhi_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpackhi_epi32 fn">_mm256_maskz_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpackhi_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpackhi_epi64 fn">_mm256_maskz_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpackhi_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpackhi_pd fn">_mm256_maskz_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpackhi_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpackhi_ps fn">_mm256_maskz_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpacklo_epi8.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpacklo_epi8 fn">_mm256_maskz_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpacklo_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpacklo_epi16 fn">_mm256_maskz_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpacklo_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpacklo_epi32 fn">_mm256_maskz_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpacklo_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpacklo_epi64 fn">_mm256_maskz_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpacklo_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpacklo_pd fn">_mm256_maskz_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_unpacklo_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskz_unpacklo_ps fn">_mm256_maskz_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_xor_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskz_xor_epi32 fn">_mm256_maskz_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_maskz_xor_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskz_xor_epi64 fn">_mm256_maskz_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_max_epi64.html" title="no_std_compat::arch::x86_64::_mm256_max_epi64 fn">_mm256_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_max_epu64.html" title="no_std_compat::arch::x86_64::_mm256_max_epu64 fn">_mm256_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_min_epi64.html" title="no_std_compat::arch::x86_64::_mm256_min_epi64 fn">_mm256_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_min_epu64.html" title="no_std_compat::arch::x86_64::_mm256_min_epu64 fn">_mm256_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_movepi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_movepi8_mask fn">_mm256_movepi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Set each bit of mask register k based on the most significant bit of the corresponding packed 8-bit integer in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_movepi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_movepi16_mask fn">_mm256_movepi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Set each bit of mask register k based on the most significant bit of the corresponding packed 16-bit integer in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_movm_epi8.html" title="no_std_compat::arch::x86_64::_mm256_movm_epi8 fn">_mm256_movm_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Set each packed 8-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_movm_epi16.html" title="no_std_compat::arch::x86_64::_mm256_movm_epi16 fn">_mm256_movm_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_multishift_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm256_multishift_epi64_epi8 fn">_mm256_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_or_epi32.html" title="no_std_compat::arch::x86_64::_mm256_or_epi32 fn">_mm256_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_or_epi64.html" title="no_std_compat::arch::x86_64::_mm256_or_epi64 fn">_mm256_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm256_permutex2var_epi8 fn">_mm256_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm256_permutex2var_epi16 fn">_mm256_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm256_permutex2var_epi32 fn">_mm256_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm256_permutex2var_epi64 fn">_mm256_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm256_permutex2var_pd fn">_mm256_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm256_permutex2var_ps fn">_mm256_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutex_epi64.html" title="no_std_compat::arch::x86_64::_mm256_permutex_epi64 fn">_mm256_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutex_pd.html" title="no_std_compat::arch::x86_64::_mm256_permutex_pd fn">_mm256_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutexvar_epi8.html" title="no_std_compat::arch::x86_64::_mm256_permutexvar_epi8 fn">_mm256_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutexvar_epi16.html" title="no_std_compat::arch::x86_64::_mm256_permutexvar_epi16 fn">_mm256_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutexvar_epi32.html" title="no_std_compat::arch::x86_64::_mm256_permutexvar_epi32 fn">_mm256_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutexvar_epi64.html" title="no_std_compat::arch::x86_64::_mm256_permutexvar_epi64 fn">_mm256_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutexvar_pd.html" title="no_std_compat::arch::x86_64::_mm256_permutexvar_pd fn">_mm256_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_permutexvar_ps.html" title="no_std_compat::arch::x86_64::_mm256_permutexvar_ps fn">_mm256_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_popcnt_epi8.html" title="no_std_compat::arch::x86_64::_mm256_popcnt_epi8 fn">_mm256_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 8-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_popcnt_epi16.html" title="no_std_compat::arch::x86_64::_mm256_popcnt_epi16 fn">_mm256_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 16-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_popcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm256_popcnt_epi32 fn">_mm256_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 32-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_popcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm256_popcnt_epi64 fn">_mm256_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 64-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_rcp14_pd.html" title="no_std_compat::arch::x86_64::_mm256_rcp14_pd fn">_mm256_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_rcp14_ps.html" title="no_std_compat::arch::x86_64::_mm256_rcp14_ps fn">_mm256_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_rol_epi32.html" title="no_std_compat::arch::x86_64::_mm256_rol_epi32 fn">_mm256_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_rol_epi64.html" title="no_std_compat::arch::x86_64::_mm256_rol_epi64 fn">_mm256_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_rolv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_rolv_epi32 fn">_mm256_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_rolv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_rolv_epi64 fn">_mm256_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_ror_epi32.html" title="no_std_compat::arch::x86_64::_mm256_ror_epi32 fn">_mm256_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_ror_epi64.html" title="no_std_compat::arch::x86_64::_mm256_ror_epi64 fn">_mm256_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_rorv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_rorv_epi32 fn">_mm256_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_rorv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_rorv_epi64 fn">_mm256_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_roundscale_pd.html" title="no_std_compat::arch::x86_64::_mm256_roundscale_pd fn">_mm256_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_roundscale_ps.html" title="no_std_compat::arch::x86_64::_mm256_roundscale_ps fn">_mm256_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_scalef_pd.html" title="no_std_compat::arch::x86_64::_mm256_scalef_pd fn">_mm256_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_scalef_ps.html" title="no_std_compat::arch::x86_64::_mm256_scalef_ps fn">_mm256_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shldi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_shldi_epi16 fn">_mm256_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shldi_epi32.html" title="no_std_compat::arch::x86_64::_mm256_shldi_epi32 fn">_mm256_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shldi_epi64.html" title="no_std_compat::arch::x86_64::_mm256_shldi_epi64 fn">_mm256_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shldv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_shldv_epi16 fn">_mm256_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shldv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_shldv_epi32 fn">_mm256_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shldv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_shldv_epi64 fn">_mm256_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shrdi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_shrdi_epi16 fn">_mm256_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shrdi_epi32.html" title="no_std_compat::arch::x86_64::_mm256_shrdi_epi32 fn">_mm256_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shrdi_epi64.html" title="no_std_compat::arch::x86_64::_mm256_shrdi_epi64 fn">_mm256_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shrdv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_shrdv_epi16 fn">_mm256_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shrdv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_shrdv_epi32 fn">_mm256_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shrdv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_shrdv_epi64 fn">_mm256_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shuffle_f32x4.html" title="no_std_compat::arch::x86_64::_mm256_shuffle_f32x4 fn">_mm256_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shuffle_f64x2.html" title="no_std_compat::arch::x86_64::_mm256_shuffle_f64x2 fn">_mm256_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shuffle_i32x4.html" title="no_std_compat::arch::x86_64::_mm256_shuffle_i32x4 fn">_mm256_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_shuffle_i64x2.html" title="no_std_compat::arch::x86_64::_mm256_shuffle_i64x2 fn">_mm256_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_sllv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_sllv_epi16 fn">_mm256_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_sra_epi64.html" title="no_std_compat::arch::x86_64::_mm256_sra_epi64 fn">_mm256_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_srai_epi64.html" title="no_std_compat::arch::x86_64::_mm256_srai_epi64 fn">_mm256_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_srav_epi16.html" title="no_std_compat::arch::x86_64::_mm256_srav_epi16 fn">_mm256_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_srav_epi64.html" title="no_std_compat::arch::x86_64::_mm256_srav_epi64 fn">_mm256_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_srlv_epi16.html" title="no_std_compat::arch::x86_64::_mm256_srlv_epi16 fn">_mm256_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_store_epi32.html" title="no_std_compat::arch::x86_64::_mm256_store_epi32 fn">_mm256_store_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 256-bits (composed of 8 packed 32-bit integers) from a into memory. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_store_epi64.html" title="no_std_compat::arch::x86_64::_mm256_store_epi64 fn">_mm256_store_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 256-bits (composed of 4 packed 64-bit integers) from a into memory. mem_addr must be aligned on a 32-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm256_storeu_epi8 fn">_mm256_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 256-bits (composed of 32 packed 8-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm256_storeu_epi16 fn">_mm256_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 256-bits (composed of 16 packed 16-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm256_storeu_epi32 fn">_mm256_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 256-bits (composed of 8 packed 32-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_storeu_epi64.html" title="no_std_compat::arch::x86_64::_mm256_storeu_epi64 fn">_mm256_storeu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 256-bits (composed of 4 packed 64-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_ternarylogic_epi32.html" title="no_std_compat::arch::x86_64::_mm256_ternarylogic_epi32 fn">_mm256_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_ternarylogic_epi64.html" title="no_std_compat::arch::x86_64::_mm256_ternarylogic_epi64 fn">_mm256_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_test_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_test_epi8_mask fn">_mm256_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_test_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_test_epi16_mask fn">_mm256_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_test_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_test_epi32_mask fn">_mm256_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_test_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_test_epi64_mask fn">_mm256_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_testn_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm256_testn_epi8_mask fn">_mm256_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_testn_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm256_testn_epi16_mask fn">_mm256_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_testn_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm256_testn_epi32_mask fn">_mm256_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_testn_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm256_testn_epi64_mask fn">_mm256_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_xor_epi32.html" title="no_std_compat::arch::x86_64::_mm256_xor_epi32 fn">_mm256_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm256_xor_epi64.html" title="no_std_compat::arch::x86_64::_mm256_xor_epi64 fn">_mm256_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_abs_epi8.html" title="no_std_compat::arch::x86_64::_mm512_abs_epi8 fn">_mm512_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_abs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_abs_epi16 fn">_mm512_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_abs_epi32.html" title="no_std_compat::arch::x86_64::_mm512_abs_epi32 fn">_mm512_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Computes the absolute values of packed 32-bit integers in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_abs_epi64.html" title="no_std_compat::arch::x86_64::_mm512_abs_epi64 fn">_mm512_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_abs_pd.html" title="no_std_compat::arch::x86_64::_mm512_abs_pd fn">_mm512_abs_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Finds the absolute value of each packed double-precision (64-bit) floating-point element in v2, storing the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_abs_ps.html" title="no_std_compat::arch::x86_64::_mm512_abs_ps fn">_mm512_abs_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Finds the absolute value of each packed single-precision (32-bit) floating-point element in v2, storing the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_add_epi8.html" title="no_std_compat::arch::x86_64::_mm512_add_epi8 fn">_mm512_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed 8-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_add_epi16.html" title="no_std_compat::arch::x86_64::_mm512_add_epi16 fn">_mm512_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed 16-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_add_epi32.html" title="no_std_compat::arch::x86_64::_mm512_add_epi32 fn">_mm512_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed 32-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_add_epi64.html" title="no_std_compat::arch::x86_64::_mm512_add_epi64 fn">_mm512_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed 64-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_add_pd.html" title="no_std_compat::arch::x86_64::_mm512_add_pd fn">_mm512_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_add_ps.html" title="no_std_compat::arch::x86_64::_mm512_add_ps fn">_mm512_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_add_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_add_round_pd fn">_mm512_add_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_add_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_add_round_ps fn">_mm512_add_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_adds_epi8.html" title="no_std_compat::arch::x86_64::_mm512_adds_epi8 fn">_mm512_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed signed 8-bit integers in a and b using saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_adds_epi16.html" title="no_std_compat::arch::x86_64::_mm512_adds_epi16 fn">_mm512_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed signed 16-bit integers in a and b using saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_adds_epu8.html" title="no_std_compat::arch::x86_64::_mm512_adds_epu8 fn">_mm512_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_adds_epu16.html" title="no_std_compat::arch::x86_64::_mm512_adds_epu16 fn">_mm512_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_aesdec_epi128.html" title="no_std_compat::arch::x86_64::_mm512_aesdec_epi128 fn">_mm512_aesdec_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512f` only"><code>avx512vaes,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs one round of an AES decryption flow on each 128-bit word (state) in <code>a</code> using
the corresponding 128-bit word (key) in <code>round_key</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_aesdeclast_epi128.html" title="no_std_compat::arch::x86_64::_mm512_aesdeclast_epi128 fn">_mm512_aesdeclast_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512f` only"><code>avx512vaes,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs the last round of an AES decryption flow on each 128-bit word (state) in <code>a</code> using
the corresponding 128-bit word (key) in <code>round_key</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_aesenc_epi128.html" title="no_std_compat::arch::x86_64::_mm512_aesenc_epi128 fn">_mm512_aesenc_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512f` only"><code>avx512vaes,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs one round of an AES encryption flow on each 128-bit word (state) in <code>a</code> using
the corresponding 128-bit word (key) in <code>round_key</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_aesenclast_epi128.html" title="no_std_compat::arch::x86_64::_mm512_aesenclast_epi128 fn">_mm512_aesenclast_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512f` only"><code>avx512vaes,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs the last round of an AES encryption flow on each 128-bit word (state) in <code>a</code> using
the corresponding 128-bit word (key) in <code>round_key</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_alignr_epi8.html" title="no_std_compat::arch::x86_64::_mm512_alignr_epi8 fn">_mm512_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_alignr_epi32.html" title="no_std_compat::arch::x86_64::_mm512_alignr_epi32 fn">_mm512_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 64 bytes (16 elements) in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_alignr_epi64.html" title="no_std_compat::arch::x86_64::_mm512_alignr_epi64 fn">_mm512_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 64 bytes (8 elements) in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_and_epi32.html" title="no_std_compat::arch::x86_64::_mm512_and_epi32 fn">_mm512_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_and_epi64.html" title="no_std_compat::arch::x86_64::_mm512_and_epi64 fn">_mm512_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of 512 bits (composed of packed 64-bit integers) in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_and_si512.html" title="no_std_compat::arch::x86_64::_mm512_and_si512 fn">_mm512_and_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of 512 bits (representing integer data) in a and b, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_andnot_epi32.html" title="no_std_compat::arch::x86_64::_mm512_andnot_epi32 fn">_mm512_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_andnot_epi64.html" title="no_std_compat::arch::x86_64::_mm512_andnot_epi64 fn">_mm512_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 512 bits (composed of packed 64-bit integers) in a and then AND with b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_andnot_si512.html" title="no_std_compat::arch::x86_64::_mm512_andnot_si512 fn">_mm512_andnot_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 512 bits (representing integer data) in a and then AND with b, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_avg_epu8.html" title="no_std_compat::arch::x86_64::_mm512_avg_epu8 fn">_mm512_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 8-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_avg_epu16.html" title="no_std_compat::arch::x86_64::_mm512_avg_epu16 fn">_mm512_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 16-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_bitshuffle_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_bitshuffle_epi64_mask fn">_mm512_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span></div><div class="item-right docblock-short"><p>Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.
Then groups 8 8-bit values from <code>c</code>as indices into the the bits of the corresponding 64-bit integer.
It then selects these bits and packs them into the output.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcast_f32x4.html" title="no_std_compat::arch::x86_64::_mm512_broadcast_f32x4 fn">_mm512_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcast_f64x4.html" title="no_std_compat::arch::x86_64::_mm512_broadcast_f64x4 fn">_mm512_broadcast_f64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcast_i32x4.html" title="no_std_compat::arch::x86_64::_mm512_broadcast_i32x4 fn">_mm512_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed 32-bit integers from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcast_i64x4.html" title="no_std_compat::arch::x86_64::_mm512_broadcast_i64x4 fn">_mm512_broadcast_i64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed 64-bit integers from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcastb_epi8.html" title="no_std_compat::arch::x86_64::_mm512_broadcastb_epi8 fn">_mm512_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 8-bit integer from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcastd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_broadcastd_epi32 fn">_mm512_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 32-bit integer from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcastmb_epi64.html" title="no_std_compat::arch::x86_64::_mm512_broadcastmb_epi64 fn">_mm512_broadcastmb_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Broadcast the low 8-bits from input mask k to all 64-bit elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcastmw_epi32.html" title="no_std_compat::arch::x86_64::_mm512_broadcastmw_epi32 fn">_mm512_broadcastmw_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Broadcast the low 16-bits from input mask k to all 32-bit elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcastq_epi64.html" title="no_std_compat::arch::x86_64::_mm512_broadcastq_epi64 fn">_mm512_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 64-bit integer from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcastsd_pd.html" title="no_std_compat::arch::x86_64::_mm512_broadcastsd_pd fn">_mm512_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcastss_ps.html" title="no_std_compat::arch::x86_64::_mm512_broadcastss_ps fn">_mm512_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_broadcastw_epi16.html" title="no_std_compat::arch::x86_64::_mm512_broadcastw_epi16 fn">_mm512_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_bslli_epi128.html" title="no_std_compat::arch::x86_64::_mm512_bslli_epi128 fn">_mm512_bslli_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift 128-bit lanes in a left by imm8 bytes while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_bsrli_epi128.html" title="no_std_compat::arch::x86_64::_mm512_bsrli_epi128 fn">_mm512_bsrli_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift 128-bit lanes in a right by imm8 bytes while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castpd128_pd512.html" title="no_std_compat::arch::x86_64::_mm512_castpd128_pd512 fn">_mm512_castpd128_pd512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m128d to type __m512d; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castpd256_pd512.html" title="no_std_compat::arch::x86_64::_mm512_castpd256_pd512 fn">_mm512_castpd256_pd512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m256d to type __m512d; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castpd512_pd128.html" title="no_std_compat::arch::x86_64::_mm512_castpd512_pd128 fn">_mm512_castpd512_pd128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512d to type __m128d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castpd512_pd256.html" title="no_std_compat::arch::x86_64::_mm512_castpd512_pd256 fn">_mm512_castpd512_pd256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512d to type __m256d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castpd_ps.html" title="no_std_compat::arch::x86_64::_mm512_castpd_ps fn">_mm512_castpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512d to type __m512. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castpd_si512.html" title="no_std_compat::arch::x86_64::_mm512_castpd_si512 fn">_mm512_castpd_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512d to type __m512i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castps128_ps512.html" title="no_std_compat::arch::x86_64::_mm512_castps128_ps512 fn">_mm512_castps128_ps512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m128 to type __m512; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castps256_ps512.html" title="no_std_compat::arch::x86_64::_mm512_castps256_ps512 fn">_mm512_castps256_ps512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m256 to type __m512; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castps512_ps128.html" title="no_std_compat::arch::x86_64::_mm512_castps512_ps128 fn">_mm512_castps512_ps128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512 to type __m128. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castps512_ps256.html" title="no_std_compat::arch::x86_64::_mm512_castps512_ps256 fn">_mm512_castps512_ps256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512 to type __m256. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castps_pd.html" title="no_std_compat::arch::x86_64::_mm512_castps_pd fn">_mm512_castps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512 to type __m512d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castps_si512.html" title="no_std_compat::arch::x86_64::_mm512_castps_si512 fn">_mm512_castps_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512 to type __m512i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castsi128_si512.html" title="no_std_compat::arch::x86_64::_mm512_castsi128_si512 fn">_mm512_castsi128_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m128i to type __m512i; the upper 384 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castsi256_si512.html" title="no_std_compat::arch::x86_64::_mm512_castsi256_si512 fn">_mm512_castsi256_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m256i to type __m512i; the upper 256 bits of the result are undefined. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castsi512_pd.html" title="no_std_compat::arch::x86_64::_mm512_castsi512_pd fn">_mm512_castsi512_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512i to type __m512d. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castsi512_ps.html" title="no_std_compat::arch::x86_64::_mm512_castsi512_ps fn">_mm512_castsi512_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512i to type __m512. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castsi512_si128.html" title="no_std_compat::arch::x86_64::_mm512_castsi512_si128 fn">_mm512_castsi512_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512i to type __m128i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_castsi512_si256.html" title="no_std_compat::arch::x86_64::_mm512_castsi512_si256 fn">_mm512_castsi512_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m512i to type __m256i. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_clmulepi64_epi128.html" title="no_std_compat::arch::x86_64::_mm512_clmulepi64_epi128 fn">_mm512_clmulepi64_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpclmulqdq,avx512f` only"><code>avx512vpclmulqdq,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs a carry-less multiplication of two 64-bit polynomials over the
finite field GF(2^k) - in each of the 4 128-bit lanes.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_epi8_mask fn">_mm512_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_epi16_mask fn">_mm512_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_epi32_mask fn">_mm512_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_epi64_mask fn">_mm512_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_epu8_mask fn">_mm512_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_epu16_mask fn">_mm512_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by <code>IMM8</code>, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_epu32_mask fn">_mm512_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_epu64_mask fn">_mm512_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_pd_mask fn">_mm512_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_ps_mask fn">_mm512_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_round_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_round_pd_mask fn">_mm512_cmp_round_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmp_round_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmp_round_ps_mask fn">_mm512_cmp_round_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_epi8_mask fn">_mm512_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_epi16_mask fn">_mm512_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_epi32_mask fn">_mm512_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_epi64_mask fn">_mm512_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_epu8_mask fn">_mm512_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_epu16_mask fn">_mm512_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_epu32_mask fn">_mm512_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_epu64_mask fn">_mm512_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_pd_mask fn">_mm512_cmpeq_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpeq_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpeq_ps_mask fn">_mm512_cmpeq_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpge_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpge_epi8_mask fn">_mm512_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpge_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpge_epi16_mask fn">_mm512_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpge_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpge_epi32_mask fn">_mm512_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpge_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpge_epi64_mask fn">_mm512_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpge_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpge_epu8_mask fn">_mm512_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpge_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpge_epu16_mask fn">_mm512_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpge_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpge_epu32_mask fn">_mm512_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpge_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpge_epu64_mask fn">_mm512_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpgt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpgt_epi8_mask fn">_mm512_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpgt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpgt_epi16_mask fn">_mm512_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpgt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpgt_epi32_mask fn">_mm512_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpgt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpgt_epi64_mask fn">_mm512_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpgt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpgt_epu8_mask fn">_mm512_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpgt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpgt_epu16_mask fn">_mm512_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpgt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpgt_epu32_mask fn">_mm512_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpgt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpgt_epu64_mask fn">_mm512_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_epi8_mask fn">_mm512_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_epi16_mask fn">_mm512_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_epi32_mask fn">_mm512_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_epi64_mask fn">_mm512_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_epu8_mask fn">_mm512_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_epu16_mask fn">_mm512_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_epu32_mask fn">_mm512_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_epu64_mask fn">_mm512_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_pd_mask fn">_mm512_cmple_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmple_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmple_ps_mask fn">_mm512_cmple_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_epi8_mask fn">_mm512_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_epi16_mask fn">_mm512_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_epi32_mask fn">_mm512_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_epi64_mask fn">_mm512_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_epu8_mask fn">_mm512_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_epu16_mask fn">_mm512_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_epu32_mask fn">_mm512_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_epu64_mask fn">_mm512_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_pd_mask fn">_mm512_cmplt_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmplt_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmplt_ps_mask fn">_mm512_cmplt_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_epi8_mask fn">_mm512_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_epi16_mask fn">_mm512_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_epi32_mask fn">_mm512_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_epi64_mask fn">_mm512_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_epu8_mask fn">_mm512_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_epu16_mask fn">_mm512_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_epu32_mask fn">_mm512_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_epu64_mask fn">_mm512_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_pd_mask fn">_mm512_cmpneq_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpneq_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpneq_ps_mask fn">_mm512_cmpneq_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpnle_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpnle_pd_mask fn">_mm512_cmpnle_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpnle_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpnle_ps_mask fn">_mm512_cmpnle_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpnlt_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpnlt_pd_mask fn">_mm512_cmpnlt_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpnlt_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpnlt_ps_mask fn">_mm512_cmpnlt_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpord_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpord_pd_mask fn">_mm512_cmpord_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpord_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpord_ps_mask fn">_mm512_cmpord_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpunord_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpunord_pd_mask fn">_mm512_cmpunord_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cmpunord_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_cmpunord_ps_mask fn">_mm512_cmpunord_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_conflict_epi32.html" title="no_std_compat::arch::x86_64::_mm512_conflict_epi32 fn">_mm512_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_conflict_epi64.html" title="no_std_compat::arch::x86_64::_mm512_conflict_epi64 fn">_mm512_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundepi32_ps.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundepi32_ps fn">_mm512_cvt_roundepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundepu32_ps.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundepu32_ps fn">_mm512_cvt_roundepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundpd_epi32 fn">_mm512_cvt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundpd_epu32 fn">_mm512_cvt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundpd_ps.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundpd_ps fn">_mm512_cvt_roundpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundph_ps.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundph_ps fn">_mm512_cvt_roundph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundps_epi32 fn">_mm512_cvt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundps_epu32 fn">_mm512_cvt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundps_pd.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundps_pd fn">_mm512_cvt_roundps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvt_roundps_ph.html" title="no_std_compat::arch::x86_64::_mm512_cvt_roundps_ph fn">_mm512_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi8_epi16.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi8_epi16 fn">_mm512_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi8_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi8_epi32 fn">_mm512_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi8_epi64.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi8_epi64 fn">_mm512_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi16_epi8 fn">_mm512_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi16_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi16_epi32 fn">_mm512_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi16_epi64.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi16_epi64 fn">_mm512_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi32_epi8 fn">_mm512_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi32_epi16 fn">_mm512_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi32_epi64.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi32_epi64 fn">_mm512_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi32_pd.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi32_pd fn">_mm512_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi32_ps.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi32_ps fn">_mm512_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi32lo_pd.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi32lo_pd fn">_mm512_cvtepi32lo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs element-by-element conversion of the lower half of packed 32-bit integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi64_epi8 fn">_mm512_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi64_epi16 fn">_mm512_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtepi64_epi32 fn">_mm512_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepu8_epi16.html" title="no_std_compat::arch::x86_64::_mm512_cvtepu8_epi16 fn">_mm512_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepu8_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtepu8_epi32 fn">_mm512_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepu8_epi64.html" title="no_std_compat::arch::x86_64::_mm512_cvtepu8_epi64 fn">_mm512_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 8 byte sof a to packed 64-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepu16_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtepu16_epi32 fn">_mm512_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepu16_epi64.html" title="no_std_compat::arch::x86_64::_mm512_cvtepu16_epi64 fn">_mm512_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepu32_epi64.html" title="no_std_compat::arch::x86_64::_mm512_cvtepu32_epi64 fn">_mm512_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepu32_pd.html" title="no_std_compat::arch::x86_64::_mm512_cvtepu32_pd fn">_mm512_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepu32_ps.html" title="no_std_compat::arch::x86_64::_mm512_cvtepu32_ps fn">_mm512_cvtepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtepu32lo_pd.html" title="no_std_compat::arch::x86_64::_mm512_cvtepu32lo_pd fn">_mm512_cvtepu32lo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs element-by-element conversion of the lower half of packed 32-bit unsigned integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtne2ps_pbh.html" title="no_std_compat::arch::x86_64::_mm512_cvtne2ps_pbh fn">_mm512_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in two 512-bit vectors
a and b to packed BF16 (16-bit) floating-point elements, and store the results in a<br />
512-bit wide vector.
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657&amp;avx512techs=AVX512_BF16&amp;text=_mm512_cvtne2ps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtneps_pbh.html" title="no_std_compat::arch::x86_64::_mm512_cvtneps_pbh fn">_mm512_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)
floating-point elements, and store the results in dst.
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_cvtneps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtpd_epi32 fn">_mm512_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_cvtpd_epu32 fn">_mm512_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtpd_ps.html" title="no_std_compat::arch::x86_64::_mm512_cvtpd_ps fn">_mm512_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtpd_pslo.html" title="no_std_compat::arch::x86_64::_mm512_cvtpd_pslo fn">_mm512_cvtpd_pslo</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs an element-by-element conversion of packed double-precision (64-bit) floating-point elements in v2 to single-precision (32-bit) floating-point elements and stores them in dst. The elements are stored in the lower half of the results vector, while the remaining upper half locations are set to 0.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtph_ps.html" title="no_std_compat::arch::x86_64::_mm512_cvtph_ps fn">_mm512_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtps_epi32 fn">_mm512_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_cvtps_epu32 fn">_mm512_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtps_pd.html" title="no_std_compat::arch::x86_64::_mm512_cvtps_pd fn">_mm512_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtps_ph.html" title="no_std_compat::arch::x86_64::_mm512_cvtps_ph fn">_mm512_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtpslo_pd.html" title="no_std_compat::arch::x86_64::_mm512_cvtpslo_pd fn">_mm512_cvtpslo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs element-by-element conversion of the lower half of packed single-precision (32-bit) floating-point elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtsepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm512_cvtsepi16_epi8 fn">_mm512_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtsepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm512_cvtsepi32_epi8 fn">_mm512_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtsepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm512_cvtsepi32_epi16 fn">_mm512_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtsepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_cvtsepi64_epi8 fn">_mm512_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtsepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm512_cvtsepi64_epi16 fn">_mm512_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtsepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtsepi64_epi32 fn">_mm512_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtsi512_si32.html" title="no_std_compat::arch::x86_64::_mm512_cvtsi512_si32 fn">_mm512_cvtsi512_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy the lower 32-bit integer in a to dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtt_roundpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtt_roundpd_epi32 fn">_mm512_cvtt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtt_roundpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_cvtt_roundpd_epu32 fn">_mm512_cvtt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtt_roundps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtt_roundps_epi32 fn">_mm512_cvtt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtt_roundps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_cvtt_roundps_epu32 fn">_mm512_cvtt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvttpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvttpd_epi32 fn">_mm512_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvttpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_cvttpd_epu32 fn">_mm512_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvttps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvttps_epi32 fn">_mm512_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvttps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_cvttps_epu32 fn">_mm512_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtusepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm512_cvtusepi16_epi8 fn">_mm512_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtusepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm512_cvtusepi32_epi8 fn">_mm512_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtusepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm512_cvtusepi32_epi16 fn">_mm512_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtusepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_cvtusepi64_epi8 fn">_mm512_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtusepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm512_cvtusepi64_epi16 fn">_mm512_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_cvtusepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm512_cvtusepi64_epi32 fn">_mm512_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_dbsad_epu8.html" title="no_std_compat::arch::x86_64::_mm512_dbsad_epu8 fn">_mm512_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst. Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_div_pd.html" title="no_std_compat::arch::x86_64::_mm512_div_pd fn">_mm512_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_div_ps.html" title="no_std_compat::arch::x86_64::_mm512_div_ps fn">_mm512_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_div_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_div_round_pd fn">_mm512_div_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, =and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_div_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_div_round_ps fn">_mm512_div_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_dpbf16_ps.html" title="no_std_compat::arch::x86_64::_mm512_dpbf16_ps fn">_mm512_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span></div><div class="item-right docblock-short"><p>Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,
accumulating the intermediate single-precision (32-bit) floating-point elements
with elements in src, and store the results in dst.Compute dot-product of BF16 (16-bit)
floating-point pairs in a and b, accumulating the intermediate single-precision (32-bit)
floating-point elements with elements in src, and store the results in dst.
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_dpbf16_ps">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_dpbusd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_dpbusd_epi32 fn">_mm512_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_dpbusds_epi32.html" title="no_std_compat::arch::x86_64::_mm512_dpbusds_epi32 fn">_mm512_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_dpwssd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_dpwssd_epi32 fn">_mm512_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_dpwssds_epi32.html" title="no_std_compat::arch::x86_64::_mm512_dpwssds_epi32 fn">_mm512_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_extractf32x4_ps.html" title="no_std_compat::arch::x86_64::_mm512_extractf32x4_ps fn">_mm512_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_extractf64x4_pd.html" title="no_std_compat::arch::x86_64::_mm512_extractf64x4_pd fn">_mm512_extractf64x4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_extracti32x4_epi32.html" title="no_std_compat::arch::x86_64::_mm512_extracti32x4_epi32 fn">_mm512_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_extracti64x4_epi64.html" title="no_std_compat::arch::x86_64::_mm512_extracti64x4_epi64 fn">_mm512_extracti64x4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fixupimm_pd.html" title="no_std_compat::arch::x86_64::_mm512_fixupimm_pd fn">_mm512_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fixupimm_ps.html" title="no_std_compat::arch::x86_64::_mm512_fixupimm_ps fn">_mm512_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fixupimm_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_fixupimm_round_pd fn">_mm512_fixupimm_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fixupimm_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_fixupimm_round_ps fn">_mm512_fixupimm_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_fmadd_pd fn">_mm512_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_fmadd_ps fn">_mm512_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_fmadd_round_pd fn">_mm512_fmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_fmadd_round_ps fn">_mm512_fmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_fmaddsub_pd fn">_mm512_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_fmaddsub_ps fn">_mm512_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmaddsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_fmaddsub_round_pd fn">_mm512_fmaddsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmaddsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_fmaddsub_round_ps fn">_mm512_fmaddsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_fmsub_pd fn">_mm512_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_fmsub_ps fn">_mm512_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_fmsub_round_pd fn">_mm512_fmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_fmsub_round_ps fn">_mm512_fmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_fmsubadd_pd fn">_mm512_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_fmsubadd_ps fn">_mm512_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmsubadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_fmsubadd_round_pd fn">_mm512_fmsubadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fmsubadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_fmsubadd_round_ps fn">_mm512_fmsubadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_fnmadd_pd fn">_mm512_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_fnmadd_ps fn">_mm512_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fnmadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_fnmadd_round_pd fn">_mm512_fnmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fnmadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_fnmadd_round_ps fn">_mm512_fnmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_fnmsub_pd fn">_mm512_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_fnmsub_ps fn">_mm512_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fnmsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_fnmsub_round_pd fn">_mm512_fnmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_fnmsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_fnmsub_round_ps fn">_mm512_fnmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_getexp_pd.html" title="no_std_compat::arch::x86_64::_mm512_getexp_pd fn">_mm512_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_getexp_ps.html" title="no_std_compat::arch::x86_64::_mm512_getexp_ps fn">_mm512_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_getexp_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_getexp_round_pd fn">_mm512_getexp_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_getexp_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_getexp_round_ps fn">_mm512_getexp_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_getmant_pd.html" title="no_std_compat::arch::x86_64::_mm512_getmant_pd fn">_mm512_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_getmant_ps.html" title="no_std_compat::arch::x86_64::_mm512_getmant_ps fn">_mm512_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.
The mantissa is normalized to the interval specified by interv, which can take the following values:
_MM_MANT_NORM_1_2     // interval [1, 2)
_MM_MANT_NORM_p5_2    // interval [0.5, 2)
_MM_MANT_NORM_p5_1    // interval [0.5, 1)
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)
The sign is determined by sc which can take the following values:
_MM_MANT_SIGN_src     // sign = sign(src)
_MM_MANT_SIGN_zero    // sign = 0
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_getmant_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_getmant_round_pd fn">_mm512_getmant_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_getmant_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_getmant_round_ps fn">_mm512_getmant_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_gf2p8affine_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_gf2p8affine_epi64_epi8 fn">_mm512_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the packed bytes in x.
That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_gf2p8affineinv_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_gf2p8affineinv_epi64_epi8 fn">_mm512_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the inverted packed bytes in x.
That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.
The inverse of 0 is 0.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_gf2p8mul_epi8.html" title="no_std_compat::arch::x86_64::_mm512_gf2p8mul_epi8 fn">_mm512_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs a multiplication in GF(2^8) on the packed bytes.
The field is in polynomial representation with the reduction polynomial
x^8 + x^4 + x^3 + x + 1.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i32gather_epi32.html" title="no_std_compat::arch::x86_64::_mm512_i32gather_epi32 fn">_mm512_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i32gather_epi64.html" title="no_std_compat::arch::x86_64::_mm512_i32gather_epi64 fn">_mm512_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i32gather_pd.html" title="no_std_compat::arch::x86_64::_mm512_i32gather_pd fn">_mm512_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i32gather_ps.html" title="no_std_compat::arch::x86_64::_mm512_i32gather_ps fn">_mm512_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i32scatter_epi32.html" title="no_std_compat::arch::x86_64::_mm512_i32scatter_epi32 fn">_mm512_i32scatter_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i32scatter_epi64.html" title="no_std_compat::arch::x86_64::_mm512_i32scatter_epi64 fn">_mm512_i32scatter_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i32scatter_pd.html" title="no_std_compat::arch::x86_64::_mm512_i32scatter_pd fn">_mm512_i32scatter_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter double-precision (64-bit) floating-point elements from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i32scatter_ps.html" title="no_std_compat::arch::x86_64::_mm512_i32scatter_ps fn">_mm512_i32scatter_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter single-precision (32-bit) floating-point elements from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i64gather_epi32.html" title="no_std_compat::arch::x86_64::_mm512_i64gather_epi32 fn">_mm512_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i64gather_epi64.html" title="no_std_compat::arch::x86_64::_mm512_i64gather_epi64 fn">_mm512_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i64gather_pd.html" title="no_std_compat::arch::x86_64::_mm512_i64gather_pd fn">_mm512_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i64gather_ps.html" title="no_std_compat::arch::x86_64::_mm512_i64gather_ps fn">_mm512_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i64scatter_epi32.html" title="no_std_compat::arch::x86_64::_mm512_i64scatter_epi32 fn">_mm512_i64scatter_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter 32-bit integers from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i64scatter_epi64.html" title="no_std_compat::arch::x86_64::_mm512_i64scatter_epi64 fn">_mm512_i64scatter_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter 64-bit integers from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i64scatter_pd.html" title="no_std_compat::arch::x86_64::_mm512_i64scatter_pd fn">_mm512_i64scatter_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter double-precision (64-bit) floating-point elements from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_i64scatter_ps.html" title="no_std_compat::arch::x86_64::_mm512_i64scatter_ps fn">_mm512_i64scatter_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter single-precision (32-bit) floating-point elements from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_insertf32x4.html" title="no_std_compat::arch::x86_64::_mm512_insertf32x4 fn">_mm512_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to dst, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into dst at the location specified by imm8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_insertf64x4.html" title="no_std_compat::arch::x86_64::_mm512_insertf64x4 fn">_mm512_insertf64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to dst, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into dst at the location specified by imm8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_inserti32x4.html" title="no_std_compat::arch::x86_64::_mm512_inserti32x4 fn">_mm512_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to dst, then insert 128 bits (composed of 4 packed 32-bit integers) from b into dst at the location specified by imm8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_inserti64x4.html" title="no_std_compat::arch::x86_64::_mm512_inserti64x4 fn">_mm512_inserti64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to dst, then insert 256 bits (composed of 4 packed 64-bit integers) from b into dst at the location specified by imm8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_int2mask.html" title="no_std_compat::arch::x86_64::_mm512_int2mask fn">_mm512_int2mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Converts integer mask into bitmask, storing the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_kand.html" title="no_std_compat::arch::x86_64::_mm512_kand fn">_mm512_kand</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of 16-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_kandn.html" title="no_std_compat::arch::x86_64::_mm512_kandn fn">_mm512_kandn</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 16-bit masks a and then AND with b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_kmov.html" title="no_std_compat::arch::x86_64::_mm512_kmov fn">_mm512_kmov</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy 16-bit mask a to k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_knot.html" title="no_std_compat::arch::x86_64::_mm512_knot fn">_mm512_knot</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of 16-bit mask a, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_kor.html" title="no_std_compat::arch::x86_64::_mm512_kor fn">_mm512_kor</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of 16-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_kortestc.html" title="no_std_compat::arch::x86_64::_mm512_kortestc fn">_mm512_kortestc</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs bitwise OR between k1 and k2, storing the result in dst. CF flag is set if dst consists of all 1’s.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_kunpackb.html" title="no_std_compat::arch::x86_64::_mm512_kunpackb fn">_mm512_kunpackb</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8 bits from masks a and b, and store the 16-bit result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_kxnor.html" title="no_std_compat::arch::x86_64::_mm512_kxnor fn">_mm512_kxnor</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XNOR of 16-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_kxor.html" title="no_std_compat::arch::x86_64::_mm512_kxor fn">_mm512_kxor</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of 16-bit masks a and b, and store the result in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_load_epi32.html" title="no_std_compat::arch::x86_64::_mm512_load_epi32 fn">_mm512_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_load_epi64.html" title="no_std_compat::arch::x86_64::_mm512_load_epi64 fn">_mm512_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load 512-bits (composed of 8 packed 64-bit integers) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_load_pd.html" title="no_std_compat::arch::x86_64::_mm512_load_pd fn">_mm512_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_load_ps.html" title="no_std_compat::arch::x86_64::_mm512_load_ps fn">_mm512_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_load_si512.html" title="no_std_compat::arch::x86_64::_mm512_load_si512 fn">_mm512_load_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load 512-bits of integer data from memory into dst. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_loadu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_loadu_epi8 fn">_mm512_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Load 512-bits (composed of 64 packed 8-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_loadu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_loadu_epi16 fn">_mm512_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Load 512-bits (composed of 32 packed 16-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_loadu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_loadu_epi32 fn">_mm512_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_loadu_epi64.html" title="no_std_compat::arch::x86_64::_mm512_loadu_epi64 fn">_mm512_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load 512-bits (composed of 8 packed 64-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_loadu_pd.html" title="no_std_compat::arch::x86_64::_mm512_loadu_pd fn">_mm512_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Loads 512-bits (composed of 8 packed double-precision (64-bit)
floating-point elements) from memory into result.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_loadu_ps.html" title="no_std_compat::arch::x86_64::_mm512_loadu_ps fn">_mm512_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Loads 512-bits (composed of 16 packed single-precision (32-bit)
floating-point elements) from memory into result.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_loadu_si512.html" title="no_std_compat::arch::x86_64::_mm512_loadu_si512 fn">_mm512_loadu_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load 512-bits of integer data from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_lzcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm512_lzcnt_epi32 fn">_mm512_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_lzcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm512_lzcnt_epi64 fn">_mm512_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_madd52hi_epu64.html" title="no_std_compat::arch::x86_64::_mm512_madd52hi_epu64 fn">_mm512_madd52hi_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma` only"><code>avx512ifma</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 52-bit integers in each 64-bit element of
<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the high 52-bit
unsigned integer from the intermediate result with the
corresponding unsigned 64-bit integer in <code>a</code>, and store the
results in <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_madd52lo_epu64.html" title="no_std_compat::arch::x86_64::_mm512_madd52lo_epu64 fn">_mm512_madd52lo_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma` only"><code>avx512ifma</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 52-bit integers in each 64-bit element of
<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the low 52-bit
unsigned integer from the intermediate result with the
corresponding unsigned 64-bit integer in <code>a</code>, and store the
results in <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_madd_epi16.html" title="no_std_compat::arch::x86_64::_mm512_madd_epi16 fn">_mm512_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maddubs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maddubs_epi16 fn">_mm512_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Vertically multiply each unsigned 8-bit integer from a with the corresponding signed 8-bit integer from b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask2_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask2_permutex2var_epi8 fn">_mm512_mask2_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask2_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask2_permutex2var_epi16 fn">_mm512_mask2_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask2_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask2_permutex2var_epi32 fn">_mm512_mask2_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask2_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask2_permutex2var_epi64 fn">_mm512_mask2_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask2_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask2_permutex2var_pd fn">_mm512_mask2_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask2_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask2_permutex2var_ps fn">_mm512_mask2_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask2int.html" title="no_std_compat::arch::x86_64::_mm512_mask2int fn">_mm512_mask2int</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Converts bit mask k1 into an integer value, storing the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmadd_pd fn">_mm512_mask3_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmadd_ps fn">_mm512_mask3_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmadd_round_pd fn">_mm512_mask3_fmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmadd_round_ps fn">_mm512_mask3_fmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmaddsub_pd fn">_mm512_mask3_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmaddsub_ps fn">_mm512_mask3_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmaddsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmaddsub_round_pd fn">_mm512_mask3_fmaddsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmaddsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmaddsub_round_ps fn">_mm512_mask3_fmaddsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmsub_pd fn">_mm512_mask3_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmsub_ps fn">_mm512_mask3_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmsub_round_pd fn">_mm512_mask3_fmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmsub_round_ps fn">_mm512_mask3_fmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmsubadd_pd fn">_mm512_mask3_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmsubadd_ps fn">_mm512_mask3_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmsubadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmsubadd_round_pd fn">_mm512_mask3_fmsubadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fmsubadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fmsubadd_round_ps fn">_mm512_mask3_fmsubadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fnmadd_pd fn">_mm512_mask3_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fnmadd_ps fn">_mm512_mask3_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fnmadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fnmadd_round_pd fn">_mm512_mask3_fnmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fnmadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fnmadd_round_ps fn">_mm512_mask3_fnmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fnmsub_pd fn">_mm512_mask3_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fnmsub_ps fn">_mm512_mask3_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fnmsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fnmsub_round_pd fn">_mm512_mask3_fnmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask3_fnmsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask3_fnmsub_round_ps fn">_mm512_mask3_fnmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_abs_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_abs_epi8 fn">_mm512_mask_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_abs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_abs_epi16 fn">_mm512_mask_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_abs_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_abs_epi32 fn">_mm512_mask_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Computes the absolute value of packed 32-bit integers in <code>a</code>, and store the
unsigned results in <code>dst</code> using writemask <code>k</code> (elements are copied from
<code>src</code> when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_abs_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_abs_epi64 fn">_mm512_mask_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_abs_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_abs_pd fn">_mm512_mask_abs_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Finds the absolute value of each packed double-precision (64-bit) floating-point element in v2, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_abs_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_abs_ps fn">_mm512_mask_abs_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Finds the absolute value of each packed single-precision (32-bit) floating-point element in v2, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_add_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_add_epi8 fn">_mm512_mask_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_add_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_add_epi16 fn">_mm512_mask_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_add_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_add_epi32 fn">_mm512_mask_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_add_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_add_epi64 fn">_mm512_mask_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_add_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_add_pd fn">_mm512_mask_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_add_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_add_ps fn">_mm512_mask_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_add_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_add_round_pd fn">_mm512_mask_add_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_add_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_add_round_ps fn">_mm512_mask_add_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_adds_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_adds_epi8 fn">_mm512_mask_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_adds_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_adds_epi16 fn">_mm512_mask_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_adds_epu8.html" title="no_std_compat::arch::x86_64::_mm512_mask_adds_epu8 fn">_mm512_mask_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_adds_epu16.html" title="no_std_compat::arch::x86_64::_mm512_mask_adds_epu16 fn">_mm512_mask_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_alignr_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_alignr_epi8 fn">_mm512_mask_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_alignr_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_alignr_epi32 fn">_mm512_mask_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 64 bytes (16 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_alignr_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_alignr_epi64 fn">_mm512_mask_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 64 bytes (8 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_and_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_and_epi32 fn">_mm512_mask_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_and_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_and_epi64 fn">_mm512_mask_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_andnot_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_andnot_epi32 fn">_mm512_mask_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_andnot_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_andnot_epi64 fn">_mm512_mask_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_avg_epu8.html" title="no_std_compat::arch::x86_64::_mm512_mask_avg_epu8 fn">_mm512_mask_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_avg_epu16.html" title="no_std_compat::arch::x86_64::_mm512_mask_avg_epu16 fn">_mm512_mask_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_bitshuffle_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_bitshuffle_epi64_mask fn">_mm512_mask_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span></div><div class="item-right docblock-short"><p>Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.
Then groups 8 8-bit values from <code>c</code>as indices into the the bits of the corresponding 64-bit integer.
It then selects these bits and packs them into the output.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_blend_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_blend_epi8 fn">_mm512_mask_blend_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Blend packed 8-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_blend_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_blend_epi16 fn">_mm512_mask_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Blend packed 16-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_blend_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_blend_epi32 fn">_mm512_mask_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_blend_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_blend_epi64 fn">_mm512_mask_blend_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_blend_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_blend_pd fn">_mm512_mask_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_blend_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_blend_ps fn">_mm512_mask_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcast_f32x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcast_f32x4 fn">_mm512_mask_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcast_f64x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcast_f64x4 fn">_mm512_mask_broadcast_f64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcast_i32x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcast_i32x4 fn">_mm512_mask_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed 32-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcast_i64x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcast_i64x4 fn">_mm512_mask_broadcast_i64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed 64-bit integers from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcastb_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcastb_epi8 fn">_mm512_mask_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 8-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcastd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcastd_epi32 fn">_mm512_mask_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcastq_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcastq_epi64 fn">_mm512_mask_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcastsd_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcastsd_pd fn">_mm512_mask_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcastss_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcastss_ps fn">_mm512_mask_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_broadcastw_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_broadcastw_epi16 fn">_mm512_mask_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_epi8_mask fn">_mm512_mask_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_epi16_mask fn">_mm512_mask_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_epi32_mask fn">_mm512_mask_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_epi64_mask fn">_mm512_mask_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_epu8_mask fn">_mm512_mask_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_epu16_mask fn">_mm512_mask_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_epu32_mask fn">_mm512_mask_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_epu64_mask fn">_mm512_mask_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_pd_mask fn">_mm512_mask_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_ps_mask fn">_mm512_mask_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_round_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_round_pd_mask fn">_mm512_mask_cmp_round_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmp_round_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmp_round_ps_mask fn">_mm512_mask_cmp_round_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_epi8_mask fn">_mm512_mask_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_epi16_mask fn">_mm512_mask_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_epi32_mask fn">_mm512_mask_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_epi64_mask fn">_mm512_mask_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_epu8_mask fn">_mm512_mask_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_epu16_mask fn">_mm512_mask_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_epu32_mask fn">_mm512_mask_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_epu64_mask fn">_mm512_mask_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_pd_mask fn">_mm512_mask_cmpeq_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpeq_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpeq_ps_mask fn">_mm512_mask_cmpeq_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpge_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpge_epi8_mask fn">_mm512_mask_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpge_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpge_epi16_mask fn">_mm512_mask_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpge_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpge_epi32_mask fn">_mm512_mask_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpge_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpge_epi64_mask fn">_mm512_mask_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpge_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpge_epu8_mask fn">_mm512_mask_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpge_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpge_epu16_mask fn">_mm512_mask_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpge_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpge_epu32_mask fn">_mm512_mask_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpge_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpge_epu64_mask fn">_mm512_mask_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpgt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpgt_epi8_mask fn">_mm512_mask_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpgt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpgt_epi16_mask fn">_mm512_mask_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpgt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpgt_epi32_mask fn">_mm512_mask_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpgt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpgt_epi64_mask fn">_mm512_mask_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpgt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpgt_epu8_mask fn">_mm512_mask_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpgt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpgt_epu16_mask fn">_mm512_mask_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpgt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpgt_epu32_mask fn">_mm512_mask_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpgt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpgt_epu64_mask fn">_mm512_mask_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_epi8_mask fn">_mm512_mask_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_epi16_mask fn">_mm512_mask_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_epi32_mask fn">_mm512_mask_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_epi64_mask fn">_mm512_mask_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_epu8_mask fn">_mm512_mask_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_epu16_mask fn">_mm512_mask_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_epu32_mask fn">_mm512_mask_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_epu64_mask fn">_mm512_mask_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_pd_mask fn">_mm512_mask_cmple_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmple_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmple_ps_mask fn">_mm512_mask_cmple_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_epi8_mask fn">_mm512_mask_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_epi16_mask fn">_mm512_mask_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_epi32_mask fn">_mm512_mask_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_epi64_mask fn">_mm512_mask_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_epu8_mask fn">_mm512_mask_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_epu16_mask fn">_mm512_mask_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_epu32_mask fn">_mm512_mask_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_epu64_mask fn">_mm512_mask_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_pd_mask fn">_mm512_mask_cmplt_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmplt_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmplt_ps_mask fn">_mm512_mask_cmplt_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_epi8_mask fn">_mm512_mask_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_epi16_mask fn">_mm512_mask_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_epi32_mask fn">_mm512_mask_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_epi64_mask fn">_mm512_mask_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_epu8_mask fn">_mm512_mask_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_epu16_mask fn">_mm512_mask_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_epu32_mask fn">_mm512_mask_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_epu64_mask fn">_mm512_mask_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_pd_mask fn">_mm512_mask_cmpneq_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpneq_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpneq_ps_mask fn">_mm512_mask_cmpneq_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpnle_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpnle_pd_mask fn">_mm512_mask_cmpnle_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpnle_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpnle_ps_mask fn">_mm512_mask_cmpnle_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpnlt_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpnlt_pd_mask fn">_mm512_mask_cmpnlt_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpnlt_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpnlt_ps_mask fn">_mm512_mask_cmpnlt_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b for not-less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpord_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpord_pd_mask fn">_mm512_mask_cmpord_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpord_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpord_ps_mask fn">_mm512_mask_cmpord_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b to see if neither is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpunord_pd_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpunord_pd_mask fn">_mm512_mask_cmpunord_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cmpunord_ps_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_cmpunord_ps_mask fn">_mm512_mask_cmpunord_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b to see if either is NaN, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compress_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_compress_epi8 fn">_mm512_mask_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compress_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_compress_epi16 fn">_mm512_mask_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compress_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_compress_epi32 fn">_mm512_mask_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compress_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_compress_epi64 fn">_mm512_mask_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compress_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_compress_pd fn">_mm512_mask_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compress_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_compress_ps fn">_mm512_mask_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compressstoreu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_compressstoreu_epi8 fn">_mm512_mask_compressstoreu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compressstoreu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_compressstoreu_epi16 fn">_mm512_mask_compressstoreu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compressstoreu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_compressstoreu_epi32 fn">_mm512_mask_compressstoreu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compressstoreu_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_compressstoreu_epi64 fn">_mm512_mask_compressstoreu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compressstoreu_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_compressstoreu_pd fn">_mm512_mask_compressstoreu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_compressstoreu_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_compressstoreu_ps fn">_mm512_mask_compressstoreu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_conflict_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_conflict_epi32 fn">_mm512_mask_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_conflict_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_conflict_epi64 fn">_mm512_mask_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundepi32_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundepi32_ps fn">_mm512_mask_cvt_roundepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundepu32_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundepu32_ps fn">_mm512_mask_cvt_roundepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundpd_epi32 fn">_mm512_mask_cvt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundpd_epu32 fn">_mm512_mask_cvt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundpd_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundpd_ps fn">_mm512_mask_cvt_roundpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundph_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundph_ps fn">_mm512_mask_cvt_roundph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundps_epi32 fn">_mm512_mask_cvt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundps_epu32 fn">_mm512_mask_cvt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundps_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundps_pd fn">_mm512_mask_cvt_roundps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvt_roundps_ph.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvt_roundps_ph fn">_mm512_mask_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi8_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi8_epi16 fn">_mm512_mask_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi8_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi8_epi32 fn">_mm512_mask_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi8_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi8_epi64 fn">_mm512_mask_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi16_epi8 fn">_mm512_mask_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi16_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi16_epi32 fn">_mm512_mask_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi16_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi16_epi64 fn">_mm512_mask_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi16_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi16_storeu_epi8 fn">_mm512_mask_cvtepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi32_epi8 fn">_mm512_mask_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi32_epi16 fn">_mm512_mask_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi32_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi32_epi64 fn">_mm512_mask_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi32_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi32_pd fn">_mm512_mask_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi32_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi32_ps fn">_mm512_mask_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi32_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi32_storeu_epi8 fn">_mm512_mask_cvtepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi32_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi32_storeu_epi16 fn">_mm512_mask_cvtepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi32lo_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi32lo_pd fn">_mm512_mask_cvtepi32lo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs element-by-element conversion of the lower half of packed 32-bit integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi64_epi8 fn">_mm512_mask_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi64_epi16 fn">_mm512_mask_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi64_epi32 fn">_mm512_mask_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi64_storeu_epi8 fn">_mm512_mask_cvtepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi64_storeu_epi16 fn">_mm512_mask_cvtepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepi64_storeu_epi32 fn">_mm512_mask_cvtepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepu8_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepu8_epi16 fn">_mm512_mask_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepu8_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepu8_epi32 fn">_mm512_mask_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepu8_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepu8_epi64 fn">_mm512_mask_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepu16_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepu16_epi32 fn">_mm512_mask_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepu16_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepu16_epi64 fn">_mm512_mask_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepu32_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepu32_epi64 fn">_mm512_mask_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepu32_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepu32_pd fn">_mm512_mask_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepu32_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepu32_ps fn">_mm512_mask_cvtepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtepu32lo_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtepu32lo_pd fn">_mm512_mask_cvtepu32lo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs element-by-element conversion of the lower half of 32-bit unsigned integer elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtne2ps_pbh.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtne2ps_pbh fn">_mm512_mask_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in two vectors
a and b to packed BF16 (16-bit) floating-point elements, and store the results
in single vector dst using writemask k (elements are copied from src when the
corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657&amp;avx512techs=AVX512_BF16&amp;text=_mm512_mask_cvtne2ps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtneps_pbh.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtneps_pbh fn">_mm512_mask_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)
floating-point elements, and store the results in dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_mask_cvtneps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtpd_epi32 fn">_mm512_mask_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtpd_epu32 fn">_mm512_mask_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtpd_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtpd_ps fn">_mm512_mask_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtpd_pslo.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtpd_pslo fn">_mm512_mask_cvtpd_pslo</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs an element-by-element conversion of packed double-precision (64-bit) floating-point elements in v2 to single-precision (32-bit) floating-point elements and stores them in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The elements are stored in the lower half of the results vector, while the remaining upper half locations are set to 0.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtph_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtph_ps fn">_mm512_mask_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtps_epi32 fn">_mm512_mask_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtps_epu32 fn">_mm512_mask_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtps_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtps_pd fn">_mm512_mask_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtps_ph.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtps_ph fn">_mm512_mask_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtpslo_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtpslo_pd fn">_mm512_mask_cvtpslo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Performs element-by-element conversion of the lower half of packed single-precision (32-bit) floating-point elements in v2 to packed double-precision (64-bit) floating-point elements, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi16_epi8 fn">_mm512_mask_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi16_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi16_storeu_epi8 fn">_mm512_mask_cvtsepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi32_epi8 fn">_mm512_mask_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi32_epi16 fn">_mm512_mask_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi32_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi32_storeu_epi8 fn">_mm512_mask_cvtsepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi32_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi32_storeu_epi16 fn">_mm512_mask_cvtsepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi64_epi8 fn">_mm512_mask_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi64_epi16 fn">_mm512_mask_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi64_epi32 fn">_mm512_mask_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi64_storeu_epi8 fn">_mm512_mask_cvtsepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi64_storeu_epi16 fn">_mm512_mask_cvtsepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtsepi64_storeu_epi32 fn">_mm512_mask_cvtsepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtt_roundpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtt_roundpd_epi32 fn">_mm512_mask_cvtt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtt_roundpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtt_roundpd_epu32 fn">_mm512_mask_cvtt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtt_roundps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtt_roundps_epi32 fn">_mm512_mask_cvtt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtt_roundps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtt_roundps_epu32 fn">_mm512_mask_cvtt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvttpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvttpd_epi32 fn">_mm512_mask_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvttpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvttpd_epu32 fn">_mm512_mask_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvttps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvttps_epi32 fn">_mm512_mask_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvttps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvttps_epu32 fn">_mm512_mask_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi16_epi8 fn">_mm512_mask_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi16_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi16_storeu_epi8 fn">_mm512_mask_cvtusepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi32_epi8 fn">_mm512_mask_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi32_epi16 fn">_mm512_mask_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi32_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi32_storeu_epi8 fn">_mm512_mask_cvtusepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi32_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi32_storeu_epi16 fn">_mm512_mask_cvtusepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi64_epi8 fn">_mm512_mask_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi64_epi16 fn">_mm512_mask_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi64_epi32 fn">_mm512_mask_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi64_storeu_epi8 fn">_mm512_mask_cvtusepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi64_storeu_epi16 fn">_mm512_mask_cvtusepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_cvtusepi64_storeu_epi32 fn">_mm512_mask_cvtusepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_dbsad_epu8.html" title="no_std_compat::arch::x86_64::_mm512_mask_dbsad_epu8 fn">_mm512_mask_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_div_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_div_pd fn">_mm512_mask_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_div_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_div_ps fn">_mm512_mask_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_div_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_div_round_pd fn">_mm512_mask_div_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_div_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_div_round_ps fn">_mm512_mask_div_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_dpbf16_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_dpbf16_ps fn">_mm512_mask_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span></div><div class="item-right docblock-short"><p>Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,
accumulating the intermediate single-precision (32-bit) floating-point elements
with elements in src, and store the results in dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_mask_dpbf16_ps">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_dpbusd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_dpbusd_epi32 fn">_mm512_mask_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_dpbusds_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_dpbusds_epi32 fn">_mm512_mask_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_dpwssd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_dpwssd_epi32 fn">_mm512_mask_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_dpwssds_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_dpwssds_epi32 fn">_mm512_mask_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expand_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_expand_epi8 fn">_mm512_mask_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expand_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_expand_epi16 fn">_mm512_mask_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expand_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_expand_epi32 fn">_mm512_mask_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expand_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_expand_epi64 fn">_mm512_mask_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expand_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_expand_pd fn">_mm512_mask_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expand_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_expand_ps fn">_mm512_mask_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expandloadu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_expandloadu_epi8 fn">_mm512_mask_expandloadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vbmi2` only"><code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expandloadu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_expandloadu_epi16 fn">_mm512_mask_expandloadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vbmi2` only"><code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expandloadu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_expandloadu_epi32 fn">_mm512_mask_expandloadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expandloadu_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_expandloadu_epi64 fn">_mm512_mask_expandloadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expandloadu_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_expandloadu_pd fn">_mm512_mask_expandloadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_expandloadu_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_expandloadu_ps fn">_mm512_mask_expandloadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_extractf32x4_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_extractf32x4_ps fn">_mm512_mask_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_extractf64x4_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_extractf64x4_pd fn">_mm512_mask_extractf64x4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_extracti32x4_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_extracti32x4_epi32 fn">_mm512_mask_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_extracti64x4_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_extracti64x4_epi64 fn">_mm512_mask_extracti64x4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fixupimm_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fixupimm_pd fn">_mm512_mask_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fixupimm_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fixupimm_ps fn">_mm512_mask_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fixupimm_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fixupimm_round_pd fn">_mm512_mask_fixupimm_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fixupimm_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fixupimm_round_ps fn">_mm512_mask_fixupimm_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmadd_pd fn">_mm512_mask_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmadd_ps fn">_mm512_mask_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmadd_round_pd fn">_mm512_mask_fmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmadd_round_ps fn">_mm512_mask_fmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmaddsub_pd fn">_mm512_mask_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmaddsub_ps fn">_mm512_mask_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmaddsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmaddsub_round_pd fn">_mm512_mask_fmaddsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmaddsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmaddsub_round_ps fn">_mm512_mask_fmaddsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmsub_pd fn">_mm512_mask_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmsub_ps fn">_mm512_mask_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmsub_round_pd fn">_mm512_mask_fmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmsub_round_ps fn">_mm512_mask_fmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmsubadd_pd fn">_mm512_mask_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmsubadd_ps fn">_mm512_mask_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmsubadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmsubadd_round_pd fn">_mm512_mask_fmsubadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fmsubadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fmsubadd_round_ps fn">_mm512_mask_fmsubadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fnmadd_pd fn">_mm512_mask_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fnmadd_ps fn">_mm512_mask_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fnmadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fnmadd_round_pd fn">_mm512_mask_fnmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fnmadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fnmadd_round_ps fn">_mm512_mask_fnmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fnmsub_pd fn">_mm512_mask_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fnmsub_ps fn">_mm512_mask_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fnmsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_fnmsub_round_pd fn">_mm512_mask_fnmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_fnmsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_fnmsub_round_ps fn">_mm512_mask_fnmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_getexp_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_getexp_pd fn">_mm512_mask_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_getexp_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_getexp_ps fn">_mm512_mask_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_getexp_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_getexp_round_pd fn">_mm512_mask_getexp_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_getexp_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_getexp_round_ps fn">_mm512_mask_getexp_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_getmant_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_getmant_pd fn">_mm512_mask_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_getmant_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_getmant_ps fn">_mm512_mask_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_getmant_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_getmant_round_pd fn">_mm512_mask_getmant_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_getmant_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_getmant_round_ps fn">_mm512_mask_getmant_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_gf2p8affine_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_gf2p8affine_epi64_epi8 fn">_mm512_mask_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the packed bytes in x.
That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_gf2p8affineinv_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_gf2p8affineinv_epi64_epi8 fn">_mm512_mask_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the inverted packed bytes in x.
That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.
The inverse of 0 is 0.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_gf2p8mul_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_gf2p8mul_epi8 fn">_mm512_mask_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs a multiplication in GF(2^8) on the packed bytes.
The field is in polynomial representation with the reduction polynomial
x^8 + x^4 + x^3 + x + 1.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i32gather_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_i32gather_epi32 fn">_mm512_mask_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i32gather_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_i32gather_epi64 fn">_mm512_mask_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i32gather_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_i32gather_pd fn">_mm512_mask_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i32gather_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_i32gather_ps fn">_mm512_mask_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i32scatter_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_i32scatter_epi32 fn">_mm512_mask_i32scatter_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i32scatter_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_i32scatter_epi64 fn">_mm512_mask_i32scatter_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter 64-bit integers from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i32scatter_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_i32scatter_pd fn">_mm512_mask_i32scatter_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter double-precision (64-bit) floating-point elements from a into memory using 32-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i32scatter_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_i32scatter_ps fn">_mm512_mask_i32scatter_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter single-precision (32-bit) floating-point elements from a into memory using 32-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i64gather_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_i64gather_epi32 fn">_mm512_mask_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i64gather_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_i64gather_epi64 fn">_mm512_mask_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i64gather_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_i64gather_pd fn">_mm512_mask_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i64gather_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_i64gather_ps fn">_mm512_mask_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged into dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i64scatter_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_i64scatter_epi32 fn">_mm512_mask_i64scatter_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter 32-bit integers from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i64scatter_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_i64scatter_epi64 fn">_mm512_mask_i64scatter_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter 64-bit integers from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i64scatter_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_i64scatter_pd fn">_mm512_mask_i64scatter_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter double-precision (64-bit) floating-point elements from a into memory using 64-bit indices. 64-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_i64scatter_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_i64scatter_ps fn">_mm512_mask_i64scatter_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scatter single-precision (32-bit) floating-point elements from a into memory using 64-bit indices. 32-bit elements are stored at addresses starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale) subject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_insertf32x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_insertf32x4 fn">_mm512_mask_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_insertf64x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_insertf64x4 fn">_mm512_mask_insertf64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_inserti32x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_inserti32x4 fn">_mm512_mask_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_inserti64x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_inserti64x4 fn">_mm512_mask_inserti64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 256 bits (composed of 4 packed 64-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_load_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_load_epi32 fn">_mm512_mask_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_load_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_load_epi64 fn">_mm512_mask_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_load_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_load_pd fn">_mm512_mask_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_load_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_load_ps fn">_mm512_mask_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_loadu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_loadu_epi8 fn">_mm512_mask_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw` only"><code>avx512f,avx512bw</code></span></div><div class="item-right docblock-short"><p>Load packed 8-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_loadu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_loadu_epi16 fn">_mm512_mask_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw` only"><code>avx512f,avx512bw</code></span></div><div class="item-right docblock-short"><p>Load packed 16-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_loadu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_loadu_epi32 fn">_mm512_mask_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_loadu_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_loadu_epi64 fn">_mm512_mask_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_loadu_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_loadu_pd fn">_mm512_mask_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_loadu_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_loadu_ps fn">_mm512_mask_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_lzcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_lzcnt_epi32 fn">_mm512_mask_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_lzcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_lzcnt_epi64 fn">_mm512_mask_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_madd_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_madd_epi16 fn">_mm512_mask_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_maddubs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_maddubs_epi16 fn">_mm512_mask_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_epi8 fn">_mm512_mask_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_epi16 fn">_mm512_mask_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_epi32 fn">_mm512_mask_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_epi64 fn">_mm512_mask_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_epu8.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_epu8 fn">_mm512_mask_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_epu16.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_epu16 fn">_mm512_mask_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_epu32 fn">_mm512_mask_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_epu64.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_epu64 fn">_mm512_mask_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_pd fn">_mm512_mask_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_ps fn">_mm512_mask_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_round_pd fn">_mm512_mask_max_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_max_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_max_round_ps fn">_mm512_mask_max_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_epi8 fn">_mm512_mask_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_epi16 fn">_mm512_mask_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_epi32 fn">_mm512_mask_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_epi64 fn">_mm512_mask_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_epu8.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_epu8 fn">_mm512_mask_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_epu16.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_epu16 fn">_mm512_mask_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_epu32 fn">_mm512_mask_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_epu64.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_epu64 fn">_mm512_mask_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_pd fn">_mm512_mask_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_ps fn">_mm512_mask_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_round_pd fn">_mm512_mask_min_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_min_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_min_round_ps fn">_mm512_mask_min_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mov_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_mov_epi8 fn">_mm512_mask_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Move packed 8-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mov_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_mov_epi16 fn">_mm512_mask_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Move packed 16-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mov_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_mov_epi32 fn">_mm512_mask_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mov_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_mov_epi64 fn">_mm512_mask_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mov_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_mov_pd fn">_mm512_mask_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mov_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_mov_ps fn">_mm512_mask_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_movedup_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_movedup_pd fn">_mm512_mask_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_movehdup_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_movehdup_ps fn">_mm512_mask_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_moveldup_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_moveldup_ps fn">_mm512_mask_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_mul_epi32 fn">_mm512_mask_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mul_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_mul_epu32 fn">_mm512_mask_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mul_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_mul_pd fn">_mm512_mask_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mul_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_mul_ps fn">_mm512_mask_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mul_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_mul_round_pd fn">_mm512_mask_mul_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mul_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_mul_round_ps fn">_mm512_mask_mul_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mulhi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_mulhi_epi16 fn">_mm512_mask_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mulhi_epu16.html" title="no_std_compat::arch::x86_64::_mm512_mask_mulhi_epu16 fn">_mm512_mask_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mulhrs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_mulhrs_epi16 fn">_mm512_mask_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mullo_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_mullo_epi16 fn">_mm512_mask_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mullo_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_mullo_epi32 fn">_mm512_mask_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_mullox_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_mullox_epi64 fn">_mm512_mask_mullox_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiplies elements in packed 64-bit integer vectors a and b together, storing the lower 64 bits of the result in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_multishift_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_multishift_epi64_epi8 fn">_mm512_mask_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_or_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_or_epi32 fn">_mm512_mask_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_or_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_or_epi64 fn">_mm512_mask_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_packs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_packs_epi16 fn">_mm512_mask_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_packs_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_packs_epi32 fn">_mm512_mask_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_packus_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_packus_epi16 fn">_mm512_mask_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_packus_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_packus_epi32 fn">_mm512_mask_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permute_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_permute_pd fn">_mm512_mask_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permute_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_permute_ps fn">_mm512_mask_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutevar_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutevar_epi32 fn">_mm512_mask_permutevar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the permutevar name. This intrinsic is identical to _mm512_mask_permutexvar_epi32, and it is recommended that you use that intrinsic name.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutevar_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutevar_pd fn">_mm512_mask_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutevar_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutevar_ps fn">_mm512_mask_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutex2var_epi8 fn">_mm512_mask_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutex2var_epi16 fn">_mm512_mask_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutex2var_epi32 fn">_mm512_mask_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutex2var_epi64 fn">_mm512_mask_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutex2var_pd fn">_mm512_mask_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutex2var_ps fn">_mm512_mask_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutex_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutex_epi64 fn">_mm512_mask_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutex_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutex_pd fn">_mm512_mask_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutexvar_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutexvar_epi8 fn">_mm512_mask_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutexvar_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutexvar_epi16 fn">_mm512_mask_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutexvar_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutexvar_epi32 fn">_mm512_mask_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutexvar_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutexvar_epi64 fn">_mm512_mask_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutexvar_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutexvar_pd fn">_mm512_mask_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_permutexvar_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_permutexvar_ps fn">_mm512_mask_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_popcnt_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_popcnt_epi8 fn">_mm512_mask_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span></div><div class="item-right docblock-short"><p>For each packed 8-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_popcnt_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_popcnt_epi16 fn">_mm512_mask_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span></div><div class="item-right docblock-short"><p>For each packed 16-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_popcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_popcnt_epi32 fn">_mm512_mask_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span></div><div class="item-right docblock-short"><p>For each packed 32-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_popcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_popcnt_epi64 fn">_mm512_mask_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span></div><div class="item-right docblock-short"><p>For each packed 64-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rcp14_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_rcp14_pd fn">_mm512_mask_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rcp14_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_rcp14_ps fn">_mm512_mask_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_add_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_add_epi32 fn">_mm512_mask_reduce_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 32-bit integers in a by addition using mask k. Returns the sum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_add_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_add_epi64 fn">_mm512_mask_reduce_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 64-bit integers in a by addition using mask k. Returns the sum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_add_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_add_pd fn">_mm512_mask_reduce_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed double-precision (64-bit) floating-point elements in a by addition using mask k. Returns the sum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_add_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_add_ps fn">_mm512_mask_reduce_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed single-precision (32-bit) floating-point elements in a by addition using mask k. Returns the sum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_and_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_and_epi32 fn">_mm512_mask_reduce_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 32-bit integers in a by bitwise AND using mask k. Returns the bitwise AND of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_and_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_and_epi64 fn">_mm512_mask_reduce_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 64-bit integers in a by addition using mask k. Returns the sum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_max_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_max_epi32 fn">_mm512_mask_reduce_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed signed 32-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_max_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_max_epi64 fn">_mm512_mask_reduce_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_max_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_max_epu32 fn">_mm512_mask_reduce_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed unsigned 32-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_max_epu64.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_max_epu64 fn">_mm512_mask_reduce_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed unsigned 64-bit integers in a by maximum using mask k. Returns the maximum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_max_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_max_pd fn">_mm512_mask_reduce_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed double-precision (64-bit) floating-point elements in a by maximum using mask k. Returns the maximum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_max_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_max_ps fn">_mm512_mask_reduce_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed single-precision (32-bit) floating-point elements in a by maximum using mask k. Returns the maximum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_min_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_min_epi32 fn">_mm512_mask_reduce_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed signed 32-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_min_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_min_epi64 fn">_mm512_mask_reduce_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_min_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_min_epu32 fn">_mm512_mask_reduce_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed unsigned 32-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_min_epu64.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_min_epu64 fn">_mm512_mask_reduce_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed signed 64-bit integers in a by maximum using mask k. Returns the minimum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_min_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_min_pd fn">_mm512_mask_reduce_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed double-precision (64-bit) floating-point elements in a by maximum using mask k. Returns the minimum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_min_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_min_ps fn">_mm512_mask_reduce_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed single-precision (32-bit) floating-point elements in a by maximum using mask k. Returns the minimum of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_mul_epi32 fn">_mm512_mask_reduce_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 32-bit integers in a by multiplication using mask k. Returns the product of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_mul_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_mul_epi64 fn">_mm512_mask_reduce_mul_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 64-bit integers in a by multiplication using mask k. Returns the product of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_mul_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_mul_pd fn">_mm512_mask_reduce_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication using mask k. Returns the product of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_mul_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_mul_ps fn">_mm512_mask_reduce_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication using mask k. Returns the product of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_or_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_or_epi32 fn">_mm512_mask_reduce_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 32-bit integers in a by bitwise OR using mask k. Returns the bitwise OR of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_reduce_or_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_reduce_or_epi64 fn">_mm512_mask_reduce_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 64-bit integers in a by bitwise OR using mask k. Returns the bitwise OR of all active elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rol_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_rol_epi32 fn">_mm512_mask_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rol_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_rol_epi64 fn">_mm512_mask_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rolv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_rolv_epi32 fn">_mm512_mask_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rolv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_rolv_epi64 fn">_mm512_mask_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_ror_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_ror_epi32 fn">_mm512_mask_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_ror_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_ror_epi64 fn">_mm512_mask_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rorv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_rorv_epi32 fn">_mm512_mask_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rorv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_rorv_epi64 fn">_mm512_mask_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_roundscale_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_roundscale_pd fn">_mm512_mask_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_roundscale_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_roundscale_ps fn">_mm512_mask_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_roundscale_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_roundscale_round_pd fn">_mm512_mask_roundscale_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_roundscale_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_roundscale_round_ps fn">_mm512_mask_roundscale_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rsqrt14_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_rsqrt14_pd fn">_mm512_mask_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_rsqrt14_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_rsqrt14_ps fn">_mm512_mask_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_scalef_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_scalef_pd fn">_mm512_mask_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_scalef_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_scalef_ps fn">_mm512_mask_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_scalef_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_scalef_round_pd fn">_mm512_mask_scalef_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_scalef_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_scalef_round_ps fn">_mm512_mask_scalef_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_set1_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_set1_epi8 fn">_mm512_mask_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast 8-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_set1_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_set1_epi16 fn">_mm512_mask_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast 16-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_set1_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_set1_epi32 fn">_mm512_mask_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_set1_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_set1_epi64 fn">_mm512_mask_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shldi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_shldi_epi16 fn">_mm512_mask_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shldi_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_shldi_epi32 fn">_mm512_mask_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shldi_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_shldi_epi64 fn">_mm512_mask_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shldv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_shldv_epi16 fn">_mm512_mask_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shldv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_shldv_epi32 fn">_mm512_mask_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shldv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_shldv_epi64 fn">_mm512_mask_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shrdi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_shrdi_epi16 fn">_mm512_mask_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shrdi_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_shrdi_epi32 fn">_mm512_mask_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shrdi_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_shrdi_epi64 fn">_mm512_mask_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src“ when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shrdv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_shrdv_epi16 fn">_mm512_mask_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shrdv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_shrdv_epi32 fn">_mm512_mask_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shrdv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_shrdv_epi64 fn">_mm512_mask_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shuffle_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_shuffle_epi8 fn">_mm512_mask_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a within 128-bit lanes using the control in the corresponding 8-bit element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shuffle_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_shuffle_epi32 fn">_mm512_mask_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shuffle_f32x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_shuffle_f32x4 fn">_mm512_mask_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shuffle_f64x2.html" title="no_std_compat::arch::x86_64::_mm512_mask_shuffle_f64x2 fn">_mm512_mask_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shuffle_i32x4.html" title="no_std_compat::arch::x86_64::_mm512_mask_shuffle_i32x4 fn">_mm512_mask_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shuffle_i64x2.html" title="no_std_compat::arch::x86_64::_mm512_mask_shuffle_i64x2 fn">_mm512_mask_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shuffle_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_shuffle_pd fn">_mm512_mask_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shuffle_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_shuffle_ps fn">_mm512_mask_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shufflehi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_shufflehi_epi16 fn">_mm512_mask_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_shufflelo_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_shufflelo_epi16 fn">_mm512_mask_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sll_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_sll_epi16 fn">_mm512_mask_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sll_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_sll_epi32 fn">_mm512_mask_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sll_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_sll_epi64 fn">_mm512_mask_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_slli_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_slli_epi16 fn">_mm512_mask_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_slli_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_slli_epi32 fn">_mm512_mask_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_slli_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_slli_epi64 fn">_mm512_mask_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sllv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_sllv_epi16 fn">_mm512_mask_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sllv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_sllv_epi32 fn">_mm512_mask_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sllv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_sllv_epi64 fn">_mm512_mask_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sqrt_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_sqrt_pd fn">_mm512_mask_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sqrt_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_sqrt_ps fn">_mm512_mask_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sqrt_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_sqrt_round_pd fn">_mm512_mask_sqrt_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sqrt_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_sqrt_round_ps fn">_mm512_mask_sqrt_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sra_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_sra_epi16 fn">_mm512_mask_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sra_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_sra_epi32 fn">_mm512_mask_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sra_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_sra_epi64 fn">_mm512_mask_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srai_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_srai_epi16 fn">_mm512_mask_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srai_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_srai_epi32 fn">_mm512_mask_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srai_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_srai_epi64 fn">_mm512_mask_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srav_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_srav_epi16 fn">_mm512_mask_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srav_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_srav_epi32 fn">_mm512_mask_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srav_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_srav_epi64 fn">_mm512_mask_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srl_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_srl_epi16 fn">_mm512_mask_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srl_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_srl_epi32 fn">_mm512_mask_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srl_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_srl_epi64 fn">_mm512_mask_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srli_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_srli_epi16 fn">_mm512_mask_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srli_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_srli_epi32 fn">_mm512_mask_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srli_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_srli_epi64 fn">_mm512_mask_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srlv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_srlv_epi16 fn">_mm512_mask_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srlv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_srlv_epi32 fn">_mm512_mask_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_srlv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_srlv_epi64 fn">_mm512_mask_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_store_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_store_epi32 fn">_mm512_mask_store_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store packed 32-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_store_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_store_epi64 fn">_mm512_mask_store_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store packed 64-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_store_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_store_pd fn">_mm512_mask_store_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_store_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_store_ps fn">_mm512_mask_store_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_storeu_epi8 fn">_mm512_mask_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw` only"><code>avx512f,avx512bw</code></span></div><div class="item-right docblock-short"><p>Store packed 8-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_storeu_epi16 fn">_mm512_mask_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw` only"><code>avx512f,avx512bw</code></span></div><div class="item-right docblock-short"><p>Store packed 16-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_storeu_epi32 fn">_mm512_mask_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store packed 32-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_storeu_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_storeu_epi64 fn">_mm512_mask_storeu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store packed 64-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_storeu_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_storeu_pd fn">_mm512_mask_storeu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_storeu_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_storeu_ps fn">_mm512_mask_storeu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sub_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_sub_epi8 fn">_mm512_mask_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sub_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_sub_epi16 fn">_mm512_mask_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sub_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_sub_epi32 fn">_mm512_mask_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sub_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_sub_epi64 fn">_mm512_mask_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sub_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_sub_pd fn">_mm512_mask_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sub_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_sub_ps fn">_mm512_mask_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_sub_round_pd fn">_mm512_mask_sub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_sub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_sub_round_ps fn">_mm512_mask_sub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_subs_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_subs_epi8 fn">_mm512_mask_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_subs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_subs_epi16 fn">_mm512_mask_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_subs_epu8.html" title="no_std_compat::arch::x86_64::_mm512_mask_subs_epu8 fn">_mm512_mask_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_subs_epu16.html" title="no_std_compat::arch::x86_64::_mm512_mask_subs_epu16 fn">_mm512_mask_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_ternarylogic_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_ternarylogic_epi32 fn">_mm512_mask_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_ternarylogic_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_ternarylogic_epi64 fn">_mm512_mask_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_test_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_test_epi8_mask fn">_mm512_mask_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_test_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_test_epi16_mask fn">_mm512_mask_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_test_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_test_epi32_mask fn">_mm512_mask_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_test_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_test_epi64_mask fn">_mm512_mask_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_testn_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_testn_epi8_mask fn">_mm512_mask_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_testn_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_testn_epi16_mask fn">_mm512_mask_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_testn_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_testn_epi32_mask fn">_mm512_mask_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_testn_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_mask_testn_epi64_mask fn">_mm512_mask_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpackhi_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpackhi_epi8 fn">_mm512_mask_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpackhi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpackhi_epi16 fn">_mm512_mask_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpackhi_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpackhi_epi32 fn">_mm512_mask_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpackhi_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpackhi_epi64 fn">_mm512_mask_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpackhi_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpackhi_pd fn">_mm512_mask_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpackhi_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpackhi_ps fn">_mm512_mask_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpacklo_epi8.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpacklo_epi8 fn">_mm512_mask_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpacklo_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpacklo_epi16 fn">_mm512_mask_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpacklo_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpacklo_epi32 fn">_mm512_mask_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpacklo_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpacklo_epi64 fn">_mm512_mask_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpacklo_pd.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpacklo_pd fn">_mm512_mask_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_unpacklo_ps.html" title="no_std_compat::arch::x86_64::_mm512_mask_unpacklo_ps fn">_mm512_mask_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_xor_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mask_xor_epi32 fn">_mm512_mask_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mask_xor_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mask_xor_epi64 fn">_mm512_mask_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_abs_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_abs_epi8 fn">_mm512_maskz_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_abs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_abs_epi16 fn">_mm512_maskz_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_abs_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_abs_epi32 fn">_mm512_maskz_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Computes the absolute value of packed 32-bit integers in <code>a</code>, and store the
unsigned results in <code>dst</code> using zeromask <code>k</code> (elements are zeroed out when
the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_abs_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_abs_epi64 fn">_mm512_maskz_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 64-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_add_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_add_epi8 fn">_mm512_maskz_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_add_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_add_epi16 fn">_mm512_maskz_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_add_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_add_epi32 fn">_mm512_maskz_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_add_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_add_epi64 fn">_mm512_maskz_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_add_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_add_pd fn">_mm512_maskz_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_add_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_add_ps fn">_mm512_maskz_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_add_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_add_round_pd fn">_mm512_maskz_add_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_add_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_add_round_ps fn">_mm512_maskz_add_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_adds_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_adds_epi8 fn">_mm512_maskz_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_adds_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_adds_epi16 fn">_mm512_maskz_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_adds_epu8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_adds_epu8 fn">_mm512_maskz_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_adds_epu16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_adds_epu16 fn">_mm512_maskz_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_alignr_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_alignr_epi8 fn">_mm512_maskz_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_alignr_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_alignr_epi32 fn">_mm512_maskz_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 32-bit elements, and stores the low 64 bytes (16 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_alignr_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_alignr_epi64 fn">_mm512_maskz_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 128-byte immediate result, shift the result right by imm8 64-bit elements, and stores the low 64 bytes (8 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_and_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_and_epi32 fn">_mm512_maskz_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_and_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_and_epi64 fn">_mm512_maskz_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_andnot_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_andnot_epi32 fn">_mm512_maskz_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_andnot_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_andnot_epi64 fn">_mm512_maskz_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_avg_epu8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_avg_epu8 fn">_mm512_maskz_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_avg_epu16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_avg_epu16 fn">_mm512_maskz_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcast_f32x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcast_f32x4 fn">_mm512_maskz_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed single-precision (32-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcast_f64x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcast_f64x4 fn">_mm512_maskz_broadcast_f64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed double-precision (64-bit) floating-point elements from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcast_i32x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcast_i32x4 fn">_mm512_maskz_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed 32-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcast_i64x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcast_i64x4 fn">_mm512_maskz_broadcast_i64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the 4 packed 64-bit integers from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcastb_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcastb_epi8 fn">_mm512_maskz_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 8-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcastd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcastd_epi32 fn">_mm512_maskz_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcastq_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcastq_epi64 fn">_mm512_maskz_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcastsd_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcastsd_pd fn">_mm512_maskz_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low double-precision (64-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcastss_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcastss_ps fn">_mm512_maskz_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_broadcastw_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_broadcastw_epi16 fn">_mm512_maskz_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_compress_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_compress_epi8 fn">_mm512_maskz_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_compress_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_compress_epi16 fn">_mm512_maskz_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_compress_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_compress_epi32 fn">_mm512_maskz_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_compress_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_compress_epi64 fn">_mm512_maskz_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_compress_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_compress_pd fn">_mm512_maskz_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_compress_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_compress_ps fn">_mm512_maskz_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_conflict_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_conflict_epi32 fn">_mm512_maskz_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_conflict_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_conflict_epi64 fn">_mm512_maskz_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundepi32_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundepi32_ps fn">_mm512_maskz_cvt_roundepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundepu32_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundepu32_ps fn">_mm512_maskz_cvt_roundepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundpd_epi32 fn">_mm512_maskz_cvt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundpd_epu32 fn">_mm512_maskz_cvt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundpd_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundpd_ps fn">_mm512_maskz_cvt_roundpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundph_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundph_ps fn">_mm512_maskz_cvt_roundph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundps_epi32 fn">_mm512_maskz_cvt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundps_epu32 fn">_mm512_maskz_cvt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundps_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundps_pd fn">_mm512_maskz_cvt_roundps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvt_roundps_ph.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvt_roundps_ph fn">_mm512_maskz_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi8_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi8_epi16 fn">_mm512_maskz_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi8_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi8_epi32 fn">_mm512_maskz_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi8_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi8_epi64 fn">_mm512_maskz_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi16_epi8 fn">_mm512_maskz_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi16_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi16_epi32 fn">_mm512_maskz_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi16_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi16_epi64 fn">_mm512_maskz_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi32_epi8 fn">_mm512_maskz_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi32_epi16 fn">_mm512_maskz_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi32_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi32_epi64 fn">_mm512_maskz_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi32_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi32_pd fn">_mm512_maskz_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi32_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi32_ps fn">_mm512_maskz_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi64_epi8 fn">_mm512_maskz_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi64_epi16 fn">_mm512_maskz_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepi64_epi32 fn">_mm512_maskz_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepu8_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepu8_epi16 fn">_mm512_maskz_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepu8_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepu8_epi32 fn">_mm512_maskz_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepu8_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepu8_epi64 fn">_mm512_maskz_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 8 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepu16_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepu16_epi32 fn">_mm512_maskz_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepu16_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepu16_epi64 fn">_mm512_maskz_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepu32_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepu32_epi64 fn">_mm512_maskz_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepu32_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepu32_pd fn">_mm512_maskz_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtepu32_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtepu32_ps fn">_mm512_maskz_cvtepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtne2ps_pbh.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtne2ps_pbh fn">_mm512_maskz_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in two vectors
a and b to packed BF16 (16-bit) floating-point elements, and store the results
in single vector dst using zeromask k (elements are zeroed out when the corresponding
mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657&amp;avx512techs=AVX512_BF16&amp;text=_mm512_maskz_cvtne2ps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtneps_pbh.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtneps_pbh fn">_mm512_maskz_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed BF16 (16-bit)
floating-point elements, and store the results in dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_maskz_cvtneps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtpd_epi32 fn">_mm512_maskz_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtpd_epu32 fn">_mm512_maskz_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtpd_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtpd_ps fn">_mm512_maskz_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtph_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtph_ps fn">_mm512_maskz_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtps_epi32 fn">_mm512_maskz_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtps_epu32 fn">_mm512_maskz_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtps_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtps_pd fn">_mm512_maskz_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtps_ph.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtps_ph fn">_mm512_maskz_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtsepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtsepi16_epi8 fn">_mm512_maskz_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtsepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtsepi32_epi8 fn">_mm512_maskz_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtsepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtsepi32_epi16 fn">_mm512_maskz_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtsepi64_epi8 fn">_mm512_maskz_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtsepi64_epi16 fn">_mm512_maskz_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtsepi64_epi32 fn">_mm512_maskz_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtt_roundpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtt_roundpd_epi32 fn">_mm512_maskz_cvtt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtt_roundpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtt_roundpd_epu32 fn">_mm512_maskz_cvtt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtt_roundps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtt_roundps_epi32 fn">_mm512_maskz_cvtt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtt_roundps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtt_roundps_epu32 fn">_mm512_maskz_cvtt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvttpd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvttpd_epi32 fn">_mm512_maskz_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvttpd_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvttpd_epu32 fn">_mm512_maskz_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvttps_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvttps_epi32 fn">_mm512_maskz_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvttps_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvttps_epu32 fn">_mm512_maskz_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtusepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtusepi16_epi8 fn">_mm512_maskz_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtusepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtusepi32_epi8 fn">_mm512_maskz_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtusepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtusepi32_epi16 fn">_mm512_maskz_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtusepi64_epi8 fn">_mm512_maskz_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtusepi64_epi16 fn">_mm512_maskz_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_cvtusepi64_epi32 fn">_mm512_maskz_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_dbsad_epu8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_dbsad_epu8 fn">_mm512_maskz_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_div_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_div_pd fn">_mm512_maskz_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_div_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_div_ps fn">_mm512_maskz_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_div_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_div_round_pd fn">_mm512_maskz_div_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_div_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_div_round_ps fn">_mm512_maskz_div_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_dpbf16_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_dpbf16_ps fn">_mm512_maskz_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span></div><div class="item-right docblock-short"><p>Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,
accumulating the intermediate single-precision (32-bit) floating-point elements
with elements in src, and store the results in dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_maskz_dpbf16_ps">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_dpbusd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_dpbusd_epi32 fn">_mm512_maskz_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_dpbusds_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_dpbusds_epi32 fn">_mm512_maskz_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_dpwssd_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_dpwssd_epi32 fn">_mm512_maskz_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_dpwssds_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_dpwssds_epi32 fn">_mm512_maskz_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expand_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expand_epi8 fn">_mm512_maskz_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expand_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expand_epi16 fn">_mm512_maskz_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expand_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expand_epi32 fn">_mm512_maskz_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expand_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expand_epi64 fn">_mm512_maskz_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expand_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expand_pd fn">_mm512_maskz_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expand_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expand_ps fn">_mm512_maskz_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expandloadu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expandloadu_epi8 fn">_mm512_maskz_expandloadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vbmi2` only"><code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expandloadu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expandloadu_epi16 fn">_mm512_maskz_expandloadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vbmi2` only"><code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expandloadu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expandloadu_epi32 fn">_mm512_maskz_expandloadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expandloadu_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expandloadu_epi64 fn">_mm512_maskz_expandloadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expandloadu_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expandloadu_pd fn">_mm512_maskz_expandloadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_expandloadu_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_expandloadu_ps fn">_mm512_maskz_expandloadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_extractf32x4_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_extractf32x4_ps fn">_mm512_maskz_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_extractf64x4_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_extractf64x4_pd fn">_mm512_maskz_extractf64x4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from a, selected with imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_extracti32x4_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_extracti32x4_epi32 fn">_mm512_maskz_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 128 bits (composed of 4 packed 32-bit integers) from a, selected with IMM2, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_extracti64x4_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_extracti64x4_epi64 fn">_mm512_maskz_extracti64x4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Extract 256 bits (composed of 4 packed 64-bit integers) from a, selected with IMM1, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fixupimm_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fixupimm_pd fn">_mm512_maskz_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fixupimm_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fixupimm_ps fn">_mm512_maskz_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fixupimm_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fixupimm_round_pd fn">_mm512_maskz_fixupimm_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fixupimm_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fixupimm_round_ps fn">_mm512_maskz_fixupimm_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmadd_pd fn">_mm512_maskz_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmadd_ps fn">_mm512_maskz_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmadd_round_pd fn">_mm512_maskz_fmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmadd_round_ps fn">_mm512_maskz_fmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in a using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmaddsub_pd fn">_mm512_maskz_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmaddsub_ps fn">_mm512_maskz_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmaddsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmaddsub_round_pd fn">_mm512_maskz_fmaddsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmaddsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmaddsub_round_ps fn">_mm512_maskz_fmaddsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmsub_pd fn">_mm512_maskz_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmsub_ps fn">_mm512_maskz_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmsub_round_pd fn">_mm512_maskz_fmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmsub_round_ps fn">_mm512_maskz_fmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmsubadd_pd fn">_mm512_maskz_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmsubadd_ps fn">_mm512_maskz_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmsubadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmsubadd_round_pd fn">_mm512_maskz_fmsubadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fmsubadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fmsubadd_round_ps fn">_mm512_maskz_fmsubadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fnmadd_pd fn">_mm512_maskz_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fnmadd_ps fn">_mm512_maskz_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fnmadd_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fnmadd_round_pd fn">_mm512_maskz_fnmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fnmadd_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fnmadd_round_ps fn">_mm512_maskz_fnmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fnmsub_pd fn">_mm512_maskz_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fnmsub_ps fn">_mm512_maskz_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fnmsub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fnmsub_round_pd fn">_mm512_maskz_fnmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_fnmsub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_fnmsub_round_ps fn">_mm512_maskz_fnmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_getexp_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_getexp_pd fn">_mm512_maskz_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_getexp_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_getexp_ps fn">_mm512_maskz_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_getexp_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_getexp_round_pd fn">_mm512_maskz_getexp_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_getexp_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_getexp_round_ps fn">_mm512_maskz_getexp_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_getmant_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_getmant_pd fn">_mm512_maskz_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_getmant_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_getmant_ps fn">_mm512_maskz_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_getmant_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_getmant_round_pd fn">_mm512_maskz_getmant_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_getmant_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_getmant_round_ps fn">_mm512_maskz_getmant_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_gf2p8affine_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_gf2p8affine_epi64_epi8 fn">_mm512_maskz_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the packed bytes in x.
That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_gf2p8affineinv_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_gf2p8affineinv_epi64_epi8 fn">_mm512_maskz_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the inverted packed bytes in x.
That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.
The inverse of 0 is 0.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_gf2p8mul_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_gf2p8mul_epi8 fn">_mm512_maskz_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span></div><div class="item-right docblock-short"><p>Performs a multiplication in GF(2^8) on the packed bytes.
The field is in polynomial representation with the reduction polynomial
x^8 + x^4 + x^3 + x + 1.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_insertf32x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_insertf32x4 fn">_mm512_maskz_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_insertf64x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_insertf64x4 fn">_mm512_maskz_insertf64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 256 bits (composed of 4 packed double-precision (64-bit) floating-point elements) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_inserti32x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_inserti32x4 fn">_mm512_maskz_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 128 bits (composed of 4 packed 32-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_inserti64x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_inserti64x4 fn">_mm512_maskz_inserti64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Copy a to tmp, then insert 256 bits (composed of 4 packed 64-bit integers) from b into tmp at the location specified by imm8. Store tmp to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_load_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_load_epi32 fn">_mm512_maskz_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_load_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_load_epi64 fn">_mm512_maskz_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_load_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_load_pd fn">_mm512_maskz_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_load_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_load_ps fn">_mm512_maskz_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_loadu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_loadu_epi8 fn">_mm512_maskz_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw` only"><code>avx512f,avx512bw</code></span></div><div class="item-right docblock-short"><p>Load packed 8-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_loadu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_loadu_epi16 fn">_mm512_maskz_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw` only"><code>avx512f,avx512bw</code></span></div><div class="item-right docblock-short"><p>Load packed 16-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_loadu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_loadu_epi32 fn">_mm512_maskz_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_loadu_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_loadu_epi64 fn">_mm512_maskz_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_loadu_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_loadu_pd fn">_mm512_maskz_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_loadu_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_loadu_ps fn">_mm512_maskz_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_lzcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_lzcnt_epi32 fn">_mm512_maskz_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_lzcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_lzcnt_epi64 fn">_mm512_maskz_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_madd_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_madd_epi16 fn">_mm512_maskz_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_maddubs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_maddubs_epi16 fn">_mm512_maskz_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_epi8 fn">_mm512_maskz_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_epi16 fn">_mm512_maskz_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_epi32 fn">_mm512_maskz_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_epi64 fn">_mm512_maskz_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_epu8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_epu8 fn">_mm512_maskz_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_epu16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_epu16 fn">_mm512_maskz_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_epu32 fn">_mm512_maskz_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_epu64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_epu64 fn">_mm512_maskz_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_pd fn">_mm512_maskz_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_ps fn">_mm512_maskz_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_round_pd fn">_mm512_maskz_max_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_max_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_max_round_ps fn">_mm512_maskz_max_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_epi8 fn">_mm512_maskz_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_epi16 fn">_mm512_maskz_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_epi32 fn">_mm512_maskz_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_epi64 fn">_mm512_maskz_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_epu8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_epu8 fn">_mm512_maskz_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_epu16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_epu16 fn">_mm512_maskz_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_epu32 fn">_mm512_maskz_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_epu64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_epu64 fn">_mm512_maskz_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_pd fn">_mm512_maskz_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_ps fn">_mm512_maskz_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_round_pd fn">_mm512_maskz_min_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_min_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_min_round_ps fn">_mm512_maskz_min_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mov_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mov_epi8 fn">_mm512_maskz_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Move packed 8-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mov_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mov_epi16 fn">_mm512_maskz_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Move packed 16-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mov_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mov_epi32 fn">_mm512_maskz_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mov_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mov_epi64 fn">_mm512_maskz_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mov_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mov_pd fn">_mm512_maskz_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mov_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mov_ps fn">_mm512_maskz_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_movedup_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_movedup_pd fn">_mm512_maskz_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_movehdup_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_movehdup_ps fn">_mm512_maskz_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_moveldup_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_moveldup_ps fn">_mm512_maskz_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mul_epi32 fn">_mm512_maskz_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mul_epu32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mul_epu32 fn">_mm512_maskz_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mul_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mul_pd fn">_mm512_maskz_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mul_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mul_ps fn">_mm512_maskz_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mul_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mul_round_pd fn">_mm512_maskz_mul_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mul_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mul_round_ps fn">_mm512_maskz_mul_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mulhi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mulhi_epi16 fn">_mm512_maskz_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mulhi_epu16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mulhi_epu16 fn">_mm512_maskz_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mulhrs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mulhrs_epi16 fn">_mm512_maskz_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mullo_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mullo_epi16 fn">_mm512_maskz_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_mullo_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_mullo_epi32 fn">_mm512_maskz_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_multishift_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_multishift_epi64_epi8 fn">_mm512_maskz_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_or_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_or_epi32 fn">_mm512_maskz_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_or_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_or_epi64 fn">_mm512_maskz_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_packs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_packs_epi16 fn">_mm512_maskz_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_packs_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_packs_epi32 fn">_mm512_maskz_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_packus_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_packus_epi16 fn">_mm512_maskz_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_packus_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_packus_epi32 fn">_mm512_maskz_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permute_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permute_pd fn">_mm512_maskz_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permute_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permute_ps fn">_mm512_maskz_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutevar_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutevar_pd fn">_mm512_maskz_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutevar_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutevar_ps fn">_mm512_maskz_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutex2var_epi8 fn">_mm512_maskz_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutex2var_epi16 fn">_mm512_maskz_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutex2var_epi32 fn">_mm512_maskz_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutex2var_epi64 fn">_mm512_maskz_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutex2var_pd fn">_mm512_maskz_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutex2var_ps fn">_mm512_maskz_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutex_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutex_epi64 fn">_mm512_maskz_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutex_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutex_pd fn">_mm512_maskz_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutexvar_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutexvar_epi8 fn">_mm512_maskz_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutexvar_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutexvar_epi16 fn">_mm512_maskz_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutexvar_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutexvar_epi32 fn">_mm512_maskz_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutexvar_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutexvar_epi64 fn">_mm512_maskz_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutexvar_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutexvar_pd fn">_mm512_maskz_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_permutexvar_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_permutexvar_ps fn">_mm512_maskz_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_popcnt_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_popcnt_epi8 fn">_mm512_maskz_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span></div><div class="item-right docblock-short"><p>For each packed 8-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_popcnt_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_popcnt_epi16 fn">_mm512_maskz_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span></div><div class="item-right docblock-short"><p>For each packed 16-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_popcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_popcnt_epi32 fn">_mm512_maskz_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span></div><div class="item-right docblock-short"><p>For each packed 32-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_popcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_popcnt_epi64 fn">_mm512_maskz_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span></div><div class="item-right docblock-short"><p>For each packed 64-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rcp14_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rcp14_pd fn">_mm512_maskz_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rcp14_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rcp14_ps fn">_mm512_maskz_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rol_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rol_epi32 fn">_mm512_maskz_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rol_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rol_epi64 fn">_mm512_maskz_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rolv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rolv_epi32 fn">_mm512_maskz_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rolv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rolv_epi64 fn">_mm512_maskz_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_ror_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_ror_epi32 fn">_mm512_maskz_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_ror_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_ror_epi64 fn">_mm512_maskz_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rorv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rorv_epi32 fn">_mm512_maskz_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rorv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rorv_epi64 fn">_mm512_maskz_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_roundscale_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_roundscale_pd fn">_mm512_maskz_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_roundscale_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_roundscale_ps fn">_mm512_maskz_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_roundscale_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_roundscale_round_pd fn">_mm512_maskz_roundscale_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_roundscale_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_roundscale_round_ps fn">_mm512_maskz_roundscale_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rsqrt14_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rsqrt14_pd fn">_mm512_maskz_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_rsqrt14_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_rsqrt14_ps fn">_mm512_maskz_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_scalef_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_scalef_pd fn">_mm512_maskz_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_scalef_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_scalef_ps fn">_mm512_maskz_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_scalef_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_scalef_round_pd fn">_mm512_maskz_scalef_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_scalef_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_scalef_round_ps fn">_mm512_maskz_scalef_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_set1_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_set1_epi8 fn">_mm512_maskz_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast 8-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_set1_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_set1_epi16 fn">_mm512_maskz_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_set1_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_set1_epi32 fn">_mm512_maskz_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_set1_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_set1_epi64 fn">_mm512_maskz_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shldi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shldi_epi16 fn">_mm512_maskz_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shldi_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shldi_epi32 fn">_mm512_maskz_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shldi_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shldi_epi64 fn">_mm512_maskz_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shldv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shldv_epi16 fn">_mm512_maskz_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shldv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shldv_epi32 fn">_mm512_maskz_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shldv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shldv_epi64 fn">_mm512_maskz_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shrdi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shrdi_epi16 fn">_mm512_maskz_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shrdi_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shrdi_epi32 fn">_mm512_maskz_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shrdi_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shrdi_epi64 fn">_mm512_maskz_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shrdv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shrdv_epi16 fn">_mm512_maskz_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shrdv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shrdv_epi32 fn">_mm512_maskz_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shrdv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shrdv_epi64 fn">_mm512_maskz_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shuffle_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shuffle_epi8 fn">_mm512_maskz_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shuffle_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shuffle_epi32 fn">_mm512_maskz_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shuffle_f32x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shuffle_f32x4 fn">_mm512_maskz_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shuffle_f64x2.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shuffle_f64x2 fn">_mm512_maskz_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shuffle_i32x4.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shuffle_i32x4 fn">_mm512_maskz_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shuffle_i64x2.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shuffle_i64x2 fn">_mm512_maskz_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shuffle_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shuffle_pd fn">_mm512_maskz_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shuffle_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shuffle_ps fn">_mm512_maskz_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shufflehi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shufflehi_epi16 fn">_mm512_maskz_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_shufflelo_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_shufflelo_epi16 fn">_mm512_maskz_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sll_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sll_epi16 fn">_mm512_maskz_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sll_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sll_epi32 fn">_mm512_maskz_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sll_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sll_epi64 fn">_mm512_maskz_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_slli_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_slli_epi16 fn">_mm512_maskz_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_slli_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_slli_epi32 fn">_mm512_maskz_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_slli_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_slli_epi64 fn">_mm512_maskz_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sllv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sllv_epi16 fn">_mm512_maskz_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sllv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sllv_epi32 fn">_mm512_maskz_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sllv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sllv_epi64 fn">_mm512_maskz_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sqrt_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sqrt_pd fn">_mm512_maskz_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sqrt_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sqrt_ps fn">_mm512_maskz_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sqrt_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sqrt_round_pd fn">_mm512_maskz_sqrt_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sqrt_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sqrt_round_ps fn">_mm512_maskz_sqrt_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sra_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sra_epi16 fn">_mm512_maskz_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sra_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sra_epi32 fn">_mm512_maskz_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sra_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sra_epi64 fn">_mm512_maskz_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srai_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srai_epi16 fn">_mm512_maskz_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srai_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srai_epi32 fn">_mm512_maskz_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srai_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srai_epi64 fn">_mm512_maskz_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srav_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srav_epi16 fn">_mm512_maskz_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srav_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srav_epi32 fn">_mm512_maskz_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srav_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srav_epi64 fn">_mm512_maskz_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srl_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srl_epi16 fn">_mm512_maskz_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srl_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srl_epi32 fn">_mm512_maskz_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srl_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srl_epi64 fn">_mm512_maskz_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srli_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srli_epi16 fn">_mm512_maskz_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srli_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srli_epi32 fn">_mm512_maskz_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srli_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srli_epi64 fn">_mm512_maskz_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srlv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srlv_epi16 fn">_mm512_maskz_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srlv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srlv_epi32 fn">_mm512_maskz_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_srlv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_srlv_epi64 fn">_mm512_maskz_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sub_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sub_epi8 fn">_mm512_maskz_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sub_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sub_epi16 fn">_mm512_maskz_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sub_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sub_epi32 fn">_mm512_maskz_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sub_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sub_epi64 fn">_mm512_maskz_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sub_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sub_pd fn">_mm512_maskz_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sub_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sub_ps fn">_mm512_maskz_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sub_round_pd fn">_mm512_maskz_sub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_sub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_sub_round_ps fn">_mm512_maskz_sub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_subs_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_subs_epi8 fn">_mm512_maskz_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_subs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_subs_epi16 fn">_mm512_maskz_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_subs_epu8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_subs_epu8 fn">_mm512_maskz_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_subs_epu16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_subs_epu16 fn">_mm512_maskz_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_ternarylogic_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_ternarylogic_epi32 fn">_mm512_maskz_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_ternarylogic_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_ternarylogic_epi64 fn">_mm512_maskz_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpackhi_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpackhi_epi8 fn">_mm512_maskz_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpackhi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpackhi_epi16 fn">_mm512_maskz_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpackhi_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpackhi_epi32 fn">_mm512_maskz_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpackhi_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpackhi_epi64 fn">_mm512_maskz_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpackhi_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpackhi_pd fn">_mm512_maskz_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpackhi_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpackhi_ps fn">_mm512_maskz_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpacklo_epi8.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpacklo_epi8 fn">_mm512_maskz_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpacklo_epi16.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpacklo_epi16 fn">_mm512_maskz_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpacklo_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpacklo_epi32 fn">_mm512_maskz_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpacklo_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpacklo_epi64 fn">_mm512_maskz_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpacklo_pd.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpacklo_pd fn">_mm512_maskz_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_unpacklo_ps.html" title="no_std_compat::arch::x86_64::_mm512_maskz_unpacklo_ps fn">_mm512_maskz_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_xor_epi32.html" title="no_std_compat::arch::x86_64::_mm512_maskz_xor_epi32 fn">_mm512_maskz_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_maskz_xor_epi64.html" title="no_std_compat::arch::x86_64::_mm512_maskz_xor_epi64 fn">_mm512_maskz_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_epi8.html" title="no_std_compat::arch::x86_64::_mm512_max_epi8 fn">_mm512_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_epi16.html" title="no_std_compat::arch::x86_64::_mm512_max_epi16 fn">_mm512_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_epi32.html" title="no_std_compat::arch::x86_64::_mm512_max_epi32 fn">_mm512_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_epi64.html" title="no_std_compat::arch::x86_64::_mm512_max_epi64 fn">_mm512_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_epu8.html" title="no_std_compat::arch::x86_64::_mm512_max_epu8 fn">_mm512_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_epu16.html" title="no_std_compat::arch::x86_64::_mm512_max_epu16 fn">_mm512_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_epu32.html" title="no_std_compat::arch::x86_64::_mm512_max_epu32 fn">_mm512_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_epu64.html" title="no_std_compat::arch::x86_64::_mm512_max_epu64 fn">_mm512_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_pd.html" title="no_std_compat::arch::x86_64::_mm512_max_pd fn">_mm512_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_ps.html" title="no_std_compat::arch::x86_64::_mm512_max_ps fn">_mm512_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_max_round_pd fn">_mm512_max_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_max_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_max_round_ps fn">_mm512_max_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_epi8.html" title="no_std_compat::arch::x86_64::_mm512_min_epi8 fn">_mm512_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_epi16.html" title="no_std_compat::arch::x86_64::_mm512_min_epi16 fn">_mm512_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_epi32.html" title="no_std_compat::arch::x86_64::_mm512_min_epi32 fn">_mm512_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_epi64.html" title="no_std_compat::arch::x86_64::_mm512_min_epi64 fn">_mm512_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_epu8.html" title="no_std_compat::arch::x86_64::_mm512_min_epu8 fn">_mm512_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_epu16.html" title="no_std_compat::arch::x86_64::_mm512_min_epu16 fn">_mm512_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_epu32.html" title="no_std_compat::arch::x86_64::_mm512_min_epu32 fn">_mm512_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_epu64.html" title="no_std_compat::arch::x86_64::_mm512_min_epu64 fn">_mm512_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_pd.html" title="no_std_compat::arch::x86_64::_mm512_min_pd fn">_mm512_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.
Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_ps.html" title="no_std_compat::arch::x86_64::_mm512_min_ps fn">_mm512_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_min_round_pd fn">_mm512_min_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_min_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_min_round_ps fn">_mm512_min_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_movedup_pd.html" title="no_std_compat::arch::x86_64::_mm512_movedup_pd fn">_mm512_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_movehdup_ps.html" title="no_std_compat::arch::x86_64::_mm512_movehdup_ps fn">_mm512_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_moveldup_ps.html" title="no_std_compat::arch::x86_64::_mm512_moveldup_ps fn">_mm512_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_movepi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_movepi8_mask fn">_mm512_movepi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Set each bit of mask register k based on the most significant bit of the corresponding packed 8-bit integer in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_movepi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_movepi16_mask fn">_mm512_movepi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Set each bit of mask register k based on the most significant bit of the corresponding packed 16-bit integer in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_movm_epi8.html" title="no_std_compat::arch::x86_64::_mm512_movm_epi8 fn">_mm512_movm_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Set each packed 8-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_movm_epi16.html" title="no_std_compat::arch::x86_64::_mm512_movm_epi16 fn">_mm512_movm_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mul_epi32 fn">_mm512_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mul_epu32.html" title="no_std_compat::arch::x86_64::_mm512_mul_epu32 fn">_mm512_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mul_pd.html" title="no_std_compat::arch::x86_64::_mm512_mul_pd fn">_mm512_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mul_ps.html" title="no_std_compat::arch::x86_64::_mm512_mul_ps fn">_mm512_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mul_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_mul_round_pd fn">_mm512_mul_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mul_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_mul_round_ps fn">_mm512_mul_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mulhi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mulhi_epi16 fn">_mm512_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mulhi_epu16.html" title="no_std_compat::arch::x86_64::_mm512_mulhi_epu16 fn">_mm512_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mulhrs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mulhrs_epi16 fn">_mm512_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mullo_epi16.html" title="no_std_compat::arch::x86_64::_mm512_mullo_epi16 fn">_mm512_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mullo_epi32.html" title="no_std_compat::arch::x86_64::_mm512_mullo_epi32 fn">_mm512_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_mullox_epi64.html" title="no_std_compat::arch::x86_64::_mm512_mullox_epi64 fn">_mm512_mullox_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiplies elements in packed 64-bit integer vectors a and b together, storing the lower 64 bits of the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_multishift_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm512_multishift_epi64_epi8 fn">_mm512_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_or_epi32.html" title="no_std_compat::arch::x86_64::_mm512_or_epi32 fn">_mm512_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_or_epi64.html" title="no_std_compat::arch::x86_64::_mm512_or_epi64 fn">_mm512_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_or_si512.html" title="no_std_compat::arch::x86_64::_mm512_or_si512 fn">_mm512_or_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of 512 bits (representing integer data) in a and b, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_packs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_packs_epi16 fn">_mm512_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_packs_epi32.html" title="no_std_compat::arch::x86_64::_mm512_packs_epi32 fn">_mm512_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_packus_epi16.html" title="no_std_compat::arch::x86_64::_mm512_packus_epi16 fn">_mm512_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_packus_epi32.html" title="no_std_compat::arch::x86_64::_mm512_packus_epi32 fn">_mm512_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permute_pd.html" title="no_std_compat::arch::x86_64::_mm512_permute_pd fn">_mm512_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permute_ps.html" title="no_std_compat::arch::x86_64::_mm512_permute_ps fn">_mm512_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutevar_epi32.html" title="no_std_compat::arch::x86_64::_mm512_permutevar_epi32 fn">_mm512_permutevar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst. Note that this intrinsic shuffles across 128-bit lanes, unlike past intrinsics that use the permutevar name. This intrinsic is identical to _mm512_permutexvar_epi32, and it is recommended that you use that intrinsic name.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutevar_pd.html" title="no_std_compat::arch::x86_64::_mm512_permutevar_pd fn">_mm512_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutevar_ps.html" title="no_std_compat::arch::x86_64::_mm512_permutevar_ps fn">_mm512_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm512_permutex2var_epi8 fn">_mm512_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm512_permutex2var_epi16 fn">_mm512_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm512_permutex2var_epi32 fn">_mm512_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm512_permutex2var_epi64 fn">_mm512_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm512_permutex2var_pd fn">_mm512_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm512_permutex2var_ps fn">_mm512_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutex_epi64.html" title="no_std_compat::arch::x86_64::_mm512_permutex_epi64 fn">_mm512_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a within 256-bit lanes using the control in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutex_pd.html" title="no_std_compat::arch::x86_64::_mm512_permutex_pd fn">_mm512_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 256-bit lanes using the control in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutexvar_epi8.html" title="no_std_compat::arch::x86_64::_mm512_permutexvar_epi8 fn">_mm512_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutexvar_epi16.html" title="no_std_compat::arch::x86_64::_mm512_permutexvar_epi16 fn">_mm512_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutexvar_epi32.html" title="no_std_compat::arch::x86_64::_mm512_permutexvar_epi32 fn">_mm512_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutexvar_epi64.html" title="no_std_compat::arch::x86_64::_mm512_permutexvar_epi64 fn">_mm512_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutexvar_pd.html" title="no_std_compat::arch::x86_64::_mm512_permutexvar_pd fn">_mm512_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_permutexvar_ps.html" title="no_std_compat::arch::x86_64::_mm512_permutexvar_ps fn">_mm512_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a across lanes using the corresponding index in idx.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_popcnt_epi8.html" title="no_std_compat::arch::x86_64::_mm512_popcnt_epi8 fn">_mm512_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span></div><div class="item-right docblock-short"><p>For each packed 8-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_popcnt_epi16.html" title="no_std_compat::arch::x86_64::_mm512_popcnt_epi16 fn">_mm512_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span></div><div class="item-right docblock-short"><p>For each packed 16-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_popcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm512_popcnt_epi32 fn">_mm512_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span></div><div class="item-right docblock-short"><p>For each packed 32-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_popcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm512_popcnt_epi64 fn">_mm512_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span></div><div class="item-right docblock-short"><p>For each packed 64-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rcp14_pd.html" title="no_std_compat::arch::x86_64::_mm512_rcp14_pd fn">_mm512_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rcp14_ps.html" title="no_std_compat::arch::x86_64::_mm512_rcp14_ps fn">_mm512_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_add_epi32.html" title="no_std_compat::arch::x86_64::_mm512_reduce_add_epi32 fn">_mm512_reduce_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 32-bit integers in a by addition. Returns the sum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_add_epi64.html" title="no_std_compat::arch::x86_64::_mm512_reduce_add_epi64 fn">_mm512_reduce_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 64-bit integers in a by addition. Returns the sum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_add_pd.html" title="no_std_compat::arch::x86_64::_mm512_reduce_add_pd fn">_mm512_reduce_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed double-precision (64-bit) floating-point elements in a by addition. Returns the sum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_add_ps.html" title="no_std_compat::arch::x86_64::_mm512_reduce_add_ps fn">_mm512_reduce_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed single-precision (32-bit) floating-point elements in a by addition. Returns the sum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_and_epi32.html" title="no_std_compat::arch::x86_64::_mm512_reduce_and_epi32 fn">_mm512_reduce_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 32-bit integers in a by bitwise AND. Returns the bitwise AND of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_and_epi64.html" title="no_std_compat::arch::x86_64::_mm512_reduce_and_epi64 fn">_mm512_reduce_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 64-bit integers in a by bitwise AND. Returns the bitwise AND of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_max_epi32.html" title="no_std_compat::arch::x86_64::_mm512_reduce_max_epi32 fn">_mm512_reduce_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed signed 32-bit integers in a by maximum. Returns the maximum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_max_epi64.html" title="no_std_compat::arch::x86_64::_mm512_reduce_max_epi64 fn">_mm512_reduce_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed signed 64-bit integers in a by maximum. Returns the maximum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_max_epu32.html" title="no_std_compat::arch::x86_64::_mm512_reduce_max_epu32 fn">_mm512_reduce_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed unsigned 32-bit integers in a by maximum. Returns the maximum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_max_epu64.html" title="no_std_compat::arch::x86_64::_mm512_reduce_max_epu64 fn">_mm512_reduce_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed unsigned 64-bit integers in a by maximum. Returns the maximum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_max_pd.html" title="no_std_compat::arch::x86_64::_mm512_reduce_max_pd fn">_mm512_reduce_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed double-precision (64-bit) floating-point elements in a by maximum. Returns the maximum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_max_ps.html" title="no_std_compat::arch::x86_64::_mm512_reduce_max_ps fn">_mm512_reduce_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed single-precision (32-bit) floating-point elements in a by maximum. Returns the maximum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_min_epi32.html" title="no_std_compat::arch::x86_64::_mm512_reduce_min_epi32 fn">_mm512_reduce_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed signed 32-bit integers in a by minimum. Returns the minimum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_min_epi64.html" title="no_std_compat::arch::x86_64::_mm512_reduce_min_epi64 fn">_mm512_reduce_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed signed 64-bit integers in a by minimum. Returns the minimum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_min_epu32.html" title="no_std_compat::arch::x86_64::_mm512_reduce_min_epu32 fn">_mm512_reduce_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed unsigned 32-bit integers in a by minimum. Returns the minimum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_min_epu64.html" title="no_std_compat::arch::x86_64::_mm512_reduce_min_epu64 fn">_mm512_reduce_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed unsigned 64-bit integers in a by minimum. Returns the minimum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_min_pd.html" title="no_std_compat::arch::x86_64::_mm512_reduce_min_pd fn">_mm512_reduce_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed double-precision (64-bit) floating-point elements in a by minimum. Returns the minimum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_min_ps.html" title="no_std_compat::arch::x86_64::_mm512_reduce_min_ps fn">_mm512_reduce_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed single-precision (32-bit) floating-point elements in a by minimum. Returns the minimum of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm512_reduce_mul_epi32 fn">_mm512_reduce_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 32-bit integers in a by multiplication. Returns the product of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_mul_epi64.html" title="no_std_compat::arch::x86_64::_mm512_reduce_mul_epi64 fn">_mm512_reduce_mul_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 64-bit integers in a by multiplication. Returns the product of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_mul_pd.html" title="no_std_compat::arch::x86_64::_mm512_reduce_mul_pd fn">_mm512_reduce_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed double-precision (64-bit) floating-point elements in a by multiplication. Returns the product of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_mul_ps.html" title="no_std_compat::arch::x86_64::_mm512_reduce_mul_ps fn">_mm512_reduce_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed single-precision (32-bit) floating-point elements in a by multiplication. Returns the product of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_or_epi32.html" title="no_std_compat::arch::x86_64::_mm512_reduce_or_epi32 fn">_mm512_reduce_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 32-bit integers in a by bitwise OR. Returns the bitwise OR of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_reduce_or_epi64.html" title="no_std_compat::arch::x86_64::_mm512_reduce_or_epi64 fn">_mm512_reduce_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Reduce the packed 64-bit integers in a by bitwise OR. Returns the bitwise OR of all elements in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rol_epi32.html" title="no_std_compat::arch::x86_64::_mm512_rol_epi32 fn">_mm512_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rol_epi64.html" title="no_std_compat::arch::x86_64::_mm512_rol_epi64 fn">_mm512_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rolv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_rolv_epi32 fn">_mm512_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rolv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_rolv_epi64 fn">_mm512_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_ror_epi32.html" title="no_std_compat::arch::x86_64::_mm512_ror_epi32 fn">_mm512_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_ror_epi64.html" title="no_std_compat::arch::x86_64::_mm512_ror_epi64 fn">_mm512_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rorv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_rorv_epi32 fn">_mm512_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rorv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_rorv_epi64 fn">_mm512_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_roundscale_pd.html" title="no_std_compat::arch::x86_64::_mm512_roundscale_pd fn">_mm512_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_roundscale_ps.html" title="no_std_compat::arch::x86_64::_mm512_roundscale_ps fn">_mm512_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_roundscale_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_roundscale_round_pd fn">_mm512_roundscale_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_roundscale_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_roundscale_round_ps fn">_mm512_roundscale_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rsqrt14_pd.html" title="no_std_compat::arch::x86_64::_mm512_rsqrt14_pd fn">_mm512_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_rsqrt14_ps.html" title="no_std_compat::arch::x86_64::_mm512_rsqrt14_ps fn">_mm512_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sad_epu8.html" title="no_std_compat::arch::x86_64::_mm512_sad_epu8 fn">_mm512_sad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the absolute differences of packed unsigned 8-bit integers in a and b, then horizontally sum each consecutive 8 differences to produce eight unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_scalef_pd.html" title="no_std_compat::arch::x86_64::_mm512_scalef_pd fn">_mm512_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_scalef_ps.html" title="no_std_compat::arch::x86_64::_mm512_scalef_ps fn">_mm512_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_scalef_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_scalef_round_pd fn">_mm512_scalef_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_scalef_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_scalef_round_ps fn">_mm512_scalef_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set1_epi8.html" title="no_std_compat::arch::x86_64::_mm512_set1_epi8 fn">_mm512_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast 8-bit integer a to all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set1_epi16.html" title="no_std_compat::arch::x86_64::_mm512_set1_epi16 fn">_mm512_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all all elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set1_epi32.html" title="no_std_compat::arch::x86_64::_mm512_set1_epi32 fn">_mm512_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast 32-bit integer <code>a</code> to all elements of <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set1_epi64.html" title="no_std_compat::arch::x86_64::_mm512_set1_epi64 fn">_mm512_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast 64-bit integer <code>a</code> to all elements of <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set1_pd.html" title="no_std_compat::arch::x86_64::_mm512_set1_pd fn">_mm512_set1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast 64-bit float <code>a</code> to all elements of <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set1_ps.html" title="no_std_compat::arch::x86_64::_mm512_set1_ps fn">_mm512_set1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Broadcast 32-bit float <code>a</code> to all elements of <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set4_epi32.html" title="no_std_compat::arch::x86_64::_mm512_set4_epi32 fn">_mm512_set4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed 32-bit integers in dst with the repeated 4 element sequence.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set4_epi64.html" title="no_std_compat::arch::x86_64::_mm512_set4_epi64 fn">_mm512_set4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed 64-bit integers in dst with the repeated 4 element sequence.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set4_pd.html" title="no_std_compat::arch::x86_64::_mm512_set4_pd fn">_mm512_set4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed double-precision (64-bit) floating-point elements in dst with the repeated 4 element sequence.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set4_ps.html" title="no_std_compat::arch::x86_64::_mm512_set4_ps fn">_mm512_set4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed single-precision (32-bit) floating-point elements in dst with the repeated 4 element sequence.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set_epi8.html" title="no_std_compat::arch::x86_64::_mm512_set_epi8 fn">_mm512_set_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed 8-bit integers in dst with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set_epi16.html" title="no_std_compat::arch::x86_64::_mm512_set_epi16 fn">_mm512_set_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed 16-bit integers in dst with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set_epi32.html" title="no_std_compat::arch::x86_64::_mm512_set_epi32 fn">_mm512_set_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sets packed 32-bit integers in <code>dst</code> with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set_epi64.html" title="no_std_compat::arch::x86_64::_mm512_set_epi64 fn">_mm512_set_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed 64-bit integers in dst with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set_pd.html" title="no_std_compat::arch::x86_64::_mm512_set_pd fn">_mm512_set_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed double-precision (64-bit) floating-point elements in dst with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_set_ps.html" title="no_std_compat::arch::x86_64::_mm512_set_ps fn">_mm512_set_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sets packed 32-bit integers in <code>dst</code> with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setr4_epi32.html" title="no_std_compat::arch::x86_64::_mm512_setr4_epi32 fn">_mm512_setr4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed 32-bit integers in dst with the repeated 4 element sequence in reverse order.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setr4_epi64.html" title="no_std_compat::arch::x86_64::_mm512_setr4_epi64 fn">_mm512_setr4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed 64-bit integers in dst with the repeated 4 element sequence in reverse order.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setr4_pd.html" title="no_std_compat::arch::x86_64::_mm512_setr4_pd fn">_mm512_setr4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed double-precision (64-bit) floating-point elements in dst with the repeated 4 element sequence in reverse order.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setr4_ps.html" title="no_std_compat::arch::x86_64::_mm512_setr4_ps fn">_mm512_setr4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed single-precision (32-bit) floating-point elements in dst with the repeated 4 element sequence in reverse order.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setr_epi32.html" title="no_std_compat::arch::x86_64::_mm512_setr_epi32 fn">_mm512_setr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sets packed 32-bit integers in <code>dst</code> with the supplied values in reverse
order.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setr_epi64.html" title="no_std_compat::arch::x86_64::_mm512_setr_epi64 fn">_mm512_setr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed 64-bit integers in dst with the supplied values in reverse order.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setr_pd.html" title="no_std_compat::arch::x86_64::_mm512_setr_pd fn">_mm512_setr_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Set packed double-precision (64-bit) floating-point elements in dst with the supplied values in reverse order.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setr_ps.html" title="no_std_compat::arch::x86_64::_mm512_setr_ps fn">_mm512_setr_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Sets packed 32-bit integers in <code>dst</code> with the supplied values in
reverse order.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setzero.html" title="no_std_compat::arch::x86_64::_mm512_setzero fn">_mm512_setzero</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Return vector of type __m512 with all elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setzero_epi32.html" title="no_std_compat::arch::x86_64::_mm512_setzero_epi32 fn">_mm512_setzero_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Return vector of type __m512i with all elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setzero_pd.html" title="no_std_compat::arch::x86_64::_mm512_setzero_pd fn">_mm512_setzero_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Returns vector of type <code>__m512d</code> with all elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setzero_ps.html" title="no_std_compat::arch::x86_64::_mm512_setzero_ps fn">_mm512_setzero_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Returns vector of type <code>__m512d</code> with all elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_setzero_si512.html" title="no_std_compat::arch::x86_64::_mm512_setzero_si512 fn">_mm512_setzero_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Returns vector of type <code>__m512i</code> with all elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shldi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_shldi_epi16 fn">_mm512_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shldi_epi32.html" title="no_std_compat::arch::x86_64::_mm512_shldi_epi32 fn">_mm512_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shldi_epi64.html" title="no_std_compat::arch::x86_64::_mm512_shldi_epi64 fn">_mm512_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shldv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_shldv_epi16 fn">_mm512_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shldv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_shldv_epi32 fn">_mm512_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shldv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_shldv_epi64 fn">_mm512_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shrdi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_shrdi_epi16 fn">_mm512_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shrdi_epi32.html" title="no_std_compat::arch::x86_64::_mm512_shrdi_epi32 fn">_mm512_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shrdi_epi64.html" title="no_std_compat::arch::x86_64::_mm512_shrdi_epi64 fn">_mm512_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shrdv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_shrdv_epi16 fn">_mm512_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shrdv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_shrdv_epi32 fn">_mm512_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shrdv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_shrdv_epi64 fn">_mm512_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shuffle_epi8.html" title="no_std_compat::arch::x86_64::_mm512_shuffle_epi8 fn">_mm512_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shuffle_epi32.html" title="no_std_compat::arch::x86_64::_mm512_shuffle_epi32 fn">_mm512_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shuffle_f32x4.html" title="no_std_compat::arch::x86_64::_mm512_shuffle_f32x4 fn">_mm512_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 single-precision (32-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shuffle_f64x2.html" title="no_std_compat::arch::x86_64::_mm512_shuffle_f64x2 fn">_mm512_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 double-precision (64-bit) floating-point elements) selected by imm8 from a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shuffle_i32x4.html" title="no_std_compat::arch::x86_64::_mm512_shuffle_i32x4 fn">_mm512_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 4 32-bit integers) selected by imm8 from a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shuffle_i64x2.html" title="no_std_compat::arch::x86_64::_mm512_shuffle_i64x2 fn">_mm512_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle 128-bits (composed of 2 64-bit integers) selected by imm8 from a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shuffle_pd.html" title="no_std_compat::arch::x86_64::_mm512_shuffle_pd fn">_mm512_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shuffle_ps.html" title="no_std_compat::arch::x86_64::_mm512_shuffle_ps fn">_mm512_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shufflehi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_shufflehi_epi16 fn">_mm512_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from from a to dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_shufflelo_epi16.html" title="no_std_compat::arch::x86_64::_mm512_shufflelo_epi16 fn">_mm512_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from from a to dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sll_epi16.html" title="no_std_compat::arch::x86_64::_mm512_sll_epi16 fn">_mm512_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sll_epi32.html" title="no_std_compat::arch::x86_64::_mm512_sll_epi32 fn">_mm512_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sll_epi64.html" title="no_std_compat::arch::x86_64::_mm512_sll_epi64 fn">_mm512_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_slli_epi16.html" title="no_std_compat::arch::x86_64::_mm512_slli_epi16 fn">_mm512_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_slli_epi32.html" title="no_std_compat::arch::x86_64::_mm512_slli_epi32 fn">_mm512_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_slli_epi64.html" title="no_std_compat::arch::x86_64::_mm512_slli_epi64 fn">_mm512_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sllv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_sllv_epi16 fn">_mm512_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sllv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_sllv_epi32 fn">_mm512_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sllv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_sllv_epi64 fn">_mm512_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sqrt_pd.html" title="no_std_compat::arch::x86_64::_mm512_sqrt_pd fn">_mm512_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sqrt_ps.html" title="no_std_compat::arch::x86_64::_mm512_sqrt_ps fn">_mm512_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sqrt_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_sqrt_round_pd fn">_mm512_sqrt_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sqrt_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_sqrt_round_ps fn">_mm512_sqrt_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sra_epi16.html" title="no_std_compat::arch::x86_64::_mm512_sra_epi16 fn">_mm512_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sra_epi32.html" title="no_std_compat::arch::x86_64::_mm512_sra_epi32 fn">_mm512_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sra_epi64.html" title="no_std_compat::arch::x86_64::_mm512_sra_epi64 fn">_mm512_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srai_epi16.html" title="no_std_compat::arch::x86_64::_mm512_srai_epi16 fn">_mm512_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srai_epi32.html" title="no_std_compat::arch::x86_64::_mm512_srai_epi32 fn">_mm512_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srai_epi64.html" title="no_std_compat::arch::x86_64::_mm512_srai_epi64 fn">_mm512_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srav_epi16.html" title="no_std_compat::arch::x86_64::_mm512_srav_epi16 fn">_mm512_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srav_epi32.html" title="no_std_compat::arch::x86_64::_mm512_srav_epi32 fn">_mm512_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srav_epi64.html" title="no_std_compat::arch::x86_64::_mm512_srav_epi64 fn">_mm512_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srl_epi16.html" title="no_std_compat::arch::x86_64::_mm512_srl_epi16 fn">_mm512_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srl_epi32.html" title="no_std_compat::arch::x86_64::_mm512_srl_epi32 fn">_mm512_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srl_epi64.html" title="no_std_compat::arch::x86_64::_mm512_srl_epi64 fn">_mm512_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srli_epi16.html" title="no_std_compat::arch::x86_64::_mm512_srli_epi16 fn">_mm512_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srli_epi32.html" title="no_std_compat::arch::x86_64::_mm512_srli_epi32 fn">_mm512_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srli_epi64.html" title="no_std_compat::arch::x86_64::_mm512_srli_epi64 fn">_mm512_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srlv_epi16.html" title="no_std_compat::arch::x86_64::_mm512_srlv_epi16 fn">_mm512_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srlv_epi32.html" title="no_std_compat::arch::x86_64::_mm512_srlv_epi32 fn">_mm512_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_srlv_epi64.html" title="no_std_compat::arch::x86_64::_mm512_srlv_epi64 fn">_mm512_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_store_epi32.html" title="no_std_compat::arch::x86_64::_mm512_store_epi32 fn">_mm512_store_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_store_epi64.html" title="no_std_compat::arch::x86_64::_mm512_store_epi64 fn">_mm512_store_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits (composed of 8 packed 64-bit integers) from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_store_pd.html" title="no_std_compat::arch::x86_64::_mm512_store_pd fn">_mm512_store_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_store_ps.html" title="no_std_compat::arch::x86_64::_mm512_store_ps fn">_mm512_store_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits of integer data from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_store_si512.html" title="no_std_compat::arch::x86_64::_mm512_store_si512 fn">_mm512_store_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits of integer data from a into memory. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm512_storeu_epi8 fn">_mm512_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Store 512-bits (composed of 64 packed 8-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm512_storeu_epi16 fn">_mm512_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Store 512-bits (composed of 32 packed 16-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm512_storeu_epi32 fn">_mm512_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_storeu_epi64.html" title="no_std_compat::arch::x86_64::_mm512_storeu_epi64 fn">_mm512_storeu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits (composed of 8 packed 64-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_storeu_pd.html" title="no_std_compat::arch::x86_64::_mm512_storeu_pd fn">_mm512_storeu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Stores 512-bits (composed of 8 packed double-precision (64-bit)
floating-point elements) from <code>a</code> into memory.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_storeu_si512.html" title="no_std_compat::arch::x86_64::_mm512_storeu_si512 fn">_mm512_storeu_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits of integer data from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_stream_pd.html" title="no_std_compat::arch::x86_64::_mm512_stream_pd fn">_mm512_stream_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits (composed of 8 packed double-precision (64-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_stream_ps.html" title="no_std_compat::arch::x86_64::_mm512_stream_ps fn">_mm512_stream_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits (composed of 16 packed single-precision (32-bit) floating-point elements) from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_stream_si512.html" title="no_std_compat::arch::x86_64::_mm512_stream_si512 fn">_mm512_stream_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Store 512-bits of integer data from a into memory using a non-temporal memory hint. mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sub_epi8.html" title="no_std_compat::arch::x86_64::_mm512_sub_epi8 fn">_mm512_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sub_epi16.html" title="no_std_compat::arch::x86_64::_mm512_sub_epi16 fn">_mm512_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sub_epi32.html" title="no_std_compat::arch::x86_64::_mm512_sub_epi32 fn">_mm512_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sub_epi64.html" title="no_std_compat::arch::x86_64::_mm512_sub_epi64 fn">_mm512_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sub_pd.html" title="no_std_compat::arch::x86_64::_mm512_sub_pd fn">_mm512_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sub_ps.html" title="no_std_compat::arch::x86_64::_mm512_sub_ps fn">_mm512_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sub_round_pd.html" title="no_std_compat::arch::x86_64::_mm512_sub_round_pd fn">_mm512_sub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_sub_round_ps.html" title="no_std_compat::arch::x86_64::_mm512_sub_round_ps fn">_mm512_sub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_subs_epi8.html" title="no_std_compat::arch::x86_64::_mm512_subs_epi8 fn">_mm512_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_subs_epi16.html" title="no_std_compat::arch::x86_64::_mm512_subs_epi16 fn">_mm512_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_subs_epu8.html" title="no_std_compat::arch::x86_64::_mm512_subs_epu8 fn">_mm512_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_subs_epu16.html" title="no_std_compat::arch::x86_64::_mm512_subs_epu16 fn">_mm512_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_ternarylogic_epi32.html" title="no_std_compat::arch::x86_64::_mm512_ternarylogic_epi32 fn">_mm512_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_ternarylogic_epi64.html" title="no_std_compat::arch::x86_64::_mm512_ternarylogic_epi64 fn">_mm512_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_test_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_test_epi8_mask fn">_mm512_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_test_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_test_epi16_mask fn">_mm512_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_test_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_test_epi32_mask fn">_mm512_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_test_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_test_epi64_mask fn">_mm512_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_testn_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm512_testn_epi8_mask fn">_mm512_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_testn_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm512_testn_epi16_mask fn">_mm512_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_testn_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm512_testn_epi32_mask fn">_mm512_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_testn_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm512_testn_epi64_mask fn">_mm512_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_undefined.html" title="no_std_compat::arch::x86_64::_mm512_undefined fn">_mm512_undefined</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Return vector of type __m512 with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_undefined_epi32.html" title="no_std_compat::arch::x86_64::_mm512_undefined_epi32 fn">_mm512_undefined_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Return vector of type __m512i with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_undefined_pd.html" title="no_std_compat::arch::x86_64::_mm512_undefined_pd fn">_mm512_undefined_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Returns vector of type <code>__m512d</code> with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_undefined_ps.html" title="no_std_compat::arch::x86_64::_mm512_undefined_ps fn">_mm512_undefined_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Returns vector of type <code>__m512</code> with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpackhi_epi8.html" title="no_std_compat::arch::x86_64::_mm512_unpackhi_epi8 fn">_mm512_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpackhi_epi16.html" title="no_std_compat::arch::x86_64::_mm512_unpackhi_epi16 fn">_mm512_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpackhi_epi32.html" title="no_std_compat::arch::x86_64::_mm512_unpackhi_epi32 fn">_mm512_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpackhi_epi64.html" title="no_std_compat::arch::x86_64::_mm512_unpackhi_epi64 fn">_mm512_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpackhi_pd.html" title="no_std_compat::arch::x86_64::_mm512_unpackhi_pd fn">_mm512_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpackhi_ps.html" title="no_std_compat::arch::x86_64::_mm512_unpackhi_ps fn">_mm512_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpacklo_epi8.html" title="no_std_compat::arch::x86_64::_mm512_unpacklo_epi8 fn">_mm512_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpacklo_epi16.html" title="no_std_compat::arch::x86_64::_mm512_unpacklo_epi16 fn">_mm512_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpacklo_epi32.html" title="no_std_compat::arch::x86_64::_mm512_unpacklo_epi32 fn">_mm512_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpacklo_epi64.html" title="no_std_compat::arch::x86_64::_mm512_unpacklo_epi64 fn">_mm512_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpacklo_pd.html" title="no_std_compat::arch::x86_64::_mm512_unpacklo_pd fn">_mm512_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_unpacklo_ps.html" title="no_std_compat::arch::x86_64::_mm512_unpacklo_ps fn">_mm512_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_xor_epi32.html" title="no_std_compat::arch::x86_64::_mm512_xor_epi32 fn">_mm512_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_xor_epi64.html" title="no_std_compat::arch::x86_64::_mm512_xor_epi64 fn">_mm512_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_xor_si512.html" title="no_std_compat::arch::x86_64::_mm512_xor_si512 fn">_mm512_xor_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of 512 bits (representing integer data) in a and b, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_zextpd128_pd512.html" title="no_std_compat::arch::x86_64::_mm512_zextpd128_pd512 fn">_mm512_zextpd128_pd512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m128d to type __m512d; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_zextpd256_pd512.html" title="no_std_compat::arch::x86_64::_mm512_zextpd256_pd512 fn">_mm512_zextpd256_pd512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m256d to type __m512d; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_zextps128_ps512.html" title="no_std_compat::arch::x86_64::_mm512_zextps128_ps512 fn">_mm512_zextps128_ps512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m128 to type __m512; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_zextps256_ps512.html" title="no_std_compat::arch::x86_64::_mm512_zextps256_ps512 fn">_mm512_zextps256_ps512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m256 to type __m512; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_zextsi128_si512.html" title="no_std_compat::arch::x86_64::_mm512_zextsi128_si512 fn">_mm512_zextsi128_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m128i to type __m512i; the upper 384 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm512_zextsi256_si512.html" title="no_std_compat::arch::x86_64::_mm512_zextsi256_si512 fn">_mm512_zextsi256_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m256i to type __m512i; the upper 256 bits of the result are zeroed. This intrinsic is only used for compilation and does not generate any instructions, thus it has zero latency.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_add_round_sd.html" title="no_std_compat::arch::x86_64::_mm_add_round_sd fn">_mm_add_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_add_round_ss.html" title="no_std_compat::arch::x86_64::_mm_add_round_ss fn">_mm_add_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_alignr_epi32.html" title="no_std_compat::arch::x86_64::_mm_alignr_epi32 fn">_mm_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_alignr_epi64.html" title="no_std_compat::arch::x86_64::_mm_alignr_epi64 fn">_mm_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_bitshuffle_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_bitshuffle_epi64_mask fn">_mm_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.
Then groups 8 8-bit values from <code>c</code>as indices into the the bits of the corresponding 64-bit integer.
It then selects these bits and packs them into the output.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_broadcastmb_epi64.html" title="no_std_compat::arch::x86_64::_mm_broadcastmb_epi64 fn">_mm_broadcastmb_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low 8-bits from input mask k to all 64-bit elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_broadcastmw_epi32.html" title="no_std_compat::arch::x86_64::_mm_broadcastmw_epi32 fn">_mm_broadcastmw_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low 16-bits from input mask k to all 32-bit elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_epi8_mask fn">_mm_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_epi16_mask fn">_mm_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_epi32_mask fn">_mm_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_epi64_mask fn">_mm_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_epu8_mask fn">_mm_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_epu16_mask fn">_mm_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_epu32_mask fn">_mm_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_epu64_mask fn">_mm_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_pd_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_pd_mask fn">_mm_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_ps_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_ps_mask fn">_mm_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_round_sd_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_round_sd_mask fn">_mm_cmp_round_sd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_round_ss_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_round_ss_mask fn">_mm_cmp_round_ss_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_sd_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_sd_mask fn">_mm_cmp_sd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmp_ss_mask.html" title="no_std_compat::arch::x86_64::_mm_cmp_ss_mask fn">_mm_cmp_ss_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpeq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epi8_mask fn">_mm_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpeq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epi16_mask fn">_mm_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpeq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epi32_mask fn">_mm_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpeq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epi64_mask fn">_mm_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpeq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epu8_mask fn">_mm_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpeq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epu16_mask fn">_mm_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpeq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epu32_mask fn">_mm_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpeq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epu64_mask fn">_mm_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpge_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpge_epi8_mask fn">_mm_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpge_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpge_epi16_mask fn">_mm_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpge_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpge_epi32_mask fn">_mm_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpge_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpge_epi64_mask fn">_mm_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpge_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpge_epu8_mask fn">_mm_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpge_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpge_epu16_mask fn">_mm_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpge_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpge_epu32_mask fn">_mm_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpge_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpge_epu64_mask fn">_mm_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpgt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epi8_mask fn">_mm_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpgt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epi16_mask fn">_mm_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpgt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epi32_mask fn">_mm_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpgt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epi64_mask fn">_mm_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpgt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epu8_mask fn">_mm_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpgt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epu16_mask fn">_mm_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpgt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epu32_mask fn">_mm_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpgt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epu64_mask fn">_mm_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmple_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmple_epi8_mask fn">_mm_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmple_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmple_epi16_mask fn">_mm_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmple_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmple_epi32_mask fn">_mm_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmple_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmple_epi64_mask fn">_mm_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmple_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmple_epu8_mask fn">_mm_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmple_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmple_epu16_mask fn">_mm_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmple_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmple_epu32_mask fn">_mm_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmple_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmple_epu64_mask fn">_mm_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmplt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epi8_mask fn">_mm_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmplt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epi16_mask fn">_mm_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmplt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epi32_mask fn">_mm_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmplt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epi64_mask fn">_mm_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmplt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epu8_mask fn">_mm_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmplt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epu16_mask fn">_mm_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmplt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epu32_mask fn">_mm_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmplt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epu64_mask fn">_mm_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpneq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_epi8_mask fn">_mm_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpneq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_epi16_mask fn">_mm_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpneq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_epi32_mask fn">_mm_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpneq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_epi64_mask fn">_mm_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpneq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_epu8_mask fn">_mm_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpneq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_epu16_mask fn">_mm_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpneq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_epu32_mask fn">_mm_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cmpneq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_epu64_mask fn">_mm_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_comi_round_sd.html" title="no_std_compat::arch::x86_64::_mm_comi_round_sd fn">_mm_comi_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_comi_round_ss.html" title="no_std_compat::arch::x86_64::_mm_comi_round_ss fn">_mm_comi_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and return the boolean result (0 or 1).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_conflict_epi32.html" title="no_std_compat::arch::x86_64::_mm_conflict_epi32 fn">_mm_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_conflict_epi64.html" title="no_std_compat::arch::x86_64::_mm_conflict_epi64 fn">_mm_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit. Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundi32_ss.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundi32_ss fn">_mm_cvt_roundi32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundi64_sd.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundi64_sd fn">_mm_cvt_roundi64_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 64-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundi64_ss.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundi64_ss fn">_mm_cvt_roundi64_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 64-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsd_i32.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsd_i32 fn">_mm_cvt_roundsd_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsd_i64.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsd_i64 fn">_mm_cvt_roundsd_i64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 64-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsd_si32.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsd_si32 fn">_mm_cvt_roundsd_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsd_si64.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsd_si64 fn">_mm_cvt_roundsd_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 64-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsd_ss.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsd_ss fn">_mm_cvt_roundsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsd_u32.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsd_u32 fn">_mm_cvt_roundsd_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsd_u64.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsd_u64 fn">_mm_cvt_roundsd_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 64-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsi32_ss.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsi32_ss fn">_mm_cvt_roundsi32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsi64_sd.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsi64_sd fn">_mm_cvt_roundsi64_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 64-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundsi64_ss.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundsi64_ss fn">_mm_cvt_roundsi64_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 64-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundss_i32.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundss_i32 fn">_mm_cvt_roundss_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundss_i64.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundss_i64 fn">_mm_cvt_roundss_i64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 64-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundss_sd.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundss_sd fn">_mm_cvt_roundss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundss_si32.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundss_si32 fn">_mm_cvt_roundss_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundss_si64.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundss_si64 fn">_mm_cvt_roundss_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 64-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundss_u32.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundss_u32 fn">_mm_cvt_roundss_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundss_u64.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundss_u64 fn">_mm_cvt_roundss_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 64-bit integer, and store the result in dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundu32_ss.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundu32_ss fn">_mm_cvt_roundu32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the unsigned 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundu64_sd.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundu64_sd fn">_mm_cvt_roundu64_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the unsigned 64-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvt_roundu64_ss.html" title="no_std_compat::arch::x86_64::_mm_cvt_roundu64_ss fn">_mm_cvt_roundu64_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the unsigned 64-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm_cvtepi16_epi8 fn">_mm_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm_cvtepi32_epi8 fn">_mm_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm_cvtepi32_epi16 fn">_mm_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_cvtepi64_epi8 fn">_mm_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm_cvtepi64_epi16 fn">_mm_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvtepi64_epi32 fn">_mm_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtepu32_pd.html" title="no_std_compat::arch::x86_64::_mm_cvtepu32_pd fn">_mm_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvti32_sd.html" title="no_std_compat::arch::x86_64::_mm_cvti32_sd fn">_mm_cvti32_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvti32_ss.html" title="no_std_compat::arch::x86_64::_mm_cvti32_ss fn">_mm_cvti32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvti64_sd.html" title="no_std_compat::arch::x86_64::_mm_cvti64_sd fn">_mm_cvti64_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 64-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvti64_ss.html" title="no_std_compat::arch::x86_64::_mm_cvti64_ss fn">_mm_cvti64_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the signed 64-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtne2ps_pbh.html" title="no_std_compat::arch::x86_64::_mm_cvtne2ps_pbh fn">_mm_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in two 128-bit vectors
a and b to packed BF16 (16-bit) floating-point elements, and store the results in a
128-bit wide vector.
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651&amp;avx512techs=AVX512_BF16&amp;text=_mm_cvtne2ps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtpd_epu32.html" title="no_std_compat::arch::x86_64::_mm_cvtpd_epu32 fn">_mm_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtph_ps.html" title="no_std_compat::arch::x86_64::_mm_cvtph_ps fn">_mm_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `f16c` only"><code>f16c</code></span></div><div class="item-right docblock-short"><p>Converts the 4 x 16-bit half-precision float values in the lowest 64-bit of
the 128-bit vector <code>a</code> into 4 x 32-bit float values stored in a 128-bit wide
vector.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtps_epu32.html" title="no_std_compat::arch::x86_64::_mm_cvtps_epu32 fn">_mm_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtps_ph.html" title="no_std_compat::arch::x86_64::_mm_cvtps_ph fn">_mm_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `f16c` only"><code>f16c</code></span></div><div class="item-right docblock-short"><p>Converts the 4 x 32-bit float values in the 128-bit vector <code>a</code> into 4 x
16-bit half-precision float values stored in the lowest 64-bit of a 128-bit
vector.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsd_i32.html" title="no_std_compat::arch::x86_64::_mm_cvtsd_i32 fn">_mm_cvtsd_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsd_i64.html" title="no_std_compat::arch::x86_64::_mm_cvtsd_i64 fn">_mm_cvtsd_i64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 64-bit integer, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsd_u32.html" title="no_std_compat::arch::x86_64::_mm_cvtsd_u32 fn">_mm_cvtsd_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsd_u64.html" title="no_std_compat::arch::x86_64::_mm_cvtsd_u64 fn">_mm_cvtsd_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 64-bit integer, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm_cvtsepi16_epi8 fn">_mm_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm_cvtsepi32_epi8 fn">_mm_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm_cvtsepi32_epi16 fn">_mm_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_cvtsepi64_epi8 fn">_mm_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm_cvtsepi64_epi16 fn">_mm_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtsepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvtsepi64_epi32 fn">_mm_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtss_i32.html" title="no_std_compat::arch::x86_64::_mm_cvtss_i32 fn">_mm_cvtss_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtss_i64.html" title="no_std_compat::arch::x86_64::_mm_cvtss_i64 fn">_mm_cvtss_i64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 64-bit integer, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtss_u32.html" title="no_std_compat::arch::x86_64::_mm_cvtss_u32 fn">_mm_cvtss_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtss_u64.html" title="no_std_compat::arch::x86_64::_mm_cvtss_u64 fn">_mm_cvtss_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 64-bit integer, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundsd_i32.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundsd_i32 fn">_mm_cvtt_roundsd_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundsd_i64.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundsd_i64 fn">_mm_cvtt_roundsd_i64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 64-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundsd_si32.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundsd_si32 fn">_mm_cvtt_roundsd_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundsd_si64.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundsd_si64 fn">_mm_cvtt_roundsd_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 64-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundsd_u32.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundsd_u32 fn">_mm_cvtt_roundsd_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundsd_u64.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundsd_u64 fn">_mm_cvtt_roundsd_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 64-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundss_i32.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundss_i32 fn">_mm_cvtt_roundss_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundss_i64.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundss_i64 fn">_mm_cvtt_roundss_i64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 64-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundss_si32.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundss_si32 fn">_mm_cvtt_roundss_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundss_si64.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundss_si64 fn">_mm_cvtt_roundss_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 64-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundss_u32.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundss_u32 fn">_mm_cvtt_roundss_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtt_roundss_u64.html" title="no_std_compat::arch::x86_64::_mm_cvtt_roundss_u64 fn">_mm_cvtt_roundss_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 64-bit integer with truncation, and store the result in dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttpd_epu32.html" title="no_std_compat::arch::x86_64::_mm_cvttpd_epu32 fn">_mm_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttps_epu32.html" title="no_std_compat::arch::x86_64::_mm_cvttps_epu32 fn">_mm_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttsd_i32.html" title="no_std_compat::arch::x86_64::_mm_cvttsd_i32 fn">_mm_cvttsd_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttsd_i64.html" title="no_std_compat::arch::x86_64::_mm_cvttsd_i64 fn">_mm_cvttsd_i64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to a 64-bit integer with truncation, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttsd_u32.html" title="no_std_compat::arch::x86_64::_mm_cvttsd_u32 fn">_mm_cvttsd_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttsd_u64.html" title="no_std_compat::arch::x86_64::_mm_cvttsd_u64 fn">_mm_cvttsd_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in a to an unsigned 64-bit integer with truncation, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttss_i32.html" title="no_std_compat::arch::x86_64::_mm_cvttss_i32 fn">_mm_cvttss_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 32-bit integer with truncation, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttss_i64.html" title="no_std_compat::arch::x86_64::_mm_cvttss_i64 fn">_mm_cvttss_i64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to a 64-bit integer with truncation, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttss_u32.html" title="no_std_compat::arch::x86_64::_mm_cvttss_u32 fn">_mm_cvttss_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 32-bit integer with truncation, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvttss_u64.html" title="no_std_compat::arch::x86_64::_mm_cvttss_u64 fn">_mm_cvttss_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in a to an unsigned 64-bit integer with truncation, and store the result in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtu32_sd.html" title="no_std_compat::arch::x86_64::_mm_cvtu32_sd fn">_mm_cvtu32_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the unsigned 32-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtu32_ss.html" title="no_std_compat::arch::x86_64::_mm_cvtu32_ss fn">_mm_cvtu32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the unsigned 32-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtu64_sd.html" title="no_std_compat::arch::x86_64::_mm_cvtu64_sd fn">_mm_cvtu64_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the unsigned 64-bit integer b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtu64_ss.html" title="no_std_compat::arch::x86_64::_mm_cvtu64_ss fn">_mm_cvtu64_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the unsigned 64-bit integer b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtusepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm_cvtusepi16_epi8 fn">_mm_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtusepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm_cvtusepi32_epi8 fn">_mm_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtusepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm_cvtusepi32_epi16 fn">_mm_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtusepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_cvtusepi64_epi8 fn">_mm_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtusepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm_cvtusepi64_epi16 fn">_mm_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_cvtusepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvtusepi64_epi32 fn">_mm_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_dbsad_epu8.html" title="no_std_compat::arch::x86_64::_mm_dbsad_epu8 fn">_mm_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst. Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_div_round_sd.html" title="no_std_compat::arch::x86_64::_mm_div_round_sd fn">_mm_div_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_div_round_ss.html" title="no_std_compat::arch::x86_64::_mm_div_round_ss fn">_mm_div_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_dpbf16_ps.html" title="no_std_compat::arch::x86_64::_mm_dpbf16_ps fn">_mm_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,
accumulating the intermediate single-precision (32-bit) floating-point elements
with elements in src, and store the results in dst.
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm_dpbf16_ps">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_dpbusd_epi32.html" title="no_std_compat::arch::x86_64::_mm_dpbusd_epi32 fn">_mm_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_dpbusds_epi32.html" title="no_std_compat::arch::x86_64::_mm_dpbusds_epi32 fn">_mm_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_dpwssd_epi32.html" title="no_std_compat::arch::x86_64::_mm_dpwssd_epi32 fn">_mm_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_dpwssds_epi32.html" title="no_std_compat::arch::x86_64::_mm_dpwssds_epi32 fn">_mm_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fixupimm_pd.html" title="no_std_compat::arch::x86_64::_mm_fixupimm_pd fn">_mm_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fixupimm_ps.html" title="no_std_compat::arch::x86_64::_mm_fixupimm_ps fn">_mm_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fixupimm_round_sd.html" title="no_std_compat::arch::x86_64::_mm_fixupimm_round_sd fn">_mm_fixupimm_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fixupimm_round_ss.html" title="no_std_compat::arch::x86_64::_mm_fixupimm_round_ss fn">_mm_fixupimm_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fixupimm_sd.html" title="no_std_compat::arch::x86_64::_mm_fixupimm_sd fn">_mm_fixupimm_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fixupimm_ss.html" title="no_std_compat::arch::x86_64::_mm_fixupimm_ss fn">_mm_fixupimm_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fmadd_round_sd.html" title="no_std_compat::arch::x86_64::_mm_fmadd_round_sd fn">_mm_fmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fmadd_round_ss.html" title="no_std_compat::arch::x86_64::_mm_fmadd_round_ss fn">_mm_fmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fmsub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_fmsub_round_sd fn">_mm_fmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fmsub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_fmsub_round_ss fn">_mm_fmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fnmadd_round_sd.html" title="no_std_compat::arch::x86_64::_mm_fnmadd_round_sd fn">_mm_fnmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fnmadd_round_ss.html" title="no_std_compat::arch::x86_64::_mm_fnmadd_round_ss fn">_mm_fnmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fnmsub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_fnmsub_round_sd fn">_mm_fnmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_fnmsub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_fnmsub_round_ss fn">_mm_fnmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getexp_pd.html" title="no_std_compat::arch::x86_64::_mm_getexp_pd fn">_mm_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getexp_ps.html" title="no_std_compat::arch::x86_64::_mm_getexp_ps fn">_mm_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst. This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getexp_round_sd.html" title="no_std_compat::arch::x86_64::_mm_getexp_round_sd fn">_mm_getexp_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getexp_round_ss.html" title="no_std_compat::arch::x86_64::_mm_getexp_round_ss fn">_mm_getexp_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getexp_sd.html" title="no_std_compat::arch::x86_64::_mm_getexp_sd fn">_mm_getexp_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getexp_ss.html" title="no_std_compat::arch::x86_64::_mm_getexp_ss fn">_mm_getexp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getmant_pd.html" title="no_std_compat::arch::x86_64::_mm_getmant_pd fn">_mm_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getmant_ps.html" title="no_std_compat::arch::x86_64::_mm_getmant_ps fn">_mm_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.
The mantissa is normalized to the interval specified by interv, which can take the following values:
_MM_MANT_NORM_1_2     // interval [1, 2)
_MM_MANT_NORM_p5_2    // interval [0.5, 2)
_MM_MANT_NORM_p5_1    // interval [0.5, 1)
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)
The sign is determined by sc which can take the following values:
_MM_MANT_SIGN_src     // sign = sign(src)
_MM_MANT_SIGN_zero    // sign = 0
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getmant_round_sd.html" title="no_std_compat::arch::x86_64::_mm_getmant_round_sd fn">_mm_getmant_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getmant_round_ss.html" title="no_std_compat::arch::x86_64::_mm_getmant_round_ss fn">_mm_getmant_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getmant_sd.html" title="no_std_compat::arch::x86_64::_mm_getmant_sd fn">_mm_getmant_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_getmant_ss.html" title="no_std_compat::arch::x86_64::_mm_getmant_ss fn">_mm_getmant_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_gf2p8affine_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_gf2p8affine_epi64_epi8 fn">_mm_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the packed bytes in x.
That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_gf2p8affineinv_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_gf2p8affineinv_epi64_epi8 fn">_mm_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the inverted packed bytes in x.
That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.
The inverse of 0 is 0.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_gf2p8mul_epi8.html" title="no_std_compat::arch::x86_64::_mm_gf2p8mul_epi8 fn">_mm_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs a multiplication in GF(2^8) on the packed bytes.
The field is in polynomial representation with the reduction polynomial
x^8 + x^4 + x^3 + x + 1.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_load_epi32.html" title="no_std_compat::arch::x86_64::_mm_load_epi32 fn">_mm_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 128-bits (composed of 4 packed 32-bit integers) from memory into dst. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_load_epi64.html" title="no_std_compat::arch::x86_64::_mm_load_epi64 fn">_mm_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 128-bits (composed of 2 packed 64-bit integers) from memory into dst. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_loadu_epi8.html" title="no_std_compat::arch::x86_64::_mm_loadu_epi8 fn">_mm_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 128-bits (composed of 16 packed 8-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_loadu_epi16.html" title="no_std_compat::arch::x86_64::_mm_loadu_epi16 fn">_mm_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 128-bits (composed of 8 packed 16-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_loadu_epi32.html" title="no_std_compat::arch::x86_64::_mm_loadu_epi32 fn">_mm_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 128-bits (composed of 4 packed 32-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_loadu_epi64.html" title="no_std_compat::arch::x86_64::_mm_loadu_epi64 fn">_mm_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load 128-bits (composed of 2 packed 64-bit integers) from memory into dst. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_lzcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm_lzcnt_epi32 fn">_mm_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_lzcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm_lzcnt_epi64 fn">_mm_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_madd52hi_epu64.html" title="no_std_compat::arch::x86_64::_mm_madd52hi_epu64 fn">_mm_madd52hi_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma,avx512vl` only"><code>avx512ifma,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 52-bit integers in each 64-bit element of
<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the high 52-bit
unsigned integer from the intermediate result with the
corresponding unsigned 64-bit integer in <code>a</code>, and store the
results in <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_madd52lo_epu64.html" title="no_std_compat::arch::x86_64::_mm_madd52lo_epu64 fn">_mm_madd52lo_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma,avx512vl` only"><code>avx512ifma,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 52-bit integers in each 64-bit element of
<code>b</code> and <code>c</code> to form a 104-bit intermediate result. Add the low 52-bit
unsigned integer from the intermediate result with the
corresponding unsigned 64-bit integer in <code>a</code>, and store the
results in <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask2_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask2_permutex2var_epi8 fn">_mm_mask2_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask2_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask2_permutex2var_epi16 fn">_mm_mask2_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask2_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask2_permutex2var_epi32 fn">_mm_mask2_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask2_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask2_permutex2var_epi64 fn">_mm_mask2_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask2_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm_mask2_permutex2var_pd fn">_mm_mask2_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set)</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask2_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm_mask2_permutex2var_ps fn">_mm_mask2_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from idx when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmadd_pd fn">_mm_mask3_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmadd_ps fn">_mm_mask3_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmadd_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmadd_round_sd fn">_mm_mask3_fmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmadd_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmadd_round_ss fn">_mm_mask3_fmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmadd_sd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmadd_sd fn">_mm_mask3_fmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmadd_ss.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmadd_ss fn">_mm_mask3_fmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmaddsub_pd fn">_mm_mask3_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmaddsub_ps fn">_mm_mask3_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmsub_pd fn">_mm_mask3_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmsub_ps fn">_mm_mask3_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmsub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmsub_round_sd fn">_mm_mask3_fmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmsub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmsub_round_ss fn">_mm_mask3_fmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmsub_sd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmsub_sd fn">_mm_mask3_fmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmsub_ss.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmsub_ss fn">_mm_mask3_fmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmsubadd_pd fn">_mm_mask3_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm_mask3_fmsubadd_ps fn">_mm_mask3_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmadd_pd fn">_mm_mask3_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmadd_ps fn">_mm_mask3_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmadd_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmadd_round_sd fn">_mm_mask3_fnmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmadd_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmadd_round_ss fn">_mm_mask3_fnmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmadd_sd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmadd_sd fn">_mm_mask3_fnmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmadd_ss.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmadd_ss fn">_mm_mask3_fnmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmsub_pd fn">_mm_mask3_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmsub_ps fn">_mm_mask3_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from c when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmsub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmsub_round_sd fn">_mm_mask3_fnmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmsub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmsub_round_ss fn">_mm_mask3_fnmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmsub_sd.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmsub_sd fn">_mm_mask3_fnmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from c to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask3_fnmsub_ss.html" title="no_std_compat::arch::x86_64::_mm_mask3_fnmsub_ss fn">_mm_mask3_fnmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from c to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_abs_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_abs_epi8 fn">_mm_mask_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set)</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_abs_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_abs_epi16 fn">_mm_mask_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_abs_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_abs_epi32 fn">_mm_mask_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_add_epi8 fn">_mm_mask_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_add_epi16 fn">_mm_mask_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_add_epi32 fn">_mm_mask_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_add_epi64 fn">_mm_mask_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_add_pd fn">_mm_mask_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_add_ps fn">_mm_mask_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_add_round_sd fn">_mm_mask_add_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_add_round_ss fn">_mm_mask_add_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_add_sd fn">_mm_mask_add_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_add_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_add_ss fn">_mm_mask_add_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_adds_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_adds_epi8 fn">_mm_mask_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_adds_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_adds_epi16 fn">_mm_mask_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_adds_epu8.html" title="no_std_compat::arch::x86_64::_mm_mask_adds_epu8 fn">_mm_mask_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_adds_epu16.html" title="no_std_compat::arch::x86_64::_mm_mask_adds_epu16 fn">_mm_mask_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_alignr_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_alignr_epi8 fn">_mm_mask_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_alignr_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_alignr_epi32 fn">_mm_mask_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_alignr_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_alignr_epi64 fn">_mm_mask_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_and_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_and_epi32 fn">_mm_mask_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs element-by-element bitwise AND between packed 32-bit integer elements of a and b, storing the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_and_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_and_epi64 fn">_mm_mask_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_andnot_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_andnot_epi32 fn">_mm_mask_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_andnot_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_andnot_epi64 fn">_mm_mask_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_avg_epu8.html" title="no_std_compat::arch::x86_64::_mm_mask_avg_epu8 fn">_mm_mask_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 8-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_avg_epu16.html" title="no_std_compat::arch::x86_64::_mm_mask_avg_epu16 fn">_mm_mask_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 16-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_bitshuffle_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_bitshuffle_epi64_mask fn">_mm_mask_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>Considers the input <code>b</code> as packed 64-bit integers and <code>c</code> as packed 8-bit integers.
Then groups 8 8-bit values from <code>c</code>as indices into the the bits of the corresponding 64-bit integer.
It then selects these bits and packs them into the output.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_blend_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_blend_epi8 fn">_mm_mask_blend_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed 8-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_blend_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_blend_epi16 fn">_mm_mask_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed 16-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_blend_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_blend_epi32 fn">_mm_mask_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed 32-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_blend_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_blend_epi64 fn">_mm_mask_blend_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed 64-bit integers from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_blend_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_blend_pd fn">_mm_mask_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed double-precision (64-bit) floating-point elements from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_blend_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_blend_ps fn">_mm_mask_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Blend packed single-precision (32-bit) floating-point elements from a and b using control mask k, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_broadcastb_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_broadcastb_epi8 fn">_mm_mask_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 8-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_broadcastd_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_broadcastd_epi32 fn">_mm_mask_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 32-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_broadcastq_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_broadcastq_epi64 fn">_mm_mask_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 64-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_broadcastss_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_broadcastss_ps fn">_mm_mask_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_broadcastw_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_broadcastw_epi16 fn">_mm_mask_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_epi8_mask fn">_mm_mask_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_epi16_mask fn">_mm_mask_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_epi32_mask fn">_mm_mask_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_epi64_mask fn">_mm_mask_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_epu8_mask fn">_mm_mask_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_epu16_mask fn">_mm_mask_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_epu32_mask fn">_mm_mask_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_epu64_mask fn">_mm_mask_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_pd_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_pd_mask fn">_mm_mask_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_ps_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_ps_mask fn">_mm_mask_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b based on the comparison operand specified by imm8, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_round_sd_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_round_sd_mask fn">_mm_mask_cmp_round_sd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_round_ss_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_round_ss_mask fn">_mm_mask_cmp_round_ss_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not seti).<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_sd_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_sd_mask fn">_mm_mask_cmp_sd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmp_ss_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmp_ss_mask fn">_mm_mask_cmp_ss_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point element in a and b based on the comparison operand specified by imm8, and store the result in mask vector k using zeromask k1 (the element is zeroed out when mask bit 0 is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpeq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpeq_epi8_mask fn">_mm_mask_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpeq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpeq_epi16_mask fn">_mm_mask_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpeq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpeq_epi32_mask fn">_mm_mask_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpeq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpeq_epi64_mask fn">_mm_mask_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpeq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpeq_epu8_mask fn">_mm_mask_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpeq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpeq_epu16_mask fn">_mm_mask_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpeq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpeq_epu32_mask fn">_mm_mask_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpeq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpeq_epu64_mask fn">_mm_mask_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for equality, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpge_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpge_epi8_mask fn">_mm_mask_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpge_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpge_epi16_mask fn">_mm_mask_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpge_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpge_epi32_mask fn">_mm_mask_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpge_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpge_epi64_mask fn">_mm_mask_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpge_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpge_epu8_mask fn">_mm_mask_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpge_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpge_epu16_mask fn">_mm_mask_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpge_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpge_epu32_mask fn">_mm_mask_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpge_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpge_epu64_mask fn">_mm_mask_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpgt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpgt_epi8_mask fn">_mm_mask_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpgt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpgt_epi16_mask fn">_mm_mask_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpgt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpgt_epi32_mask fn">_mm_mask_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpgt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpgt_epi64_mask fn">_mm_mask_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpgt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpgt_epu8_mask fn">_mm_mask_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpgt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpgt_epu16_mask fn">_mm_mask_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpgt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpgt_epu32_mask fn">_mm_mask_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpgt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpgt_epu64_mask fn">_mm_mask_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for greater-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmple_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmple_epi8_mask fn">_mm_mask_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmple_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmple_epi16_mask fn">_mm_mask_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmple_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmple_epi32_mask fn">_mm_mask_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmple_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmple_epi64_mask fn">_mm_mask_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmple_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmple_epu8_mask fn">_mm_mask_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmple_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmple_epu16_mask fn">_mm_mask_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmple_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmple_epu32_mask fn">_mm_mask_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmple_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmple_epu64_mask fn">_mm_mask_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmplt_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmplt_epi8_mask fn">_mm_mask_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmplt_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmplt_epi16_mask fn">_mm_mask_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmplt_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmplt_epi32_mask fn">_mm_mask_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmplt_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmplt_epi64_mask fn">_mm_mask_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmplt_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmplt_epu8_mask fn">_mm_mask_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmplt_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmplt_epu16_mask fn">_mm_mask_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmplt_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmplt_epu32_mask fn">_mm_mask_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for less-than-or-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmplt_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmplt_epu64_mask fn">_mm_mask_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for less-than, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpneq_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpneq_epi8_mask fn">_mm_mask_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpneq_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpneq_epi16_mask fn">_mm_mask_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpneq_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpneq_epi32_mask fn">_mm_mask_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpneq_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpneq_epi64_mask fn">_mm_mask_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpneq_epu8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpneq_epu8_mask fn">_mm_mask_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpneq_epu16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpneq_epu16_mask fn">_mm_mask_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpneq_epu32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpneq_epu32_mask fn">_mm_mask_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cmpneq_epu64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_cmpneq_epu64_mask fn">_mm_mask_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b for not-equal, and store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compress_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_compress_epi8 fn">_mm_mask_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compress_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_compress_epi16 fn">_mm_mask_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compress_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_compress_epi32 fn">_mm_mask_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compress_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_compress_epi64 fn">_mm_mask_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compress_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_compress_pd fn">_mm_mask_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compress_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_compress_ps fn">_mm_mask_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to dst, and pass through the remaining elements from src.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compressstoreu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_compressstoreu_epi8 fn">_mm_mask_compressstoreu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 8-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compressstoreu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_compressstoreu_epi16 fn">_mm_mask_compressstoreu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 16-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compressstoreu_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_compressstoreu_epi32 fn">_mm_mask_compressstoreu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compressstoreu_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_compressstoreu_epi64 fn">_mm_mask_compressstoreu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 64-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compressstoreu_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_compressstoreu_pd fn">_mm_mask_compressstoreu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_compressstoreu_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_compressstoreu_ps fn">_mm_mask_compressstoreu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_conflict_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_conflict_epi32 fn">_mm_mask_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_conflict_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_conflict_epi64 fn">_mm_mask_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using writemask k (elements are copied from src when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvt_roundps_ph.html" title="no_std_compat::arch::x86_64::_mm_mask_cvt_roundps_ph fn">_mm_mask_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvt_roundsd_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_cvt_roundsd_ss fn">_mm_mask_cvt_roundsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvt_roundss_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_cvt_roundss_sd fn">_mm_mask_cvt_roundss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi8_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi8_epi16 fn">_mm_mask_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi8_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi8_epi32 fn">_mm_mask_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi8_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi8_epi64 fn">_mm_mask_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi16_epi8 fn">_mm_mask_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi16_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi16_epi32 fn">_mm_mask_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi16_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi16_epi64 fn">_mm_mask_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi16_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi16_storeu_epi8 fn">_mm_mask_cvtepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi32_epi8 fn">_mm_mask_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi32_epi16 fn">_mm_mask_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi32_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi32_epi64 fn">_mm_mask_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi32_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi32_pd fn">_mm_mask_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi32_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi32_ps fn">_mm_mask_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi32_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi32_storeu_epi8 fn">_mm_mask_cvtepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi32_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi32_storeu_epi16 fn">_mm_mask_cvtepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi64_epi8 fn">_mm_mask_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi64_epi16 fn">_mm_mask_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi64_epi32 fn">_mm_mask_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi64_storeu_epi8 fn">_mm_mask_cvtepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi64_storeu_epi16 fn">_mm_mask_cvtepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepi64_storeu_epi32 fn">_mm_mask_cvtepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepu8_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepu8_epi16 fn">_mm_mask_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepu8_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepu8_epi32 fn">_mm_mask_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 4 bytes of a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepu8_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepu8_epi64 fn">_mm_mask_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepu16_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepu16_epi32 fn">_mm_mask_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepu16_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepu16_epi64 fn">_mm_mask_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepu32_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepu32_epi64 fn">_mm_mask_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtepu32_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtepu32_pd fn">_mm_mask_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtne2ps_pbh.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtne2ps_pbh fn">_mm_mask_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in two vectors
a and b to packed BF16 (16-bit) floating-point elements, and store the results
in single vector dst using writemask k (elements are copied from src when the
corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651&amp;avx512techs=AVX512_BF16&amp;text=_mm_mask_cvtne2ps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtpd_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtpd_epi32 fn">_mm_mask_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtpd_epu32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtpd_epu32 fn">_mm_mask_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtpd_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtpd_ps fn">_mm_mask_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtph_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtph_ps fn">_mm_mask_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtps_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtps_epi32 fn">_mm_mask_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtps_epu32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtps_epu32 fn">_mm_mask_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtps_ph.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtps_ph fn">_mm_mask_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsd_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsd_ss fn">_mm_mask_cvtsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi16_epi8 fn">_mm_mask_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi16_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi16_storeu_epi8 fn">_mm_mask_cvtsepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi32_epi8 fn">_mm_mask_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi32_epi16 fn">_mm_mask_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi32_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi32_storeu_epi8 fn">_mm_mask_cvtsepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi32_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi32_storeu_epi16 fn">_mm_mask_cvtsepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi64_epi8 fn">_mm_mask_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi64_epi16 fn">_mm_mask_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi64_epi32 fn">_mm_mask_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi64_storeu_epi8 fn">_mm_mask_cvtsepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi64_storeu_epi16 fn">_mm_mask_cvtsepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtsepi64_storeu_epi32 fn">_mm_mask_cvtsepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtss_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtss_sd fn">_mm_mask_cvtss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvttpd_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvttpd_epi32 fn">_mm_mask_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvttpd_epu32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvttpd_epu32 fn">_mm_mask_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvttps_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvttps_epi32 fn">_mm_mask_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvttps_epu32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvttps_epu32 fn">_mm_mask_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi16_epi8 fn">_mm_mask_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi16_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi16_storeu_epi8 fn">_mm_mask_cvtusepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi32_epi8 fn">_mm_mask_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi32_epi16 fn">_mm_mask_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi32_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi32_storeu_epi8 fn">_mm_mask_cvtusepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi32_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi32_storeu_epi16 fn">_mm_mask_cvtusepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi64_epi8 fn">_mm_mask_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi64_epi16 fn">_mm_mask_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi64_epi32 fn">_mm_mask_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi64_storeu_epi8 fn">_mm_mask_cvtusepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed 8-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi64_storeu_epi16 fn">_mm_mask_cvtusepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed 16-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_cvtusepi64_storeu_epi32 fn">_mm_mask_cvtusepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed 32-bit integers with unsigned saturation, and store the active results (those with their respective bit set in writemask k) to unaligned memory at base_addr.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_dbsad_epu8.html" title="no_std_compat::arch::x86_64::_mm_mask_dbsad_epu8 fn">_mm_mask_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_div_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_div_pd fn">_mm_mask_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_div_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_div_ps fn">_mm_mask_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_div_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_div_round_sd fn">_mm_mask_div_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_div_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_div_round_ss fn">_mm_mask_div_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_div_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_div_sd fn">_mm_mask_div_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_div_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_div_ss fn">_mm_mask_div_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_dpbf16_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_dpbf16_ps fn">_mm_mask_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,
accumulating the intermediate single-precision (32-bit) floating-point elements
with elements in src, and store the results in dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm_mask_dpbf16_ps">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_dpbusd_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_dpbusd_epi32 fn">_mm_mask_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_dpbusds_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_dpbusds_epi32 fn">_mm_mask_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_dpwssd_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_dpwssd_epi32 fn">_mm_mask_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_dpwssds_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_dpwssds_epi32 fn">_mm_mask_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expand_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_expand_epi8 fn">_mm_mask_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expand_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_expand_epi16 fn">_mm_mask_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expand_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_expand_epi32 fn">_mm_mask_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expand_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_expand_epi64 fn">_mm_mask_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expand_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_expand_pd fn">_mm_mask_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expand_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_expand_ps fn">_mm_mask_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expandloadu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_expandloadu_epi8 fn">_mm_mask_expandloadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only"><code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expandloadu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_expandloadu_epi16 fn">_mm_mask_expandloadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only"><code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expandloadu_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_expandloadu_epi32 fn">_mm_mask_expandloadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expandloadu_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_expandloadu_epi64 fn">_mm_mask_expandloadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expandloadu_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_expandloadu_pd fn">_mm_mask_expandloadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_expandloadu_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_expandloadu_ps fn">_mm_mask_expandloadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fixupimm_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_fixupimm_pd fn">_mm_mask_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fixupimm_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_fixupimm_ps fn">_mm_mask_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fixupimm_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fixupimm_round_sd fn">_mm_mask_fixupimm_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fixupimm_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fixupimm_round_ss fn">_mm_mask_fixupimm_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fixupimm_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fixupimm_sd fn">_mm_mask_fixupimm_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fixupimm_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fixupimm_ss fn">_mm_mask_fixupimm_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_fmadd_pd fn">_mm_mask_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_fmadd_ps fn">_mm_mask_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmadd_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fmadd_round_sd fn">_mm_mask_fmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmadd_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fmadd_round_ss fn">_mm_mask_fmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmadd_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fmadd_sd fn">_mm_mask_fmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmadd_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fmadd_ss fn">_mm_mask_fmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_fmaddsub_pd fn">_mm_mask_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_fmaddsub_ps fn">_mm_mask_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_fmsub_pd fn">_mm_mask_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_fmsub_ps fn">_mm_mask_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmsub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fmsub_round_sd fn">_mm_mask_fmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmsub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fmsub_round_ss fn">_mm_mask_fmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmsub_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fmsub_sd fn">_mm_mask_fmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmsub_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fmsub_ss fn">_mm_mask_fmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_fmsubadd_pd fn">_mm_mask_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_fmsubadd_ps fn">_mm_mask_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmadd_pd fn">_mm_mask_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmadd_ps fn">_mm_mask_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmadd_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmadd_round_sd fn">_mm_mask_fnmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmadd_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmadd_round_ss fn">_mm_mask_fnmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmadd_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmadd_sd fn">_mm_mask_fnmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmadd_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmadd_ss fn">_mm_mask_fnmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using writemask k (the element is copied from a when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmsub_pd fn">_mm_mask_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmsub_ps fn">_mm_mask_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmsub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmsub_round_sd fn">_mm_mask_fnmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmsub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmsub_round_ss fn">_mm_mask_fnmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmsub_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmsub_sd fn">_mm_mask_fnmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_fnmsub_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_fnmsub_ss fn">_mm_mask_fnmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using writemask k (the element is copied from c when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getexp_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_getexp_pd fn">_mm_mask_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getexp_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_getexp_ps fn">_mm_mask_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getexp_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_getexp_round_sd fn">_mm_mask_getexp_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getexp_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_getexp_round_ss fn">_mm_mask_getexp_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getexp_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_getexp_sd fn">_mm_mask_getexp_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getexp_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_getexp_ss fn">_mm_mask_getexp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getmant_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_getmant_pd fn">_mm_mask_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getmant_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_getmant_ps fn">_mm_mask_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getmant_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_getmant_round_sd fn">_mm_mask_getmant_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getmant_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_getmant_round_ss fn">_mm_mask_getmant_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getmant_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_getmant_sd fn">_mm_mask_getmant_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_getmant_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_getmant_ss fn">_mm_mask_getmant_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_gf2p8affine_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_gf2p8affine_epi64_epi8 fn">_mm_mask_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the packed bytes in x.
That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_gf2p8affineinv_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_gf2p8affineinv_epi64_epi8 fn">_mm_mask_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the inverted packed bytes in x.
That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.
The inverse of 0 is 0.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_gf2p8mul_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_gf2p8mul_epi8 fn">_mm_mask_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs a multiplication in GF(2^8) on the packed bytes.
The field is in polynomial representation with the reduction polynomial
x^8 + x^4 + x^3 + x + 1.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_load_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_load_epi32 fn">_mm_mask_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_load_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_load_epi64 fn">_mm_mask_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_load_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_load_pd fn">_mm_mask_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_load_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_load_ps fn">_mm_mask_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_loadu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_loadu_epi8 fn">_mm_mask_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx,sse` only"><code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 8-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_loadu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_loadu_epi16 fn">_mm_mask_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx,sse` only"><code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 16-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_loadu_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_loadu_epi32 fn">_mm_mask_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_loadu_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_loadu_epi64 fn">_mm_mask_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_loadu_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_loadu_pd fn">_mm_mask_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_loadu_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_loadu_ps fn">_mm_mask_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using writemask k
(elements are copied from src when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_lzcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_lzcnt_epi32 fn">_mm_mask_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_lzcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_lzcnt_epi64 fn">_mm_mask_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_madd_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_madd_epi16 fn">_mm_mask_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_maddubs_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_maddubs_epi16 fn">_mm_mask_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_max_epi8 fn">_mm_mask_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_max_epi16 fn">_mm_mask_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_max_epi32 fn">_mm_mask_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_max_epi64 fn">_mm_mask_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_epu8.html" title="no_std_compat::arch::x86_64::_mm_mask_max_epu8 fn">_mm_mask_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_epu16.html" title="no_std_compat::arch::x86_64::_mm_mask_max_epu16 fn">_mm_mask_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_epu32.html" title="no_std_compat::arch::x86_64::_mm_mask_max_epu32 fn">_mm_mask_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_epu64.html" title="no_std_compat::arch::x86_64::_mm_mask_max_epu64 fn">_mm_mask_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_max_pd fn">_mm_mask_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_max_ps fn">_mm_mask_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_max_round_sd fn">_mm_mask_max_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_max_round_ss fn">_mm_mask_max_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_max_sd fn">_mm_mask_max_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_max_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_max_ss fn">_mm_mask_max_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_min_epi8 fn">_mm_mask_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_min_epi16 fn">_mm_mask_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_min_epi32 fn">_mm_mask_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_epu8.html" title="no_std_compat::arch::x86_64::_mm_mask_min_epu8 fn">_mm_mask_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_epu16.html" title="no_std_compat::arch::x86_64::_mm_mask_min_epu16 fn">_mm_mask_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_epu32.html" title="no_std_compat::arch::x86_64::_mm_mask_min_epu32 fn">_mm_mask_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_epu64.html" title="no_std_compat::arch::x86_64::_mm_mask_min_epu64 fn">_mm_mask_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_min_pd fn">_mm_mask_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_min_ps fn">_mm_mask_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_min_round_sd fn">_mm_mask_min_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_min_round_ss fn">_mm_mask_min_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_min_sd fn">_mm_mask_min_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_min_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_min_ss fn">_mm_mask_min_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mov_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_mov_epi8 fn">_mm_mask_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 8-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mov_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_mov_epi16 fn">_mm_mask_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 16-bit integers from a into dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mov_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_mov_epi32 fn">_mm_mask_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 32-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mov_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_mov_epi64 fn">_mm_mask_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 64-bit integers from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mov_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_mov_pd fn">_mm_mask_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed double-precision (64-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mov_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_mov_ps fn">_mm_mask_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed single-precision (32-bit) floating-point elements from a to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_move_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_move_sd fn">_mm_mask_move_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_move_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_move_ss fn">_mm_mask_move_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_movedup_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_movedup_pd fn">_mm_mask_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_movehdup_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_movehdup_ps fn">_mm_mask_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_moveldup_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_moveldup_ps fn">_mm_mask_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_mul_epi32 fn">_mm_mask_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mul_epu32.html" title="no_std_compat::arch::x86_64::_mm_mask_mul_epu32 fn">_mm_mask_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mul_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_mul_pd fn">_mm_mask_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mul_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_mul_ps fn">_mm_mask_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mul_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_mul_round_sd fn">_mm_mask_mul_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mul_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_mul_round_ss fn">_mm_mask_mul_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mul_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_mul_sd fn">_mm_mask_mul_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mul_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_mul_ss fn">_mm_mask_mul_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mulhi_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_mulhi_epi16 fn">_mm_mask_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mulhi_epu16.html" title="no_std_compat::arch::x86_64::_mm_mask_mulhi_epu16 fn">_mm_mask_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mulhrs_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_mulhrs_epi16 fn">_mm_mask_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mullo_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_mullo_epi16 fn">_mm_mask_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_mullo_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_mullo_epi32 fn">_mm_mask_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_multishift_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_multishift_epi64_epi8 fn">_mm_mask_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_or_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_or_epi32 fn">_mm_mask_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_or_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_or_epi64 fn">_mm_mask_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_packs_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_packs_epi16 fn">_mm_mask_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_packs_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_packs_epi32 fn">_mm_mask_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_packus_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_packus_epi16 fn">_mm_mask_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_packus_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_packus_epi32 fn">_mm_mask_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permute_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_permute_pd fn">_mm_mask_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permute_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_permute_ps fn">_mm_mask_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutevar_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_permutevar_pd fn">_mm_mask_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutevar_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_permutevar_ps fn">_mm_mask_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_permutex2var_epi8 fn">_mm_mask_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_permutex2var_epi16 fn">_mm_mask_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_permutex2var_epi32 fn">_mm_mask_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_permutex2var_epi64 fn">_mm_mask_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_permutex2var_pd fn">_mm_mask_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_permutex2var_ps fn">_mm_mask_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutexvar_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_permutexvar_epi8 fn">_mm_mask_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_permutexvar_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_permutexvar_epi16 fn">_mm_mask_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_popcnt_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_popcnt_epi8 fn">_mm_mask_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 8-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_popcnt_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_popcnt_epi16 fn">_mm_mask_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 16-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_popcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_popcnt_epi32 fn">_mm_mask_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 32-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_popcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_popcnt_epi64 fn">_mm_mask_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 64-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rcp14_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_rcp14_pd fn">_mm_mask_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rcp14_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_rcp14_ps fn">_mm_mask_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rcp14_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_rcp14_sd fn">_mm_mask_rcp14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rcp14_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_rcp14_ss fn">_mm_mask_rcp14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rol_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_rol_epi32 fn">_mm_mask_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rol_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_rol_epi64 fn">_mm_mask_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rolv_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_rolv_epi32 fn">_mm_mask_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rolv_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_rolv_epi64 fn">_mm_mask_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_ror_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_ror_epi32 fn">_mm_mask_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_ror_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_ror_epi64 fn">_mm_mask_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rorv_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_rorv_epi32 fn">_mm_mask_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rorv_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_rorv_epi64 fn">_mm_mask_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_roundscale_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_roundscale_pd fn">_mm_mask_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_roundscale_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_roundscale_ps fn">_mm_mask_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_roundscale_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_roundscale_round_sd fn">_mm_mask_roundscale_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_roundscale_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_roundscale_round_ss fn">_mm_mask_roundscale_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_roundscale_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_roundscale_sd fn">_mm_mask_roundscale_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_roundscale_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_roundscale_ss fn">_mm_mask_roundscale_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rsqrt14_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_rsqrt14_pd fn">_mm_mask_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rsqrt14_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_rsqrt14_ps fn">_mm_mask_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rsqrt14_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_rsqrt14_sd fn">_mm_mask_rsqrt14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_rsqrt14_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_rsqrt14_ss fn">_mm_mask_rsqrt14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_scalef_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_scalef_pd fn">_mm_mask_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_scalef_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_scalef_ps fn">_mm_mask_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_scalef_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_scalef_round_sd fn">_mm_mask_scalef_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_scalef_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_scalef_round_ss fn">_mm_mask_scalef_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_scalef_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_scalef_sd fn">_mm_mask_scalef_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_scalef_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_scalef_ss fn">_mm_mask_scalef_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_set1_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_set1_epi8 fn">_mm_mask_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 8-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_set1_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_set1_epi16 fn">_mm_mask_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 16-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_set1_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_set1_epi32 fn">_mm_mask_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 32-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_set1_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_set1_epi64 fn">_mm_mask_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 64-bit integer a to all elements of dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shldi_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_shldi_epi16 fn">_mm_mask_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shldi_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_shldi_epi32 fn">_mm_mask_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shldi_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_shldi_epi64 fn">_mm_mask_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shldv_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_shldv_epi16 fn">_mm_mask_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shldv_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_shldv_epi32 fn">_mm_mask_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shldv_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_shldv_epi64 fn">_mm_mask_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shrdi_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_shrdi_epi16 fn">_mm_mask_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shrdi_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_shrdi_epi32 fn">_mm_mask_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shrdi_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_shrdi_epi64 fn">_mm_mask_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using writemask k (elements are copied from src“ when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shrdv_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_shrdv_epi16 fn">_mm_mask_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shrdv_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_shrdv_epi32 fn">_mm_mask_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shrdv_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_shrdv_epi64 fn">_mm_mask_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using writemask k (elements are copied from a when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shuffle_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_shuffle_epi8 fn">_mm_mask_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a within 128-bit lanes using the control in the corresponding 8-bit element of b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shuffle_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_shuffle_epi32 fn">_mm_mask_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shuffle_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_shuffle_pd fn">_mm_mask_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shuffle_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_shuffle_ps fn">_mm_mask_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shufflehi_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_shufflehi_epi16 fn">_mm_mask_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_shufflelo_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_shufflelo_epi16 fn">_mm_mask_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sll_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_sll_epi16 fn">_mm_mask_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sll_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_sll_epi32 fn">_mm_mask_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sll_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_sll_epi64 fn">_mm_mask_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_slli_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_slli_epi16 fn">_mm_mask_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_slli_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_slli_epi32 fn">_mm_mask_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_slli_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_slli_epi64 fn">_mm_mask_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sllv_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_sllv_epi16 fn">_mm_mask_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sllv_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_sllv_epi32 fn">_mm_mask_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sllv_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_sllv_epi64 fn">_mm_mask_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sqrt_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_sqrt_pd fn">_mm_mask_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sqrt_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_sqrt_ps fn">_mm_mask_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sqrt_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_sqrt_round_sd fn">_mm_mask_sqrt_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sqrt_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_sqrt_round_ss fn">_mm_mask_sqrt_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sqrt_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_sqrt_sd fn">_mm_mask_sqrt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sqrt_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_sqrt_ss fn">_mm_mask_sqrt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sra_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_sra_epi16 fn">_mm_mask_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sra_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_sra_epi32 fn">_mm_mask_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sra_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_sra_epi64 fn">_mm_mask_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srai_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_srai_epi16 fn">_mm_mask_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srai_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_srai_epi32 fn">_mm_mask_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srai_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_srai_epi64 fn">_mm_mask_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srav_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_srav_epi16 fn">_mm_mask_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srav_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_srav_epi32 fn">_mm_mask_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srav_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_srav_epi64 fn">_mm_mask_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srl_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_srl_epi16 fn">_mm_mask_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srl_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_srl_epi32 fn">_mm_mask_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srl_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_srl_epi64 fn">_mm_mask_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srli_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_srli_epi16 fn">_mm_mask_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srli_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_srli_epi32 fn">_mm_mask_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srli_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_srli_epi64 fn">_mm_mask_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srlv_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_srlv_epi16 fn">_mm_mask_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srlv_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_srlv_epi32 fn">_mm_mask_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_srlv_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_srlv_epi64 fn">_mm_mask_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_store_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_store_epi32 fn">_mm_mask_store_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed 32-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_store_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_store_epi64 fn">_mm_mask_store_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed 64-bit integers from a into memory using writemask k.
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_store_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_store_pd fn">_mm_mask_store_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_store_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_store_ps fn">_mm_mask_store_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_storeu_epi8 fn">_mm_mask_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx,sse` only"><code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed 8-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_storeu_epi16 fn">_mm_mask_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx,sse` only"><code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed 16-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_storeu_epi32 fn">_mm_mask_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed 32-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_storeu_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_storeu_epi64 fn">_mm_mask_storeu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed 64-bit integers from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_storeu_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_storeu_pd fn">_mm_mask_storeu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed double-precision (64-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_storeu_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_storeu_ps fn">_mm_mask_storeu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Store packed single-precision (32-bit) floating-point elements from a into memory using writemask k.
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_epi8 fn">_mm_mask_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_epi16 fn">_mm_mask_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_epi32 fn">_mm_mask_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_epi64 fn">_mm_mask_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_pd fn">_mm_mask_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_ps fn">_mm_mask_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_round_sd fn">_mm_mask_sub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_round_ss fn">_mm_mask_sub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_sd.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_sd fn">_mm_mask_sub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_sub_ss.html" title="no_std_compat::arch::x86_64::_mm_mask_sub_ss fn">_mm_mask_sub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_subs_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_subs_epi8 fn">_mm_mask_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_subs_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_subs_epi16 fn">_mm_mask_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_subs_epu8.html" title="no_std_compat::arch::x86_64::_mm_mask_subs_epu8 fn">_mm_mask_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_subs_epu16.html" title="no_std_compat::arch::x86_64::_mm_mask_subs_epu16 fn">_mm_mask_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_ternarylogic_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_ternarylogic_epi32 fn">_mm_mask_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 32-bit granularity (32-bit elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_ternarylogic_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_ternarylogic_epi64 fn">_mm_mask_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from src, a, and b are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using writemask k at 64-bit granularity (64-bit elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_test_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_test_epi8_mask fn">_mm_mask_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_test_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_test_epi16_mask fn">_mm_mask_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_test_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_test_epi32_mask fn">_mm_mask_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_test_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_test_epi64_mask fn">_mm_mask_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_testn_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_testn_epi8_mask fn">_mm_mask_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_testn_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_testn_epi16_mask fn">_mm_mask_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_testn_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_testn_epi32_mask fn">_mm_mask_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_testn_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_mask_testn_epi64_mask fn">_mm_mask_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k (subject to writemask k) if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpackhi_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_unpackhi_epi8 fn">_mm_mask_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpackhi_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_unpackhi_epi16 fn">_mm_mask_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpackhi_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_unpackhi_epi32 fn">_mm_mask_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpackhi_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_unpackhi_epi64 fn">_mm_mask_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpackhi_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_unpackhi_pd fn">_mm_mask_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpackhi_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_unpackhi_ps fn">_mm_mask_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpacklo_epi8.html" title="no_std_compat::arch::x86_64::_mm_mask_unpacklo_epi8 fn">_mm_mask_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpacklo_epi16.html" title="no_std_compat::arch::x86_64::_mm_mask_unpacklo_epi16 fn">_mm_mask_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpacklo_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_unpacklo_epi32 fn">_mm_mask_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpacklo_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_unpacklo_epi64 fn">_mm_mask_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpacklo_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_unpacklo_pd fn">_mm_mask_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_unpacklo_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_unpacklo_ps fn">_mm_mask_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_xor_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_xor_epi32 fn">_mm_mask_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mask_xor_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_xor_epi64 fn">_mm_mask_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_abs_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_abs_epi8 fn">_mm_maskz_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 8-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_abs_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_abs_epi16 fn">_mm_maskz_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 16-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_abs_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_abs_epi32 fn">_mm_maskz_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the absolute value of packed signed 32-bit integers in a, and store the unsigned results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_epi8 fn">_mm_maskz_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_epi16 fn">_mm_maskz_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_epi32 fn">_mm_maskz_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_epi64 fn">_mm_maskz_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_pd fn">_mm_maskz_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_ps fn">_mm_maskz_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_round_sd fn">_mm_maskz_add_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_round_ss fn">_mm_maskz_add_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_sd fn">_mm_maskz_add_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_add_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_add_ss fn">_mm_maskz_add_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Add the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_adds_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_adds_epi8 fn">_mm_maskz_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed signed 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_adds_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_adds_epi16 fn">_mm_maskz_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed signed 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_adds_epu8.html" title="no_std_compat::arch::x86_64::_mm_maskz_adds_epu8 fn">_mm_maskz_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 8-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_adds_epu16.html" title="no_std_compat::arch::x86_64::_mm_maskz_adds_epu16 fn">_mm_maskz_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Add packed unsigned 16-bit integers in a and b using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_alignr_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_alignr_epi8 fn">_mm_maskz_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate pairs of 16-byte blocks in a and b into a 32-byte temporary result, shift the result right by imm8 bytes, and store the low 16 bytes in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_alignr_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_alignr_epi32 fn">_mm_maskz_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 32-bit elements, and store the low 16 bytes (4 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_alignr_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_alignr_epi64 fn">_mm_maskz_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate a and b into a 32-byte immediate result, shift the result right by imm8 64-bit elements, and store the low 16 bytes (2 elements) in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_and_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_and_epi32 fn">_mm_maskz_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_and_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_and_epi64 fn">_mm_maskz_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_andnot_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_andnot_epi32 fn">_mm_maskz_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 32-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_andnot_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_andnot_epi64 fn">_mm_maskz_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NOT of packed 64-bit integers in a and then AND with b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_avg_epu8.html" title="no_std_compat::arch::x86_64::_mm_maskz_avg_epu8 fn">_mm_maskz_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 8-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_avg_epu16.html" title="no_std_compat::arch::x86_64::_mm_maskz_avg_epu16 fn">_mm_maskz_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Average packed unsigned 16-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_broadcastb_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_broadcastb_epi8 fn">_mm_maskz_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 8-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_broadcastd_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_broadcastd_epi32 fn">_mm_maskz_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 32-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_broadcastq_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_broadcastq_epi64 fn">_mm_maskz_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 64-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_broadcastss_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_broadcastss_ps fn">_mm_maskz_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low single-precision (32-bit) floating-point element from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_broadcastw_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_broadcastw_epi16 fn">_mm_maskz_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_compress_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_compress_epi8 fn">_mm_maskz_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 8-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_compress_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_compress_epi16 fn">_mm_maskz_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 16-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_compress_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_compress_epi32 fn">_mm_maskz_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 32-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_compress_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_compress_epi64 fn">_mm_maskz_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active 64-bit integers in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_compress_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_compress_pd fn">_mm_maskz_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active double-precision (64-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_compress_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_compress_ps fn">_mm_maskz_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Contiguously store the active single-precision (32-bit) floating-point elements in a (those with their respective bit set in zeromask k) to dst, and set the remaining elements to zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_conflict_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_conflict_epi32 fn">_mm_maskz_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_conflict_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_conflict_epi64 fn">_mm_maskz_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Test each 64-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Each element’s comparison forms a zero extended bit vector in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvt_roundps_ph.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvt_roundps_ph fn">_mm_maskz_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvt_roundsd_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvt_roundsd_ss fn">_mm_maskz_cvt_roundsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the rounding[3:0] parameter, which can be one of:<br />
(_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions<br />
(_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions<br />
(_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions<br />
(_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions<br />
_MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvt_roundss_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvt_roundss_sd fn">_mm_maskz_cvt_roundss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi8_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi8_epi16 fn">_mm_maskz_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi8_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi8_epi32 fn">_mm_maskz_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi8_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi8_epi64 fn">_mm_maskz_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi16_epi8 fn">_mm_maskz_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 16-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi16_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi16_epi32 fn">_mm_maskz_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi16_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi16_epi64 fn">_mm_maskz_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi32_epi8 fn">_mm_maskz_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi32_epi16 fn">_mm_maskz_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 32-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi32_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi32_epi64 fn">_mm_maskz_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi32_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi32_pd fn">_mm_maskz_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi32_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi32_ps fn">_mm_maskz_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi64_epi8 fn">_mm_maskz_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 8-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi64_epi16 fn">_mm_maskz_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 16-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepi64_epi32 fn">_mm_maskz_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed 64-bit integers in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepu8_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepu8_epi16 fn">_mm_maskz_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in a to packed 16-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepu8_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepu8_epi32 fn">_mm_maskz_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in th elow 4 bytes of a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepu8_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepu8_epi64 fn">_mm_maskz_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 8-bit integers in the low 2 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepu16_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepu16_epi32 fn">_mm_maskz_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepu16_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepu16_epi64 fn">_mm_maskz_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 16-bit integers in the low 4 bytes of a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepu32_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepu32_epi64 fn">_mm_maskz_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Zero extend packed unsigned 32-bit integers in a to packed 64-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtepu32_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtepu32_pd fn">_mm_maskz_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed double-precision (64-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtne2ps_pbh.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtne2ps_pbh fn">_mm_maskz_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in two vectors
a and b to packed BF16 (16-bit) floating-point elements, and store the results
in single vector dst using zeromask k (elements are zeroed out when the corresponding
mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651&amp;avx512techs=AVX512_BF16&amp;text=_mm_maskz_cvtne2ps_pbh">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtpd_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtpd_epi32 fn">_mm_maskz_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtpd_epu32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtpd_epu32 fn">_mm_maskz_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtpd_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtpd_ps fn">_mm_maskz_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtph_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtph_ps fn">_mm_maskz_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed half-precision (16-bit) floating-point elements in a to packed single-precision (32-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtps_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtps_epi32 fn">_mm_maskz_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtps_epu32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtps_epu32 fn">_mm_maskz_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtps_ph.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtps_ph fn">_mm_maskz_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed half-precision (16-bit) floating-point elements, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtsd_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtsd_ss fn">_mm_maskz_cvtsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower double-precision (64-bit) floating-point element in b to a single-precision (32-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtsepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtsepi16_epi8 fn">_mm_maskz_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtsepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtsepi32_epi8 fn">_mm_maskz_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtsepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtsepi32_epi16 fn">_mm_maskz_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtsepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtsepi64_epi8 fn">_mm_maskz_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 8-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtsepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtsepi64_epi16 fn">_mm_maskz_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 16-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtsepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtsepi64_epi32 fn">_mm_maskz_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 64-bit integers in a to packed 32-bit integers with signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtss_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtss_sd fn">_mm_maskz_cvtss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the lower single-precision (32-bit) floating-point element in b to a double-precision (64-bit) floating-point element, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvttpd_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvttpd_epi32 fn">_mm_maskz_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvttpd_epu32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvttpd_epu32 fn">_mm_maskz_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (64-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvttps_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvttps_epi32 fn">_mm_maskz_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed single-precision (32-bit) floating-point elements in a to packed 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvttps_epu32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvttps_epu32 fn">_mm_maskz_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed double-precision (32-bit) floating-point elements in a to packed unsigned 32-bit integers with truncation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtusepi16_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtusepi16_epi8 fn">_mm_maskz_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 16-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtusepi32_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtusepi32_epi8 fn">_mm_maskz_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtusepi32_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtusepi32_epi16 fn">_mm_maskz_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 32-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtusepi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtusepi64_epi8 fn">_mm_maskz_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 8-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtusepi64_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtusepi64_epi16 fn">_mm_maskz_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 16-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_cvtusepi64_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_cvtusepi64_epi32 fn">_mm_maskz_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed unsigned 64-bit integers in a to packed unsigned 32-bit integers with unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_dbsad_epu8.html" title="no_std_compat::arch::x86_64::_mm_maskz_dbsad_epu8 fn">_mm_maskz_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in a compared to those in b, and store the 16-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from a, and the last two SADs use the uppper 8-bit quadruplet of the lane from a. Quadruplets from b are selected from within 128-bit lanes according to the control in imm8, and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_div_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_div_pd fn">_mm_maskz_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_div_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_div_ps fn">_mm_maskz_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Divide packed single-precision (32-bit) floating-point elements in a by packed elements in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_div_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_div_round_sd fn">_mm_maskz_div_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_div_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_div_round_ss fn">_mm_maskz_div_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_div_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_div_sd fn">_mm_maskz_div_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower double-precision (64-bit) floating-point element in a by the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_div_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_div_ss fn">_mm_maskz_div_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Divide the lower single-precision (32-bit) floating-point element in a by the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_dpbf16_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_dpbf16_ps fn">_mm_maskz_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute dot-product of BF16 (16-bit) floating-point pairs in a and b,
accumulating the intermediate single-precision (32-bit) floating-point elements
with elements in src, and store the results in dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm_maskz_dpbf16_ps">Intel’s documentation</a></p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_dpbusd_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_dpbusd_epi32 fn">_mm_maskz_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_dpbusds_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_dpbusds_epi32 fn">_mm_maskz_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in a with corresponding signed 8-bit integers in b, producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_dpwssd_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_dpwssd_epi32 fn">_mm_maskz_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_dpwssds_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_dpwssds_epi32 fn">_mm_maskz_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply groups of 2 adjacent pairs of signed 16-bit integers in a with corresponding 16-bit integers in b, producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in src using signed saturation, and store the packed 32-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expand_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_expand_epi8 fn">_mm_maskz_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expand_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_expand_epi16 fn">_mm_maskz_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expand_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_expand_epi32 fn">_mm_maskz_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expand_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_expand_epi64 fn">_mm_maskz_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expand_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_expand_pd fn">_mm_maskz_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active double-precision (64-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expand_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_expand_ps fn">_mm_maskz_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from a (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expandloadu_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_expandloadu_epi8 fn">_mm_maskz_expandloadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only"><code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 8-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expandloadu_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_expandloadu_epi16 fn">_mm_maskz_expandloadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only"><code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 16-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expandloadu_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_expandloadu_epi32 fn">_mm_maskz_expandloadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 32-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expandloadu_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_expandloadu_epi64 fn">_mm_maskz_expandloadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active 64-bit integers from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expandloadu_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_expandloadu_pd fn">_mm_maskz_expandloadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (64-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_expandloadu_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_expandloadu_ps fn">_mm_maskz_expandloadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load contiguous active single-precision (32-bit) floating-point elements from unaligned memory at mem_addr (those with their respective bit set in mask k), and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fixupimm_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fixupimm_pd fn">_mm_maskz_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed double-precision (64-bit) floating-point elements in a and b using packed 64-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fixupimm_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_fixupimm_ps fn">_mm_maskz_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Fix up packed single-precision (32-bit) floating-point elements in a and b using packed 32-bit integers in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fixupimm_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fixupimm_round_sd fn">_mm_maskz_fixupimm_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fixupimm_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fixupimm_round_ss fn">_mm_maskz_fixupimm_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fixupimm_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fixupimm_sd fn">_mm_maskz_fixupimm_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower double-precision (64-bit) floating-point elements in a and b using the lower 64-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fixupimm_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fixupimm_ss fn">_mm_maskz_fixupimm_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Fix up the lower single-precision (32-bit) floating-point elements in a and b using the lower 32-bit integer in c, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. imm8 is used to set the required flags reporting.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmadd_pd fn">_mm_maskz_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmadd_ps fn">_mm_maskz_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmadd_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmadd_round_sd fn">_mm_maskz_fmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmadd_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmadd_round_ss fn">_mm_maskz_fmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmadd_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmadd_sd fn">_mm_maskz_fmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmadd_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmadd_ss fn">_mm_maskz_fmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmaddsub_pd fn">_mm_maskz_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmaddsub_ps fn">_mm_maskz_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmsub_pd fn">_mm_maskz_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmsub_ps fn">_mm_maskz_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmsub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmsub_round_sd fn">_mm_maskz_fmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmsub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmsub_round_ss fn">_mm_maskz_fmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmsub_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmsub_sd fn">_mm_maskz_fmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmsub_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmsub_ss fn">_mm_maskz_fmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmsubadd_pd fn">_mm_maskz_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, alternatively add and subtract packed elements in c to/from the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_fmsubadd_ps fn">_mm_maskz_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, alternatively subtract and add packed elements in c from/to the intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmadd_pd fn">_mm_maskz_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmadd_ps fn">_mm_maskz_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, add the negated intermediate result to packed elements in c, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmadd_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmadd_round_sd fn">_mm_maskz_fnmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmadd_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmadd_round_ss fn">_mm_maskz_fnmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmadd_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmadd_sd fn">_mm_maskz_fnmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmadd_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmadd_ss fn">_mm_maskz_fnmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and add the negated intermediate result to the lower element in c. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmsub_pd fn">_mm_maskz_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmsub_ps fn">_mm_maskz_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, subtract packed elements in c from the negated intermediate result, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmsub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmsub_round_sd fn">_mm_maskz_fnmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmsub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmsub_round_ss fn">_mm_maskz_fnmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmsub_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmsub_sd fn">_mm_maskz_fnmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_fnmsub_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_fnmsub_ss fn">_mm_maskz_fnmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point elements in a and b, and subtract the lower element in c from the negated intermediate result. Store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getexp_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_getexp_pd fn">_mm_maskz_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed double-precision (64-bit) floating-point element in a to a double-precision (64-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getexp_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_getexp_ps fn">_mm_maskz_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of each packed single-precision (32-bit) floating-point element in a to a single-precision (32-bit) floating-point number representing the integer exponent, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates floor(log2(x)) for each element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getexp_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_getexp_round_sd fn">_mm_maskz_getexp_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getexp_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_getexp_round_ss fn">_mm_maskz_getexp_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getexp_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_getexp_sd fn">_mm_maskz_getexp_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower double-precision (64-bit) floating-point element in b to a double-precision (64-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getexp_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_getexp_ss fn">_mm_maskz_getexp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Convert the exponent of the lower single-precision (32-bit) floating-point element in b to a single-precision (32-bit) floating-point number representing the integer exponent, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates floor(log2(x)) for the lower element.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getmant_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_getmant_pd fn">_mm_maskz_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getmant_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_getmant_ps fn">_mm_maskz_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getmant_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_getmant_round_sd fn">_mm_maskz_getmant_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getmant_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_getmant_round_ss fn">_mm_maskz_getmant_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getmant_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_getmant_sd fn">_mm_maskz_getmant_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_getmant_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_getmant_ss fn">_mm_maskz_getmant_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Normalize the mantissas of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. This intrinsic essentially calculates ±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.<br />
The mantissa is normalized to the interval specified by interv, which can take the following values:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
The sign is determined by sc which can take the following values:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_gf2p8affine_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_gf2p8affine_epi64_epi8 fn">_mm_maskz_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the packed bytes in x.
That is computes a*x+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_gf2p8affineinv_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_gf2p8affineinv_epi64_epi8 fn">_mm_maskz_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs an affine transformation on the inverted packed bytes in x.
That is computes a*inv(x)+b over the Galois Field 2^8 for each packed byte with a being a 8x8 bit matrix
and b being a constant 8-bit immediate value.
The inverse of a byte is defined with respect to the reduction polynomial x^8+x^4+x^3+x+1.
The inverse of 0 is 0.
Each pack of 8 bytes in x is paired with the 64-bit word at the same position in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_gf2p8mul_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_gf2p8mul_epi8 fn">_mm_maskz_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Performs a multiplication in GF(2^8) on the packed bytes.
The field is in polynomial representation with the reduction polynomial
x^8 + x^4 + x^3 + x + 1.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_load_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_load_epi32 fn">_mm_maskz_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_load_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_load_epi64 fn">_mm_maskz_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_load_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_load_pd fn">_mm_maskz_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_load_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_load_ps fn">_mm_maskz_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_loadu_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_loadu_epi8 fn">_mm_maskz_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx,sse` only"><code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 8-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_loadu_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_loadu_epi16 fn">_mm_maskz_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512bw,avx512vl,avx,sse` only"><code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 16-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_loadu_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_loadu_epi32 fn">_mm_maskz_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 32-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_loadu_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_loadu_epi64 fn">_mm_maskz_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed 64-bit integers from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_loadu_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_loadu_pd fn">_mm_maskz_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed double-precision (64-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_loadu_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_loadu_ps fn">_mm_maskz_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl,avx,sse` only"><code>avx512f,avx512vl,avx,sse</code></span></div><div class="item-right docblock-short"><p>Load packed single-precision (32-bit) floating-point elements from memory into dst using zeromask k
(elements are zeroed out when the corresponding mask bit is not set).
mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_lzcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_lzcnt_epi32 fn">_mm_maskz_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 32-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_lzcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_lzcnt_epi64 fn">_mm_maskz_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span></div><div class="item-right docblock-short"><p>Counts the number of leading zero bits in each packed 64-bit integer in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_madd_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_madd_epi16 fn">_mm_maskz_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_maddubs_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_maddubs_epi16 fn">_mm_maskz_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed unsigned 8-bit integers in a by packed signed 8-bit integers in b, producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_epi8 fn">_mm_maskz_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_epi16 fn">_mm_maskz_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_epi32 fn">_mm_maskz_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_epi64 fn">_mm_maskz_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_epu8.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_epu8 fn">_mm_maskz_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_epu16.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_epu16 fn">_mm_maskz_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_epu32.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_epu32 fn">_mm_maskz_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_epu64.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_epu64 fn">_mm_maskz_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_pd fn">_mm_maskz_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_ps fn">_mm_maskz_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed maximum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_round_sd fn">_mm_maskz_max_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_round_ss fn">_mm_maskz_max_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_sd fn">_mm_maskz_max_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_max_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_max_ss fn">_mm_maskz_max_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_epi8 fn">_mm_maskz_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_epi16 fn">_mm_maskz_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_epi32 fn">_mm_maskz_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_epu8.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_epu8 fn">_mm_maskz_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 8-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_epu16.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_epu16 fn">_mm_maskz_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 16-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_epu32.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_epu32 fn">_mm_maskz_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 32-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_epu64.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_epu64 fn">_mm_maskz_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_pd fn">_mm_maskz_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed double-precision (64-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_ps fn">_mm_maskz_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed single-precision (32-bit) floating-point elements in a and b, and store packed minimum values in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_round_sd fn">_mm_maskz_min_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_round_ss fn">_mm_maskz_min_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_sd fn">_mm_maskz_min_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_min_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_min_ss fn">_mm_maskz_min_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mov_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_mov_epi8 fn">_mm_maskz_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 8-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mov_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_mov_epi16 fn">_mm_maskz_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 16-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mov_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_mov_epi32 fn">_mm_maskz_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 32-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mov_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_mov_epi64 fn">_mm_maskz_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed 64-bit integers from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mov_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_mov_pd fn">_mm_maskz_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed double-precision (64-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mov_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_mov_ps fn">_mm_maskz_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Move packed single-precision (32-bit) floating-point elements from a into dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_move_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_move_sd fn">_mm_maskz_move_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move the lower double-precision (64-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_move_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_move_ss fn">_mm_maskz_move_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Move the lower single-precision (32-bit) floating-point element from b to the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_movedup_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_movedup_pd fn">_mm_maskz_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed double-precision (64-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_movehdup_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_movehdup_ps fn">_mm_maskz_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate odd-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_moveldup_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_moveldup_ps fn">_mm_maskz_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed single-precision (32-bit) floating-point elements from a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_mul_epi32 fn">_mm_maskz_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the low signed 32-bit integers from each packed 64-bit element in a and b, and store the signed 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mul_epu32.html" title="no_std_compat::arch::x86_64::_mm_maskz_mul_epu32 fn">_mm_maskz_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the low unsigned 32-bit integers from each packed 64-bit element in a and b, and store the unsigned 64-bit results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mul_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_mul_pd fn">_mm_maskz_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed double-precision (64-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mul_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_mul_ps fn">_mm_maskz_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed single-precision (32-bit) floating-point elements in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mul_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_mul_round_sd fn">_mm_maskz_mul_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mul_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_mul_round_ss fn">_mm_maskz_mul_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mul_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_mul_sd fn">_mm_maskz_mul_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mul_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_mul_ss fn">_mm_maskz_mul_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mulhi_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_mulhi_epi16 fn">_mm_maskz_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed signed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mulhi_epu16.html" title="no_std_compat::arch::x86_64::_mm_maskz_mulhi_epu16 fn">_mm_maskz_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed unsigned 16-bit integers in a and b, producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mulhrs_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_mulhrs_epi16 fn">_mm_maskz_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply packed signed 16-bit integers in a and b, producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mullo_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_mullo_epi16 fn">_mm_maskz_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 16-bit integers in a and b, producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_mullo_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_mullo_epi32 fn">_mm_maskz_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Multiply the packed 32-bit integers in a and b, producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_multishift_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_multishift_epi64_epi8 fn">_mm_maskz_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_or_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_or_epi32 fn">_mm_maskz_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_or_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_or_epi64 fn">_mm_maskz_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_packs_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_packs_epi16 fn">_mm_maskz_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_packs_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_packs_epi32 fn">_mm_maskz_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using signed saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_packus_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_packus_epi16 fn">_mm_maskz_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 16-bit integers from a and b to packed 8-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_packus_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_packus_epi32 fn">_mm_maskz_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Convert packed signed 32-bit integers from a and b to packed 16-bit integers using unsigned saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permute_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_permute_pd fn">_mm_maskz_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permute_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_permute_ps fn">_mm_maskz_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutevar_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutevar_pd fn">_mm_maskz_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutevar_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutevar_ps fn">_mm_maskz_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a within 128-bit lanes using the control in b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutex2var_epi8 fn">_mm_maskz_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutex2var_epi16 fn">_mm_maskz_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutex2var_epi32 fn">_mm_maskz_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutex2var_epi64 fn">_mm_maskz_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutex2var_pd fn">_mm_maskz_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutex2var_ps fn">_mm_maskz_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutexvar_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutexvar_epi8 fn">_mm_maskz_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_permutexvar_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_permutexvar_epi16 fn">_mm_maskz_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_popcnt_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_popcnt_epi8 fn">_mm_maskz_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 8-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_popcnt_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_popcnt_epi16 fn">_mm_maskz_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 16-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_popcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_popcnt_epi32 fn">_mm_maskz_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 32-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_popcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_popcnt_epi64 fn">_mm_maskz_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 64-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rcp14_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_rcp14_pd fn">_mm_maskz_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rcp14_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_rcp14_ps fn">_mm_maskz_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rcp14_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_rcp14_sd fn">_mm_maskz_rcp14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rcp14_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_rcp14_ss fn">_mm_maskz_rcp14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rol_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_rol_epi32 fn">_mm_maskz_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rol_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_rol_epi64 fn">_mm_maskz_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rolv_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_rolv_epi32 fn">_mm_maskz_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rolv_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_rolv_epi64 fn">_mm_maskz_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_ror_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_ror_epi32 fn">_mm_maskz_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_ror_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_ror_epi64 fn">_mm_maskz_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rorv_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_rorv_epi32 fn">_mm_maskz_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rorv_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_rorv_epi64 fn">_mm_maskz_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_roundscale_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_roundscale_pd fn">_mm_maskz_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_roundscale_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_roundscale_ps fn">_mm_maskz_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_roundscale_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_roundscale_round_sd fn">_mm_maskz_roundscale_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_roundscale_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_roundscale_round_ss fn">_mm_maskz_roundscale_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_roundscale_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_roundscale_sd fn">_mm_maskz_roundscale_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_roundscale_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_roundscale_ss fn">_mm_maskz_roundscale_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rsqrt14_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_rsqrt14_pd fn">_mm_maskz_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rsqrt14_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_rsqrt14_ps fn">_mm_maskz_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set). The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rsqrt14_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_rsqrt14_sd fn">_mm_maskz_rsqrt14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_rsqrt14_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_rsqrt14_ss fn">_mm_maskz_rsqrt14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_scalef_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_scalef_pd fn">_mm_maskz_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_scalef_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_scalef_ps fn">_mm_maskz_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_scalef_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_scalef_round_sd fn">_mm_maskz_scalef_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_scalef_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_scalef_round_ss fn">_mm_maskz_scalef_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_scalef_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_scalef_sd fn">_mm_maskz_scalef_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_scalef_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_scalef_ss fn">_mm_maskz_scalef_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_set1_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_set1_epi8 fn">_mm_maskz_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 8-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_set1_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_set1_epi16 fn">_mm_maskz_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast the low packed 16-bit integer from a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_set1_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_set1_epi32 fn">_mm_maskz_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 32-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_set1_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_set1_epi64 fn">_mm_maskz_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Broadcast 64-bit integer a to all elements of dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shldi_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_shldi_epi16 fn">_mm_maskz_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shldi_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_shldi_epi32 fn">_mm_maskz_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shldi_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_shldi_epi64 fn">_mm_maskz_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shldv_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_shldv_epi16 fn">_mm_maskz_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shldv_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_shldv_epi32 fn">_mm_maskz_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shldv_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_shldv_epi64 fn">_mm_maskz_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shrdi_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_shrdi_epi16 fn">_mm_maskz_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shrdi_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_shrdi_epi32 fn">_mm_maskz_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shrdi_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_shrdi_epi64 fn">_mm_maskz_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shrdv_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_shrdv_epi16 fn">_mm_maskz_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shrdv_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_shrdv_epi32 fn">_mm_maskz_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shrdv_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_shrdv_epi64 fn">_mm_maskz_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shuffle_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_shuffle_epi8 fn">_mm_maskz_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle packed 8-bit integers in a according to shuffle control mask in the corresponding 8-bit element of b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shuffle_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_shuffle_epi32 fn">_mm_maskz_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shuffle_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_shuffle_pd fn">_mm_maskz_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shuffle_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_shuffle_ps fn">_mm_maskz_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a using the control in imm8, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shufflehi_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_shufflehi_epi16 fn">_mm_maskz_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the high 64 bits of 128-bit lanes of dst, with the low 64 bits of 128-bit lanes being copied from from a to dst, using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_shufflelo_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_shufflelo_epi16 fn">_mm_maskz_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of a using the control in imm8. Store the results in the low 64 bits of 128-bit lanes of dst, with the high 64 bits of 128-bit lanes being copied from from a to dst, using writemask k (elements are copied from src when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sll_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_sll_epi16 fn">_mm_maskz_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sll_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_sll_epi32 fn">_mm_maskz_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sll_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_sll_epi64 fn">_mm_maskz_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_slli_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_slli_epi16 fn">_mm_maskz_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_slli_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_slli_epi32 fn">_mm_maskz_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_slli_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_slli_epi64 fn">_mm_maskz_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sllv_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_sllv_epi16 fn">_mm_maskz_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sllv_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_sllv_epi32 fn">_mm_maskz_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sllv_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_sllv_epi64 fn">_mm_maskz_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sqrt_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_sqrt_pd fn">_mm_maskz_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sqrt_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_sqrt_ps fn">_mm_maskz_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the square root of packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sqrt_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_sqrt_round_sd fn">_mm_maskz_sqrt_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sqrt_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_sqrt_round_ss fn">_mm_maskz_sqrt_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sqrt_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_sqrt_sd fn">_mm_maskz_sqrt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sqrt_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_sqrt_ss fn">_mm_maskz_sqrt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sra_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_sra_epi16 fn">_mm_maskz_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sra_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_sra_epi32 fn">_mm_maskz_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sra_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_sra_epi64 fn">_mm_maskz_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srai_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_srai_epi16 fn">_mm_maskz_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srai_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_srai_epi32 fn">_mm_maskz_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srai_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_srai_epi64 fn">_mm_maskz_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srav_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_srav_epi16 fn">_mm_maskz_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srav_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_srav_epi32 fn">_mm_maskz_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srav_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_srav_epi64 fn">_mm_maskz_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srl_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_srl_epi16 fn">_mm_maskz_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srl_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_srl_epi32 fn">_mm_maskz_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srl_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_srl_epi64 fn">_mm_maskz_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srli_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_srli_epi16 fn">_mm_maskz_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srli_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_srli_epi32 fn">_mm_maskz_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srli_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_srli_epi64 fn">_mm_maskz_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srlv_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_srlv_epi16 fn">_mm_maskz_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srlv_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_srlv_epi32 fn">_mm_maskz_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 32-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_srlv_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_srlv_epi64 fn">_mm_maskz_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_epi8 fn">_mm_maskz_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in b from packed 8-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_epi16 fn">_mm_maskz_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in b from packed 16-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_epi32 fn">_mm_maskz_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 32-bit integers in b from packed 32-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_epi64 fn">_mm_maskz_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed 64-bit integers in b from packed 64-bit integers in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_pd fn">_mm_maskz_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in b from packed double-precision (64-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_ps fn">_mm_maskz_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed single-precision (32-bit) floating-point elements in b from packed single-precision (32-bit) floating-point elements in a, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_round_sd fn">_mm_maskz_sub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_round_ss fn">_mm_maskz_sub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_sd.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_sd fn">_mm_maskz_sub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_sub_ss.html" title="no_std_compat::arch::x86_64::_mm_maskz_sub_ss fn">_mm_maskz_sub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst using zeromask k (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_subs_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_subs_epi8 fn">_mm_maskz_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 8-bit integers in b from packed 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_subs_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_subs_epi16 fn">_mm_maskz_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed signed 16-bit integers in b from packed 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_subs_epu8.html" title="no_std_compat::arch::x86_64::_mm_maskz_subs_epu8 fn">_mm_maskz_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 8-bit integers in b from packed unsigned 8-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_subs_epu16.html" title="no_std_compat::arch::x86_64::_mm_maskz_subs_epu16 fn">_mm_maskz_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 16-bit integers in b from packed unsigned 16-bit integers in a using saturation, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_ternarylogic_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_ternarylogic_epi32 fn">_mm_maskz_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_ternarylogic_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_ternarylogic_epi64 fn">_mm_maskz_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst using zeromask k at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpackhi_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpackhi_epi8 fn">_mm_maskz_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpackhi_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpackhi_epi16 fn">_mm_maskz_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpackhi_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpackhi_epi32 fn">_mm_maskz_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpackhi_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpackhi_epi64 fn">_mm_maskz_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpackhi_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpackhi_pd fn">_mm_maskz_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpackhi_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpackhi_ps fn">_mm_maskz_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpacklo_epi8.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpacklo_epi8 fn">_mm_maskz_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpacklo_epi16.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpacklo_epi16 fn">_mm_maskz_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpacklo_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpacklo_epi32 fn">_mm_maskz_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpacklo_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpacklo_epi64 fn">_mm_maskz_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpacklo_pd.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpacklo_pd fn">_mm_maskz_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_unpacklo_ps.html" title="no_std_compat::arch::x86_64::_mm_maskz_unpacklo_ps fn">_mm_maskz_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_xor_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskz_xor_epi32 fn">_mm_maskz_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_maskz_xor_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskz_xor_epi64 fn">_mm_maskz_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst using zeromask k (elements are zeroed out when the corresponding mask bit is not set).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_max_epi64.html" title="no_std_compat::arch::x86_64::_mm_max_epi64 fn">_mm_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed signed 64-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_max_epu64.html" title="no_std_compat::arch::x86_64::_mm_max_epu64 fn">_mm_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed maximum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_max_round_sd.html" title="no_std_compat::arch::x86_64::_mm_max_round_sd fn">_mm_max_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_max_round_ss.html" title="no_std_compat::arch::x86_64::_mm_max_round_ss fn">_mm_max_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the maximum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_min_epu64.html" title="no_std_compat::arch::x86_64::_mm_min_epu64 fn">_mm_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compare packed unsigned 64-bit integers in a and b, and store packed minimum values in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_min_round_sd.html" title="no_std_compat::arch::x86_64::_mm_min_round_sd fn">_mm_min_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower double-precision (64-bit) floating-point elements in a and b, store the minimum value in the lower element of dst , and copy the upper element from a to the upper element of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_min_round_ss.html" title="no_std_compat::arch::x86_64::_mm_min_round_ss fn">_mm_min_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compare the lower single-precision (32-bit) floating-point elements in a and b, store the minimum value in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_movepi8_mask.html" title="no_std_compat::arch::x86_64::_mm_movepi8_mask fn">_mm_movepi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Set each bit of mask register k based on the most significant bit of the corresponding packed 8-bit integer in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_movepi16_mask.html" title="no_std_compat::arch::x86_64::_mm_movepi16_mask fn">_mm_movepi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Set each bit of mask register k based on the most significant bit of the corresponding packed 16-bit integer in a.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_movm_epi8.html" title="no_std_compat::arch::x86_64::_mm_movm_epi8 fn">_mm_movm_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Set each packed 8-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_movm_epi16.html" title="no_std_compat::arch::x86_64::_mm_movm_epi16 fn">_mm_movm_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mul_round_sd.html" title="no_std_compat::arch::x86_64::_mm_mul_round_sd fn">_mm_mul_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower double-precision (64-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_mul_round_ss.html" title="no_std_compat::arch::x86_64::_mm_mul_round_ss fn">_mm_mul_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Multiply the lower single-precision (32-bit) floating-point element in a and b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_multishift_epi64_epi8.html" title="no_std_compat::arch::x86_64::_mm_multishift_epi64_epi8 fn">_mm_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each 64-bit element in b, select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of a, and store the 8 assembled bytes to the corresponding 64-bit element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_or_epi32.html" title="no_std_compat::arch::x86_64::_mm_or_epi32 fn">_mm_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 32-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_or_epi64.html" title="no_std_compat::arch::x86_64::_mm_or_epi64 fn">_mm_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise OR of packed 64-bit integers in a and b, and store the resut in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_permutex2var_epi8.html" title="no_std_compat::arch::x86_64::_mm_permutex2var_epi8 fn">_mm_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_permutex2var_epi16.html" title="no_std_compat::arch::x86_64::_mm_permutex2var_epi16 fn">_mm_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_permutex2var_epi32.html" title="no_std_compat::arch::x86_64::_mm_permutex2var_epi32 fn">_mm_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 32-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_permutex2var_epi64.html" title="no_std_compat::arch::x86_64::_mm_permutex2var_epi64 fn">_mm_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 64-bit integers in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_permutex2var_pd.html" title="no_std_compat::arch::x86_64::_mm_permutex2var_pd fn">_mm_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle double-precision (64-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_permutex2var_ps.html" title="no_std_compat::arch::x86_64::_mm_permutex2var_ps fn">_mm_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle single-precision (32-bit) floating-point elements in a and b across lanes using the corresponding selector and index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_permutexvar_epi8.html" title="no_std_compat::arch::x86_64::_mm_permutexvar_epi8 fn">_mm_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 8-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_permutexvar_epi16.html" title="no_std_compat::arch::x86_64::_mm_permutexvar_epi16 fn">_mm_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shuffle 16-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_popcnt_epi8.html" title="no_std_compat::arch::x86_64::_mm_popcnt_epi8 fn">_mm_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 8-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_popcnt_epi16.html" title="no_std_compat::arch::x86_64::_mm_popcnt_epi16 fn">_mm_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 16-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_popcnt_epi32.html" title="no_std_compat::arch::x86_64::_mm_popcnt_epi32 fn">_mm_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 32-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_popcnt_epi64.html" title="no_std_compat::arch::x86_64::_mm_popcnt_epi64 fn">_mm_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span></div><div class="item-right docblock-short"><p>For each packed 64-bit integer maps the value to the number of logical 1 bits.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rcp14_pd.html" title="no_std_compat::arch::x86_64::_mm_rcp14_pd fn">_mm_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rcp14_ps.html" title="no_std_compat::arch::x86_64::_mm_rcp14_ps fn">_mm_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in a, and store the results in dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rcp14_sd.html" title="no_std_compat::arch::x86_64::_mm_rcp14_sd fn">_mm_rcp14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rcp14_ss.html" title="no_std_compat::arch::x86_64::_mm_rcp14_ss fn">_mm_rcp14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rol_epi32.html" title="no_std_compat::arch::x86_64::_mm_rol_epi32 fn">_mm_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rol_epi64.html" title="no_std_compat::arch::x86_64::_mm_rol_epi64 fn">_mm_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rolv_epi32.html" title="no_std_compat::arch::x86_64::_mm_rolv_epi32 fn">_mm_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rolv_epi64.html" title="no_std_compat::arch::x86_64::_mm_rolv_epi64 fn">_mm_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the left by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_ror_epi32.html" title="no_std_compat::arch::x86_64::_mm_ror_epi32 fn">_mm_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_ror_epi64.html" title="no_std_compat::arch::x86_64::_mm_ror_epi64 fn">_mm_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in imm8, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rorv_epi32.html" title="no_std_compat::arch::x86_64::_mm_rorv_epi32 fn">_mm_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 32-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rorv_epi64.html" title="no_std_compat::arch::x86_64::_mm_rorv_epi64 fn">_mm_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Rotate the bits in each packed 64-bit integer in a to the right by the number of bits specified in the corresponding element of b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_roundscale_pd.html" title="no_std_compat::arch::x86_64::_mm_roundscale_pd fn">_mm_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed double-precision (64-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_roundscale_ps.html" title="no_std_compat::arch::x86_64::_mm_roundscale_ps fn">_mm_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Round packed single-precision (32-bit) floating-point elements in a to the number of fraction bits specified by imm8, and store the results in dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_roundscale_round_sd.html" title="no_std_compat::arch::x86_64::_mm_roundscale_round_sd fn">_mm_roundscale_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_roundscale_round_ss.html" title="no_std_compat::arch::x86_64::_mm_roundscale_round_ss fn">_mm_roundscale_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_roundscale_sd.html" title="no_std_compat::arch::x86_64::_mm_roundscale_sd fn">_mm_roundscale_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower double-precision (64-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_roundscale_ss.html" title="no_std_compat::arch::x86_64::_mm_roundscale_ss fn">_mm_roundscale_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Round the lower single-precision (32-bit) floating-point element in b to the number of fraction bits specified by imm8, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.<br />
Rounding is done according to the imm8[2:0] parameter, which can be one of:<br />
_MM_FROUND_TO_NEAREST_INT // round to nearest<br />
_MM_FROUND_TO_NEG_INF     // round down<br />
_MM_FROUND_TO_POS_INF     // round up<br />
_MM_FROUND_TO_ZERO        // truncate<br />
_MM_FROUND_CUR_DIRECTION  // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rsqrt14_sd.html" title="no_std_compat::arch::x86_64::_mm_rsqrt14_sd fn">_mm_rsqrt14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_rsqrt14_ss.html" title="no_std_compat::arch::x86_64::_mm_rsqrt14_ss fn">_mm_rsqrt14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst. The maximum relative error for this approximation is less than 2^-14.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_scalef_pd.html" title="no_std_compat::arch::x86_64::_mm_scalef_pd fn">_mm_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_scalef_ps.html" title="no_std_compat::arch::x86_64::_mm_scalef_ps fn">_mm_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_scalef_round_sd.html" title="no_std_compat::arch::x86_64::_mm_scalef_round_sd fn">_mm_scalef_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_scalef_round_ss.html" title="no_std_compat::arch::x86_64::_mm_scalef_round_ss fn">_mm_scalef_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_scalef_sd.html" title="no_std_compat::arch::x86_64::_mm_scalef_sd fn">_mm_scalef_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed double-precision (64-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_scalef_ss.html" title="no_std_compat::arch::x86_64::_mm_scalef_ss fn">_mm_scalef_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Scale the packed single-precision (32-bit) floating-point elements in a using values from b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shldi_epi16.html" title="no_std_compat::arch::x86_64::_mm_shldi_epi16 fn">_mm_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by imm8 bits, and store the upper 16-bits in dst).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shldi_epi32.html" title="no_std_compat::arch::x86_64::_mm_shldi_epi32 fn">_mm_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by imm8 bits, and store the upper 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shldi_epi64.html" title="no_std_compat::arch::x86_64::_mm_shldi_epi64 fn">_mm_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by imm8 bits, and store the upper 64-bits in dst).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shldv_epi16.html" title="no_std_compat::arch::x86_64::_mm_shldv_epi16 fn">_mm_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in a and b producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 16-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shldv_epi32.html" title="no_std_compat::arch::x86_64::_mm_shldv_epi32 fn">_mm_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in a and b producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shldv_epi64.html" title="no_std_compat::arch::x86_64::_mm_shldv_epi64 fn">_mm_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in a and b producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of c, and store the upper 64-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shrdi_epi16.html" title="no_std_compat::arch::x86_64::_mm_shrdi_epi16 fn">_mm_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by imm8 bits, and store the lower 16-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shrdi_epi32.html" title="no_std_compat::arch::x86_64::_mm_shrdi_epi32 fn">_mm_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by imm8 bits, and store the lower 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shrdi_epi64.html" title="no_std_compat::arch::x86_64::_mm_shrdi_epi64 fn">_mm_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by imm8 bits, and store the lower 64-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shrdv_epi16.html" title="no_std_compat::arch::x86_64::_mm_shrdv_epi16 fn">_mm_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 16-bit integers in b and a producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 16-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shrdv_epi32.html" title="no_std_compat::arch::x86_64::_mm_shrdv_epi32 fn">_mm_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 32-bit integers in b and a producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 32-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_shrdv_epi64.html" title="no_std_compat::arch::x86_64::_mm_shrdv_epi64 fn">_mm_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span></div><div class="item-right docblock-short"><p>Concatenate packed 64-bit integers in b and a producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of c, and store the lower 64-bits in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_sllv_epi16.html" title="no_std_compat::arch::x86_64::_mm_sllv_epi16 fn">_mm_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a left by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_sqrt_round_sd.html" title="no_std_compat::arch::x86_64::_mm_sqrt_round_sd fn">_mm_sqrt_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower double-precision (64-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_sqrt_round_ss.html" title="no_std_compat::arch::x86_64::_mm_sqrt_round_ss fn">_mm_sqrt_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Compute the square root of the lower single-precision (32-bit) floating-point element in b, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_sra_epi64.html" title="no_std_compat::arch::x86_64::_mm_sra_epi64 fn">_mm_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_srai_epi64.html" title="no_std_compat::arch::x86_64::_mm_srai_epi64 fn">_mm_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by imm8 while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_srav_epi16.html" title="no_std_compat::arch::x86_64::_mm_srav_epi16 fn">_mm_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_srav_epi64.html" title="no_std_compat::arch::x86_64::_mm_srav_epi64 fn">_mm_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 64-bit integers in a right by the amount specified by the corresponding element in count while shifting in sign bits, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_srlv_epi16.html" title="no_std_compat::arch::x86_64::_mm_srlv_epi16 fn">_mm_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Shift packed 16-bit integers in a right by the amount specified by the corresponding element in count while shifting in zeros, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_store_epi32.html" title="no_std_compat::arch::x86_64::_mm_store_epi32 fn">_mm_store_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 128-bits (composed of 4 packed 32-bit integers) from a into memory. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_store_epi64.html" title="no_std_compat::arch::x86_64::_mm_store_epi64 fn">_mm_store_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 128-bits (composed of 2 packed 64-bit integers) from a into memory. mem_addr must be aligned on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_storeu_epi8.html" title="no_std_compat::arch::x86_64::_mm_storeu_epi8 fn">_mm_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 128-bits (composed of 16 packed 8-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_storeu_epi16.html" title="no_std_compat::arch::x86_64::_mm_storeu_epi16 fn">_mm_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 128-bits (composed of 8 packed 16-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_storeu_epi32.html" title="no_std_compat::arch::x86_64::_mm_storeu_epi32 fn">_mm_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 128-bits (composed of 4 packed 32-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_storeu_epi64.html" title="no_std_compat::arch::x86_64::_mm_storeu_epi64 fn">_mm_storeu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Store 128-bits (composed of 2 packed 64-bit integers) from a into memory. mem_addr does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_sub_round_sd.html" title="no_std_compat::arch::x86_64::_mm_sub_round_sd fn">_mm_sub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower double-precision (64-bit) floating-point element in b from the lower double-precision (64-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper element from a to the upper element of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_sub_round_ss.html" title="no_std_compat::arch::x86_64::_mm_sub_round_ss fn">_mm_sub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Subtract the lower single-precision (32-bit) floating-point element in b from the lower single-precision (32-bit) floating-point element in a, store the result in the lower element of dst, and copy the upper 3 packed elements from a to the upper elements of dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_ternarylogic_epi32.html" title="no_std_compat::arch::x86_64::_mm_ternarylogic_epi32 fn">_mm_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 32-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_ternarylogic_epi64.html" title="no_std_compat::arch::x86_64::_mm_ternarylogic_epi64 fn">_mm_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in imm8. For each bit in each packed 64-bit integer, the corresponding bit from a, b, and c are used to form a 3 bit index into imm8, and the value at that bit in imm8 is written to the corresponding bit in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_test_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_test_epi8_mask fn">_mm_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_test_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_test_epi16_mask fn">_mm_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_test_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_test_epi32_mask fn">_mm_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_test_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_test_epi64_mask fn">_mm_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise AND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is non-zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_testn_epi8_mask.html" title="no_std_compat::arch::x86_64::_mm_testn_epi8_mask fn">_mm_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 8-bit integers in a and b, producing intermediate 8-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_testn_epi16_mask.html" title="no_std_compat::arch::x86_64::_mm_testn_epi16_mask fn">_mm_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 16-bit integers in a and b, producing intermediate 16-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_testn_epi32_mask.html" title="no_std_compat::arch::x86_64::_mm_testn_epi32_mask fn">_mm_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 32-bit integers in a and b, producing intermediate 32-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_testn_epi64_mask.html" title="no_std_compat::arch::x86_64::_mm_testn_epi64_mask fn">_mm_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise NAND of packed 64-bit integers in a and b, producing intermediate 64-bit values, and set the corresponding bit in result mask k if the intermediate value is zero.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_xor_epi32.html" title="no_std_compat::arch::x86_64::_mm_xor_epi32 fn">_mm_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 32-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._mm_xor_epi64.html" title="no_std_compat::arch::x86_64::_mm_xor_epi64 fn">_mm_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span></div><div class="item-right docblock-short"><p>Compute the bitwise XOR of packed 64-bit integers in a and b, and store the results in dst.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._store_mask32.html" title="no_std_compat::arch::x86_64::_store_mask32 fn">_store_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Store 32-bit mask from a into memory.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._store_mask64.html" title="no_std_compat::arch::x86_64::_store_mask64 fn">_store_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span></div><div class="item-right docblock-short"><p>Store 64-bit mask from a into memory.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._xabort.html" title="no_std_compat::arch::x86_64::_xabort fn">_xabort</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `rtm` only"><code>rtm</code></span></div><div class="item-right docblock-short"><p>Forces a restricted transactional memory (RTM) region to abort.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._xabort_code.html" title="no_std_compat::arch::x86_64::_xabort_code fn">_xabort_code</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Retrieves the parameter passed to <a href="fn._xabort.html" title="_xabort"><code>_xabort</code></a> when <a href="fn._xbegin.html" title="_xbegin"><code>_xbegin</code></a>’s status has the
<code>_XABORT_EXPLICIT</code> flag set.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._xbegin.html" title="no_std_compat::arch::x86_64::_xbegin fn">_xbegin</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `rtm` only"><code>rtm</code></span></div><div class="item-right docblock-short"><p>Specifies the start of a restricted transactional memory (RTM) code region and returns a value
indicating status.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._xend.html" title="no_std_compat::arch::x86_64::_xend fn">_xend</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `rtm` only"><code>rtm</code></span></div><div class="item-right docblock-short"><p>Specifies the end of a restricted transactional memory (RTM) code region.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn._xtest.html" title="no_std_compat::arch::x86_64::_xtest fn">_xtest</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `rtm` only"><code>rtm</code></span></div><div class="item-right docblock-short"><p>Queries whether the processor is executing in a transactional region identified by restricted
transactional memory (RTM) or hardware lock elision (HLE).</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.cmpxchg16b.html" title="no_std_compat::arch::x86_64::cmpxchg16b fn">cmpxchg16b</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `cmpxchg16b` only"><code>cmpxchg16b</code></span></div><div class="item-right docblock-short"><p>Compares and exchange 16 bytes (128 bits) of data atomically.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.has_cpuid.html" title="no_std_compat::arch::x86_64::has_cpuid fn">has_cpuid</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Does the host support the <code>cpuid</code> instruction?</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="fn" href="fn.ud2.html" title="no_std_compat::arch::x86_64::ud2 fn">ud2</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>Generates the trap instruction <code>UD2</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._MM_GET_EXCEPTION_MASK.html" title="no_std_compat::arch::x86_64::_MM_GET_EXCEPTION_MASK fn">_MM_GET_EXCEPTION_MASK</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._MM_GET_EXCEPTION_STATE.html" title="no_std_compat::arch::x86_64::_MM_GET_EXCEPTION_STATE fn">_MM_GET_EXCEPTION_STATE</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._MM_GET_FLUSH_ZERO_MODE.html" title="no_std_compat::arch::x86_64::_MM_GET_FLUSH_ZERO_MODE fn">_MM_GET_FLUSH_ZERO_MODE</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._MM_GET_ROUNDING_MODE.html" title="no_std_compat::arch::x86_64::_MM_GET_ROUNDING_MODE fn">_MM_GET_ROUNDING_MODE</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._MM_SET_EXCEPTION_MASK.html" title="no_std_compat::arch::x86_64::_MM_SET_EXCEPTION_MASK fn">_MM_SET_EXCEPTION_MASK</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._MM_SET_EXCEPTION_STATE.html" title="no_std_compat::arch::x86_64::_MM_SET_EXCEPTION_STATE fn">_MM_SET_EXCEPTION_STATE</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._MM_SET_FLUSH_ZERO_MODE.html" title="no_std_compat::arch::x86_64::_MM_SET_FLUSH_ZERO_MODE fn">_MM_SET_FLUSH_ZERO_MODE</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._MM_SET_ROUNDING_MODE.html" title="no_std_compat::arch::x86_64::_MM_SET_ROUNDING_MODE fn">_MM_SET_ROUNDING_MODE</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>See <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._MM_TRANSPOSE4_PS.html" title="no_std_compat::arch::x86_64::_MM_TRANSPOSE4_PS fn">_MM_TRANSPOSE4_PS</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Transpose the 4x4 matrix formed by 4 rows of __m128 in place.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.__cpuid.html" title="no_std_compat::arch::x86_64::__cpuid fn">__cpuid</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>See <a href="fn.__cpuid_count.html"><code>__cpuid_count</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.__cpuid_count.html" title="no_std_compat::arch::x86_64::__cpuid_count fn">__cpuid_count</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the result of the <code>cpuid</code> instruction for a given <code>leaf</code> (<code>EAX</code>)
and
<code>sub_leaf</code> (<code>ECX</code>).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.__get_cpuid_max.html" title="no_std_compat::arch::x86_64::__get_cpuid_max fn">__get_cpuid_max</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>) <code>cpuid</code>
values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.__rdtscp.html" title="no_std_compat::arch::x86_64::__rdtscp fn">__rdtscp</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Reads the current value of the processor’s time-stamp counter and
the <code>IA32_TSC_AUX MSR</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._addcarry_u32.html" title="no_std_compat::arch::x86_64::_addcarry_u32 fn">_addcarry_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Adds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit carry-in <code>c_in</code>
(carry flag), and store the unsigned 32-bit result in <code>out</code>, and the carry-out
is returned (carry or overflow flag).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._addcarry_u64.html" title="no_std_compat::arch::x86_64::_addcarry_u64 fn">_addcarry_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Adds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit carry-in <code>c_in</code>
(carry flag), and store the unsigned 64-bit result in <code>out</code>, and the carry-out
is returned (carry or overflow flag).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._addcarryx_u32.html" title="no_std_compat::arch::x86_64::_addcarryx_u32 fn">_addcarryx_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `adx` only"><code>adx</code></span></div><div class="item-right docblock-short"><p>Adds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit carry-in <code>c_in</code>
(carry or overflow flag), and store the unsigned 32-bit result in <code>out</code>, and
the carry-out is returned (carry or overflow flag).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._addcarryx_u64.html" title="no_std_compat::arch::x86_64::_addcarryx_u64 fn">_addcarryx_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `adx` only"><code>adx</code></span></div><div class="item-right docblock-short"><p>Adds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit carry-in <code>c_in</code>
(carry or overflow flag), and store the unsigned 64-bit result in <code>out</code>, and
the carry-out is returned (carry or overflow flag).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._andn_u32.html" title="no_std_compat::arch::x86_64::_andn_u32 fn">_andn_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Bitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._andn_u64.html" title="no_std_compat::arch::x86_64::_andn_u64 fn">_andn_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Bitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bextr2_u32.html" title="no_std_compat::arch::x86_64::_bextr2_u32 fn">_bextr2_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Extracts bits of <code>a</code> specified by <code>control</code> into
the least significant bits of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bextr2_u64.html" title="no_std_compat::arch::x86_64::_bextr2_u64 fn">_bextr2_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Extracts bits of <code>a</code> specified by <code>control</code> into
the least significant bits of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bextr_u32.html" title="no_std_compat::arch::x86_64::_bextr_u32 fn">_bextr_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Extracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into
the least significant bits of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bextr_u64.html" title="no_std_compat::arch::x86_64::_bextr_u64 fn">_bextr_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Extracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into
the least significant bits of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bittest.html" title="no_std_compat::arch::x86_64::_bittest fn">_bittest</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bittest64.html" title="no_std_compat::arch::x86_64::_bittest64 fn">_bittest64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bittestandcomplement.html" title="no_std_compat::arch::x86_64::_bittestandcomplement fn">_bittestandcomplement</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>, then inverts that bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bittestandcomplement64.html" title="no_std_compat::arch::x86_64::_bittestandcomplement64 fn">_bittestandcomplement64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>, then inverts that bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bittestandreset.html" title="no_std_compat::arch::x86_64::_bittestandreset fn">_bittestandreset</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>, then resets that bit to <code>0</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bittestandreset64.html" title="no_std_compat::arch::x86_64::_bittestandreset64 fn">_bittestandreset64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>, then resets that bit to <code>0</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bittestandset.html" title="no_std_compat::arch::x86_64::_bittestandset fn">_bittestandset</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>, then sets the bit to <code>1</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bittestandset64.html" title="no_std_compat::arch::x86_64::_bittestandset64 fn">_bittestandset64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns the bit in position <code>b</code> of the memory addressed by <code>p</code>, then sets the bit to <code>1</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blcfill_u32.html" title="no_std_compat::arch::x86_64::_blcfill_u32 fn">_blcfill_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Clears all bits below the least significant zero bit of <code>x</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blcfill_u64.html" title="no_std_compat::arch::x86_64::_blcfill_u64 fn">_blcfill_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Clears all bits below the least significant zero bit of <code>x</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blci_u32.html" title="no_std_compat::arch::x86_64::_blci_u32 fn">_blci_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets all bits of <code>x</code> to 1 except for the least significant zero bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blci_u64.html" title="no_std_compat::arch::x86_64::_blci_u64 fn">_blci_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets all bits of <code>x</code> to 1 except for the least significant zero bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blcic_u32.html" title="no_std_compat::arch::x86_64::_blcic_u32 fn">_blcic_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets the least significant zero bit of <code>x</code> and clears all other bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blcic_u64.html" title="no_std_compat::arch::x86_64::_blcic_u64 fn">_blcic_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets the least significant zero bit of <code>x</code> and clears all other bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blcmsk_u32.html" title="no_std_compat::arch::x86_64::_blcmsk_u32 fn">_blcmsk_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets the least significant zero bit of <code>x</code> and clears all bits above
that bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blcmsk_u64.html" title="no_std_compat::arch::x86_64::_blcmsk_u64 fn">_blcmsk_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets the least significant zero bit of <code>x</code> and clears all bits above
that bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blcs_u32.html" title="no_std_compat::arch::x86_64::_blcs_u32 fn">_blcs_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets the least significant zero bit of <code>x</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blcs_u64.html" title="no_std_compat::arch::x86_64::_blcs_u64 fn">_blcs_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets the least significant zero bit of <code>x</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsfill_u32.html" title="no_std_compat::arch::x86_64::_blsfill_u32 fn">_blsfill_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets all bits of <code>x</code> below the least significant one.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsfill_u64.html" title="no_std_compat::arch::x86_64::_blsfill_u64 fn">_blsfill_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets all bits of <code>x</code> below the least significant one.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsi_u32.html" title="no_std_compat::arch::x86_64::_blsi_u32 fn">_blsi_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Extracts lowest set isolated bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsi_u64.html" title="no_std_compat::arch::x86_64::_blsi_u64 fn">_blsi_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Extracts lowest set isolated bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsic_u32.html" title="no_std_compat::arch::x86_64::_blsic_u32 fn">_blsic_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Clears least significant bit and sets all other bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsic_u64.html" title="no_std_compat::arch::x86_64::_blsic_u64 fn">_blsic_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Clears least significant bit and sets all other bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsmsk_u32.html" title="no_std_compat::arch::x86_64::_blsmsk_u32 fn">_blsmsk_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Gets mask up to lowest set bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsmsk_u64.html" title="no_std_compat::arch::x86_64::_blsmsk_u64 fn">_blsmsk_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Gets mask up to lowest set bit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsr_u32.html" title="no_std_compat::arch::x86_64::_blsr_u32 fn">_blsr_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Resets the lowest set bit of <code>x</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._blsr_u64.html" title="no_std_compat::arch::x86_64::_blsr_u64 fn">_blsr_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Resets the lowest set bit of <code>x</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bswap.html" title="no_std_compat::arch::x86_64::_bswap fn">_bswap</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns an integer with the reversed byte order of x</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bswap64.html" title="no_std_compat::arch::x86_64::_bswap64 fn">_bswap64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Returns an integer with the reversed byte order of x</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bzhi_u32.html" title="no_std_compat::arch::x86_64::_bzhi_u32 fn">_bzhi_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span></div><div class="item-right docblock-short"><p>Zeroes higher bits of <code>a</code> &gt;= <code>index</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._bzhi_u64.html" title="no_std_compat::arch::x86_64::_bzhi_u64 fn">_bzhi_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span></div><div class="item-right docblock-short"><p>Zeroes higher bits of <code>a</code> &gt;= <code>index</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._fxrstor.html" title="no_std_compat::arch::x86_64::_fxrstor fn">_fxrstor</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fxsr` only"><code>fxsr</code></span></div><div class="item-right docblock-short"><p>Restores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from the
512-byte-long 16-byte-aligned memory region <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._fxrstor64.html" title="no_std_compat::arch::x86_64::_fxrstor64 fn">_fxrstor64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fxsr` only"><code>fxsr</code></span></div><div class="item-right docblock-short"><p>Restores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from the
512-byte-long 16-byte-aligned memory region <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._fxsave.html" title="no_std_compat::arch::x86_64::_fxsave fn">_fxsave</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fxsr` only"><code>fxsr</code></span></div><div class="item-right docblock-short"><p>Saves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> registers to the
512-byte-long 16-byte-aligned memory region <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._fxsave64.html" title="no_std_compat::arch::x86_64::_fxsave64 fn">_fxsave64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fxsr` only"><code>fxsr</code></span></div><div class="item-right docblock-short"><p>Saves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> registers to the
512-byte-long 16-byte-aligned memory region <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._lzcnt_u32.html" title="no_std_compat::arch::x86_64::_lzcnt_u32 fn">_lzcnt_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `lzcnt` only"><code>lzcnt</code></span></div><div class="item-right docblock-short"><p>Counts the leading most significant zero bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._lzcnt_u64.html" title="no_std_compat::arch::x86_64::_lzcnt_u64 fn">_lzcnt_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `lzcnt` only"><code>lzcnt</code></span></div><div class="item-right docblock-short"><p>Counts the leading most significant zero bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_abs_epi8.html" title="no_std_compat::arch::x86_64::_mm256_abs_epi8 fn">_mm256_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Computes the absolute values of packed 8-bit integers in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_abs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_abs_epi16 fn">_mm256_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Computes the absolute values of packed 16-bit integers in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_abs_epi32.html" title="no_std_compat::arch::x86_64::_mm256_abs_epi32 fn">_mm256_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Computes the absolute values of packed 32-bit integers in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_add_epi8.html" title="no_std_compat::arch::x86_64::_mm256_add_epi8 fn">_mm256_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Adds packed 8-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_add_epi16.html" title="no_std_compat::arch::x86_64::_mm256_add_epi16 fn">_mm256_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Adds packed 16-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_add_epi32.html" title="no_std_compat::arch::x86_64::_mm256_add_epi32 fn">_mm256_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Adds packed 32-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_add_epi64.html" title="no_std_compat::arch::x86_64::_mm256_add_epi64 fn">_mm256_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Adds packed 64-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_add_pd.html" title="no_std_compat::arch::x86_64::_mm256_add_pd fn">_mm256_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Adds packed double-precision (64-bit) floating-point elements
in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_add_ps.html" title="no_std_compat::arch::x86_64::_mm256_add_ps fn">_mm256_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Adds packed single-precision (32-bit) floating-point elements in <code>a</code> and
<code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_adds_epi8.html" title="no_std_compat::arch::x86_64::_mm256_adds_epi8 fn">_mm256_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Adds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_adds_epi16.html" title="no_std_compat::arch::x86_64::_mm256_adds_epi16 fn">_mm256_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Adds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_adds_epu8.html" title="no_std_compat::arch::x86_64::_mm256_adds_epu8 fn">_mm256_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Adds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_adds_epu16.html" title="no_std_compat::arch::x86_64::_mm256_adds_epu16 fn">_mm256_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Adds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_addsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_addsub_pd fn">_mm256_addsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Alternatively adds and subtracts packed double-precision (64-bit)
floating-point elements in <code>a</code> to/from packed elements in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_addsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_addsub_ps fn">_mm256_addsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Alternatively adds and subtracts packed single-precision (32-bit)
floating-point elements in <code>a</code> to/from packed elements in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_alignr_epi8.html" title="no_std_compat::arch::x86_64::_mm256_alignr_epi8 fn">_mm256_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Concatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte temporary
result, shifts the result right by <code>n</code> bytes, and returns the low 16 bytes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_and_pd.html" title="no_std_compat::arch::x86_64::_mm256_and_pd fn">_mm256_and_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of a packed double-precision (64-bit)
floating-point elements in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_and_ps.html" title="no_std_compat::arch::x86_64::_mm256_and_ps fn">_mm256_and_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of packed single-precision (32-bit) floating-point
elements in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_and_si256.html" title="no_std_compat::arch::x86_64::_mm256_and_si256 fn">_mm256_and_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing integer data)
in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_andnot_pd.html" title="no_std_compat::arch::x86_64::_mm256_andnot_pd fn">_mm256_andnot_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise NOT of packed double-precision (64-bit) floating-point
elements in <code>a</code>, and then AND with <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_andnot_ps.html" title="no_std_compat::arch::x86_64::_mm256_andnot_ps fn">_mm256_andnot_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise NOT of packed single-precision (32-bit) floating-point
elements in <code>a</code>
and then AND with <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_andnot_si256.html" title="no_std_compat::arch::x86_64::_mm256_andnot_si256 fn">_mm256_andnot_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise NOT of 256 bits (representing integer data)
in <code>a</code> and then AND with <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_avg_epu8.html" title="no_std_compat::arch::x86_64::_mm256_avg_epu8 fn">_mm256_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Averages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_avg_epu16.html" title="no_std_compat::arch::x86_64::_mm256_avg_epu16 fn">_mm256_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Averages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_blend_epi16.html" title="no_std_compat::arch::x86_64::_mm256_blend_epi16 fn">_mm256_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Blends packed 16-bit integers from <code>a</code> and <code>b</code> using control mask <code>IMM8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_blend_epi32.html" title="no_std_compat::arch::x86_64::_mm256_blend_epi32 fn">_mm256_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Blends packed 32-bit integers from <code>a</code> and <code>b</code> using control mask <code>IMM8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_blend_pd.html" title="no_std_compat::arch::x86_64::_mm256_blend_pd fn">_mm256_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Blends packed double-precision (64-bit) floating-point elements from
<code>a</code> and <code>b</code> using control mask <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_blend_ps.html" title="no_std_compat::arch::x86_64::_mm256_blend_ps fn">_mm256_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Blends packed single-precision (32-bit) floating-point elements from
<code>a</code> and <code>b</code> using control mask <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_blendv_epi8.html" title="no_std_compat::arch::x86_64::_mm256_blendv_epi8 fn">_mm256_blendv_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Blends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_blendv_pd.html" title="no_std_compat::arch::x86_64::_mm256_blendv_pd fn">_mm256_blendv_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Blends packed double-precision (64-bit) floating-point elements from
<code>a</code> and <code>b</code> using <code>c</code> as a mask.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_blendv_ps.html" title="no_std_compat::arch::x86_64::_mm256_blendv_ps fn">_mm256_blendv_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Blends packed single-precision (32-bit) floating-point elements from
<code>a</code> and <code>b</code> using <code>c</code> as a mask.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcast_pd.html" title="no_std_compat::arch::x86_64::_mm256_broadcast_pd fn">_mm256_broadcast_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts 128 bits from memory (composed of 2 packed double-precision
(64-bit) floating-point elements) to all elements of the returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcast_ps.html" title="no_std_compat::arch::x86_64::_mm256_broadcast_ps fn">_mm256_broadcast_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts 128 bits from memory (composed of 4 packed single-precision
(32-bit) floating-point elements) to all elements of the returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcast_sd.html" title="no_std_compat::arch::x86_64::_mm256_broadcast_sd fn">_mm256_broadcast_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts a double-precision (64-bit) floating-point element from memory
to all elements of the returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcast_ss.html" title="no_std_compat::arch::x86_64::_mm256_broadcast_ss fn">_mm256_broadcast_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts a single-precision (32-bit) floating-point element from memory
to all elements of the returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcastb_epi8.html" title="no_std_compat::arch::x86_64::_mm256_broadcastb_epi8 fn">_mm256_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low packed 8-bit integer from <code>a</code> to all elements of
the 256-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcastd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_broadcastd_epi32 fn">_mm256_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low packed 32-bit integer from <code>a</code> to all elements of
the 256-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcastq_epi64.html" title="no_std_compat::arch::x86_64::_mm256_broadcastq_epi64 fn">_mm256_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low packed 64-bit integer from <code>a</code> to all elements of
the 256-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcastsd_pd.html" title="no_std_compat::arch::x86_64::_mm256_broadcastsd_pd fn">_mm256_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low double-precision (64-bit) floating-point element
from <code>a</code> to all elements of the 256-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcastsi128_si256.html" title="no_std_compat::arch::x86_64::_mm256_broadcastsi128_si256 fn">_mm256_broadcastsi128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts 128 bits of integer data from a to all 128-bit lanes in
the 256-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcastss_ps.html" title="no_std_compat::arch::x86_64::_mm256_broadcastss_ps fn">_mm256_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low single-precision (32-bit) floating-point element
from <code>a</code> to all elements of the 256-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_broadcastw_epi16.html" title="no_std_compat::arch::x86_64::_mm256_broadcastw_epi16 fn">_mm256_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low packed 16-bit integer from a to all elements of
the 256-bit returned value</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_bslli_epi128.html" title="no_std_compat::arch::x86_64::_mm256_bslli_epi128 fn">_mm256_bslli_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_bsrli_epi128.html" title="no_std_compat::arch::x86_64::_mm256_bsrli_epi128 fn">_mm256_bsrli_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castpd128_pd256.html" title="no_std_compat::arch::x86_64::_mm256_castpd128_pd256 fn">_mm256_castpd128_pd256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m128d to type __m256d;
the upper 128 bits of the result are undefined.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castpd256_pd128.html" title="no_std_compat::arch::x86_64::_mm256_castpd256_pd128 fn">_mm256_castpd256_pd128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m256d to type __m128d.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castpd_ps.html" title="no_std_compat::arch::x86_64::_mm256_castpd_ps fn">_mm256_castpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m256d to type __m256.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castpd_si256.html" title="no_std_compat::arch::x86_64::_mm256_castpd_si256 fn">_mm256_castpd_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m256d to type __m256i.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castps128_ps256.html" title="no_std_compat::arch::x86_64::_mm256_castps128_ps256 fn">_mm256_castps128_ps256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m128 to type __m256;
the upper 128 bits of the result are undefined.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castps256_ps128.html" title="no_std_compat::arch::x86_64::_mm256_castps256_ps128 fn">_mm256_castps256_ps128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m256 to type __m128.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castps_pd.html" title="no_std_compat::arch::x86_64::_mm256_castps_pd fn">_mm256_castps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Cast vector of type __m256 to type __m256d.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castps_si256.html" title="no_std_compat::arch::x86_64::_mm256_castps_si256 fn">_mm256_castps_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m256 to type __m256i.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castsi128_si256.html" title="no_std_compat::arch::x86_64::_mm256_castsi128_si256 fn">_mm256_castsi128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m128i to type __m256i;
the upper 128 bits of the result are undefined.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castsi256_pd.html" title="no_std_compat::arch::x86_64::_mm256_castsi256_pd fn">_mm256_castsi256_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m256i to type __m256d.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castsi256_ps.html" title="no_std_compat::arch::x86_64::_mm256_castsi256_ps fn">_mm256_castsi256_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m256i to type __m256.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_castsi256_si128.html" title="no_std_compat::arch::x86_64::_mm256_castsi256_si128 fn">_mm256_castsi256_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Casts vector of type __m256i to type __m128i.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_ceil_pd.html" title="no_std_compat::arch::x86_64::_mm256_ceil_pd fn">_mm256_ceil_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Rounds packed double-precision (64-bit) floating point elements in <code>a</code>
toward positive infinity.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_ceil_ps.html" title="no_std_compat::arch::x86_64::_mm256_ceil_ps fn">_mm256_ceil_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Rounds packed single-precision (32-bit) floating point elements in <code>a</code>
toward positive infinity.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmp_pd.html" title="no_std_compat::arch::x86_64::_mm256_cmp_pd fn">_mm256_cmp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Compares packed double-precision (64-bit) floating-point
elements in <code>a</code> and <code>b</code> based on the comparison operand
specified by <code>IMM5</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmp_ps.html" title="no_std_compat::arch::x86_64::_mm256_cmp_ps fn">_mm256_cmp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Compares packed single-precision (32-bit) floating-point
elements in <code>a</code> and <code>b</code> based on the comparison operand
specified by <code>IMM5</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmpeq_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epi8 fn">_mm256_cmpeq_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmpeq_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epi16 fn">_mm256_cmpeq_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmpeq_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epi32 fn">_mm256_cmpeq_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmpeq_epi64.html" title="no_std_compat::arch::x86_64::_mm256_cmpeq_epi64 fn">_mm256_cmpeq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmpgt_epi8.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epi8 fn">_mm256_cmpgt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmpgt_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epi16 fn">_mm256_cmpgt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 16-bit integers in <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmpgt_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epi32 fn">_mm256_cmpgt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 32-bit integers in <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cmpgt_epi64.html" title="no_std_compat::arch::x86_64::_mm256_cmpgt_epi64 fn">_mm256_cmpgt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 64-bit integers in <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepi8_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi8_epi16 fn">_mm256_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Sign-extend 8-bit integers to 16-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepi8_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi8_epi32 fn">_mm256_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Sign-extend 8-bit integers to 32-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepi8_epi64.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi8_epi64 fn">_mm256_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Sign-extend 8-bit integers to 64-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepi16_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi16_epi32 fn">_mm256_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Sign-extend 16-bit integers to 32-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepi16_epi64.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi16_epi64 fn">_mm256_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Sign-extend 16-bit integers to 64-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepi32_epi64.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi32_epi64 fn">_mm256_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Sign-extend 32-bit integers to 64-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepi32_pd.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi32_pd fn">_mm256_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Converts packed 32-bit integers in <code>a</code> to packed double-precision (64-bit)
floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepi32_ps.html" title="no_std_compat::arch::x86_64::_mm256_cvtepi32_ps fn">_mm256_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Converts packed 32-bit integers in <code>a</code> to packed single-precision (32-bit)
floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepu8_epi16.html" title="no_std_compat::arch::x86_64::_mm256_cvtepu8_epi16 fn">_mm256_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Zero-extend unsigned 8-bit integers in <code>a</code> to 16-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepu8_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvtepu8_epi32 fn">_mm256_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Zero-extend the lower eight unsigned 8-bit integers in <code>a</code> to 32-bit
integers. The upper eight elements of <code>a</code> are unused.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepu8_epi64.html" title="no_std_compat::arch::x86_64::_mm256_cvtepu8_epi64 fn">_mm256_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Zero-extend the lower four unsigned 8-bit integers in <code>a</code> to 64-bit
integers. The upper twelve elements of <code>a</code> are unused.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepu16_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvtepu16_epi32 fn">_mm256_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Zeroes extend packed unsigned 16-bit integers in <code>a</code> to packed 32-bit
integers, and stores the results in <code>dst</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepu16_epi64.html" title="no_std_compat::arch::x86_64::_mm256_cvtepu16_epi64 fn">_mm256_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Zero-extend the lower four unsigned 16-bit integers in <code>a</code> to 64-bit
integers. The upper four elements of <code>a</code> are unused.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtepu32_epi64.html" title="no_std_compat::arch::x86_64::_mm256_cvtepu32_epi64 fn">_mm256_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Zero-extend unsigned 32-bit integers in <code>a</code> to 64-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtpd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvtpd_epi32 fn">_mm256_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Converts packed double-precision (64-bit) floating-point elements in <code>a</code>
to packed 32-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtpd_ps.html" title="no_std_compat::arch::x86_64::_mm256_cvtpd_ps fn">_mm256_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Converts packed double-precision (64-bit) floating-point elements in <code>a</code>
to packed single-precision (32-bit) floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtps_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvtps_epi32 fn">_mm256_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Converts packed single-precision (32-bit) floating-point elements in <code>a</code>
to packed 32-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtps_pd.html" title="no_std_compat::arch::x86_64::_mm256_cvtps_pd fn">_mm256_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Converts packed single-precision (32-bit) floating-point elements in <code>a</code>
to packed double-precision (64-bit) floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtsd_f64.html" title="no_std_compat::arch::x86_64::_mm256_cvtsd_f64 fn">_mm256_cvtsd_f64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns the first element of the input vector of <code>[4 x double]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtsi256_si32.html" title="no_std_compat::arch::x86_64::_mm256_cvtsi256_si32 fn">_mm256_cvtsi256_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns the first element of the input vector of <code>[8 x i32]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvtss_f32.html" title="no_std_compat::arch::x86_64::_mm256_cvtss_f32 fn">_mm256_cvtss_f32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Returns the first element of the input vector of <code>[8 x float]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvttpd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvttpd_epi32 fn">_mm256_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Converts packed double-precision (64-bit) floating-point elements in <code>a</code>
to packed 32-bit integers with truncation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_cvttps_epi32.html" title="no_std_compat::arch::x86_64::_mm256_cvttps_epi32 fn">_mm256_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Converts packed single-precision (32-bit) floating-point elements in <code>a</code>
to packed 32-bit integers with truncation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_div_pd.html" title="no_std_compat::arch::x86_64::_mm256_div_pd fn">_mm256_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the division of each of the 4 packed 64-bit floating-point elements
in <code>a</code> by the corresponding packed elements in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_div_ps.html" title="no_std_compat::arch::x86_64::_mm256_div_ps fn">_mm256_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the division of each of the 8 packed 32-bit floating-point elements
in <code>a</code> by the corresponding packed elements in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_dp_ps.html" title="no_std_compat::arch::x86_64::_mm256_dp_ps fn">_mm256_dp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Conditionally multiplies the packed single-precision (32-bit) floating-point
elements in <code>a</code> and <code>b</code> using the high 4 bits in <code>imm8</code>,
sum the four products, and conditionally return the sum
using the low 4 bits of <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_extract_epi8.html" title="no_std_compat::arch::x86_64::_mm256_extract_epi8 fn">_mm256_extract_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Extracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. Returns a 32-bit
integer containing the zero-extended integer data.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_extract_epi16.html" title="no_std_compat::arch::x86_64::_mm256_extract_epi16 fn">_mm256_extract_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Extracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. Returns a 32-bit
integer containing the zero-extended integer data.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_extract_epi32.html" title="no_std_compat::arch::x86_64::_mm256_extract_epi32 fn">_mm256_extract_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Extracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_extract_epi64.html" title="no_std_compat::arch::x86_64::_mm256_extract_epi64 fn">_mm256_extract_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Extracts a 64-bit integer from <code>a</code>, selected with <code>INDEX</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_extractf128_pd.html" title="no_std_compat::arch::x86_64::_mm256_extractf128_pd fn">_mm256_extractf128_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Extracts 128 bits (composed of 2 packed double-precision (64-bit)
floating-point elements) from <code>a</code>, selected with <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_extractf128_ps.html" title="no_std_compat::arch::x86_64::_mm256_extractf128_ps fn">_mm256_extractf128_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Extracts 128 bits (composed of 4 packed single-precision (32-bit)
floating-point elements) from <code>a</code>, selected with <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_extractf128_si256.html" title="no_std_compat::arch::x86_64::_mm256_extractf128_si256 fn">_mm256_extractf128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Extracts 128 bits (composed of integer data) from <code>a</code>, selected with <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_extracti128_si256.html" title="no_std_compat::arch::x86_64::_mm256_extracti128_si256 fn">_mm256_extracti128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Extracts 128 bits (of integer data) from <code>a</code> selected with <code>IMM1</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_floor_pd.html" title="no_std_compat::arch::x86_64::_mm256_floor_pd fn">_mm256_floor_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Rounds packed double-precision (64-bit) floating point elements in <code>a</code>
toward negative infinity.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_floor_ps.html" title="no_std_compat::arch::x86_64::_mm256_floor_ps fn">_mm256_floor_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Rounds packed single-precision (32-bit) floating point elements in <code>a</code>
toward negative infinity.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_fmadd_pd fn">_mm256_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and add the intermediate result to packed elements in <code>c</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_fmadd_ps fn">_mm256_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and add the intermediate result to packed elements in <code>c</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_fmaddsub_pd fn">_mm256_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and alternatively add and subtract packed elements in <code>c</code> to/from
the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_fmaddsub_ps fn">_mm256_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and alternatively add and subtract packed elements in <code>c</code> to/from
the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_fmsub_pd fn">_mm256_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and subtract packed elements in <code>c</code> from the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_fmsub_ps fn">_mm256_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and subtract packed elements in <code>c</code> from the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_fmsubadd_pd fn">_mm256_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and alternatively subtract and add packed elements in <code>c</code> from/to
the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_fmsubadd_ps fn">_mm256_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and alternatively subtract and add packed elements in <code>c</code> from/to
the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_fnmadd_pd fn">_mm256_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and add the negated intermediate result to packed elements in <code>c</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_fnmadd_ps fn">_mm256_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and add the negated intermediate result to packed elements in <code>c</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_fnmsub_pd fn">_mm256_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and subtract packed elements in <code>c</code> from the negated intermediate
result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_fnmsub_ps fn">_mm256_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and subtract packed elements in <code>c</code> from the negated intermediate
result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hadd_epi16.html" title="no_std_compat::arch::x86_64::_mm256_hadd_epi16 fn">_mm256_hadd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Horizontally adds adjacent pairs of 16-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hadd_epi32.html" title="no_std_compat::arch::x86_64::_mm256_hadd_epi32 fn">_mm256_hadd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Horizontally adds adjacent pairs of 32-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hadd_pd.html" title="no_std_compat::arch::x86_64::_mm256_hadd_pd fn">_mm256_hadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Horizontal addition of adjacent pairs in the two packed vectors
of 4 64-bit floating points <code>a</code> and <code>b</code>.
In the result, sums of elements from <code>a</code> are returned in even locations,
while sums of elements from <code>b</code> are returned in odd locations.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hadd_ps.html" title="no_std_compat::arch::x86_64::_mm256_hadd_ps fn">_mm256_hadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Horizontal addition of adjacent pairs in the two packed vectors
of 8 32-bit floating points <code>a</code> and <code>b</code>.
In the result, sums of elements from <code>a</code> are returned in locations of
indices 0, 1, 4, 5; while sums of elements from <code>b</code> are locations
2, 3, 6, 7.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hadds_epi16.html" title="no_std_compat::arch::x86_64::_mm256_hadds_epi16 fn">_mm256_hadds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Horizontally adds adjacent pairs of 16-bit integers in <code>a</code> and <code>b</code>
using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hsub_epi16.html" title="no_std_compat::arch::x86_64::_mm256_hsub_epi16 fn">_mm256_hsub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Horizontally subtract adjacent pairs of 16-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hsub_epi32.html" title="no_std_compat::arch::x86_64::_mm256_hsub_epi32 fn">_mm256_hsub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Horizontally subtract adjacent pairs of 32-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hsub_pd.html" title="no_std_compat::arch::x86_64::_mm256_hsub_pd fn">_mm256_hsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Horizontal subtraction of adjacent pairs in the two packed vectors
of 4 64-bit floating points <code>a</code> and <code>b</code>.
In the result, sums of elements from <code>a</code> are returned in even locations,
while sums of elements from <code>b</code> are returned in odd locations.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hsub_ps.html" title="no_std_compat::arch::x86_64::_mm256_hsub_ps fn">_mm256_hsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Horizontal subtraction of adjacent pairs in the two packed vectors
of 8 32-bit floating points <code>a</code> and <code>b</code>.
In the result, sums of elements from <code>a</code> are returned in locations of
indices 0, 1, 4, 5; while sums of elements from <code>b</code> are locations
2, 3, 6, 7.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_hsubs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_hsubs_epi16 fn">_mm256_hsubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Horizontally subtract adjacent pairs of 16-bit integers in <code>a</code> and <code>b</code>
using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_i32gather_epi32.html" title="no_std_compat::arch::x86_64::_mm256_i32gather_epi32 fn">_mm256_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_i32gather_epi64.html" title="no_std_compat::arch::x86_64::_mm256_i32gather_epi64 fn">_mm256_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 and 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_i32gather_pd.html" title="no_std_compat::arch::x86_64::_mm256_i32gather_pd fn">_mm256_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_i32gather_ps.html" title="no_std_compat::arch::x86_64::_mm256_i32gather_ps fn">_mm256_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_i64gather_epi32.html" title="no_std_compat::arch::x86_64::_mm256_i64gather_epi32 fn">_mm256_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_i64gather_epi64.html" title="no_std_compat::arch::x86_64::_mm256_i64gather_epi64 fn">_mm256_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_i64gather_pd.html" title="no_std_compat::arch::x86_64::_mm256_i64gather_pd fn">_mm256_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_i64gather_ps.html" title="no_std_compat::arch::x86_64::_mm256_i64gather_ps fn">_mm256_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_insert_epi8.html" title="no_std_compat::arch::x86_64::_mm256_insert_epi8 fn">_mm256_insert_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Copies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into result
at the location specified by <code>index</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_insert_epi16.html" title="no_std_compat::arch::x86_64::_mm256_insert_epi16 fn">_mm256_insert_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Copies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into result
at the location specified by <code>index</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_insert_epi32.html" title="no_std_compat::arch::x86_64::_mm256_insert_epi32 fn">_mm256_insert_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Copies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into result
at the location specified by <code>index</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_insert_epi64.html" title="no_std_compat::arch::x86_64::_mm256_insert_epi64 fn">_mm256_insert_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Copies <code>a</code> to result, and insert the 64-bit integer <code>i</code> into result
at the location specified by <code>index</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_insertf128_pd.html" title="no_std_compat::arch::x86_64::_mm256_insertf128_pd fn">_mm256_insertf128_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Copies <code>a</code> to result, then inserts 128 bits (composed of 2 packed
double-precision (64-bit) floating-point elements) from <code>b</code> into result
at the location specified by <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_insertf128_ps.html" title="no_std_compat::arch::x86_64::_mm256_insertf128_ps fn">_mm256_insertf128_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Copies <code>a</code> to result, then inserts 128 bits (composed of 4 packed
single-precision (32-bit) floating-point elements) from <code>b</code> into result
at the location specified by <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_insertf128_si256.html" title="no_std_compat::arch::x86_64::_mm256_insertf128_si256 fn">_mm256_insertf128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Copies <code>a</code> to result, then inserts 128 bits from <code>b</code> into result
at the location specified by <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_inserti128_si256.html" title="no_std_compat::arch::x86_64::_mm256_inserti128_si256 fn">_mm256_inserti128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Copies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) from <code>b</code> at the
location specified by <code>IMM1</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_lddqu_si256.html" title="no_std_compat::arch::x86_64::_mm256_lddqu_si256 fn">_mm256_lddqu_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads 256-bits of integer data from unaligned memory into result.
This intrinsic may perform better than <code>_mm256_loadu_si256</code> when the
data crosses a cache line boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_load_pd.html" title="no_std_compat::arch::x86_64::_mm256_load_pd fn">_mm256_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads 256-bits (composed of 4 packed double-precision (64-bit)
floating-point elements) from memory into result.
<code>mem_addr</code> must be aligned on a 32-byte boundary or a
general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_load_ps.html" title="no_std_compat::arch::x86_64::_mm256_load_ps fn">_mm256_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads 256-bits (composed of 8 packed single-precision (32-bit)
floating-point elements) from memory into result.
<code>mem_addr</code> must be aligned on a 32-byte boundary or a
general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_load_si256.html" title="no_std_compat::arch::x86_64::_mm256_load_si256 fn">_mm256_load_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads 256-bits of integer data from memory into result.
<code>mem_addr</code> must be aligned on a 32-byte boundary or a
general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_loadu2_m128.html" title="no_std_compat::arch::x86_64::_mm256_loadu2_m128 fn">_mm256_loadu2_m128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span></div><div class="item-right docblock-short"><p>Loads two 128-bit values (composed of 4 packed single-precision (32-bit)
floating-point elements) from memory, and combine them into a 256-bit
value.
<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_loadu2_m128d.html" title="no_std_compat::arch::x86_64::_mm256_loadu2_m128d fn">_mm256_loadu2_m128d</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span></div><div class="item-right docblock-short"><p>Loads two 128-bit values (composed of 2 packed double-precision (64-bit)
floating-point elements) from memory, and combine them into a 256-bit
value.
<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_loadu2_m128i.html" title="no_std_compat::arch::x86_64::_mm256_loadu2_m128i fn">_mm256_loadu2_m128i</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span></div><div class="item-right docblock-short"><p>Loads two 128-bit values (composed of integer data) from memory, and combine
them into a 256-bit value.
<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_loadu_pd.html" title="no_std_compat::arch::x86_64::_mm256_loadu_pd fn">_mm256_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads 256-bits (composed of 4 packed double-precision (64-bit)
floating-point elements) from memory into result.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_loadu_ps.html" title="no_std_compat::arch::x86_64::_mm256_loadu_ps fn">_mm256_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads 256-bits (composed of 8 packed single-precision (32-bit)
floating-point elements) from memory into result.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_loadu_si256.html" title="no_std_compat::arch::x86_64::_mm256_loadu_si256 fn">_mm256_loadu_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads 256-bits of integer data from memory into result.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_madd_epi16.html" title="no_std_compat::arch::x86_64::_mm256_madd_epi16 fn">_mm256_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Multiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, producing
intermediate signed 32-bit integers. Horizontally add adjacent pairs
of intermediate 32-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_maddubs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_maddubs_epi16 fn">_mm256_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Vertically multiplies each unsigned 8-bit integer from <code>a</code> with the
corresponding signed 8-bit integer from <code>b</code>, producing intermediate
signed 16-bit integers. Horizontally add adjacent pairs of intermediate
signed 16-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mask_i32gather_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_i32gather_epi32 fn">_mm256_mask_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mask_i32gather_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_i32gather_epi64 fn">_mm256_mask_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mask_i32gather_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_i32gather_pd fn">_mm256_mask_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mask_i32gather_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_i32gather_ps fn">_mm256_mask_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mask_i64gather_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mask_i64gather_epi32 fn">_mm256_mask_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mask_i64gather_epi64.html" title="no_std_compat::arch::x86_64::_mm256_mask_i64gather_epi64 fn">_mm256_mask_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mask_i64gather_pd.html" title="no_std_compat::arch::x86_64::_mm256_mask_i64gather_pd fn">_mm256_mask_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mask_i64gather_ps.html" title="no_std_compat::arch::x86_64::_mm256_mask_i64gather_ps fn">_mm256_mask_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_maskload_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskload_epi32 fn">_mm256_maskload_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Loads packed 32-bit integers from memory pointed by <code>mem_addr</code> using <code>mask</code>
(elements are zeroed out when the highest bit is not set in the
corresponding element).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_maskload_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskload_epi64 fn">_mm256_maskload_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Loads packed 64-bit integers from memory pointed by <code>mem_addr</code> using <code>mask</code>
(elements are zeroed out when the highest bit is not set in the
corresponding element).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_maskload_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskload_pd fn">_mm256_maskload_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads packed double-precision (64-bit) floating-point elements from memory
into result using <code>mask</code> (elements are zeroed out when the high bit of the
corresponding element is not set).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_maskload_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskload_ps fn">_mm256_maskload_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads packed single-precision (32-bit) floating-point elements from memory
into result using <code>mask</code> (elements are zeroed out when the high bit of the
corresponding element is not set).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_maskstore_epi32.html" title="no_std_compat::arch::x86_64::_mm256_maskstore_epi32 fn">_mm256_maskstore_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Stores packed 32-bit integers from <code>a</code> into memory pointed by <code>mem_addr</code>
using <code>mask</code> (elements are not stored when the highest bit is not set
in the corresponding element).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_maskstore_epi64.html" title="no_std_compat::arch::x86_64::_mm256_maskstore_epi64 fn">_mm256_maskstore_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Stores packed 64-bit integers from <code>a</code> into memory pointed by <code>mem_addr</code>
using <code>mask</code> (elements are not stored when the highest bit is not set
in the corresponding element).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_maskstore_pd.html" title="no_std_compat::arch::x86_64::_mm256_maskstore_pd fn">_mm256_maskstore_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores packed double-precision (64-bit) floating-point elements from <code>a</code>
into memory using <code>mask</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_maskstore_ps.html" title="no_std_compat::arch::x86_64::_mm256_maskstore_ps fn">_mm256_maskstore_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores packed single-precision (32-bit) floating-point elements from <code>a</code>
into memory using <code>mask</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_max_epi8.html" title="no_std_compat::arch::x86_64::_mm256_max_epi8 fn">_mm256_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the packed
maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_max_epi16.html" title="no_std_compat::arch::x86_64::_mm256_max_epi16 fn">_mm256_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns the packed
maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_max_epi32.html" title="no_std_compat::arch::x86_64::_mm256_max_epi32 fn">_mm256_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns the packed
maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_max_epu8.html" title="no_std_compat::arch::x86_64::_mm256_max_epu8 fn">_mm256_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and returns
the packed maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_max_epu16.html" title="no_std_compat::arch::x86_64::_mm256_max_epu16 fn">_mm256_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and returns
the packed maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_max_epu32.html" title="no_std_compat::arch::x86_64::_mm256_max_epu32 fn">_mm256_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and returns
the packed maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_max_pd.html" title="no_std_compat::arch::x86_64::_mm256_max_pd fn">_mm256_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Compares packed double-precision (64-bit) floating-point elements
in <code>a</code> and <code>b</code>, and returns packed maximum values</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_max_ps.html" title="no_std_compat::arch::x86_64::_mm256_max_ps fn">_mm256_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Compares packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and returns packed maximum values</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_min_epi8.html" title="no_std_compat::arch::x86_64::_mm256_min_epi8 fn">_mm256_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the packed
minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_min_epi16.html" title="no_std_compat::arch::x86_64::_mm256_min_epi16 fn">_mm256_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns the packed
minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_min_epi32.html" title="no_std_compat::arch::x86_64::_mm256_min_epi32 fn">_mm256_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns the packed
minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_min_epu8.html" title="no_std_compat::arch::x86_64::_mm256_min_epu8 fn">_mm256_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and returns
the packed minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_min_epu16.html" title="no_std_compat::arch::x86_64::_mm256_min_epu16 fn">_mm256_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and returns
the packed minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_min_epu32.html" title="no_std_compat::arch::x86_64::_mm256_min_epu32 fn">_mm256_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and returns
the packed minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_min_pd.html" title="no_std_compat::arch::x86_64::_mm256_min_pd fn">_mm256_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Compares packed double-precision (64-bit) floating-point elements
in <code>a</code> and <code>b</code>, and returns packed minimum values</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_min_ps.html" title="no_std_compat::arch::x86_64::_mm256_min_ps fn">_mm256_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Compares packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and returns packed minimum values</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_movedup_pd.html" title="no_std_compat::arch::x86_64::_mm256_movedup_pd fn">_mm256_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed double-precision (64-bit) floating-point elements
from <code>a</code>, and returns the results.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_movehdup_ps.html" title="no_std_compat::arch::x86_64::_mm256_movehdup_ps fn">_mm256_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Duplicate odd-indexed single-precision (32-bit) floating-point elements
from <code>a</code>, and returns the results.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_moveldup_ps.html" title="no_std_compat::arch::x86_64::_mm256_moveldup_ps fn">_mm256_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed single-precision (32-bit) floating-point elements
from <code>a</code>, and returns the results.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_movemask_epi8.html" title="no_std_compat::arch::x86_64::_mm256_movemask_epi8 fn">_mm256_movemask_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Creates mask from the most significant bit of each 8-bit element in <code>a</code>,
return the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_movemask_pd.html" title="no_std_compat::arch::x86_64::_mm256_movemask_pd fn">_mm256_movemask_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets each bit of the returned mask based on the most significant bit of the
corresponding packed double-precision (64-bit) floating-point element in
<code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_movemask_ps.html" title="no_std_compat::arch::x86_64::_mm256_movemask_ps fn">_mm256_movemask_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets each bit of the returned mask based on the most significant bit of the
corresponding packed single-precision (32-bit) floating-point element in
<code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mpsadbw_epu8.html" title="no_std_compat::arch::x86_64::_mm256_mpsadbw_epu8 fn">_mm256_mpsadbw_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Computes the sum of absolute differences (SADs) of quadruplets of unsigned
8-bit integers in <code>a</code> compared to those in <code>b</code>, and stores the 16-bit
results in dst. Eight SADs are performed for each 128-bit lane using one
quadruplet from <code>b</code> and eight quadruplets from <code>a</code>. One quadruplet is
selected from <code>b</code> starting at on the offset specified in <code>imm8</code>. Eight
quadruplets are formed from sequential 8-bit integers selected from <code>a</code>
starting at the offset specified in <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mul_epi32 fn">_mm256_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Multiplies the low 32-bit integers from each packed 64-bit element in
<code>a</code> and <code>b</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mul_epu32.html" title="no_std_compat::arch::x86_64::_mm256_mul_epu32 fn">_mm256_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Multiplies the low unsigned 32-bit integers from each packed 64-bit
element in <code>a</code> and <code>b</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mul_pd.html" title="no_std_compat::arch::x86_64::_mm256_mul_pd fn">_mm256_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements
in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mul_ps.html" title="no_std_compat::arch::x86_64::_mm256_mul_ps fn">_mm256_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code> and
<code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mulhi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mulhi_epi16 fn">_mm256_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Multiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing
intermediate 32-bit integers and returning the high 16 bits of the
intermediate integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mulhi_epu16.html" title="no_std_compat::arch::x86_64::_mm256_mulhi_epu16 fn">_mm256_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Multiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, producing
intermediate 32-bit integers and returning the high 16 bits of the
intermediate integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mulhrs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mulhrs_epi16 fn">_mm256_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Multiplies packed 16-bit integers in <code>a</code> and <code>b</code>, producing
intermediate signed 32-bit integers. Truncate each intermediate
integer to the 18 most significant bits, round by adding 1, and
return bits <code>[16:1]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mullo_epi16.html" title="no_std_compat::arch::x86_64::_mm256_mullo_epi16 fn">_mm256_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Multiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing
intermediate 32-bit integers, and returns the low 16 bits of the
intermediate integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_mullo_epi32.html" title="no_std_compat::arch::x86_64::_mm256_mullo_epi32 fn">_mm256_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Multiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing
intermediate 64-bit integers, and returns the low 32 bits of the
intermediate integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_or_pd.html" title="no_std_compat::arch::x86_64::_mm256_or_pd fn">_mm256_or_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise OR packed double-precision (64-bit) floating-point
elements in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_or_ps.html" title="no_std_compat::arch::x86_64::_mm256_or_ps fn">_mm256_or_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise OR packed single-precision (32-bit) floating-point
elements in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_or_si256.html" title="no_std_compat::arch::x86_64::_mm256_or_si256 fn">_mm256_or_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise OR of 256 bits (representing integer data) in <code>a</code>
and <code>b</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_packs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_packs_epi16 fn">_mm256_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Converts packed 16-bit integers from <code>a</code> and <code>b</code> to packed 8-bit integers
using signed saturation</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_packs_epi32.html" title="no_std_compat::arch::x86_64::_mm256_packs_epi32 fn">_mm256_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Converts packed 32-bit integers from <code>a</code> and <code>b</code> to packed 16-bit integers
using signed saturation</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_packus_epi16.html" title="no_std_compat::arch::x86_64::_mm256_packus_epi16 fn">_mm256_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Converts packed 16-bit integers from <code>a</code> and <code>b</code> to packed 8-bit integers
using unsigned saturation</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_packus_epi32.html" title="no_std_compat::arch::x86_64::_mm256_packus_epi32 fn">_mm256_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Converts packed 32-bit integers from <code>a</code> and <code>b</code> to packed 16-bit integers
using unsigned saturation</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permute2f128_pd.html" title="no_std_compat::arch::x86_64::_mm256_permute2f128_pd fn">_mm256_permute2f128_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles 256 bits (composed of 4 packed double-precision (64-bit)
floating-point elements) selected by <code>imm8</code> from <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permute2f128_ps.html" title="no_std_compat::arch::x86_64::_mm256_permute2f128_ps fn">_mm256_permute2f128_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles 256 bits (composed of 8 packed single-precision (32-bit)
floating-point elements) selected by <code>imm8</code> from <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permute2f128_si256.html" title="no_std_compat::arch::x86_64::_mm256_permute2f128_si256 fn">_mm256_permute2f128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles 128-bits (composed of integer data) selected by <code>imm8</code>
from <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permute2x128_si256.html" title="no_std_compat::arch::x86_64::_mm256_permute2x128_si256 fn">_mm256_permute2x128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permute4x64_epi64.html" title="no_std_compat::arch::x86_64::_mm256_permute4x64_epi64 fn">_mm256_permute4x64_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Permutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permute4x64_pd.html" title="no_std_compat::arch::x86_64::_mm256_permute4x64_pd fn">_mm256_permute4x64_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shuffles 64-bit floating-point elements in <code>a</code> across lanes using the
control in <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permute_pd.html" title="no_std_compat::arch::x86_64::_mm256_permute_pd fn">_mm256_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles double-precision (64-bit) floating-point elements in <code>a</code>
within 128-bit lanes using the control in <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permute_ps.html" title="no_std_compat::arch::x86_64::_mm256_permute_ps fn">_mm256_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles single-precision (32-bit) floating-point elements in <code>a</code>
within 128-bit lanes using the control in <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permutevar8x32_epi32.html" title="no_std_compat::arch::x86_64::_mm256_permutevar8x32_epi32 fn">_mm256_permutevar8x32_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Permutes packed 32-bit integers from <code>a</code> according to the content of <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permutevar8x32_ps.html" title="no_std_compat::arch::x86_64::_mm256_permutevar8x32_ps fn">_mm256_permutevar8x32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shuffles eight 32-bit foating-point elements in <code>a</code> across lanes using
the corresponding 32-bit integer index in <code>idx</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permutevar_pd.html" title="no_std_compat::arch::x86_64::_mm256_permutevar_pd fn">_mm256_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles double-precision (64-bit) floating-point elements in <code>a</code>
within 256-bit lanes using the control in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_permutevar_ps.html" title="no_std_compat::arch::x86_64::_mm256_permutevar_ps fn">_mm256_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles single-precision (32-bit) floating-point elements in <code>a</code>
within 128-bit lanes using the control in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_rcp_ps.html" title="no_std_compat::arch::x86_64::_mm256_rcp_ps fn">_mm256_rcp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the approximate reciprocal of packed single-precision (32-bit)
floating-point elements in <code>a</code>, and returns the results. The maximum
relative error for this approximation is less than 1.5*2^-12.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_round_pd.html" title="no_std_compat::arch::x86_64::_mm256_round_pd fn">_mm256_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Rounds packed double-precision (64-bit) floating point elements in <code>a</code>
according to the flag <code>ROUNDING</code>. The value of <code>ROUNDING</code> may be as follows:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_round_ps.html" title="no_std_compat::arch::x86_64::_mm256_round_ps fn">_mm256_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Rounds packed single-precision (32-bit) floating point elements in <code>a</code>
according to the flag <code>ROUNDING</code>. The value of <code>ROUNDING</code> may be as follows:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_rsqrt_ps.html" title="no_std_compat::arch::x86_64::_mm256_rsqrt_ps fn">_mm256_rsqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the approximate reciprocal square root of packed single-precision
(32-bit) floating-point elements in <code>a</code>, and returns the results.
The maximum relative error for this approximation is less than 1.5*2^-12.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sad_epu8.html" title="no_std_compat::arch::x86_64::_mm256_sad_epu8 fn">_mm256_sad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Computes the absolute differences of packed unsigned 8-bit integers in <code>a</code>
and <code>b</code>, then horizontally sum each consecutive 8 differences to
produce four unsigned 16-bit integers, and pack these unsigned 16-bit
integers in the low 16 bits of the 64-bit return value</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set1_epi8.html" title="no_std_compat::arch::x86_64::_mm256_set1_epi8 fn">_mm256_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts 8-bit integer <code>a</code> to all elements of returned vector.
This intrinsic may generate the <code>vpbroadcastb</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set1_epi16.html" title="no_std_compat::arch::x86_64::_mm256_set1_epi16 fn">_mm256_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts 16-bit integer <code>a</code> to all all elements of returned vector.
This intrinsic may generate the <code>vpbroadcastw</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set1_epi32.html" title="no_std_compat::arch::x86_64::_mm256_set1_epi32 fn">_mm256_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts 32-bit integer <code>a</code> to all elements of returned vector.
This intrinsic may generate the <code>vpbroadcastd</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set1_epi64x.html" title="no_std_compat::arch::x86_64::_mm256_set1_epi64x fn">_mm256_set1_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts 64-bit integer <code>a</code> to all elements of returned vector.
This intrinsic may generate the <code>vpbroadcastq</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set1_pd.html" title="no_std_compat::arch::x86_64::_mm256_set1_pd fn">_mm256_set1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts double-precision (64-bit) floating-point value <code>a</code> to all
elements of returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set1_ps.html" title="no_std_compat::arch::x86_64::_mm256_set1_ps fn">_mm256_set1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts single-precision (32-bit) floating-point value <code>a</code> to all
elements of returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set_epi8.html" title="no_std_compat::arch::x86_64::_mm256_set_epi8 fn">_mm256_set_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed 8-bit integers in returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set_epi16.html" title="no_std_compat::arch::x86_64::_mm256_set_epi16 fn">_mm256_set_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed 16-bit integers in returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set_epi32.html" title="no_std_compat::arch::x86_64::_mm256_set_epi32 fn">_mm256_set_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed 32-bit integers in returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set_epi64x.html" title="no_std_compat::arch::x86_64::_mm256_set_epi64x fn">_mm256_set_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed 64-bit integers in returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set_m128.html" title="no_std_compat::arch::x86_64::_mm256_set_m128 fn">_mm256_set_m128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed __m256 returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set_m128d.html" title="no_std_compat::arch::x86_64::_mm256_set_m128d fn">_mm256_set_m128d</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed __m256d returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set_m128i.html" title="no_std_compat::arch::x86_64::_mm256_set_m128i fn">_mm256_set_m128i</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed __m256i returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set_pd.html" title="no_std_compat::arch::x86_64::_mm256_set_pd fn">_mm256_set_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed double-precision (64-bit) floating-point elements in returned
vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_set_ps.html" title="no_std_compat::arch::x86_64::_mm256_set_ps fn">_mm256_set_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed single-precision (32-bit) floating-point elements in returned
vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setr_epi8.html" title="no_std_compat::arch::x86_64::_mm256_setr_epi8 fn">_mm256_setr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed 8-bit integers in returned vector with the supplied values in
reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setr_epi16.html" title="no_std_compat::arch::x86_64::_mm256_setr_epi16 fn">_mm256_setr_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed 16-bit integers in returned vector with the supplied values in
reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setr_epi32.html" title="no_std_compat::arch::x86_64::_mm256_setr_epi32 fn">_mm256_setr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed 32-bit integers in returned vector with the supplied values in
reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setr_epi64x.html" title="no_std_compat::arch::x86_64::_mm256_setr_epi64x fn">_mm256_setr_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed 64-bit integers in returned vector with the supplied values in
reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setr_m128.html" title="no_std_compat::arch::x86_64::_mm256_setr_m128 fn">_mm256_setr_m128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed __m256 returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setr_m128d.html" title="no_std_compat::arch::x86_64::_mm256_setr_m128d fn">_mm256_setr_m128d</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed __m256d returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setr_m128i.html" title="no_std_compat::arch::x86_64::_mm256_setr_m128i fn">_mm256_setr_m128i</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed __m256i returned vector with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setr_pd.html" title="no_std_compat::arch::x86_64::_mm256_setr_pd fn">_mm256_setr_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed double-precision (64-bit) floating-point elements in returned
vector with the supplied values in reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setr_ps.html" title="no_std_compat::arch::x86_64::_mm256_setr_ps fn">_mm256_setr_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Sets packed single-precision (32-bit) floating-point elements in returned
vector with the supplied values in reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setzero_pd.html" title="no_std_compat::arch::x86_64::_mm256_setzero_pd fn">_mm256_setzero_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Returns vector of type __m256d with all elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setzero_ps.html" title="no_std_compat::arch::x86_64::_mm256_setzero_ps fn">_mm256_setzero_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Returns vector of type __m256 with all elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_setzero_si256.html" title="no_std_compat::arch::x86_64::_mm256_setzero_si256 fn">_mm256_setzero_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Returns vector of type __m256i with all elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_shuffle_epi8.html" title="no_std_compat::arch::x86_64::_mm256_shuffle_epi8 fn">_mm256_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shuffles bytes from <code>a</code> according to the content of <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_shuffle_epi32.html" title="no_std_compat::arch::x86_64::_mm256_shuffle_epi32 fn">_mm256_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shuffles 32-bit integers in 128-bit lanes of <code>a</code> using the control in
<code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_shuffle_pd.html" title="no_std_compat::arch::x86_64::_mm256_shuffle_pd fn">_mm256_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles double-precision (64-bit) floating-point elements within 128-bit
lanes using the control in <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_shuffle_ps.html" title="no_std_compat::arch::x86_64::_mm256_shuffle_ps fn">_mm256_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles single-precision (32-bit) floating-point elements in <code>a</code> within
128-bit lanes using the control in <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_shufflehi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_shufflehi_epi16 fn">_mm256_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shuffles 16-bit integers in the high 64 bits of 128-bit lanes of <code>a</code> using
the control in <code>imm8</code>. The low 64 bits of 128-bit lanes of <code>a</code> are copied
to the output.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_shufflelo_epi16.html" title="no_std_compat::arch::x86_64::_mm256_shufflelo_epi16 fn">_mm256_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shuffles 16-bit integers in the low 64 bits of 128-bit lanes of <code>a</code> using
the control in <code>imm8</code>. The high 64 bits of 128-bit lanes of <code>a</code> are copied
to the output.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sign_epi8.html" title="no_std_compat::arch::x86_64::_mm256_sign_epi8 fn">_mm256_sign_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Negates packed 8-bit integers in <code>a</code> when the corresponding signed
8-bit integer in <code>b</code> is negative, and returns the results.
Results are zeroed out when the corresponding element in <code>b</code> is zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sign_epi16.html" title="no_std_compat::arch::x86_64::_mm256_sign_epi16 fn">_mm256_sign_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Negates packed 16-bit integers in <code>a</code> when the corresponding signed
16-bit integer in <code>b</code> is negative, and returns the results.
Results are zeroed out when the corresponding element in <code>b</code> is zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sign_epi32.html" title="no_std_compat::arch::x86_64::_mm256_sign_epi32 fn">_mm256_sign_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Negates packed 32-bit integers in <code>a</code> when the corresponding signed
32-bit integer in <code>b</code> is negative, and returns the results.
Results are zeroed out when the corresponding element in <code>b</code> is zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sll_epi16.html" title="no_std_compat::arch::x86_64::_mm256_sll_epi16 fn">_mm256_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> left by <code>count</code> while
shifting in zeros, and returns the result</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sll_epi32.html" title="no_std_compat::arch::x86_64::_mm256_sll_epi32 fn">_mm256_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> left by <code>count</code> while
shifting in zeros, and returns the result</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sll_epi64.html" title="no_std_compat::arch::x86_64::_mm256_sll_epi64 fn">_mm256_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> left by <code>count</code> while
shifting in zeros, and returns the result</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_slli_epi16.html" title="no_std_compat::arch::x86_64::_mm256_slli_epi16 fn">_mm256_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while
shifting in zeros, return the results;</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_slli_epi32.html" title="no_std_compat::arch::x86_64::_mm256_slli_epi32 fn">_mm256_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while
shifting in zeros, return the results;</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_slli_epi64.html" title="no_std_compat::arch::x86_64::_mm256_slli_epi64 fn">_mm256_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while
shifting in zeros, return the results;</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_slli_si256.html" title="no_std_compat::arch::x86_64::_mm256_slli_si256 fn">_mm256_slli_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sllv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_sllv_epi32 fn">_mm256_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> left by the amount
specified by the corresponding element in <code>count</code> while
shifting in zeros, and returns the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sllv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_sllv_epi64 fn">_mm256_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> left by the amount
specified by the corresponding element in <code>count</code> while
shifting in zeros, and returns the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sqrt_pd.html" title="no_std_compat::arch::x86_64::_mm256_sqrt_pd fn">_mm256_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Returns the square root of packed double-precision (64-bit) floating point
elements in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sqrt_ps.html" title="no_std_compat::arch::x86_64::_mm256_sqrt_ps fn">_mm256_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Returns the square root of packed single-precision (32-bit) floating point
elements in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sra_epi16.html" title="no_std_compat::arch::x86_64::_mm256_sra_epi16 fn">_mm256_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> right by <code>count</code> while
shifting in sign bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sra_epi32.html" title="no_std_compat::arch::x86_64::_mm256_sra_epi32 fn">_mm256_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by <code>count</code> while
shifting in sign bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srai_epi16.html" title="no_std_compat::arch::x86_64::_mm256_srai_epi16 fn">_mm256_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while
shifting in sign bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srai_epi32.html" title="no_std_compat::arch::x86_64::_mm256_srai_epi32 fn">_mm256_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while
shifting in sign bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srav_epi32.html" title="no_std_compat::arch::x86_64::_mm256_srav_epi32 fn">_mm256_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by the amount specified by the
corresponding element in <code>count</code> while shifting in sign bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srl_epi16.html" title="no_std_compat::arch::x86_64::_mm256_srl_epi16 fn">_mm256_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> right by <code>count</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srl_epi32.html" title="no_std_compat::arch::x86_64::_mm256_srl_epi32 fn">_mm256_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by <code>count</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srl_epi64.html" title="no_std_compat::arch::x86_64::_mm256_srl_epi64 fn">_mm256_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> right by <code>count</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srli_epi16.html" title="no_std_compat::arch::x86_64::_mm256_srli_epi16 fn">_mm256_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in
zeros</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srli_epi32.html" title="no_std_compat::arch::x86_64::_mm256_srli_epi32 fn">_mm256_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in
zeros</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srli_epi64.html" title="no_std_compat::arch::x86_64::_mm256_srli_epi64 fn">_mm256_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in
zeros</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srli_si256.html" title="no_std_compat::arch::x86_64::_mm256_srli_si256 fn">_mm256_srli_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srlv_epi32.html" title="no_std_compat::arch::x86_64::_mm256_srlv_epi32 fn">_mm256_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by the amount specified by
the corresponding element in <code>count</code> while shifting in zeros,</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_srlv_epi64.html" title="no_std_compat::arch::x86_64::_mm256_srlv_epi64 fn">_mm256_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> right by the amount specified by
the corresponding element in <code>count</code> while shifting in zeros,</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_store_pd.html" title="no_std_compat::arch::x86_64::_mm256_store_pd fn">_mm256_store_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores 256-bits (composed of 4 packed double-precision (64-bit)
floating-point elements) from <code>a</code> into memory.
<code>mem_addr</code> must be aligned on a 32-byte boundary or a
general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_store_ps.html" title="no_std_compat::arch::x86_64::_mm256_store_ps fn">_mm256_store_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores 256-bits (composed of 8 packed single-precision (32-bit)
floating-point elements) from <code>a</code> into memory.
<code>mem_addr</code> must be aligned on a 32-byte boundary or a
general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_store_si256.html" title="no_std_compat::arch::x86_64::_mm256_store_si256 fn">_mm256_store_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores 256-bits of integer data from <code>a</code> into memory.
<code>mem_addr</code> must be aligned on a 32-byte boundary or a
general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_storeu2_m128.html" title="no_std_compat::arch::x86_64::_mm256_storeu2_m128 fn">_mm256_storeu2_m128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span></div><div class="item-right docblock-short"><p>Stores the high and low 128-bit halves (each composed of 4 packed
single-precision (32-bit) floating-point elements) from <code>a</code> into memory two
different 128-bit locations.
<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_storeu2_m128d.html" title="no_std_compat::arch::x86_64::_mm256_storeu2_m128d fn">_mm256_storeu2_m128d</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span></div><div class="item-right docblock-short"><p>Stores the high and low 128-bit halves (each composed of 2 packed
double-precision (64-bit) floating-point elements) from <code>a</code> into memory two
different 128-bit locations.
<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_storeu2_m128i.html" title="no_std_compat::arch::x86_64::_mm256_storeu2_m128i fn">_mm256_storeu2_m128i</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span></div><div class="item-right docblock-short"><p>Stores the high and low 128-bit halves (each composed of integer data) from
<code>a</code> into memory two different 128-bit locations.
<code>hiaddr</code> and <code>loaddr</code> do not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_storeu_pd.html" title="no_std_compat::arch::x86_64::_mm256_storeu_pd fn">_mm256_storeu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores 256-bits (composed of 4 packed double-precision (64-bit)
floating-point elements) from <code>a</code> into memory.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_storeu_ps.html" title="no_std_compat::arch::x86_64::_mm256_storeu_ps fn">_mm256_storeu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores 256-bits (composed of 8 packed single-precision (32-bit)
floating-point elements) from <code>a</code> into memory.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_storeu_si256.html" title="no_std_compat::arch::x86_64::_mm256_storeu_si256 fn">_mm256_storeu_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores 256-bits of integer data from <code>a</code> into memory.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_stream_pd.html" title="no_std_compat::arch::x86_64::_mm256_stream_pd fn">_mm256_stream_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Moves double-precision values from a 256-bit vector of <code>[4 x double]</code>
to a 32-byte aligned memory location. To minimize caching, the data is
flagged as non-temporal (unlikely to be used again soon).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_stream_ps.html" title="no_std_compat::arch::x86_64::_mm256_stream_ps fn">_mm256_stream_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Moves single-precision floating point values from a 256-bit vector
of <code>[8 x float]</code> to a 32-byte aligned memory location. To minimize
caching, the data is flagged as non-temporal (unlikely to be used again
soon).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_stream_si256.html" title="no_std_compat::arch::x86_64::_mm256_stream_si256 fn">_mm256_stream_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Moves integer data from a 256-bit integer vector to a 32-byte
aligned memory location. To minimize caching, the data is flagged as
non-temporal (unlikely to be used again soon)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sub_epi8.html" title="no_std_compat::arch::x86_64::_mm256_sub_epi8 fn">_mm256_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in <code>b</code> from packed 8-bit integers in <code>a</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sub_epi16.html" title="no_std_compat::arch::x86_64::_mm256_sub_epi16 fn">_mm256_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in <code>b</code> from packed 16-bit integers in <code>a</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sub_epi32.html" title="no_std_compat::arch::x86_64::_mm256_sub_epi32 fn">_mm256_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 32-bit integers in <code>b</code> from packed 32-bit integers in <code>a</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sub_epi64.html" title="no_std_compat::arch::x86_64::_mm256_sub_epi64 fn">_mm256_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 64-bit integers in <code>b</code> from packed 64-bit integers in <code>a</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sub_pd.html" title="no_std_compat::arch::x86_64::_mm256_sub_pd fn">_mm256_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Subtracts packed double-precision (64-bit) floating-point elements in <code>b</code>
from packed elements in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_sub_ps.html" title="no_std_compat::arch::x86_64::_mm256_sub_ps fn">_mm256_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Subtracts packed single-precision (32-bit) floating-point elements in <code>b</code>
from packed elements in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_subs_epi8.html" title="no_std_compat::arch::x86_64::_mm256_subs_epi8 fn">_mm256_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in <code>b</code> from packed 8-bit integers in
<code>a</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_subs_epi16.html" title="no_std_compat::arch::x86_64::_mm256_subs_epi16 fn">_mm256_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in <code>b</code> from packed 16-bit integers in
<code>a</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_subs_epu8.html" title="no_std_compat::arch::x86_64::_mm256_subs_epu8 fn">_mm256_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 8-bit integers in <code>b</code> from packed 8-bit
integers in <code>a</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_subs_epu16.html" title="no_std_compat::arch::x86_64::_mm256_subs_epu16 fn">_mm256_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 16-bit integers in <code>b</code> from packed 16-bit
integers in <code>a</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_testc_pd.html" title="no_std_compat::arch::x86_64::_mm256_testc_pd fn">_mm256_testc_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing double-precision (64-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_testc_ps.html" title="no_std_compat::arch::x86_64::_mm256_testc_ps fn">_mm256_testc_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing single-precision (32-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_testc_si256.html" title="no_std_compat::arch::x86_64::_mm256_testc_si256 fn">_mm256_testc_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing integer data) in <code>a</code> and
<code>b</code>, and set <code>ZF</code> to 1 if the result is zero, otherwise set <code>ZF</code> to 0.
Computes the bitwise NOT of <code>a</code> and then AND with <code>b</code>, and set <code>CF</code> to 1 if
the result is zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_testnzc_pd.html" title="no_std_compat::arch::x86_64::_mm256_testnzc_pd fn">_mm256_testnzc_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing double-precision (64-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and <code>CF</code> values
are zero, otherwise return 0.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_testnzc_ps.html" title="no_std_compat::arch::x86_64::_mm256_testnzc_ps fn">_mm256_testnzc_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing single-precision (32-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and <code>CF</code> values
are zero, otherwise return 0.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_testnzc_si256.html" title="no_std_compat::arch::x86_64::_mm256_testnzc_si256 fn">_mm256_testnzc_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing integer data) in <code>a</code> and
<code>b</code>, and set <code>ZF</code> to 1 if the result is zero, otherwise set <code>ZF</code> to 0.
Computes the bitwise NOT of <code>a</code> and then AND with <code>b</code>, and set <code>CF</code> to 1 if
the result is zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and
<code>CF</code> values are zero, otherwise return 0.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_testz_pd.html" title="no_std_compat::arch::x86_64::_mm256_testz_pd fn">_mm256_testz_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing double-precision (64-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_testz_ps.html" title="no_std_compat::arch::x86_64::_mm256_testz_ps fn">_mm256_testz_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing single-precision (32-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 256-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_testz_si256.html" title="no_std_compat::arch::x86_64::_mm256_testz_si256 fn">_mm256_testz_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 256 bits (representing integer data) in <code>a</code> and
<code>b</code>, and set <code>ZF</code> to 1 if the result is zero, otherwise set <code>ZF</code> to 0.
Computes the bitwise NOT of <code>a</code> and then AND with <code>b</code>, and set <code>CF</code> to 1 if
the result is zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_undefined_pd.html" title="no_std_compat::arch::x86_64::_mm256_undefined_pd fn">_mm256_undefined_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Returns vector of type <code>__m256d</code> with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_undefined_ps.html" title="no_std_compat::arch::x86_64::_mm256_undefined_ps fn">_mm256_undefined_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Returns vector of type <code>__m256</code> with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_undefined_si256.html" title="no_std_compat::arch::x86_64::_mm256_undefined_si256 fn">_mm256_undefined_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Returns vector of type __m256i with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpackhi_epi8.html" title="no_std_compat::arch::x86_64::_mm256_unpackhi_epi8 fn">_mm256_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 8-bit integers from the high half of each
128-bit lane in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpackhi_epi16.html" title="no_std_compat::arch::x86_64::_mm256_unpackhi_epi16 fn">_mm256_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 16-bit integers from the high half of each
128-bit lane of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpackhi_epi32.html" title="no_std_compat::arch::x86_64::_mm256_unpackhi_epi32 fn">_mm256_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 32-bit integers from the high half of each
128-bit lane of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpackhi_epi64.html" title="no_std_compat::arch::x86_64::_mm256_unpackhi_epi64 fn">_mm256_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 64-bit integers from the high half of each
128-bit lane of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpackhi_pd.html" title="no_std_compat::arch::x86_64::_mm256_unpackhi_pd fn">_mm256_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave double-precision (64-bit) floating-point elements
from the high half of each 128-bit lane in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpackhi_ps.html" title="no_std_compat::arch::x86_64::_mm256_unpackhi_ps fn">_mm256_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave single-precision (32-bit) floating-point elements
from the high half of each 128-bit lane in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpacklo_epi8.html" title="no_std_compat::arch::x86_64::_mm256_unpacklo_epi8 fn">_mm256_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 8-bit integers from the low half of each
128-bit lane of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpacklo_epi16.html" title="no_std_compat::arch::x86_64::_mm256_unpacklo_epi16 fn">_mm256_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 16-bit integers from the low half of each
128-bit lane of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpacklo_epi32.html" title="no_std_compat::arch::x86_64::_mm256_unpacklo_epi32 fn">_mm256_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 32-bit integers from the low half of each
128-bit lane of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpacklo_epi64.html" title="no_std_compat::arch::x86_64::_mm256_unpacklo_epi64 fn">_mm256_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 64-bit integers from the low half of each
128-bit lane of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpacklo_pd.html" title="no_std_compat::arch::x86_64::_mm256_unpacklo_pd fn">_mm256_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave double-precision (64-bit) floating-point elements
from the low half of each 128-bit lane in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_unpacklo_ps.html" title="no_std_compat::arch::x86_64::_mm256_unpacklo_ps fn">_mm256_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave single-precision (32-bit) floating-point elements
from the low half of each 128-bit lane in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_xor_pd.html" title="no_std_compat::arch::x86_64::_mm256_xor_pd fn">_mm256_xor_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise XOR of packed double-precision (64-bit) floating-point
elements in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_xor_ps.html" title="no_std_compat::arch::x86_64::_mm256_xor_ps fn">_mm256_xor_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise XOR of packed single-precision (32-bit) floating-point
elements in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_xor_si256.html" title="no_std_compat::arch::x86_64::_mm256_xor_si256 fn">_mm256_xor_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise XOR of 256 bits (representing integer data)
in <code>a</code> and <code>b</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_zeroall.html" title="no_std_compat::arch::x86_64::_mm256_zeroall fn">_mm256_zeroall</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Zeroes the contents of all XMM or YMM registers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_zeroupper.html" title="no_std_compat::arch::x86_64::_mm256_zeroupper fn">_mm256_zeroupper</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Zeroes the upper 128 bits of all YMM registers;
the lower 128-bits of the registers are unmodified.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_zextpd128_pd256.html" title="no_std_compat::arch::x86_64::_mm256_zextpd128_pd256 fn">_mm256_zextpd128_pd256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span></div><div class="item-right docblock-short"><p>Constructs a 256-bit floating-point vector of <code>[4 x double]</code> from a
128-bit floating-point vector of <code>[2 x double]</code>. The lower 128 bits
contain the value of the source vector. The upper 128 bits are set
to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_zextps128_ps256.html" title="no_std_compat::arch::x86_64::_mm256_zextps128_ps256 fn">_mm256_zextps128_ps256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span></div><div class="item-right docblock-short"><p>Constructs a 256-bit floating-point vector of <code>[8 x float]</code> from a
128-bit floating-point vector of <code>[4 x float]</code>. The lower 128 bits contain
the value of the source vector. The upper 128 bits are set to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm256_zextsi128_si256.html" title="no_std_compat::arch::x86_64::_mm256_zextsi128_si256 fn">_mm256_zextsi128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span></div><div class="item-right docblock-short"><p>Constructs a 256-bit integer vector from a 128-bit integer vector.
The lower 128 bits contain the value of the source vector. The upper
128 bits are set to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm512_storeu_ps.html" title="no_std_compat::arch::x86_64::_mm512_storeu_ps fn">_mm512_storeu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span></div><div class="item-right docblock-short"><p>Stores 512-bits (composed of 16 packed single-precision (32-bit)
floating-point elements) from <code>a</code> into memory.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_abs_epi8.html" title="no_std_compat::arch::x86_64::_mm_abs_epi8 fn">_mm_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Computes the absolute value of packed 8-bit signed integers in <code>a</code> and
return the unsigned results.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_abs_epi16.html" title="no_std_compat::arch::x86_64::_mm_abs_epi16 fn">_mm_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Computes the absolute value of each of the packed 16-bit signed integers in
<code>a</code> and
return the 16-bit unsigned integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_abs_epi32.html" title="no_std_compat::arch::x86_64::_mm_abs_epi32 fn">_mm_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Computes the absolute value of each of the packed 32-bit signed integers in
<code>a</code> and
return the 32-bit unsigned integer</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_add_epi8.html" title="no_std_compat::arch::x86_64::_mm_add_epi8 fn">_mm_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Adds packed 8-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_add_epi16.html" title="no_std_compat::arch::x86_64::_mm_add_epi16 fn">_mm_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Adds packed 16-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_add_epi32.html" title="no_std_compat::arch::x86_64::_mm_add_epi32 fn">_mm_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Adds packed 32-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_add_epi64.html" title="no_std_compat::arch::x86_64::_mm_add_epi64 fn">_mm_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Adds packed 64-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_add_pd.html" title="no_std_compat::arch::x86_64::_mm_add_pd fn">_mm_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Adds packed double-precision (64-bit) floating-point elements in <code>a</code> and
<code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_add_ps.html" title="no_std_compat::arch::x86_64::_mm_add_ps fn">_mm_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Adds __m128 vectors.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_add_sd.html" title="no_std_compat::arch::x86_64::_mm_add_sd fn">_mm_add_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the sum of the
low elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_add_ss.html" title="no_std_compat::arch::x86_64::_mm_add_ss fn">_mm_add_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Adds the first component of <code>a</code> and <code>b</code>, the other components are copied
from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_adds_epi8.html" title="no_std_compat::arch::x86_64::_mm_adds_epi8 fn">_mm_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Adds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_adds_epi16.html" title="no_std_compat::arch::x86_64::_mm_adds_epi16 fn">_mm_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Adds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_adds_epu8.html" title="no_std_compat::arch::x86_64::_mm_adds_epu8 fn">_mm_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Adds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_adds_epu16.html" title="no_std_compat::arch::x86_64::_mm_adds_epu16 fn">_mm_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Adds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_addsub_pd.html" title="no_std_compat::arch::x86_64::_mm_addsub_pd fn">_mm_addsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Alternatively add and subtract packed double-precision (64-bit)
floating-point elements in <code>a</code> to/from packed elements in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_addsub_ps.html" title="no_std_compat::arch::x86_64::_mm_addsub_ps fn">_mm_addsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Alternatively add and subtract packed single-precision (32-bit)
floating-point elements in <code>a</code> to/from packed elements in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_aesdec_si128.html" title="no_std_compat::arch::x86_64::_mm_aesdec_si128 fn">_mm_aesdec_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span></div><div class="item-right docblock-short"><p>Performs one round of an AES decryption flow on data (state) in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_aesdeclast_si128.html" title="no_std_compat::arch::x86_64::_mm_aesdeclast_si128 fn">_mm_aesdeclast_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span></div><div class="item-right docblock-short"><p>Performs the last round of an AES decryption flow on data (state) in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_aesenc_si128.html" title="no_std_compat::arch::x86_64::_mm_aesenc_si128 fn">_mm_aesenc_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span></div><div class="item-right docblock-short"><p>Performs one round of an AES encryption flow on data (state) in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_aesenclast_si128.html" title="no_std_compat::arch::x86_64::_mm_aesenclast_si128 fn">_mm_aesenclast_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span></div><div class="item-right docblock-short"><p>Performs the last round of an AES encryption flow on data (state) in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_aesimc_si128.html" title="no_std_compat::arch::x86_64::_mm_aesimc_si128 fn">_mm_aesimc_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span></div><div class="item-right docblock-short"><p>Performs the <code>InvMixColumns</code> transformation on <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_aeskeygenassist_si128.html" title="no_std_compat::arch::x86_64::_mm_aeskeygenassist_si128 fn">_mm_aeskeygenassist_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span></div><div class="item-right docblock-short"><p>Assist in expanding the AES cipher key.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_alignr_epi8.html" title="no_std_compat::arch::x86_64::_mm_alignr_epi8 fn">_mm_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Concatenate 16-byte blocks in <code>a</code> and <code>b</code> into a 32-byte temporary result,
shift the result right by <code>n</code> bytes, and returns the low 16 bytes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_and_pd.html" title="no_std_compat::arch::x86_64::_mm_and_pd fn">_mm_and_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of packed double-precision (64-bit) floating-point
elements in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_and_ps.html" title="no_std_compat::arch::x86_64::_mm_and_ps fn">_mm_and_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Bitwise AND of packed single-precision (32-bit) floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_and_si128.html" title="no_std_compat::arch::x86_64::_mm_and_si128 fn">_mm_and_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 128 bits (representing integer data) in <code>a</code> and
<code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_andnot_pd.html" title="no_std_compat::arch::x86_64::_mm_andnot_pd fn">_mm_andnot_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise NOT of <code>a</code> and then AND with <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_andnot_ps.html" title="no_std_compat::arch::x86_64::_mm_andnot_ps fn">_mm_andnot_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Bitwise AND-NOT of packed single-precision (32-bit) floating-point
elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_andnot_si128.html" title="no_std_compat::arch::x86_64::_mm_andnot_si128 fn">_mm_andnot_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise NOT of 128 bits (representing integer data) in <code>a</code> and
then AND with <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_avg_epu8.html" title="no_std_compat::arch::x86_64::_mm_avg_epu8 fn">_mm_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Averages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_avg_epu16.html" title="no_std_compat::arch::x86_64::_mm_avg_epu16 fn">_mm_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Averages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_blend_epi16.html" title="no_std_compat::arch::x86_64::_mm_blend_epi16 fn">_mm_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Blend packed 16-bit integers from <code>a</code> and <code>b</code> using the mask <code>IMM8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_blend_epi32.html" title="no_std_compat::arch::x86_64::_mm_blend_epi32 fn">_mm_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Blends packed 32-bit integers from <code>a</code> and <code>b</code> using control mask <code>IMM4</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_blend_pd.html" title="no_std_compat::arch::x86_64::_mm_blend_pd fn">_mm_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Blend packed double-precision (64-bit) floating-point elements from <code>a</code>
and <code>b</code> using control mask <code>IMM2</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_blend_ps.html" title="no_std_compat::arch::x86_64::_mm_blend_ps fn">_mm_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Blend packed single-precision (32-bit) floating-point elements from <code>a</code>
and <code>b</code> using mask <code>IMM4</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_blendv_epi8.html" title="no_std_compat::arch::x86_64::_mm_blendv_epi8 fn">_mm_blendv_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Blend packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_blendv_pd.html" title="no_std_compat::arch::x86_64::_mm_blendv_pd fn">_mm_blendv_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Blend packed double-precision (64-bit) floating-point elements from <code>a</code>
and <code>b</code> using <code>mask</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_blendv_ps.html" title="no_std_compat::arch::x86_64::_mm_blendv_ps fn">_mm_blendv_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Blend packed single-precision (32-bit) floating-point elements from <code>a</code>
and <code>b</code> using <code>mask</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_broadcast_ss.html" title="no_std_compat::arch::x86_64::_mm_broadcast_ss fn">_mm_broadcast_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Broadcasts a single-precision (32-bit) floating-point element from memory
to all elements of the returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_broadcastb_epi8.html" title="no_std_compat::arch::x86_64::_mm_broadcastb_epi8 fn">_mm_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low packed 8-bit integer from <code>a</code> to all elements of
the 128-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_broadcastd_epi32.html" title="no_std_compat::arch::x86_64::_mm_broadcastd_epi32 fn">_mm_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low packed 32-bit integer from <code>a</code> to all elements of
the 128-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_broadcastq_epi64.html" title="no_std_compat::arch::x86_64::_mm_broadcastq_epi64 fn">_mm_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low packed 64-bit integer from <code>a</code> to all elements of
the 128-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_broadcastsd_pd.html" title="no_std_compat::arch::x86_64::_mm_broadcastsd_pd fn">_mm_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low double-precision (64-bit) floating-point element
from <code>a</code> to all elements of the 128-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_broadcastss_ps.html" title="no_std_compat::arch::x86_64::_mm_broadcastss_ps fn">_mm_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low single-precision (32-bit) floating-point element
from <code>a</code> to all elements of the 128-bit returned value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_broadcastw_epi16.html" title="no_std_compat::arch::x86_64::_mm_broadcastw_epi16 fn">_mm_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Broadcasts the low packed 16-bit integer from a to all elements of
the 128-bit returned value</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_bslli_si128.html" title="no_std_compat::arch::x86_64::_mm_bslli_si128 fn">_mm_bslli_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_bsrli_si128.html" title="no_std_compat::arch::x86_64::_mm_bsrli_si128 fn">_mm_bsrli_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_castpd_ps.html" title="no_std_compat::arch::x86_64::_mm_castpd_ps fn">_mm_castpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Casts a 128-bit floating-point vector of <code>[2 x double]</code> into a 128-bit
floating-point vector of <code>[4 x float]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_castpd_si128.html" title="no_std_compat::arch::x86_64::_mm_castpd_si128 fn">_mm_castpd_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Casts a 128-bit floating-point vector of <code>[2 x double]</code> into a 128-bit
integer vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_castps_pd.html" title="no_std_compat::arch::x86_64::_mm_castps_pd fn">_mm_castps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Casts a 128-bit floating-point vector of <code>[4 x float]</code> into a 128-bit
floating-point vector of <code>[2 x double]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_castps_si128.html" title="no_std_compat::arch::x86_64::_mm_castps_si128 fn">_mm_castps_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Casts a 128-bit floating-point vector of <code>[4 x float]</code> into a 128-bit
integer vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_castsi128_pd.html" title="no_std_compat::arch::x86_64::_mm_castsi128_pd fn">_mm_castsi128_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Casts a 128-bit integer vector into a 128-bit floating-point vector
of <code>[2 x double]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_castsi128_ps.html" title="no_std_compat::arch::x86_64::_mm_castsi128_ps fn">_mm_castsi128_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Casts a 128-bit integer vector into a 128-bit floating-point vector
of <code>[4 x float]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ceil_pd.html" title="no_std_compat::arch::x86_64::_mm_ceil_pd fn">_mm_ceil_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the packed double-precision (64-bit) floating-point elements in <code>a</code>
up to an integer value, and stores the results as packed double-precision
floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ceil_ps.html" title="no_std_compat::arch::x86_64::_mm_ceil_ps fn">_mm_ceil_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the packed single-precision (32-bit) floating-point elements in <code>a</code>
up to an integer value, and stores the results as packed single-precision
floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ceil_sd.html" title="no_std_compat::arch::x86_64::_mm_ceil_sd fn">_mm_ceil_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the lower double-precision (64-bit) floating-point element in <code>b</code>
up to an integer value, store the result as a double-precision
floating-point element in the lower element of the intrisic result,
and copies the upper element from <code>a</code> to the upper element
of the intrinsic result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ceil_ss.html" title="no_std_compat::arch::x86_64::_mm_ceil_ss fn">_mm_ceil_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the lower single-precision (32-bit) floating-point element in <code>b</code>
up to an integer value, store the result as a single-precision
floating-point element in the lower element of the intrinsic result,
and copies the upper 3 packed elements from <code>a</code> to the upper elements
of the intrinsic result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_clflush.html" title="no_std_compat::arch::x86_64::_mm_clflush fn">_mm_clflush</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Invalidates and flushes the cache line that contains <code>p</code> from all levels of
the cache hierarchy.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_clmulepi64_si128.html" title="no_std_compat::arch::x86_64::_mm_clmulepi64_si128 fn">_mm_clmulepi64_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `pclmulqdq` only"><code>pclmulqdq</code></span></div><div class="item-right docblock-short"><p>Performs a carry-less multiplication of two 64-bit polynomials over the
finite field GF(2^k).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmp_pd.html" title="no_std_compat::arch::x86_64::_mm_cmp_pd fn">_mm_cmp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed double-precision (64-bit) floating-point
elements in <code>a</code> and <code>b</code> based on the comparison operand
specified by <code>IMM5</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmp_ps.html" title="no_std_compat::arch::x86_64::_mm_cmp_ps fn">_mm_cmp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span></div><div class="item-right docblock-short"><p>Compares packed single-precision (32-bit) floating-point
elements in <code>a</code> and <code>b</code> based on the comparison operand
specified by <code>IMM5</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmp_sd.html" title="no_std_compat::arch::x86_64::_mm_cmp_sd fn">_mm_cmp_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower double-precision (64-bit) floating-point element in
<code>a</code> and <code>b</code> based on the comparison operand specified by <code>IMM5</code>,
store the result in the lower element of returned vector,
and copies the upper element from <code>a</code> to the upper element of returned
vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmp_ss.html" title="no_std_compat::arch::x86_64::_mm_cmp_ss fn">_mm_cmp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span></div><div class="item-right docblock-short"><p>Compares the lower single-precision (32-bit) floating-point element in
<code>a</code> and <code>b</code> based on the comparison operand specified by <code>IMM5</code>,
store the result in the lower element of returned vector,
and copies the upper 3 packed elements from <code>a</code> to the upper elements of
returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpeq_epi8.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epi8 fn">_mm_cmpeq_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpeq_epi16.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epi16 fn">_mm_cmpeq_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpeq_epi32.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epi32 fn">_mm_cmpeq_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpeq_epi64.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_epi64 fn">_mm_cmpeq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Compares packed 64-bit integers in <code>a</code> and <code>b</code> for equality</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpeq_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_pd fn">_mm_cmpeq_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpeq_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_ps fn">_mm_cmpeq_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input elements
were equal, or <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpeq_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_sd fn">_mm_cmpeq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the equality
comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpeq_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpeq_ss fn">_mm_cmpeq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for equality. The lowest 32 bits of
the result will be <code>0xffffffff</code> if the two inputs are equal, or <code>0</code>
otherwise. The upper 96 bits of the result are the upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpestra.html" title="no_std_compat::arch::x86_64::_mm_cmpestra fn">_mm_cmpestra</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>
using the control in <code>IMM8</code>, and return <code>1</code> if <code>b</code> did not
contain a null character and the resulting mask was zero, and <code>0</code>
otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpestrc.html" title="no_std_compat::arch::x86_64::_mm_cmpestrc fn">_mm_cmpestrc</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>
using the control in <code>IMM8</code>, and return <code>1</code> if the resulting mask
was non-zero, and <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpestri.html" title="no_std_compat::arch::x86_64::_mm_cmpestri fn">_mm_cmpestri</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code> using the
control in <code>IMM8</code> and return the generated index. Similar to
<a href="fn._mm_cmpistri.html"><code>_mm_cmpistri</code></a> with the exception that <a href="fn._mm_cmpistri.html"><code>_mm_cmpistri</code></a> implicitly
determines the length of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpestrm.html" title="no_std_compat::arch::x86_64::_mm_cmpestrm fn">_mm_cmpestrm</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>
using the control in <code>IMM8</code>, and return the generated mask.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpestro.html" title="no_std_compat::arch::x86_64::_mm_cmpestro fn">_mm_cmpestro</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>
using the control in <code>IMM8</code>, and return bit <code>0</code> of the resulting
bit mask.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpestrs.html" title="no_std_compat::arch::x86_64::_mm_cmpestrs fn">_mm_cmpestrs</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>
using the control in <code>IMM8</code>, and return <code>1</code> if any character in
a was null, and <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpestrz.html" title="no_std_compat::arch::x86_64::_mm_cmpestrz fn">_mm_cmpestrz</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings in <code>a</code> and <code>b</code> with lengths <code>la</code> and <code>lb</code>
using the control in <code>IMM8</code>, and return <code>1</code> if any character in
<code>b</code> was null, and <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpge_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpge_pd fn">_mm_cmpge_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for greater-than-or-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpge_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpge_ps fn">_mm_cmpge_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input element
in <code>a</code> is greater than or equal to the corresponding element in <code>b</code>, or <code>0</code>
otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpge_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpge_sd fn">_mm_cmpge_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the
greater-than-or-equal comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpge_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpge_ss fn">_mm_cmpge_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for greater than or equal. The
lowest 32 bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is
greater than or equal <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits
of the result are the upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpgt_epi8.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epi8 fn">_mm_cmpgt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpgt_epi16.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epi16 fn">_mm_cmpgt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 16-bit integers in <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpgt_epi32.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epi32 fn">_mm_cmpgt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 32-bit integers in <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpgt_epi64.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_epi64 fn">_mm_cmpgt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed 64-bit integers in <code>a</code> and <code>b</code> for greater-than,
return the results.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpgt_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_pd fn">_mm_cmpgt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpgt_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_ps fn">_mm_cmpgt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input element
in <code>a</code> is greater than the corresponding element in <code>b</code>, or <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpgt_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_sd fn">_mm_cmpgt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the
greater-than comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpgt_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpgt_ss fn">_mm_cmpgt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for greater than. The lowest 32
bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is greater
than <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result
are the upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpistra.html" title="no_std_compat::arch::x86_64::_mm_cmpistra fn">_mm_cmpistra</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the
control in <code>IMM8</code>, and return <code>1</code> if <code>b</code> did not contain a null
character and the resulting mask was zero, and <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpistrc.html" title="no_std_compat::arch::x86_64::_mm_cmpistrc fn">_mm_cmpistrc</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the
control in <code>IMM8</code>, and return <code>1</code> if the resulting mask was non-zero,
and <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpistri.html" title="no_std_compat::arch::x86_64::_mm_cmpistri fn">_mm_cmpistri</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the
control in <code>IMM8</code> and return the generated index. Similar to
<a href="fn._mm_cmpestri.html" title="_mm_cmpestri"><code>_mm_cmpestri</code></a> with the exception that <a href="fn._mm_cmpestri.html" title="_mm_cmpestri"><code>_mm_cmpestri</code></a> requires the
lengths of <code>a</code> and <code>b</code> to be explicitly specified.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpistrm.html" title="no_std_compat::arch::x86_64::_mm_cmpistrm fn">_mm_cmpistrm</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the
control in <code>IMM8</code>, and return the generated mask.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpistro.html" title="no_std_compat::arch::x86_64::_mm_cmpistro fn">_mm_cmpistro</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the
control in <code>IMM8</code>, and return bit <code>0</code> of the resulting bit mask.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpistrs.html" title="no_std_compat::arch::x86_64::_mm_cmpistrs fn">_mm_cmpistrs</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the
control in <code>IMM8</code>, and returns <code>1</code> if any character in <code>a</code> was null,
and <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpistrz.html" title="no_std_compat::arch::x86_64::_mm_cmpistrz fn">_mm_cmpistrz</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Compares packed strings with implicit lengths in <code>a</code> and <code>b</code> using the
control in <code>IMM8</code>, and return <code>1</code> if any character in <code>b</code> was null.
and <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmple_pd.html" title="no_std_compat::arch::x86_64::_mm_cmple_pd fn">_mm_cmple_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for less-than-or-equal</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmple_ps.html" title="no_std_compat::arch::x86_64::_mm_cmple_ps fn">_mm_cmple_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input element
in <code>a</code> is less than or equal to the corresponding element in <code>b</code>, or <code>0</code>
otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmple_sd.html" title="no_std_compat::arch::x86_64::_mm_cmple_sd fn">_mm_cmple_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the
less-than-or-equal comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmple_ss.html" title="no_std_compat::arch::x86_64::_mm_cmple_ss fn">_mm_cmple_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for less than or equal. The lowest
32 bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is less than
or equal <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result
are the upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmplt_epi8.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epi8 fn">_mm_cmplt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 8-bit integers in <code>a</code> and <code>b</code> for less-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmplt_epi16.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epi16 fn">_mm_cmplt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 16-bit integers in <code>a</code> and <code>b</code> for less-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmplt_epi32.html" title="no_std_compat::arch::x86_64::_mm_cmplt_epi32 fn">_mm_cmplt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 32-bit integers in <code>a</code> and <code>b</code> for less-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmplt_pd.html" title="no_std_compat::arch::x86_64::_mm_cmplt_pd fn">_mm_cmplt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for less-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmplt_ps.html" title="no_std_compat::arch::x86_64::_mm_cmplt_ps fn">_mm_cmplt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input element
in <code>a</code> is less than the corresponding element in <code>b</code>, or <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmplt_sd.html" title="no_std_compat::arch::x86_64::_mm_cmplt_sd fn">_mm_cmplt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the less-than
comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmplt_ss.html" title="no_std_compat::arch::x86_64::_mm_cmplt_ss fn">_mm_cmplt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for less than. The lowest 32 bits
of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is less than
<code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result are the
upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpneq_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_pd fn">_mm_cmpneq_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for not-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpneq_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_ps fn">_mm_cmpneq_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input elements
are <strong>not</strong> equal, or <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpneq_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_sd fn">_mm_cmpneq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the not-equal
comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpneq_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpneq_ss fn">_mm_cmpneq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for inequality. The lowest 32 bits
of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not equal to
<code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result are the
upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnge_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpnge_pd fn">_mm_cmpnge_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for
not-greater-than-or-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnge_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpnge_ps fn">_mm_cmpnge_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input element
in <code>a</code> is <strong>not</strong> greater than or equal to the corresponding element in <code>b</code>,
or <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnge_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpnge_sd fn">_mm_cmpnge_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the
not-greater-than-or-equal comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnge_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpnge_ss fn">_mm_cmpnge_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for not-greater-than-or-equal. The
lowest 32 bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not
greater than or equal to <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96
bits of the result are the upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpngt_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpngt_pd fn">_mm_cmpngt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for not-greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpngt_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpngt_ps fn">_mm_cmpngt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input element
in <code>a</code> is <strong>not</strong> greater than the corresponding element in <code>b</code>, or <code>0</code>
otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpngt_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpngt_sd fn">_mm_cmpngt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the
not-greater-than comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpngt_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpngt_ss fn">_mm_cmpngt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for not-greater-than. The lowest 32
bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not greater
than <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result are
the upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnle_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpnle_pd fn">_mm_cmpnle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for not-less-than-or-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnle_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpnle_ps fn">_mm_cmpnle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input element
in <code>a</code> is <strong>not</strong> less than or equal to the corresponding element in <code>b</code>, or
<code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnle_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpnle_sd fn">_mm_cmpnle_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the
not-less-than-or-equal comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnle_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpnle_ss fn">_mm_cmpnle_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for not-less-than-or-equal. The
lowest 32 bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not
less than or equal to <code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits
of the result are the upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnlt_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpnlt_pd fn">_mm_cmpnlt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> for not-less-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnlt_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpnlt_ps fn">_mm_cmpnlt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
The result in the output vector will be <code>0xffffffff</code> if the input element
in <code>a</code> is <strong>not</strong> less than the corresponding element in <code>b</code>, or <code>0</code>
otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnlt_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpnlt_sd fn">_mm_cmpnlt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the
not-less-than comparison of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpnlt_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpnlt_ss fn">_mm_cmpnlt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the lowest <code>f32</code> of both inputs for not-less-than. The lowest 32
bits of the result will be <code>0xffffffff</code> if <code>a.extract(0)</code> is not less than
<code>b.extract(0)</code>, or <code>0</code> otherwise. The upper 96 bits of the result are the
upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpord_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpord_pd fn">_mm_cmpord_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> to see if neither is <code>NaN</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpord_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpord_ps fn">_mm_cmpord_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
Returns four floats that have one of two possible bit patterns. The element
in the output vector will be <code>0xffffffff</code> if the input elements in <code>a</code> and
<code>b</code> are ordered (i.e., neither of them is a NaN), or 0 otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpord_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpord_sd fn">_mm_cmpord_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the result
of comparing both of the lower elements of <code>a</code> and <code>b</code> to <code>NaN</code>. If
neither are equal to <code>NaN</code> then <code>0xFFFFFFFFFFFFFFFF</code> is used and <code>0</code>
otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpord_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpord_ss fn">_mm_cmpord_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Checks if the lowest <code>f32</code> of both inputs are ordered. The lowest 32 bits of
the result will be <code>0xffffffff</code> if neither of <code>a.extract(0)</code> or
<code>b.extract(0)</code> is a NaN, or <code>0</code> otherwise. The upper 96 bits of the result
are the upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpunord_pd.html" title="no_std_compat::arch::x86_64::_mm_cmpunord_pd fn">_mm_cmpunord_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares corresponding elements in <code>a</code> and <code>b</code> to see if either is <code>NaN</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpunord_ps.html" title="no_std_compat::arch::x86_64::_mm_cmpunord_ps fn">_mm_cmpunord_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares each of the four floats in <code>a</code> to the corresponding element in <code>b</code>.
Returns four floats that have one of two possible bit patterns. The element
in the output vector will be <code>0xffffffff</code> if the input elements in <code>a</code> and
<code>b</code> are unordered (i.e., at least on of them is a NaN), or 0 otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpunord_sd.html" title="no_std_compat::arch::x86_64::_mm_cmpunord_sd fn">_mm_cmpunord_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the result of
comparing both of the lower elements of <code>a</code> and <code>b</code> to <code>NaN</code>. If either is
equal to <code>NaN</code> then <code>0xFFFFFFFFFFFFFFFF</code> is used and <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cmpunord_ss.html" title="no_std_compat::arch::x86_64::_mm_cmpunord_ss fn">_mm_cmpunord_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Checks if the lowest <code>f32</code> of both inputs are unordered. The lowest 32 bits
of the result will be <code>0xffffffff</code> if any of <code>a.extract(0)</code> or
<code>b.extract(0)</code> is a NaN, or <code>0</code> otherwise. The upper 96 bits of the result
are the upper 96 bits of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comieq_sd.html" title="no_std_compat::arch::x86_64::_mm_comieq_sd fn">_mm_comieq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comieq_ss.html" title="no_std_compat::arch::x86_64::_mm_comieq_ss fn">_mm_comieq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if they are equal, or <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comige_sd.html" title="no_std_compat::arch::x86_64::_mm_comige_sd fn">_mm_comige_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for greater-than-or-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comige_ss.html" title="no_std_compat::arch::x86_64::_mm_comige_ss fn">_mm_comige_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if the value from <code>a</code> is greater than or equal to the one from <code>b</code>, or
<code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comigt_sd.html" title="no_std_compat::arch::x86_64::_mm_comigt_sd fn">_mm_comigt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comigt_ss.html" title="no_std_compat::arch::x86_64::_mm_comigt_ss fn">_mm_comigt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if the value from <code>a</code> is greater than the one from <code>b</code>, or <code>0</code>
otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comile_sd.html" title="no_std_compat::arch::x86_64::_mm_comile_sd fn">_mm_comile_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for less-than-or-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comile_ss.html" title="no_std_compat::arch::x86_64::_mm_comile_ss fn">_mm_comile_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if the value from <code>a</code> is less than or equal to the one from <code>b</code>, or <code>0</code>
otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comilt_sd.html" title="no_std_compat::arch::x86_64::_mm_comilt_sd fn">_mm_comilt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for less-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comilt_ss.html" title="no_std_compat::arch::x86_64::_mm_comilt_ss fn">_mm_comilt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if the value from <code>a</code> is less than the one from <code>b</code>, or <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comineq_sd.html" title="no_std_compat::arch::x86_64::_mm_comineq_sd fn">_mm_comineq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for not-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_comineq_ss.html" title="no_std_compat::arch::x86_64::_mm_comineq_ss fn">_mm_comineq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if they are <strong>not</strong> equal, or <code>0</code> otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_crc32_u8.html" title="no_std_compat::arch::x86_64::_mm_crc32_u8 fn">_mm_crc32_u8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Starting with the initial value in <code>crc</code>, return the accumulated
CRC32-C value for unsigned 8-bit integer <code>v</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_crc32_u16.html" title="no_std_compat::arch::x86_64::_mm_crc32_u16 fn">_mm_crc32_u16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Starting with the initial value in <code>crc</code>, return the accumulated
CRC32-C value for unsigned 16-bit integer <code>v</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_crc32_u32.html" title="no_std_compat::arch::x86_64::_mm_crc32_u32 fn">_mm_crc32_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Starting with the initial value in <code>crc</code>, return the accumulated
CRC32-C value for unsigned 32-bit integer <code>v</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_crc32_u64.html" title="no_std_compat::arch::x86_64::_mm_crc32_u64 fn">_mm_crc32_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="item-right docblock-short"><p>Starting with the initial value in <code>crc</code>, return the accumulated
CRC32-C value for unsigned 64-bit integer <code>v</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvt_si2ss.html" title="no_std_compat::arch::x86_64::_mm_cvt_si2ss fn">_mm_cvt_si2ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Alias for <a href="fn._mm_cvtsi32_ss.html"><code>_mm_cvtsi32_ss</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvt_ss2si.html" title="no_std_compat::arch::x86_64::_mm_cvt_ss2si fn">_mm_cvt_ss2si</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Alias for <a href="fn._mm_cvtss_si32.html"><code>_mm_cvtss_si32</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepi8_epi16.html" title="no_std_compat::arch::x86_64::_mm_cvtepi8_epi16 fn">_mm_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in <code>a</code> to packed 16-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepi8_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvtepi8_epi32 fn">_mm_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in <code>a</code> to packed 32-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepi8_epi64.html" title="no_std_compat::arch::x86_64::_mm_cvtepi8_epi64 fn">_mm_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 8-bit integers in the low 8 bytes of <code>a</code> to packed
64-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepi16_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvtepi16_epi32 fn">_mm_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in <code>a</code> to packed 32-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepi16_epi64.html" title="no_std_compat::arch::x86_64::_mm_cvtepi16_epi64 fn">_mm_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 16-bit integers in <code>a</code> to packed 64-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepi32_epi64.html" title="no_std_compat::arch::x86_64::_mm_cvtepi32_epi64 fn">_mm_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Sign extend packed 32-bit integers in <code>a</code> to packed 64-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepi32_pd.html" title="no_std_compat::arch::x86_64::_mm_cvtepi32_pd fn">_mm_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts the lower two packed 32-bit integers in <code>a</code> to packed
double-precision (64-bit) floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepi32_ps.html" title="no_std_compat::arch::x86_64::_mm_cvtepi32_ps fn">_mm_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed 32-bit integers in <code>a</code> to packed single-precision (32-bit)
floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepu8_epi16.html" title="no_std_compat::arch::x86_64::_mm_cvtepu8_epi16 fn">_mm_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Zeroes extend packed unsigned 8-bit integers in <code>a</code> to packed 16-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepu8_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvtepu8_epi32 fn">_mm_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Zeroes extend packed unsigned 8-bit integers in <code>a</code> to packed 32-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepu8_epi64.html" title="no_std_compat::arch::x86_64::_mm_cvtepu8_epi64 fn">_mm_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Zeroes extend packed unsigned 8-bit integers in <code>a</code> to packed 64-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepu16_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvtepu16_epi32 fn">_mm_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Zeroes extend packed unsigned 16-bit integers in <code>a</code>
to packed 32-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepu16_epi64.html" title="no_std_compat::arch::x86_64::_mm_cvtepu16_epi64 fn">_mm_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Zeroes extend packed unsigned 16-bit integers in <code>a</code>
to packed 64-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtepu32_epi64.html" title="no_std_compat::arch::x86_64::_mm_cvtepu32_epi64 fn">_mm_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Zeroes extend packed unsigned 32-bit integers in <code>a</code>
to packed 64-bit integers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtpd_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvtpd_epi32 fn">_mm_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed double-precision (64-bit) floating-point elements in <code>a</code> to
packed 32-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtpd_ps.html" title="no_std_compat::arch::x86_64::_mm_cvtpd_ps fn">_mm_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed double-precision (64-bit) floating-point elements in <code>a</code> to
packed single-precision (32-bit) floating-point elements</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtps_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvtps_epi32 fn">_mm_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed single-precision (32-bit) floating-point elements in <code>a</code>
to packed 32-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtps_pd.html" title="no_std_compat::arch::x86_64::_mm_cvtps_pd fn">_mm_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed single-precision (32-bit) floating-point elements in <code>a</code> to
packed
double-precision (64-bit) floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsd_f64.html" title="no_std_compat::arch::x86_64::_mm_cvtsd_f64 fn">_mm_cvtsd_f64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns the lower double-precision (64-bit) floating-point element of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsd_si32.html" title="no_std_compat::arch::x86_64::_mm_cvtsd_si32 fn">_mm_cvtsd_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts the lower double-precision (64-bit) floating-point element in a to
a 32-bit integer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsd_si64.html" title="no_std_compat::arch::x86_64::_mm_cvtsd_si64 fn">_mm_cvtsd_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts the lower double-precision (64-bit) floating-point element in a to
a 64-bit integer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsd_si64x.html" title="no_std_compat::arch::x86_64::_mm_cvtsd_si64x fn">_mm_cvtsd_si64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Alias for <code>_mm_cvtsd_si64</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsd_ss.html" title="no_std_compat::arch::x86_64::_mm_cvtsd_ss fn">_mm_cvtsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts the lower double-precision (64-bit) floating-point element in <code>b</code>
to a single-precision (32-bit) floating-point element, store the result in
the lower element of the return value, and copies the upper element from <code>a</code>
to the upper element the return value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi32_sd.html" title="no_std_compat::arch::x86_64::_mm_cvtsi32_sd fn">_mm_cvtsi32_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns <code>a</code> with its lower element replaced by <code>b</code> after converting it to
an <code>f64</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi32_si128.html" title="no_std_compat::arch::x86_64::_mm_cvtsi32_si128 fn">_mm_cvtsi32_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a vector whose lowest element is <code>a</code> and all higher elements are
<code>0</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi32_ss.html" title="no_std_compat::arch::x86_64::_mm_cvtsi32_ss fn">_mm_cvtsi32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Converts a 32 bit integer to a 32 bit float. The result vector is the input
vector <code>a</code> with the lowest 32 bit float replaced by the converted integer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi64_sd.html" title="no_std_compat::arch::x86_64::_mm_cvtsi64_sd fn">_mm_cvtsi64_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns <code>a</code> with its lower element replaced by <code>b</code> after converting it to
an <code>f64</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi64_si128.html" title="no_std_compat::arch::x86_64::_mm_cvtsi64_si128 fn">_mm_cvtsi64_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a vector whose lowest element is <code>a</code> and all higher elements are
<code>0</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi64_ss.html" title="no_std_compat::arch::x86_64::_mm_cvtsi64_ss fn">_mm_cvtsi64_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Converts a 64 bit integer to a 32 bit float. The result vector is the input
vector <code>a</code> with the lowest 32 bit float replaced by the converted integer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi64x_sd.html" title="no_std_compat::arch::x86_64::_mm_cvtsi64x_sd fn">_mm_cvtsi64x_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns <code>a</code> with its lower element replaced by <code>b</code> after converting it to
an <code>f64</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi64x_si128.html" title="no_std_compat::arch::x86_64::_mm_cvtsi64x_si128 fn">_mm_cvtsi64x_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a vector whose lowest element is <code>a</code> and all higher elements are
<code>0</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi128_si32.html" title="no_std_compat::arch::x86_64::_mm_cvtsi128_si32 fn">_mm_cvtsi128_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns the lowest element of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi128_si64.html" title="no_std_compat::arch::x86_64::_mm_cvtsi128_si64 fn">_mm_cvtsi128_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns the lowest element of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtsi128_si64x.html" title="no_std_compat::arch::x86_64::_mm_cvtsi128_si64x fn">_mm_cvtsi128_si64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns the lowest element of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtss_f32.html" title="no_std_compat::arch::x86_64::_mm_cvtss_f32 fn">_mm_cvtss_f32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Extracts the lowest 32 bit float from the input vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtss_sd.html" title="no_std_compat::arch::x86_64::_mm_cvtss_sd fn">_mm_cvtss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts the lower single-precision (32-bit) floating-point element in <code>b</code>
to a double-precision (64-bit) floating-point element, store the result in
the lower element of the return value, and copies the upper element from <code>a</code>
to the upper element the return value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtss_si32.html" title="no_std_compat::arch::x86_64::_mm_cvtss_si32 fn">_mm_cvtss_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Converts the lowest 32 bit float in the input vector to a 32 bit integer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtss_si64.html" title="no_std_compat::arch::x86_64::_mm_cvtss_si64 fn">_mm_cvtss_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Converts the lowest 32 bit float in the input vector to a 64 bit integer.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvtt_ss2si.html" title="no_std_compat::arch::x86_64::_mm_cvtt_ss2si fn">_mm_cvtt_ss2si</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Alias for <a href="fn._mm_cvttss_si32.html"><code>_mm_cvttss_si32</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvttpd_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvttpd_epi32 fn">_mm_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed double-precision (64-bit) floating-point elements in <code>a</code> to
packed 32-bit integers with truncation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvttps_epi32.html" title="no_std_compat::arch::x86_64::_mm_cvttps_epi32 fn">_mm_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed single-precision (32-bit) floating-point elements in <code>a</code> to
packed 32-bit integers with truncation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvttsd_si32.html" title="no_std_compat::arch::x86_64::_mm_cvttsd_si32 fn">_mm_cvttsd_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts the lower double-precision (64-bit) floating-point element in <code>a</code>
to a 32-bit integer with truncation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvttsd_si64.html" title="no_std_compat::arch::x86_64::_mm_cvttsd_si64 fn">_mm_cvttsd_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts the lower double-precision (64-bit) floating-point element in <code>a</code>
to a 64-bit integer with truncation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvttsd_si64x.html" title="no_std_compat::arch::x86_64::_mm_cvttsd_si64x fn">_mm_cvttsd_si64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Alias for <code>_mm_cvttsd_si64</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvttss_si32.html" title="no_std_compat::arch::x86_64::_mm_cvttss_si32 fn">_mm_cvttss_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Converts the lowest 32 bit float in the input vector to a 32 bit integer
with
truncation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_cvttss_si64.html" title="no_std_compat::arch::x86_64::_mm_cvttss_si64 fn">_mm_cvttss_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Converts the lowest 32 bit float in the input vector to a 64 bit integer
with truncation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_div_pd.html" title="no_std_compat::arch::x86_64::_mm_div_pd fn">_mm_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Divide packed double-precision (64-bit) floating-point elements in <code>a</code> by
packed elements in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_div_ps.html" title="no_std_compat::arch::x86_64::_mm_div_ps fn">_mm_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Divides __m128 vectors.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_div_sd.html" title="no_std_compat::arch::x86_64::_mm_div_sd fn">_mm_div_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the result of
diving the lower element of <code>a</code> by the lower element of <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_div_ss.html" title="no_std_compat::arch::x86_64::_mm_div_ss fn">_mm_div_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Divides the first component of <code>b</code> by <code>a</code>, the other components are
copied from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_dp_pd.html" title="no_std_compat::arch::x86_64::_mm_dp_pd fn">_mm_dp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Returns the dot product of two __m128d vectors.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_dp_ps.html" title="no_std_compat::arch::x86_64::_mm_dp_ps fn">_mm_dp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Returns the dot product of two __m128 vectors.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_extract_epi8.html" title="no_std_compat::arch::x86_64::_mm_extract_epi8 fn">_mm_extract_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Extracts an 8-bit integer from <code>a</code>, selected with <code>IMM8</code>. Returns a 32-bit
integer containing the zero-extended integer data.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_extract_epi16.html" title="no_std_compat::arch::x86_64::_mm_extract_epi16 fn">_mm_extract_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns the <code>imm8</code> element of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_extract_epi32.html" title="no_std_compat::arch::x86_64::_mm_extract_epi32 fn">_mm_extract_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Extracts an 32-bit integer from <code>a</code> selected with <code>IMM8</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_extract_epi64.html" title="no_std_compat::arch::x86_64::_mm_extract_epi64 fn">_mm_extract_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Extracts an 64-bit integer from <code>a</code> selected with <code>IMM1</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_extract_ps.html" title="no_std_compat::arch::x86_64::_mm_extract_ps fn">_mm_extract_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Extracts a single-precision (32-bit) floating-point element from <code>a</code>,
selected with <code>IMM8</code>. The returned <code>i32</code> stores the float’s bit-pattern,
and may be converted back to a floating point number via casting.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_extract_si64.html" title="no_std_compat::arch::x86_64::_mm_extract_si64 fn">_mm_extract_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4a` only"><code>sse4a</code></span></div><div class="item-right docblock-short"><p>Extracts the bit range specified by <code>y</code> from the lower 64 bits of <code>x</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_floor_pd.html" title="no_std_compat::arch::x86_64::_mm_floor_pd fn">_mm_floor_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the packed double-precision (64-bit) floating-point elements in <code>a</code>
down to an integer value, and stores the results as packed double-precision
floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_floor_ps.html" title="no_std_compat::arch::x86_64::_mm_floor_ps fn">_mm_floor_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the packed single-precision (32-bit) floating-point elements in <code>a</code>
down to an integer value, and stores the results as packed single-precision
floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_floor_sd.html" title="no_std_compat::arch::x86_64::_mm_floor_sd fn">_mm_floor_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the lower double-precision (64-bit) floating-point element in <code>b</code>
down to an integer value, store the result as a double-precision
floating-point element in the lower element of the intrinsic result,
and copies the upper element from <code>a</code> to the upper element of the intrinsic
result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_floor_ss.html" title="no_std_compat::arch::x86_64::_mm_floor_ss fn">_mm_floor_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the lower single-precision (32-bit) floating-point element in <code>b</code>
down to an integer value, store the result as a single-precision
floating-point element in the lower element of the intrinsic result,
and copies the upper 3 packed elements from <code>a</code> to the upper elements
of the intrinsic result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmadd_pd.html" title="no_std_compat::arch::x86_64::_mm_fmadd_pd fn">_mm_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and add the intermediate result to packed elements in <code>c</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmadd_ps.html" title="no_std_compat::arch::x86_64::_mm_fmadd_ps fn">_mm_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and add the intermediate result to packed elements in <code>c</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmadd_sd.html" title="no_std_compat::arch::x86_64::_mm_fmadd_sd fn">_mm_fmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies the lower double-precision (64-bit) floating-point elements in
<code>a</code> and <code>b</code>, and add the intermediate result to the lower element in <code>c</code>.
Stores the result in the lower element of the returned value, and copy the
upper element from <code>a</code> to the upper elements of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmadd_ss.html" title="no_std_compat::arch::x86_64::_mm_fmadd_ss fn">_mm_fmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies the lower single-precision (32-bit) floating-point elements in
<code>a</code> and <code>b</code>, and add the intermediate result to the lower element in <code>c</code>.
Stores the result in the lower element of the returned value, and copy the
3 upper elements from <code>a</code> to the upper elements of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmaddsub_pd.html" title="no_std_compat::arch::x86_64::_mm_fmaddsub_pd fn">_mm_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and alternatively add and subtract packed elements in <code>c</code> to/from
the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmaddsub_ps.html" title="no_std_compat::arch::x86_64::_mm_fmaddsub_ps fn">_mm_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and alternatively add and subtract packed elements in <code>c</code> to/from
the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmsub_pd.html" title="no_std_compat::arch::x86_64::_mm_fmsub_pd fn">_mm_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and subtract packed elements in <code>c</code> from the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmsub_ps.html" title="no_std_compat::arch::x86_64::_mm_fmsub_ps fn">_mm_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and subtract packed elements in <code>c</code> from the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmsub_sd.html" title="no_std_compat::arch::x86_64::_mm_fmsub_sd fn">_mm_fmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies the lower double-precision (64-bit) floating-point elements in
<code>a</code> and <code>b</code>, and subtract the lower element in <code>c</code> from the intermediate
result. Store the result in the lower element of the returned value, and
copy the upper element from <code>a</code> to the upper elements of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmsub_ss.html" title="no_std_compat::arch::x86_64::_mm_fmsub_ss fn">_mm_fmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies the lower single-precision (32-bit) floating-point elements in
<code>a</code> and <code>b</code>,  and subtract the lower element in <code>c</code> from the intermediate
result. Store the result in the lower element of the returned value, and
copy the 3 upper elements from <code>a</code> to the upper elements of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmsubadd_pd.html" title="no_std_compat::arch::x86_64::_mm_fmsubadd_pd fn">_mm_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and alternatively subtract and add packed elements in <code>c</code> from/to
the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fmsubadd_ps.html" title="no_std_compat::arch::x86_64::_mm_fmsubadd_ps fn">_mm_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and alternatively subtract and add packed elements in <code>c</code> from/to
the intermediate result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fnmadd_pd.html" title="no_std_compat::arch::x86_64::_mm_fnmadd_pd fn">_mm_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and add the negated intermediate result to packed elements in <code>c</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fnmadd_ps.html" title="no_std_compat::arch::x86_64::_mm_fnmadd_ps fn">_mm_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and add the negated intermediate result to packed elements in <code>c</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fnmadd_sd.html" title="no_std_compat::arch::x86_64::_mm_fnmadd_sd fn">_mm_fnmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies the lower double-precision (64-bit) floating-point elements in
<code>a</code> and <code>b</code>, and add the negated intermediate result to the lower element
in <code>c</code>. Store the result in the lower element of the returned value, and
copy the upper element from <code>a</code> to the upper elements of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fnmadd_ss.html" title="no_std_compat::arch::x86_64::_mm_fnmadd_ss fn">_mm_fnmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies the lower single-precision (32-bit) floating-point elements in
<code>a</code> and <code>b</code>, and add the negated intermediate result to the lower element
in <code>c</code>. Store the result in the lower element of the returned value, and
copy the 3 upper elements from <code>a</code> to the upper elements of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fnmsub_pd.html" title="no_std_compat::arch::x86_64::_mm_fnmsub_pd fn">_mm_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>, and subtract packed elements in <code>c</code> from the negated intermediate
result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fnmsub_ps.html" title="no_std_compat::arch::x86_64::_mm_fnmsub_ps fn">_mm_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies packed single-precision (32-bit) floating-point elements in <code>a</code>
and <code>b</code>, and subtract packed elements in <code>c</code> from the negated intermediate
result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fnmsub_sd.html" title="no_std_compat::arch::x86_64::_mm_fnmsub_sd fn">_mm_fnmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies the lower double-precision (64-bit) floating-point elements in
<code>a</code> and <code>b</code>, and subtract packed elements in <code>c</code> from the negated
intermediate result. Store the result in the lower element of the returned
value, and copy the upper element from <code>a</code> to the upper elements of the
result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_fnmsub_ss.html" title="no_std_compat::arch::x86_64::_mm_fnmsub_ss fn">_mm_fnmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span></div><div class="item-right docblock-short"><p>Multiplies the lower single-precision (32-bit) floating-point elements in
<code>a</code> and <code>b</code>, and subtract packed elements in <code>c</code> from the negated
intermediate result. Store the result in the lower element of the
returned value, and copy the 3 upper elements from <code>a</code> to the upper
elements of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_getcsr.html" title="no_std_compat::arch::x86_64::_mm_getcsr fn">_mm_getcsr</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Gets the unsigned 32-bit value of the MXCSR control and status register.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hadd_epi16.html" title="no_std_compat::arch::x86_64::_mm_hadd_epi16 fn">_mm_hadd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Horizontally adds the adjacent pairs of values contained in 2 packed
128-bit vectors of <code>[8 x i16]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hadd_epi32.html" title="no_std_compat::arch::x86_64::_mm_hadd_epi32 fn">_mm_hadd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Horizontally adds the adjacent pairs of values contained in 2 packed
128-bit vectors of <code>[4 x i32]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hadd_pd.html" title="no_std_compat::arch::x86_64::_mm_hadd_pd fn">_mm_hadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Horizontally adds adjacent pairs of double-precision (64-bit)
floating-point elements in <code>a</code> and <code>b</code>, and pack the results.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hadd_ps.html" title="no_std_compat::arch::x86_64::_mm_hadd_ps fn">_mm_hadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Horizontally adds adjacent pairs of single-precision (32-bit)
floating-point elements in <code>a</code> and <code>b</code>, and pack the results.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hadds_epi16.html" title="no_std_compat::arch::x86_64::_mm_hadds_epi16 fn">_mm_hadds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Horizontally adds the adjacent pairs of values contained in 2 packed
128-bit vectors of <code>[8 x i16]</code>. Positive sums greater than 7FFFh are
saturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hsub_epi16.html" title="no_std_compat::arch::x86_64::_mm_hsub_epi16 fn">_mm_hsub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Horizontally subtract the adjacent pairs of values contained in 2
packed 128-bit vectors of <code>[8 x i16]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hsub_epi32.html" title="no_std_compat::arch::x86_64::_mm_hsub_epi32 fn">_mm_hsub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Horizontally subtract the adjacent pairs of values contained in 2
packed 128-bit vectors of <code>[4 x i32]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hsub_pd.html" title="no_std_compat::arch::x86_64::_mm_hsub_pd fn">_mm_hsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Horizontally subtract adjacent pairs of double-precision (64-bit)
floating-point elements in <code>a</code> and <code>b</code>, and pack the results.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hsub_ps.html" title="no_std_compat::arch::x86_64::_mm_hsub_ps fn">_mm_hsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Horizontally adds adjacent pairs of single-precision (32-bit)
floating-point elements in <code>a</code> and <code>b</code>, and pack the results.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_hsubs_epi16.html" title="no_std_compat::arch::x86_64::_mm_hsubs_epi16 fn">_mm_hsubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Horizontally subtract the adjacent pairs of values contained in 2
packed 128-bit vectors of <code>[8 x i16]</code>. Positive differences greater than
7FFFh are saturated to 7FFFh. Negative differences less than 8000h are
saturated to 8000h.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_i32gather_epi32.html" title="no_std_compat::arch::x86_64::_mm_i32gather_epi32 fn">_mm_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_i32gather_epi64.html" title="no_std_compat::arch::x86_64::_mm_i32gather_epi64 fn">_mm_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_i32gather_pd.html" title="no_std_compat::arch::x86_64::_mm_i32gather_pd fn">_mm_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_i32gather_ps.html" title="no_std_compat::arch::x86_64::_mm_i32gather_ps fn">_mm_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_i64gather_epi32.html" title="no_std_compat::arch::x86_64::_mm_i64gather_epi32 fn">_mm_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_i64gather_epi64.html" title="no_std_compat::arch::x86_64::_mm_i64gather_epi64 fn">_mm_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_i64gather_pd.html" title="no_std_compat::arch::x86_64::_mm_i64gather_pd fn">_mm_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_i64gather_ps.html" title="no_std_compat::arch::x86_64::_mm_i64gather_ps fn">_mm_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_insert_epi8.html" title="no_std_compat::arch::x86_64::_mm_insert_epi8 fn">_mm_insert_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Returns a copy of <code>a</code> with the 8-bit integer from <code>i</code> inserted at a
location specified by <code>IMM8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_insert_epi16.html" title="no_std_compat::arch::x86_64::_mm_insert_epi16 fn">_mm_insert_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector where the <code>imm8</code> element of <code>a</code> is replaced with <code>i</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_insert_epi32.html" title="no_std_compat::arch::x86_64::_mm_insert_epi32 fn">_mm_insert_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Returns a copy of <code>a</code> with the 32-bit integer from <code>i</code> inserted at a
location specified by <code>IMM8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_insert_epi64.html" title="no_std_compat::arch::x86_64::_mm_insert_epi64 fn">_mm_insert_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Returns a copy of <code>a</code> with the 64-bit integer from <code>i</code> inserted at a
location specified by <code>IMM1</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_insert_ps.html" title="no_std_compat::arch::x86_64::_mm_insert_ps fn">_mm_insert_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Select a single value in <code>a</code> to store at some position in <code>b</code>,
Then zero elements according to <code>IMM8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_insert_si64.html" title="no_std_compat::arch::x86_64::_mm_insert_si64 fn">_mm_insert_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4a` only"><code>sse4a</code></span></div><div class="item-right docblock-short"><p>Inserts the <code>[length:0]</code> bits of <code>y</code> into <code>x</code> at <code>index</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_lddqu_si128.html" title="no_std_compat::arch::x86_64::_mm_lddqu_si128 fn">_mm_lddqu_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Loads 128-bits of integer data from unaligned memory.
This intrinsic may perform better than <code>_mm_loadu_si128</code>
when the data crosses a cache line boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_lfence.html" title="no_std_compat::arch::x86_64::_mm_lfence fn">_mm_lfence</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Performs a serializing operation on all load-from-memory instructions
that were issued prior to this instruction.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_load1_pd.html" title="no_std_compat::arch::x86_64::_mm_load1_pd fn">_mm_load1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads a double-precision (64-bit) floating-point element from memory
into both elements of returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_load1_ps.html" title="no_std_compat::arch::x86_64::_mm_load1_ps fn">_mm_load1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Construct a <code>__m128</code> by duplicating the value read from <code>p</code> into all
elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_load_pd.html" title="no_std_compat::arch::x86_64::_mm_load_pd fn">_mm_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads 128-bits (composed of 2 packed double-precision (64-bit)
floating-point elements) from memory into the returned vector.
<code>mem_addr</code> must be aligned on a 16-byte boundary or a general-protection
exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_load_pd1.html" title="no_std_compat::arch::x86_64::_mm_load_pd1 fn">_mm_load_pd1</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads a double-precision (64-bit) floating-point element from memory
into both elements of returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_load_ps.html" title="no_std_compat::arch::x86_64::_mm_load_ps fn">_mm_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Loads four <code>f32</code> values from <em>aligned</em> memory into a <code>__m128</code>. If the
pointer is not aligned to a 128-bit boundary (16 bytes) a general
protection fault will be triggered (fatal program crash).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_load_ps1.html" title="no_std_compat::arch::x86_64::_mm_load_ps1 fn">_mm_load_ps1</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Alias for <a href="fn._mm_load1_ps.html"><code>_mm_load1_ps</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_load_sd.html" title="no_std_compat::arch::x86_64::_mm_load_sd fn">_mm_load_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads a 64-bit double-precision value to the low element of a
128-bit integer vector and clears the upper element.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_load_si128.html" title="no_std_compat::arch::x86_64::_mm_load_si128 fn">_mm_load_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads 128-bits of integer data from memory into a new vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_load_ss.html" title="no_std_compat::arch::x86_64::_mm_load_ss fn">_mm_load_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Construct a <code>__m128</code> with the lowest element read from <code>p</code> and the other
elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loaddup_pd.html" title="no_std_compat::arch::x86_64::_mm_loaddup_pd fn">_mm_loaddup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Loads a double-precision (64-bit) floating-point element from memory
into both elements of return vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loadh_pd.html" title="no_std_compat::arch::x86_64::_mm_loadh_pd fn">_mm_loadh_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads a double-precision value into the high-order bits of a 128-bit
vector of <code>[2 x double]</code>. The low-order bits are copied from the low-order
bits of the first operand.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loadl_epi64.html" title="no_std_compat::arch::x86_64::_mm_loadl_epi64 fn">_mm_loadl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads 64-bit integer from memory into first element of returned vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loadl_pd.html" title="no_std_compat::arch::x86_64::_mm_loadl_pd fn">_mm_loadl_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads a double-precision value into the low-order bits of a 128-bit
vector of <code>[2 x double]</code>. The high-order bits are copied from the
high-order bits of the first operand.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loadr_pd.html" title="no_std_compat::arch::x86_64::_mm_loadr_pd fn">_mm_loadr_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads 2 double-precision (64-bit) floating-point elements from memory into
the returned vector in reverse order. <code>mem_addr</code> must be aligned on a
16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loadr_ps.html" title="no_std_compat::arch::x86_64::_mm_loadr_ps fn">_mm_loadr_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Loads four <code>f32</code> values from aligned memory into a <code>__m128</code> in reverse
order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loadu_pd.html" title="no_std_compat::arch::x86_64::_mm_loadu_pd fn">_mm_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads 128-bits (composed of 2 packed double-precision (64-bit)
floating-point elements) from memory into the returned vector.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loadu_ps.html" title="no_std_compat::arch::x86_64::_mm_loadu_ps fn">_mm_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Loads four <code>f32</code> values from memory into a <code>__m128</code>. There are no
restrictions
on memory alignment. For aligned memory
<a href="fn._mm_load_ps.html"><code>_mm_load_ps</code></a>
may be faster.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loadu_si64.html" title="no_std_compat::arch::x86_64::_mm_loadu_si64 fn">_mm_loadu_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Loads unaligned 64-bits of integer data from memory into new vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_loadu_si128.html" title="no_std_compat::arch::x86_64::_mm_loadu_si128 fn">_mm_loadu_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Loads 128-bits of integer data from memory into a new vector.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_madd_epi16.html" title="no_std_compat::arch::x86_64::_mm_madd_epi16 fn">_mm_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Multiplies and then horizontally add signed 16 bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maddubs_epi16.html" title="no_std_compat::arch::x86_64::_mm_maddubs_epi16 fn">_mm_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Multiplies corresponding pairs of packed 8-bit unsigned integer
values contained in the first source operand and packed 8-bit signed
integer values contained in the second source operand, add pairs of
contiguous products with signed saturation, and writes the 16-bit sums to
the corresponding bits in the destination.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mask_i32gather_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_i32gather_epi32 fn">_mm_mask_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mask_i32gather_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_i32gather_epi64 fn">_mm_mask_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mask_i32gather_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_i32gather_pd fn">_mm_mask_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mask_i32gather_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_i32gather_ps fn">_mm_mask_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mask_i64gather_epi32.html" title="no_std_compat::arch::x86_64::_mm_mask_i64gather_epi32 fn">_mm_mask_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mask_i64gather_epi64.html" title="no_std_compat::arch::x86_64::_mm_mask_i64gather_epi64 fn">_mm_mask_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mask_i64gather_pd.html" title="no_std_compat::arch::x86_64::_mm_mask_i64gather_pd fn">_mm_mask_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mask_i64gather_ps.html" title="no_std_compat::arch::x86_64::_mm_mask_i64gather_ps fn">_mm_mask_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Returns values from <code>slice</code> at offsets determined by <code>offsets * scale</code>,
where
<code>scale</code> should be 1, 2, 4 or 8. If mask is set, load the value from <code>src</code> in
that position instead.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maskload_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskload_epi32 fn">_mm_maskload_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Loads packed 32-bit integers from memory pointed by <code>mem_addr</code> using <code>mask</code>
(elements are zeroed out when the highest bit is not set in the
corresponding element).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maskload_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskload_epi64 fn">_mm_maskload_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Loads packed 64-bit integers from memory pointed by <code>mem_addr</code> using <code>mask</code>
(elements are zeroed out when the highest bit is not set in the
corresponding element).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maskload_pd.html" title="no_std_compat::arch::x86_64::_mm_maskload_pd fn">_mm_maskload_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads packed double-precision (64-bit) floating-point elements from memory
into result using <code>mask</code> (elements are zeroed out when the high bit of the
corresponding element is not set).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maskload_ps.html" title="no_std_compat::arch::x86_64::_mm_maskload_ps fn">_mm_maskload_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Loads packed single-precision (32-bit) floating-point elements from memory
into result using <code>mask</code> (elements are zeroed out when the high bit of the
corresponding element is not set).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maskmoveu_si128.html" title="no_std_compat::arch::x86_64::_mm_maskmoveu_si128 fn">_mm_maskmoveu_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Conditionally store 8-bit integer elements from <code>a</code> into memory using
<code>mask</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maskstore_epi32.html" title="no_std_compat::arch::x86_64::_mm_maskstore_epi32 fn">_mm_maskstore_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Stores packed 32-bit integers from <code>a</code> into memory pointed by <code>mem_addr</code>
using <code>mask</code> (elements are not stored when the highest bit is not set
in the corresponding element).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maskstore_epi64.html" title="no_std_compat::arch::x86_64::_mm_maskstore_epi64 fn">_mm_maskstore_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Stores packed 64-bit integers from <code>a</code> into memory pointed by <code>mem_addr</code>
using <code>mask</code> (elements are not stored when the highest bit is not set
in the corresponding element).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maskstore_pd.html" title="no_std_compat::arch::x86_64::_mm_maskstore_pd fn">_mm_maskstore_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores packed double-precision (64-bit) floating-point elements from <code>a</code>
into memory using <code>mask</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_maskstore_ps.html" title="no_std_compat::arch::x86_64::_mm_maskstore_ps fn">_mm_maskstore_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Stores packed single-precision (32-bit) floating-point elements from <code>a</code>
into memory using <code>mask</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_epi8.html" title="no_std_compat::arch::x86_64::_mm_max_epi8 fn">_mm_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Compares packed 8-bit integers in <code>a</code> and <code>b</code> and returns packed maximum
values in dst.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_epi16.html" title="no_std_compat::arch::x86_64::_mm_max_epi16 fn">_mm_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns the packed
maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_epi32.html" title="no_std_compat::arch::x86_64::_mm_max_epi32 fn">_mm_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Compares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns packed maximum
values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_epu8.html" title="no_std_compat::arch::x86_64::_mm_max_epu8 fn">_mm_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and returns the
packed maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_epu16.html" title="no_std_compat::arch::x86_64::_mm_max_epu16 fn">_mm_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and returns packed
maximum.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_epu32.html" title="no_std_compat::arch::x86_64::_mm_max_epu32 fn">_mm_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and returns packed
maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_pd.html" title="no_std_compat::arch::x86_64::_mm_max_pd fn">_mm_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the maximum values from corresponding elements in
<code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_ps.html" title="no_std_compat::arch::x86_64::_mm_max_ps fn">_mm_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares packed single-precision (32-bit) floating-point elements in <code>a</code> and
<code>b</code>, and return the corresponding maximum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_sd.html" title="no_std_compat::arch::x86_64::_mm_max_sd fn">_mm_max_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the maximum
of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_max_ss.html" title="no_std_compat::arch::x86_64::_mm_max_ss fn">_mm_max_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the first single-precision (32-bit) floating-point element of <code>a</code>
and <code>b</code>, and return the maximum value in the first element of the return
value, the other elements are copied from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mfence.html" title="no_std_compat::arch::x86_64::_mm_mfence fn">_mm_mfence</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Performs a serializing operation on all load-from-memory and store-to-memory
instructions that were issued prior to this instruction.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_epi8.html" title="no_std_compat::arch::x86_64::_mm_min_epi8 fn">_mm_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Compares packed 8-bit integers in <code>a</code> and <code>b</code> and returns packed minimum
values in dst.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_epi16.html" title="no_std_compat::arch::x86_64::_mm_min_epi16 fn">_mm_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns the packed
minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_epi32.html" title="no_std_compat::arch::x86_64::_mm_min_epi32 fn">_mm_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Compares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns packed minimum
values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_epu8.html" title="no_std_compat::arch::x86_64::_mm_min_epu8 fn">_mm_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and returns the
packed minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_epu16.html" title="no_std_compat::arch::x86_64::_mm_min_epu16 fn">_mm_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and returns packed
minimum.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_epu32.html" title="no_std_compat::arch::x86_64::_mm_min_epu32 fn">_mm_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Compares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and returns packed
minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_pd.html" title="no_std_compat::arch::x86_64::_mm_min_pd fn">_mm_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the minimum values from corresponding elements in
<code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_ps.html" title="no_std_compat::arch::x86_64::_mm_min_ps fn">_mm_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares packed single-precision (32-bit) floating-point elements in <code>a</code> and
<code>b</code>, and return the corresponding minimum values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_sd.html" title="no_std_compat::arch::x86_64::_mm_min_sd fn">_mm_min_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the minimum
of the lower elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_min_ss.html" title="no_std_compat::arch::x86_64::_mm_min_ss fn">_mm_min_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares the first single-precision (32-bit) floating-point element of <code>a</code>
and <code>b</code>, and return the minimum value in the first element of the return
value, the other elements are copied from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_minpos_epu16.html" title="no_std_compat::arch::x86_64::_mm_minpos_epu16 fn">_mm_minpos_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Finds the minimum unsigned 16-bit element in the 128-bit __m128i vector,
returning a vector containing its value in its first position, and its
index
in its second position; all other elements are set to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_move_epi64.html" title="no_std_compat::arch::x86_64::_mm_move_epi64 fn">_mm_move_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a vector where the low element is extracted from <code>a</code> and its upper
element is zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_move_sd.html" title="no_std_compat::arch::x86_64::_mm_move_sd fn">_mm_move_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Constructs a 128-bit floating-point vector of <code>[2 x double]</code>. The lower
64 bits are set to the lower 64 bits of the second parameter. The upper
64 bits are set to the upper 64 bits of the first parameter.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_move_ss.html" title="no_std_compat::arch::x86_64::_mm_move_ss fn">_mm_move_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Returns a <code>__m128</code> with the first component from <code>b</code> and the remaining
components from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_movedup_pd.html" title="no_std_compat::arch::x86_64::_mm_movedup_pd fn">_mm_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Duplicate the low double-precision (64-bit) floating-point element
from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_movehdup_ps.html" title="no_std_compat::arch::x86_64::_mm_movehdup_ps fn">_mm_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Duplicate odd-indexed single-precision (32-bit) floating-point elements
from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_movehl_ps.html" title="no_std_compat::arch::x86_64::_mm_movehl_ps fn">_mm_movehl_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Combine higher half of <code>a</code> and <code>b</code>. The highwe half of <code>b</code> occupies the
lower half of result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_moveldup_ps.html" title="no_std_compat::arch::x86_64::_mm_moveldup_ps fn">_mm_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span></div><div class="item-right docblock-short"><p>Duplicate even-indexed single-precision (32-bit) floating-point elements
from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_movelh_ps.html" title="no_std_compat::arch::x86_64::_mm_movelh_ps fn">_mm_movelh_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Combine lower half of <code>a</code> and <code>b</code>. The lower half of <code>b</code> occupies the
higher half of result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_movemask_epi8.html" title="no_std_compat::arch::x86_64::_mm_movemask_epi8 fn">_mm_movemask_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a mask of the most significant bit of each element in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_movemask_pd.html" title="no_std_compat::arch::x86_64::_mm_movemask_pd fn">_mm_movemask_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a mask of the most significant bit of each element in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_movemask_ps.html" title="no_std_compat::arch::x86_64::_mm_movemask_ps fn">_mm_movemask_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Returns a mask of the most significant bit of each element in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mpsadbw_epu8.html" title="no_std_compat::arch::x86_64::_mm_mpsadbw_epu8 fn">_mm_mpsadbw_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Subtracts 8-bit unsigned integer values and computes the absolute
values of the differences to the corresponding bits in the destination.
Then sums of the absolute differences are returned according to the bit
fields in the immediate operand.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mul_epi32.html" title="no_std_compat::arch::x86_64::_mm_mul_epi32 fn">_mm_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Multiplies the low 32-bit integers from each packed 64-bit
element in <code>a</code> and <code>b</code>, and returns the signed 64-bit result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mul_epu32.html" title="no_std_compat::arch::x86_64::_mm_mul_epu32 fn">_mm_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Multiplies the low unsigned 32-bit integers from each packed 64-bit element
in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mul_pd.html" title="no_std_compat::arch::x86_64::_mm_mul_pd fn">_mm_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Multiplies packed double-precision (64-bit) floating-point elements in <code>a</code>
and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mul_ps.html" title="no_std_compat::arch::x86_64::_mm_mul_ps fn">_mm_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Multiplies __m128 vectors.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mul_sd.html" title="no_std_compat::arch::x86_64::_mm_mul_sd fn">_mm_mul_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by multiplying the
low elements of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mul_ss.html" title="no_std_compat::arch::x86_64::_mm_mul_ss fn">_mm_mul_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Multiplies the first component of <code>a</code> and <code>b</code>, the other components are
copied from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mulhi_epi16.html" title="no_std_compat::arch::x86_64::_mm_mulhi_epi16 fn">_mm_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Multiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mulhi_epu16.html" title="no_std_compat::arch::x86_64::_mm_mulhi_epu16 fn">_mm_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Multiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mulhrs_epi16.html" title="no_std_compat::arch::x86_64::_mm_mulhrs_epi16 fn">_mm_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Multiplies packed 16-bit signed integer values, truncate the 32-bit
product to the 18 most significant bits by right-shifting, round the
truncated value by adding 1, and write bits <code>[16:1]</code> to the destination.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mullo_epi16.html" title="no_std_compat::arch::x86_64::_mm_mullo_epi16 fn">_mm_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Multiplies the packed 16-bit integers in <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_mullo_epi32.html" title="no_std_compat::arch::x86_64::_mm_mullo_epi32 fn">_mm_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Multiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing intermediate
64-bit integers, and returns the lowest 32-bit, whatever they might be,
reinterpreted as a signed integer. While <code>pmulld __m128i::splat(2), __m128i::splat(2)</code> returns the obvious <code>__m128i::splat(4)</code>, due to wrapping
arithmetic <code>pmulld __m128i::splat(i32::MAX), __m128i::splat(2)</code> would
return a negative number.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_or_pd.html" title="no_std_compat::arch::x86_64::_mm_or_pd fn">_mm_or_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise OR of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_or_ps.html" title="no_std_compat::arch::x86_64::_mm_or_ps fn">_mm_or_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Bitwise OR of packed single-precision (32-bit) floating-point elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_or_si128.html" title="no_std_compat::arch::x86_64::_mm_or_si128 fn">_mm_or_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise OR of 128 bits (representing integer data) in <code>a</code> and
<code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_packs_epi16.html" title="no_std_compat::arch::x86_64::_mm_packs_epi16 fn">_mm_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed 16-bit integers from <code>a</code> and <code>b</code> to packed 8-bit integers
using signed saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_packs_epi32.html" title="no_std_compat::arch::x86_64::_mm_packs_epi32 fn">_mm_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed 32-bit integers from <code>a</code> and <code>b</code> to packed 16-bit integers
using signed saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_packus_epi16.html" title="no_std_compat::arch::x86_64::_mm_packus_epi16 fn">_mm_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Converts packed 16-bit integers from <code>a</code> and <code>b</code> to packed 8-bit integers
using unsigned saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_packus_epi32.html" title="no_std_compat::arch::x86_64::_mm_packus_epi32 fn">_mm_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Converts packed 32-bit integers from <code>a</code> and <code>b</code> to packed 16-bit integers
using unsigned saturation</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_pause.html" title="no_std_compat::arch::x86_64::_mm_pause fn">_mm_pause</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Provides a hint to the processor that the code sequence is a spin-wait loop.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_permute_pd.html" title="no_std_compat::arch::x86_64::_mm_permute_pd fn">_mm_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span></div><div class="item-right docblock-short"><p>Shuffles double-precision (64-bit) floating-point elements in <code>a</code>
using the control in <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_permute_ps.html" title="no_std_compat::arch::x86_64::_mm_permute_ps fn">_mm_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span></div><div class="item-right docblock-short"><p>Shuffles single-precision (32-bit) floating-point elements in <code>a</code>
using the control in <code>imm8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_permutevar_pd.html" title="no_std_compat::arch::x86_64::_mm_permutevar_pd fn">_mm_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles double-precision (64-bit) floating-point elements in <code>a</code>
using the control in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_permutevar_ps.html" title="no_std_compat::arch::x86_64::_mm_permutevar_ps fn">_mm_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Shuffles single-precision (32-bit) floating-point elements in <code>a</code>
using the control in <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_prefetch.html" title="no_std_compat::arch::x86_64::_mm_prefetch fn">_mm_prefetch</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Fetch the cache line that contains address <code>p</code> using the given <code>STRATEGY</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_rcp_ps.html" title="no_std_compat::arch::x86_64::_mm_rcp_ps fn">_mm_rcp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Returns the approximate reciprocal of packed single-precision (32-bit)
floating-point elements in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_rcp_ss.html" title="no_std_compat::arch::x86_64::_mm_rcp_ss fn">_mm_rcp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Returns the approximate reciprocal of the first single-precision
(32-bit) floating-point element in <code>a</code>, the other elements are unchanged.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_round_pd.html" title="no_std_compat::arch::x86_64::_mm_round_pd fn">_mm_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the packed double-precision (64-bit) floating-point elements in <code>a</code>
using the <code>ROUNDING</code> parameter, and stores the results as packed
double-precision floating-point elements.
Rounding is done according to the rounding parameter, which can be one of:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_round_ps.html" title="no_std_compat::arch::x86_64::_mm_round_ps fn">_mm_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the packed single-precision (32-bit) floating-point elements in <code>a</code>
using the <code>ROUNDING</code> parameter, and stores the results as packed
single-precision floating-point elements.
Rounding is done according to the rounding parameter, which can be one of:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_round_sd.html" title="no_std_compat::arch::x86_64::_mm_round_sd fn">_mm_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the lower double-precision (64-bit) floating-point element in <code>b</code>
using the <code>ROUNDING</code> parameter, store the result as a double-precision
floating-point element in the lower element of the intrinsic result,
and copies the upper element from <code>a</code> to the upper element of the intrinsic
result.
Rounding is done according to the rounding parameter, which can be one of:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_round_ss.html" title="no_std_compat::arch::x86_64::_mm_round_ss fn">_mm_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Round the lower single-precision (32-bit) floating-point element in <code>b</code>
using the <code>ROUNDING</code> parameter, store the result as a single-precision
floating-point element in the lower element of the intrinsic result,
and copies the upper 3 packed elements from <code>a</code> to the upper elements
of the intrinsic result.
Rounding is done according to the rounding parameter, which can be one of:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_rsqrt_ps.html" title="no_std_compat::arch::x86_64::_mm_rsqrt_ps fn">_mm_rsqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Returns the approximate reciprocal square root of packed single-precision
(32-bit) floating-point elements in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_rsqrt_ss.html" title="no_std_compat::arch::x86_64::_mm_rsqrt_ss fn">_mm_rsqrt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Returns the approximate reciprocal square root of the first single-precision
(32-bit) floating-point element in <code>a</code>, the other elements are unchanged.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sad_epu8.html" title="no_std_compat::arch::x86_64::_mm_sad_epu8 fn">_mm_sad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sum the absolute differences of packed unsigned 8-bit integers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set1_epi8.html" title="no_std_compat::arch::x86_64::_mm_set1_epi8 fn">_mm_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Broadcasts 8-bit integer <code>a</code> to all elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set1_epi16.html" title="no_std_compat::arch::x86_64::_mm_set1_epi16 fn">_mm_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Broadcasts 16-bit integer <code>a</code> to all elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set1_epi32.html" title="no_std_compat::arch::x86_64::_mm_set1_epi32 fn">_mm_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Broadcasts 32-bit integer <code>a</code> to all elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set1_epi64x.html" title="no_std_compat::arch::x86_64::_mm_set1_epi64x fn">_mm_set1_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Broadcasts 64-bit integer <code>a</code> to all elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set1_pd.html" title="no_std_compat::arch::x86_64::_mm_set1_pd fn">_mm_set1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Broadcasts double-precision (64-bit) floating-point value a to all elements
of the return value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set1_ps.html" title="no_std_compat::arch::x86_64::_mm_set1_ps fn">_mm_set1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Construct a <code>__m128</code> with all element set to <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_epi8.html" title="no_std_compat::arch::x86_64::_mm_set_epi8 fn">_mm_set_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sets packed 8-bit integers with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_epi16.html" title="no_std_compat::arch::x86_64::_mm_set_epi16 fn">_mm_set_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sets packed 16-bit integers with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_epi32.html" title="no_std_compat::arch::x86_64::_mm_set_epi32 fn">_mm_set_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sets packed 32-bit integers with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_epi64x.html" title="no_std_compat::arch::x86_64::_mm_set_epi64x fn">_mm_set_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sets packed 64-bit integers with the supplied values, from highest to
lowest.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_pd.html" title="no_std_compat::arch::x86_64::_mm_set_pd fn">_mm_set_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sets packed double-precision (64-bit) floating-point elements in the return
value with the supplied values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_pd1.html" title="no_std_compat::arch::x86_64::_mm_set_pd1 fn">_mm_set_pd1</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Broadcasts double-precision (64-bit) floating-point value a to all elements
of the return value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_ps.html" title="no_std_compat::arch::x86_64::_mm_set_ps fn">_mm_set_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Construct a <code>__m128</code> from four floating point values highest to lowest.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_ps1.html" title="no_std_compat::arch::x86_64::_mm_set_ps1 fn">_mm_set_ps1</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Alias for <a href="fn._mm_set1_ps.html"><code>_mm_set1_ps</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_sd.html" title="no_std_compat::arch::x86_64::_mm_set_sd fn">_mm_set_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Copies double-precision (64-bit) floating-point element <code>a</code> to the lower
element of the packed 64-bit return value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_set_ss.html" title="no_std_compat::arch::x86_64::_mm_set_ss fn">_mm_set_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Construct a <code>__m128</code> with the lowest element set to <code>a</code> and the rest set to
zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_setcsr.html" title="no_std_compat::arch::x86_64::_mm_setcsr fn">_mm_setcsr</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Sets the MXCSR register with the 32-bit unsigned integer value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_setr_epi8.html" title="no_std_compat::arch::x86_64::_mm_setr_epi8 fn">_mm_setr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sets packed 8-bit integers with the supplied values in reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_setr_epi16.html" title="no_std_compat::arch::x86_64::_mm_setr_epi16 fn">_mm_setr_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sets packed 16-bit integers with the supplied values in reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_setr_epi32.html" title="no_std_compat::arch::x86_64::_mm_setr_epi32 fn">_mm_setr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sets packed 32-bit integers with the supplied values in reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_setr_pd.html" title="no_std_compat::arch::x86_64::_mm_setr_pd fn">_mm_setr_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Sets packed double-precision (64-bit) floating-point elements in the return
value with the supplied values in reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_setr_ps.html" title="no_std_compat::arch::x86_64::_mm_setr_ps fn">_mm_setr_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Construct a <code>__m128</code> from four floating point values lowest to highest.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_setzero_pd.html" title="no_std_compat::arch::x86_64::_mm_setzero_pd fn">_mm_setzero_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns packed double-precision (64-bit) floating-point elements with all
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_setzero_ps.html" title="no_std_compat::arch::x86_64::_mm_setzero_ps fn">_mm_setzero_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Construct a <code>__m128</code> with all elements initialized to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_setzero_si128.html" title="no_std_compat::arch::x86_64::_mm_setzero_si128 fn">_mm_setzero_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a vector with all elements set to zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sfence.html" title="no_std_compat::arch::x86_64::_mm_sfence fn">_mm_sfence</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Performs a serializing operation on all store-to-memory instructions that
were issued prior to this instruction.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sha1msg1_epu32.html" title="no_std_compat::arch::x86_64::_mm_sha1msg1_epu32 fn">_mm_sha1msg1_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span></div><div class="item-right docblock-short"><p>Performs an intermediate calculation for the next four SHA1 message values
(unsigned 32-bit integers) using previous message values from <code>a</code> and <code>b</code>,
and returning the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sha1msg2_epu32.html" title="no_std_compat::arch::x86_64::_mm_sha1msg2_epu32 fn">_mm_sha1msg2_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span></div><div class="item-right docblock-short"><p>Performs the final calculation for the next four SHA1 message values
(unsigned 32-bit integers) using the intermediate result in <code>a</code> and the
previous message values in <code>b</code>, and returns the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sha1nexte_epu32.html" title="no_std_compat::arch::x86_64::_mm_sha1nexte_epu32 fn">_mm_sha1nexte_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span></div><div class="item-right docblock-short"><p>Calculate SHA1 state variable E after four rounds of operation from the
current SHA1 state variable <code>a</code>, add that value to the scheduled values
(unsigned 32-bit integers) in <code>b</code>, and returns the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sha1rnds4_epu32.html" title="no_std_compat::arch::x86_64::_mm_sha1rnds4_epu32 fn">_mm_sha1rnds4_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span></div><div class="item-right docblock-short"><p>Performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D)
from <code>a</code> and some pre-computed sum of the next 4 round message values
(unsigned 32-bit integers), and state variable E from <code>b</code>, and return the
updated SHA1 state (A,B,C,D). <code>FUNC</code> contains the logic functions and round
constants.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sha256msg1_epu32.html" title="no_std_compat::arch::x86_64::_mm_sha256msg1_epu32 fn">_mm_sha256msg1_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span></div><div class="item-right docblock-short"><p>Performs an intermediate calculation for the next four SHA256 message values
(unsigned 32-bit integers) using previous message values from <code>a</code> and <code>b</code>,
and return the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sha256msg2_epu32.html" title="no_std_compat::arch::x86_64::_mm_sha256msg2_epu32 fn">_mm_sha256msg2_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span></div><div class="item-right docblock-short"><p>Performs the final calculation for the next four SHA256 message values
(unsigned 32-bit integers) using previous message values from <code>a</code> and <code>b</code>,
and return the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sha256rnds2_epu32.html" title="no_std_compat::arch::x86_64::_mm_sha256rnds2_epu32 fn">_mm_sha256rnds2_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span></div><div class="item-right docblock-short"><p>Performs 2 rounds of SHA256 operation using an initial SHA256 state
(C,D,G,H) from <code>a</code>, an initial SHA256 state (A,B,E,F) from <code>b</code>, and a
pre-computed sum of the next 2 round message values (unsigned 32-bit
integers) and the corresponding round constants from <code>k</code>, and store the
updated SHA256 state (A,B,E,F) in dst.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_shuffle_epi8.html" title="no_std_compat::arch::x86_64::_mm_shuffle_epi8 fn">_mm_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Shuffles bytes from <code>a</code> according to the content of <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_shuffle_epi32.html" title="no_std_compat::arch::x86_64::_mm_shuffle_epi32 fn">_mm_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shuffles 32-bit integers in <code>a</code> using the control in <code>IMM8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_shuffle_pd.html" title="no_std_compat::arch::x86_64::_mm_shuffle_pd fn">_mm_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Constructs a 128-bit floating-point vector of <code>[2 x double]</code> from two
128-bit vector parameters of <code>[2 x double]</code>, using the immediate-value
parameter as a specifier.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_shuffle_ps.html" title="no_std_compat::arch::x86_64::_mm_shuffle_ps fn">_mm_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Shuffles packed single-precision (32-bit) floating-point elements in <code>a</code> and
<code>b</code> using <code>MASK</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_shufflehi_epi16.html" title="no_std_compat::arch::x86_64::_mm_shufflehi_epi16 fn">_mm_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shuffles 16-bit integers in the high 64 bits of <code>a</code> using the control in
<code>IMM8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_shufflelo_epi16.html" title="no_std_compat::arch::x86_64::_mm_shufflelo_epi16 fn">_mm_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shuffles 16-bit integers in the low 64 bits of <code>a</code> using the control in
<code>IMM8</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sign_epi8.html" title="no_std_compat::arch::x86_64::_mm_sign_epi8 fn">_mm_sign_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Negates packed 8-bit integers in <code>a</code> when the corresponding signed 8-bit
integer in <code>b</code> is negative, and returns the result.
Elements in result are zeroed out when the corresponding element in <code>b</code>
is zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sign_epi16.html" title="no_std_compat::arch::x86_64::_mm_sign_epi16 fn">_mm_sign_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Negates packed 16-bit integers in <code>a</code> when the corresponding signed 16-bit
integer in <code>b</code> is negative, and returns the results.
Elements in result are zeroed out when the corresponding element in <code>b</code>
is zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sign_epi32.html" title="no_std_compat::arch::x86_64::_mm_sign_epi32 fn">_mm_sign_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span></div><div class="item-right docblock-short"><p>Negates packed 32-bit integers in <code>a</code> when the corresponding signed 32-bit
integer in <code>b</code> is negative, and returns the results.
Element in result are zeroed out when the corresponding element in <code>b</code>
is zero.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sll_epi16.html" title="no_std_compat::arch::x86_64::_mm_sll_epi16 fn">_mm_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> left by <code>count</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sll_epi32.html" title="no_std_compat::arch::x86_64::_mm_sll_epi32 fn">_mm_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> left by <code>count</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sll_epi64.html" title="no_std_compat::arch::x86_64::_mm_sll_epi64 fn">_mm_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> left by <code>count</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_slli_epi16.html" title="no_std_compat::arch::x86_64::_mm_slli_epi16 fn">_mm_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_slli_epi32.html" title="no_std_compat::arch::x86_64::_mm_slli_epi32 fn">_mm_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_slli_epi64.html" title="no_std_compat::arch::x86_64::_mm_slli_epi64 fn">_mm_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_slli_si128.html" title="no_std_compat::arch::x86_64::_mm_slli_si128 fn">_mm_slli_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts <code>a</code> left by <code>IMM8</code> bytes while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sllv_epi32.html" title="no_std_compat::arch::x86_64::_mm_sllv_epi32 fn">_mm_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> left by the amount
specified by the corresponding element in <code>count</code> while
shifting in zeros, and returns the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sllv_epi64.html" title="no_std_compat::arch::x86_64::_mm_sllv_epi64 fn">_mm_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> left by the amount
specified by the corresponding element in <code>count</code> while
shifting in zeros, and returns the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sqrt_pd.html" title="no_std_compat::arch::x86_64::_mm_sqrt_pd fn">_mm_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the square root of each of the values in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sqrt_ps.html" title="no_std_compat::arch::x86_64::_mm_sqrt_ps fn">_mm_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Returns the square root of packed single-precision (32-bit) floating-point
elements in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sqrt_sd.html" title="no_std_compat::arch::x86_64::_mm_sqrt_sd fn">_mm_sqrt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by the square
root of the lower element <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sqrt_ss.html" title="no_std_compat::arch::x86_64::_mm_sqrt_ss fn">_mm_sqrt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Returns the square root of the first single-precision (32-bit)
floating-point element in <code>a</code>, the other elements are unchanged.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sra_epi16.html" title="no_std_compat::arch::x86_64::_mm_sra_epi16 fn">_mm_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> right by <code>count</code> while shifting in sign
bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sra_epi32.html" title="no_std_compat::arch::x86_64::_mm_sra_epi32 fn">_mm_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by <code>count</code> while shifting in sign
bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srai_epi16.html" title="no_std_compat::arch::x86_64::_mm_srai_epi16 fn">_mm_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in sign
bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srai_epi32.html" title="no_std_compat::arch::x86_64::_mm_srai_epi32 fn">_mm_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in sign
bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srav_epi32.html" title="no_std_compat::arch::x86_64::_mm_srav_epi32 fn">_mm_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by the amount specified by the
corresponding element in <code>count</code> while shifting in sign bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srl_epi16.html" title="no_std_compat::arch::x86_64::_mm_srl_epi16 fn">_mm_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> right by <code>count</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srl_epi32.html" title="no_std_compat::arch::x86_64::_mm_srl_epi32 fn">_mm_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by <code>count</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srl_epi64.html" title="no_std_compat::arch::x86_64::_mm_srl_epi64 fn">_mm_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> right by <code>count</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srli_epi16.html" title="no_std_compat::arch::x86_64::_mm_srli_epi16 fn">_mm_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srli_epi32.html" title="no_std_compat::arch::x86_64::_mm_srli_epi32 fn">_mm_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srli_epi64.html" title="no_std_compat::arch::x86_64::_mm_srli_epi64 fn">_mm_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while shifting in
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srli_si128.html" title="no_std_compat::arch::x86_64::_mm_srli_si128 fn">_mm_srli_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Shifts <code>a</code> right by <code>IMM8</code> bytes while shifting in zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srlv_epi32.html" title="no_std_compat::arch::x86_64::_mm_srlv_epi32 fn">_mm_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 32-bit integers in <code>a</code> right by the amount specified by
the corresponding element in <code>count</code> while shifting in zeros,</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_srlv_epi64.html" title="no_std_compat::arch::x86_64::_mm_srlv_epi64 fn">_mm_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span></div><div class="item-right docblock-short"><p>Shifts packed 64-bit integers in <code>a</code> right by the amount specified by
the corresponding element in <code>count</code> while shifting in zeros,</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_store1_pd.html" title="no_std_compat::arch::x86_64::_mm_store1_pd fn">_mm_store1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores the lower double-precision (64-bit) floating-point element from <code>a</code>
into 2 contiguous elements in memory. <code>mem_addr</code> must be aligned on a
16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_store1_ps.html" title="no_std_compat::arch::x86_64::_mm_store1_ps fn">_mm_store1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Stores the lowest 32 bit float of <code>a</code> repeated four times into <em>aligned</em>
memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_store_pd.html" title="no_std_compat::arch::x86_64::_mm_store_pd fn">_mm_store_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores 128-bits (composed of 2 packed double-precision (64-bit)
floating-point elements) from <code>a</code> into memory. <code>mem_addr</code> must be aligned
on a 16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_store_pd1.html" title="no_std_compat::arch::x86_64::_mm_store_pd1 fn">_mm_store_pd1</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores the lower double-precision (64-bit) floating-point element from <code>a</code>
into 2 contiguous elements in memory. <code>mem_addr</code> must be aligned on a
16-byte boundary or a general-protection exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_store_ps.html" title="no_std_compat::arch::x86_64::_mm_store_ps fn">_mm_store_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Stores four 32-bit floats into <em>aligned</em> memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_store_ps1.html" title="no_std_compat::arch::x86_64::_mm_store_ps1 fn">_mm_store_ps1</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Alias for <a href="fn._mm_store1_ps.html"><code>_mm_store1_ps</code></a></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_store_sd.html" title="no_std_compat::arch::x86_64::_mm_store_sd fn">_mm_store_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores the lower 64 bits of a 128-bit vector of <code>[2 x double]</code> to a
memory location.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_store_si128.html" title="no_std_compat::arch::x86_64::_mm_store_si128 fn">_mm_store_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores 128-bits of integer data from <code>a</code> into memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_store_ss.html" title="no_std_compat::arch::x86_64::_mm_store_ss fn">_mm_store_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Stores the lowest 32 bit float of <code>a</code> into memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_storeh_pd.html" title="no_std_compat::arch::x86_64::_mm_storeh_pd fn">_mm_storeh_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores the upper 64 bits of a 128-bit vector of <code>[2 x double]</code> to a
memory location.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_storel_epi64.html" title="no_std_compat::arch::x86_64::_mm_storel_epi64 fn">_mm_storel_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores the lower 64-bit integer <code>a</code> to a memory location.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_storel_pd.html" title="no_std_compat::arch::x86_64::_mm_storel_pd fn">_mm_storel_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores the lower 64 bits of a 128-bit vector of <code>[2 x double]</code> to a
memory location.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_storer_pd.html" title="no_std_compat::arch::x86_64::_mm_storer_pd fn">_mm_storer_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores 2 double-precision (64-bit) floating-point elements from <code>a</code> into
memory in reverse order.
<code>mem_addr</code> must be aligned on a 16-byte boundary or a general-protection
exception may be generated.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_storer_ps.html" title="no_std_compat::arch::x86_64::_mm_storer_ps fn">_mm_storer_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Stores four 32-bit floats into <em>aligned</em> memory in reverse order.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_storeu_pd.html" title="no_std_compat::arch::x86_64::_mm_storeu_pd fn">_mm_storeu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores 128-bits (composed of 2 packed double-precision (64-bit)
floating-point elements) from <code>a</code> into memory.
<code>mem_addr</code> does not need to be aligned on any particular boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_storeu_ps.html" title="no_std_compat::arch::x86_64::_mm_storeu_ps fn">_mm_storeu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Stores four 32-bit floats into memory. There are no restrictions on memory
alignment. For aligned memory <a href="fn._mm_store_ps.html"><code>_mm_store_ps</code></a> may be
faster.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_storeu_si128.html" title="no_std_compat::arch::x86_64::_mm_storeu_si128 fn">_mm_storeu_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores 128-bits of integer data from <code>a</code> into memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_stream_pd.html" title="no_std_compat::arch::x86_64::_mm_stream_pd fn">_mm_stream_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores a 128-bit floating point vector of <code>[2 x double]</code> to a 128-bit
aligned memory location.
To minimize caching, the data is flagged as non-temporal (unlikely to be
used again soon).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_stream_ps.html" title="no_std_compat::arch::x86_64::_mm_stream_ps fn">_mm_stream_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Stores <code>a</code> into the memory at <code>mem_addr</code> using a non-temporal memory hint.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_stream_sd.html" title="no_std_compat::arch::x86_64::_mm_stream_sd fn">_mm_stream_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4a` only"><code>sse4a</code></span></div><div class="item-right docblock-short"><p>Non-temporal store of <code>a.0</code> into <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_stream_si32.html" title="no_std_compat::arch::x86_64::_mm_stream_si32 fn">_mm_stream_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores a 32-bit integer value in the specified memory location.
To minimize caching, the data is flagged as non-temporal (unlikely to be
used again soon).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_stream_si64.html" title="no_std_compat::arch::x86_64::_mm_stream_si64 fn">_mm_stream_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores a 64-bit integer value in the specified memory location.
To minimize caching, the data is flagged as non-temporal (unlikely to be
used again soon).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_stream_si128.html" title="no_std_compat::arch::x86_64::_mm_stream_si128 fn">_mm_stream_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Stores a 128-bit integer vector to a 128-bit aligned memory location.
To minimize caching, the data is flagged as non-temporal (unlikely to be
used again soon).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_stream_ss.html" title="no_std_compat::arch::x86_64::_mm_stream_ss fn">_mm_stream_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4a` only"><code>sse4a</code></span></div><div class="item-right docblock-short"><p>Non-temporal store of <code>a.0</code> into <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sub_epi8.html" title="no_std_compat::arch::x86_64::_mm_sub_epi8 fn">_mm_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Subtracts packed 8-bit integers in <code>b</code> from packed 8-bit integers in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sub_epi16.html" title="no_std_compat::arch::x86_64::_mm_sub_epi16 fn">_mm_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Subtracts packed 16-bit integers in <code>b</code> from packed 16-bit integers in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sub_epi32.html" title="no_std_compat::arch::x86_64::_mm_sub_epi32 fn">_mm_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 32-bit integers in <code>b</code> from packed 32-bit integers in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sub_epi64.html" title="no_std_compat::arch::x86_64::_mm_sub_epi64 fn">_mm_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 64-bit integers in <code>b</code> from packed 64-bit integers in <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sub_pd.html" title="no_std_compat::arch::x86_64::_mm_sub_pd fn">_mm_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Subtract packed double-precision (64-bit) floating-point elements in <code>b</code>
from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sub_ps.html" title="no_std_compat::arch::x86_64::_mm_sub_ps fn">_mm_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Subtracts __m128 vectors.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sub_sd.html" title="no_std_compat::arch::x86_64::_mm_sub_sd fn">_mm_sub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns a new vector with the low element of <code>a</code> replaced by subtracting the
low element by <code>b</code> from the low element of <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_sub_ss.html" title="no_std_compat::arch::x86_64::_mm_sub_ss fn">_mm_sub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Subtracts the first component of <code>b</code> from <code>a</code>, the other components are
copied from <code>a</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_subs_epi8.html" title="no_std_compat::arch::x86_64::_mm_subs_epi8 fn">_mm_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 8-bit integers in <code>b</code> from packed 8-bit integers in <code>a</code>
using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_subs_epi16.html" title="no_std_compat::arch::x86_64::_mm_subs_epi16 fn">_mm_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Subtract packed 16-bit integers in <code>b</code> from packed 16-bit integers in <code>a</code>
using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_subs_epu8.html" title="no_std_compat::arch::x86_64::_mm_subs_epu8 fn">_mm_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 8-bit integers in <code>b</code> from packed unsigned 8-bit
integers in <code>a</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_subs_epu16.html" title="no_std_compat::arch::x86_64::_mm_subs_epu16 fn">_mm_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Subtract packed unsigned 16-bit integers in <code>b</code> from packed unsigned 16-bit
integers in <code>a</code> using saturation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_test_all_ones.html" title="no_std_compat::arch::x86_64::_mm_test_all_ones fn">_mm_test_all_ones</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Tests whether the specified bits in <code>a</code> 128-bit integer vector are all
ones.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_test_all_zeros.html" title="no_std_compat::arch::x86_64::_mm_test_all_zeros fn">_mm_test_all_zeros</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Tests whether the specified bits in a 128-bit integer vector are all
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_test_mix_ones_zeros.html" title="no_std_compat::arch::x86_64::_mm_test_mix_ones_zeros fn">_mm_test_mix_ones_zeros</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Tests whether the specified bits in a 128-bit integer vector are
neither all zeros nor all ones.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_testc_pd.html" title="no_std_compat::arch::x86_64::_mm_testc_pd fn">_mm_testc_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 128 bits (representing double-precision (64-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_testc_ps.html" title="no_std_compat::arch::x86_64::_mm_testc_ps fn">_mm_testc_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 128 bits (representing single-precision (32-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return the <code>CF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_testc_si128.html" title="no_std_compat::arch::x86_64::_mm_testc_si128 fn">_mm_testc_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Tests whether the specified bits in a 128-bit integer vector are all
ones.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_testnzc_pd.html" title="no_std_compat::arch::x86_64::_mm_testnzc_pd fn">_mm_testnzc_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 128 bits (representing double-precision (64-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and <code>CF</code> values
are zero, otherwise return 0.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_testnzc_ps.html" title="no_std_compat::arch::x86_64::_mm_testnzc_ps fn">_mm_testnzc_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 128 bits (representing single-precision (32-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return 1 if both the <code>ZF</code> and <code>CF</code> values
are zero, otherwise return 0.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_testnzc_si128.html" title="no_std_compat::arch::x86_64::_mm_testnzc_si128 fn">_mm_testnzc_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Tests whether the specified bits in a 128-bit integer vector are
neither all zeros nor all ones.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_testz_pd.html" title="no_std_compat::arch::x86_64::_mm_testz_pd fn">_mm_testz_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 128 bits (representing double-precision (64-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 64-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 64-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_testz_ps.html" title="no_std_compat::arch::x86_64::_mm_testz_ps fn">_mm_testz_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise AND of 128 bits (representing single-precision (32-bit)
floating-point elements) in <code>a</code> and <code>b</code>, producing an intermediate 128-bit
value, and set <code>ZF</code> to 1 if the sign bit of each 32-bit element in the
intermediate value is zero, otherwise set <code>ZF</code> to 0. Compute the bitwise
NOT of <code>a</code> and then AND with <code>b</code>, producing an intermediate value, and set
<code>CF</code> to 1 if the sign bit of each 32-bit element in the intermediate value
is zero, otherwise set <code>CF</code> to 0. Return the <code>ZF</code> value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_testz_si128.html" title="no_std_compat::arch::x86_64::_mm_testz_si128 fn">_mm_testz_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="item-right docblock-short"><p>Tests whether the specified bits in a 128-bit integer vector are all
zeros.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_tzcnt_32.html" title="no_std_compat::arch::x86_64::_mm_tzcnt_32 fn">_mm_tzcnt_32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Counts the number of trailing least significant zero bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_tzcnt_64.html" title="no_std_compat::arch::x86_64::_mm_tzcnt_64 fn">_mm_tzcnt_64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Counts the number of trailing least significant zero bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomieq_sd.html" title="no_std_compat::arch::x86_64::_mm_ucomieq_sd fn">_mm_ucomieq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for equality.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomieq_ss.html" title="no_std_compat::arch::x86_64::_mm_ucomieq_ss fn">_mm_ucomieq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if they are equal, or <code>0</code> otherwise. This instruction will not signal
an exception if either argument is a quiet NaN.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomige_sd.html" title="no_std_compat::arch::x86_64::_mm_ucomige_sd fn">_mm_ucomige_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for greater-than-or-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomige_ss.html" title="no_std_compat::arch::x86_64::_mm_ucomige_ss fn">_mm_ucomige_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if the value from <code>a</code> is greater than or equal to the one from <code>b</code>, or
<code>0</code> otherwise. This instruction will not signal an exception if either
argument is a quiet NaN.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomigt_sd.html" title="no_std_compat::arch::x86_64::_mm_ucomigt_sd fn">_mm_ucomigt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for greater-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomigt_ss.html" title="no_std_compat::arch::x86_64::_mm_ucomigt_ss fn">_mm_ucomigt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if the value from <code>a</code> is greater than the one from <code>b</code>, or <code>0</code>
otherwise. This instruction will not signal an exception if either argument
is a quiet NaN.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomile_sd.html" title="no_std_compat::arch::x86_64::_mm_ucomile_sd fn">_mm_ucomile_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for less-than-or-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomile_ss.html" title="no_std_compat::arch::x86_64::_mm_ucomile_ss fn">_mm_ucomile_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if the value from <code>a</code> is less than or equal to the one from <code>b</code>, or <code>0</code>
otherwise. This instruction will not signal an exception if either argument
is a quiet NaN.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomilt_sd.html" title="no_std_compat::arch::x86_64::_mm_ucomilt_sd fn">_mm_ucomilt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for less-than.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomilt_ss.html" title="no_std_compat::arch::x86_64::_mm_ucomilt_ss fn">_mm_ucomilt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if the value from <code>a</code> is less than the one from <code>b</code>, or <code>0</code> otherwise.
This instruction will not signal an exception if either argument is a quiet
NaN.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomineq_sd.html" title="no_std_compat::arch::x86_64::_mm_ucomineq_sd fn">_mm_ucomineq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Compares the lower element of <code>a</code> and <code>b</code> for not-equal.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_ucomineq_ss.html" title="no_std_compat::arch::x86_64::_mm_ucomineq_ss fn">_mm_ucomineq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Compares two 32-bit floats from the low-order bits of <code>a</code> and <code>b</code>. Returns
<code>1</code> if they are <strong>not</strong> equal, or <code>0</code> otherwise. This instruction will not
signal an exception if either argument is a quiet NaN.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_undefined_pd.html" title="no_std_compat::arch::x86_64::_mm_undefined_pd fn">_mm_undefined_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns vector of type __m128d with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_undefined_ps.html" title="no_std_compat::arch::x86_64::_mm_undefined_ps fn">_mm_undefined_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Returns vector of type __m128 with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_undefined_si128.html" title="no_std_compat::arch::x86_64::_mm_undefined_si128 fn">_mm_undefined_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Returns vector of type __m128i with undefined elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpackhi_epi8.html" title="no_std_compat::arch::x86_64::_mm_unpackhi_epi8 fn">_mm_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 8-bit integers from the high half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpackhi_epi16.html" title="no_std_compat::arch::x86_64::_mm_unpackhi_epi16 fn">_mm_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 16-bit integers from the high half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpackhi_epi32.html" title="no_std_compat::arch::x86_64::_mm_unpackhi_epi32 fn">_mm_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 32-bit integers from the high half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpackhi_epi64.html" title="no_std_compat::arch::x86_64::_mm_unpackhi_epi64 fn">_mm_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 64-bit integers from the high half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpackhi_pd.html" title="no_std_compat::arch::x86_64::_mm_unpackhi_pd fn">_mm_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>The resulting <code>__m128d</code> element is composed by the low-order values of
the two <code>__m128d</code> interleaved input elements, i.e.:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpackhi_ps.html" title="no_std_compat::arch::x86_64::_mm_unpackhi_ps fn">_mm_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave single-precision (32-bit) floating-point elements
from the higher half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpacklo_epi8.html" title="no_std_compat::arch::x86_64::_mm_unpacklo_epi8 fn">_mm_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 8-bit integers from the low half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpacklo_epi16.html" title="no_std_compat::arch::x86_64::_mm_unpacklo_epi16 fn">_mm_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 16-bit integers from the low half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpacklo_epi32.html" title="no_std_compat::arch::x86_64::_mm_unpacklo_epi32 fn">_mm_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 32-bit integers from the low half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpacklo_epi64.html" title="no_std_compat::arch::x86_64::_mm_unpacklo_epi64 fn">_mm_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave 64-bit integers from the low half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpacklo_pd.html" title="no_std_compat::arch::x86_64::_mm_unpacklo_pd fn">_mm_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>The resulting <code>__m128d</code> element is composed by the high-order values of
the two <code>__m128d</code> interleaved input elements, i.e.:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_unpacklo_ps.html" title="no_std_compat::arch::x86_64::_mm_unpacklo_ps fn">_mm_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Unpacks and interleave single-precision (32-bit) floating-point elements
from the lower half of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_xor_pd.html" title="no_std_compat::arch::x86_64::_mm_xor_pd fn">_mm_xor_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise OR of <code>a</code> and <code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_xor_ps.html" title="no_std_compat::arch::x86_64::_mm_xor_ps fn">_mm_xor_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span></div><div class="item-right docblock-short"><p>Bitwise exclusive OR of packed single-precision (32-bit) floating-point
elements.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mm_xor_si128.html" title="no_std_compat::arch::x86_64::_mm_xor_si128 fn">_mm_xor_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span></div><div class="item-right docblock-short"><p>Computes the bitwise XOR of 128 bits (representing integer data) in <code>a</code> and
<code>b</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mulx_u32.html" title="no_std_compat::arch::x86_64::_mulx_u32 fn">_mulx_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span></div><div class="item-right docblock-short"><p>Unsigned multiply without affecting flags.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._mulx_u64.html" title="no_std_compat::arch::x86_64::_mulx_u64 fn">_mulx_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span></div><div class="item-right docblock-short"><p>Unsigned multiply without affecting flags.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._pdep_u32.html" title="no_std_compat::arch::x86_64::_pdep_u32 fn">_pdep_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span></div><div class="item-right docblock-short"><p>Scatter contiguous low order bits of <code>a</code> to the result at the positions
specified by the <code>mask</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._pdep_u64.html" title="no_std_compat::arch::x86_64::_pdep_u64 fn">_pdep_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span></div><div class="item-right docblock-short"><p>Scatter contiguous low order bits of <code>a</code> to the result at the positions
specified by the <code>mask</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._pext_u32.html" title="no_std_compat::arch::x86_64::_pext_u32 fn">_pext_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span></div><div class="item-right docblock-short"><p>Gathers the bits of <code>x</code> specified by the <code>mask</code> into the contiguous low
order bit positions of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._pext_u64.html" title="no_std_compat::arch::x86_64::_pext_u64 fn">_pext_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span></div><div class="item-right docblock-short"><p>Gathers the bits of <code>x</code> specified by the <code>mask</code> into the contiguous low
order bit positions of the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._popcnt32.html" title="no_std_compat::arch::x86_64::_popcnt32 fn">_popcnt32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `popcnt` only"><code>popcnt</code></span></div><div class="item-right docblock-short"><p>Counts the bits that are set.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._popcnt64.html" title="no_std_compat::arch::x86_64::_popcnt64 fn">_popcnt64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `popcnt` only"><code>popcnt</code></span></div><div class="item-right docblock-short"><p>Counts the bits that are set.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._rdrand16_step.html" title="no_std_compat::arch::x86_64::_rdrand16_step fn">_rdrand16_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `rdrand` only"><code>rdrand</code></span></div><div class="item-right docblock-short"><p>Read a hardware generated 16-bit random value and store the result in val.
Returns 1 if a random value was generated, and 0 otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._rdrand32_step.html" title="no_std_compat::arch::x86_64::_rdrand32_step fn">_rdrand32_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `rdrand` only"><code>rdrand</code></span></div><div class="item-right docblock-short"><p>Read a hardware generated 32-bit random value and store the result in val.
Returns 1 if a random value was generated, and 0 otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._rdrand64_step.html" title="no_std_compat::arch::x86_64::_rdrand64_step fn">_rdrand64_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `rdrand` only"><code>rdrand</code></span></div><div class="item-right docblock-short"><p>Read a hardware generated 64-bit random value and store the result in val.
Returns 1 if a random value was generated, and 0 otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._rdseed16_step.html" title="no_std_compat::arch::x86_64::_rdseed16_step fn">_rdseed16_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `rdseed` only"><code>rdseed</code></span></div><div class="item-right docblock-short"><p>Read a 16-bit NIST SP800-90B and SP800-90C compliant random value and store
in val. Return 1 if a random value was generated, and 0 otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._rdseed32_step.html" title="no_std_compat::arch::x86_64::_rdseed32_step fn">_rdseed32_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `rdseed` only"><code>rdseed</code></span></div><div class="item-right docblock-short"><p>Read a 32-bit NIST SP800-90B and SP800-90C compliant random value and store
in val. Return 1 if a random value was generated, and 0 otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._rdseed64_step.html" title="no_std_compat::arch::x86_64::_rdseed64_step fn">_rdseed64_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `rdseed` only"><code>rdseed</code></span></div><div class="item-right docblock-short"><p>Read a 64-bit NIST SP800-90B and SP800-90C compliant random value and store
in val. Return 1 if a random value was generated, and 0 otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._rdtsc.html" title="no_std_compat::arch::x86_64::_rdtsc fn">_rdtsc</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Reads the current value of the processor’s time-stamp counter.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._subborrow_u32.html" title="no_std_compat::arch::x86_64::_subborrow_u32 fn">_subborrow_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Adds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit carry-in <code>c_in</code>
(carry or overflow flag), and store the unsigned 32-bit result in <code>out</code>, and
the carry-out is returned (carry or overflow flag).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._subborrow_u64.html" title="no_std_compat::arch::x86_64::_subborrow_u64 fn">_subborrow_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>Adds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit carry-in <code>c_in</code>.
(carry or overflow flag), and store the unsigned 64-bit result in <code>out</code>, and
the carry-out is returned (carry or overflow flag).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._t1mskc_u32.html" title="no_std_compat::arch::x86_64::_t1mskc_u32 fn">_t1mskc_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Clears all bits below the least significant zero of <code>x</code> and sets all other
bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._t1mskc_u64.html" title="no_std_compat::arch::x86_64::_t1mskc_u64 fn">_t1mskc_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Clears all bits below the least significant zero of <code>x</code> and sets all other
bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._tzcnt_u32.html" title="no_std_compat::arch::x86_64::_tzcnt_u32 fn">_tzcnt_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Counts the number of trailing least significant zero bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._tzcnt_u64.html" title="no_std_compat::arch::x86_64::_tzcnt_u64 fn">_tzcnt_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span></div><div class="item-right docblock-short"><p>Counts the number of trailing least significant zero bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._tzmsk_u32.html" title="no_std_compat::arch::x86_64::_tzmsk_u32 fn">_tzmsk_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets all bits below the least significant one of <code>x</code> and clears all other
bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._tzmsk_u64.html" title="no_std_compat::arch::x86_64::_tzmsk_u64 fn">_tzmsk_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span></div><div class="item-right docblock-short"><p>Sets all bits below the least significant one of <code>x</code> and clears all other
bits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xgetbv.html" title="no_std_compat::arch::x86_64::_xgetbv fn">_xgetbv</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span></div><div class="item-right docblock-short"><p>Reads the contents of the extended control register <code>XCR</code>
specified in <code>xcr_no</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xrstor.html" title="no_std_compat::arch::x86_64::_xrstor fn">_xrstor</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial restore of the enabled processor states using
the state information stored in memory at <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xrstor64.html" title="no_std_compat::arch::x86_64::_xrstor64 fn">_xrstor64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial restore of the enabled processor states using
the state information stored in memory at <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xrstors.html" title="no_std_compat::arch::x86_64::_xrstors fn">_xrstors</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave,xsaves` only"><code>xsave,xsaves</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial restore of the enabled processor states using the
state information stored in memory at <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xrstors64.html" title="no_std_compat::arch::x86_64::_xrstors64 fn">_xrstors64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave,xsaves` only"><code>xsave,xsaves</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial restore of the enabled processor states using the
state information stored in memory at <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xsave.html" title="no_std_compat::arch::x86_64::_xsave fn">_xsave</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial save of the enabled processor states to memory at
<code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xsave64.html" title="no_std_compat::arch::x86_64::_xsave64 fn">_xsave64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial save of the enabled processor states to memory at
<code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xsavec.html" title="no_std_compat::arch::x86_64::_xsavec fn">_xsavec</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave,xsavec` only"><code>xsave,xsavec</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial save of the enabled processor states to memory
at <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xsavec64.html" title="no_std_compat::arch::x86_64::_xsavec64 fn">_xsavec64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave,xsavec` only"><code>xsave,xsavec</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial save of the enabled processor states to memory
at <code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xsaveopt.html" title="no_std_compat::arch::x86_64::_xsaveopt fn">_xsaveopt</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave,xsaveopt` only"><code>xsave,xsaveopt</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial save of the enabled processor states to memory at
<code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xsaveopt64.html" title="no_std_compat::arch::x86_64::_xsaveopt64 fn">_xsaveopt64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave,xsaveopt` only"><code>xsave,xsaveopt</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial save of the enabled processor states to memory at
<code>mem_addr</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xsaves.html" title="no_std_compat::arch::x86_64::_xsaves fn">_xsaves</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave,xsaves` only"><code>xsave,xsaves</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial save of the enabled processor states to memory at
<code>mem_addr</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xsaves64.html" title="no_std_compat::arch::x86_64::_xsaves64 fn">_xsaves64</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave,xsaves` only"><code>xsave,xsaves</code></span></div><div class="item-right docblock-short"><p>Performs a full or partial save of the enabled processor states to memory at
<code>mem_addr</code></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn._xsetbv.html" title="no_std_compat::arch::x86_64::_xsetbv fn">_xsetbv</a><a title="unsafe function" href="#"><sup>⚠</sup></a><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span></div><div class="item-right docblock-short"><p>Copies 64-bits from <code>val</code> to the extended control register (<code>XCR</code>) specified
by <code>a</code>.</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="type" href="type._MM_CMPINT_ENUM.html" title="no_std_compat::arch::x86_64::_MM_CMPINT_ENUM type">_MM_CMPINT_ENUM</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>The <code>_MM_CMPINT_ENUM</code> type used to specify comparison operations in AVX-512 intrinsics.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="type" href="type._MM_MANTISSA_NORM_ENUM.html" title="no_std_compat::arch::x86_64::_MM_MANTISSA_NORM_ENUM type">_MM_MANTISSA_NORM_ENUM</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>The <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa normalized operations in AVX-512 intrinsics.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="type" href="type._MM_MANTISSA_SIGN_ENUM.html" title="no_std_compat::arch::x86_64::_MM_MANTISSA_SIGN_ENUM type">_MM_MANTISSA_SIGN_ENUM</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>The <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa signed operations in AVX-512 intrinsics.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="type" href="type._MM_PERM_ENUM.html" title="no_std_compat::arch::x86_64::_MM_PERM_ENUM type">_MM_PERM_ENUM</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>The <code>MM_PERM_ENUM</code> type used to specify shuffle operations in AVX-512 intrinsics.</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="type" href="type.__mmask8.html" title="no_std_compat::arch::x86_64::__mmask8 type">__mmask8</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>The <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit integer</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="type" href="type.__mmask16.html" title="no_std_compat::arch::x86_64::__mmask16 type">__mmask16</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>The <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit integer</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="type" href="type.__mmask32.html" title="no_std_compat::arch::x86_64::__mmask32 type">__mmask32</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>The <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit integer</p>
</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="type" href="type.__mmask64.html" title="no_std_compat::arch::x86_64::__mmask64 type">__mmask64</a><span class="stab unstable" title="">Experimental</span></div><div class="item-right docblock-short"><p>The <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit integer</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="no_std_compat" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>