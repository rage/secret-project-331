<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A priority queue implemented with a binary heap."><meta name="keywords" content="rust, rustlang, rust-lang, BinaryHeap"><title>BinaryHeap in no_std_compat::collections::binary_heap - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../no_std_compat/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../no_std_compat/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">BinaryHeap</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.append">append</a></li><li><a href="#method.as_slice">as_slice</a></li><li><a href="#method.capacity">capacity</a></li><li><a href="#method.clear">clear</a></li><li><a href="#method.drain">drain</a></li><li><a href="#method.drain_sorted">drain_sorted</a></li><li><a href="#method.into_iter_sorted">into_iter_sorted</a></li><li><a href="#method.into_sorted_vec">into_sorted_vec</a></li><li><a href="#method.into_vec">into_vec</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.len">len</a></li><li><a href="#method.new">new</a></li><li><a href="#method.peek">peek</a></li><li><a href="#method.peek_mut">peek_mut</a></li><li><a href="#method.pop">pop</a></li><li><a href="#method.push">push</a></li><li><a href="#method.reserve">reserve</a></li><li><a href="#method.reserve_exact">reserve_exact</a></li><li><a href="#method.retain">retain</a></li><li><a href="#method.shrink_to">shrink_to</a></li><li><a href="#method.shrink_to_fit">shrink_to_fit</a></li><li><a href="#method.try_reserve">try_reserve</a></li><li><a href="#method.try_reserve_exact">try_reserve_exact</a></li><li><a href="#method.with_capacity">with_capacity</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone">Clone</a></li><li><a href="#impl-Debug">Debug</a></li><li><a href="#impl-Default">Default</a></li><li><a href="#impl-Extend%3C%26%27a%20T%3E">Extend&lt;&amp;&#39;a T&gt;</a></li><li><a href="#impl-Extend%3CT%3E">Extend&lt;T&gt;</a></li><li><a href="#impl-From%3C%5BT%3B%20N%5D%3E">From&lt;[T; N]&gt;</a></li><li><a href="#impl-From%3CBinaryHeap%3CT%3E%3E">From&lt;BinaryHeap&lt;T&gt;&gt;</a></li><li><a href="#impl-From%3CVec%3CT%2C%20Global%3E%3E">From&lt;Vec&lt;T, Global&gt;&gt;</a></li><li><a href="#impl-FromIterator%3CT%3E">FromIterator&lt;T&gt;</a></li><li><a href="#impl-IntoIterator">IntoIterator</a></li><li><a href="#impl-IntoIterator-1">IntoIterator</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Sync">Sync</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In no_std_compat::collections::binary_heap</a></h2><div id="sidebar-vars" data-name="BinaryHeap" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../no_std_compat/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="../../index.html">no_std_compat</a>::<wbr><a href="../index.html">collections</a>::<wbr><a href="index.html">binary_heap</a>::<wbr><a class="struct" href="#">BinaryHeap</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#264-266">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct BinaryHeap&lt;T&gt; { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A priority queue implemented with a binary heap.</p>
<p>This will be a max-heap.</p>
<p>It is a logic error for an item to be modified in such a way that the
item’s ordering relative to any other item, as determined by the <a href="../../cmp/trait.Ord.html"><code>Ord</code></a>
trait, changes while it is in the heap. This is normally only possible
through <a href="../../cell/struct.Cell.html"><code>Cell</code></a>, <a href="../../cell/struct.RefCell.html"><code>RefCell</code></a>, global state, I/O, or unsafe code. The
behavior resulting from such a logic error is not specified (it
could include panics, incorrect results, aborts, memory leaks, or
non-termination) but will not be undefined behavior.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;

<span class="comment">// Type inference lets us omit an explicit type signature (which</span>
<span class="comment">// would be `BinaryHeap&lt;i32&gt;` in this example).</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();

<span class="comment">// We can use peek to look at the next item in the heap. In this case,</span>
<span class="comment">// there&#39;s no items in there yet so we get None.</span>
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">peek</span>(), <span class="prelude-val">None</span>);

<span class="comment">// Let&#39;s add some scores...</span>
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">5</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">2</span>);

<span class="comment">// Now peek shows the most important item in the heap.</span>
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">peek</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));

<span class="comment">// We can check the length of a heap.</span>
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">len</span>(), <span class="number">3</span>);

<span class="comment">// We can iterate over the items in the heap, although they are returned in</span>
<span class="comment">// a random order.</span>
<span class="kw">for</span> <span class="ident">x</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">heap</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{x}&quot;</span>);
}

<span class="comment">// If we instead pop these scores, they should come back in order.</span>
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">None</span>);

<span class="comment">// We can clear the heap of any remaining items.</span>
<span class="ident">heap</span>.<span class="ident">clear</span>();

<span class="comment">// The heap should now be empty.</span>
<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">is_empty</span>())</code></pre></div>
<p>A <code>BinaryHeap</code> with a known list of items can be initialized from an array:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;

<span class="kw">let</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>]);</code></pre></div>
<h3 id="min-heap"><a href="#min-heap">Min-heap</a></h3>
<p>Either <a href="../../cmp/struct.Reverse.html"><code>core::cmp::Reverse</code></a> or a custom <a href="../../cmp/trait.Ord.html"><code>Ord</code></a> implementation can be used to
make <code>BinaryHeap</code> a min-heap. This makes <code>heap.pop()</code> return the smallest
value instead of the greatest one.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">use</span> <span class="ident">std::cmp::Reverse</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();

<span class="comment">// Wrap values in `Reverse`</span>
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="ident">Reverse</span>(<span class="number">1</span>));
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="ident">Reverse</span>(<span class="number">5</span>));
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="ident">Reverse</span>(<span class="number">2</span>));

<span class="comment">// If we pop these scores now, they should come back in the reverse order.</span>
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="ident">Reverse</span>(<span class="number">1</span>)));
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="ident">Reverse</span>(<span class="number">2</span>)));
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="ident">Reverse</span>(<span class="number">5</span>)));
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">None</span>);</code></pre></div>
<h2 id="time-complexity"><a href="#time-complexity">Time complexity</a></h2><div><table><thead><tr><th><a href="../struct.BinaryHeap.html#method.push">push</a></th><th><a href="../struct.BinaryHeap.html#method.pop">pop</a></th><th><a href="../struct.BinaryHeap.html#method.peek">peek</a>/<a href="../struct.BinaryHeap.html#method.peek_mut">peek_mut</a></th></tr></thead><tbody>
<tr><td><em>O</em>(1)~</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(1)</td></tr>
</tbody></table>
</div>
<p>The value for <code>push</code> is an expected cost; the method documentation gives a
more detailed analysis.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#355-817">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../cmp/trait.Ord.html" title="trait no_std_compat::cmp::Ord">Ord</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#369">source</a></span><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>() -&gt; <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates an empty <code>BinaryHeap</code> as a max-heap.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">4</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.with_capacity" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#389">source</a></span><a href="#method.with_capacity" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.with_capacity" class="fnname">with_capacity</a>(capacity: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates an empty <code>BinaryHeap</code> with a specific capacity.
This preallocates enough memory for <code>capacity</code> elements,
so that the <code>BinaryHeap</code> does not have to be reallocated
until it contains at least that many values.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::with_capacity</span>(<span class="number">10</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">4</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.peek_mut" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#423">source</a></span><a href="#method.peek_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.peek_mut" class="fnname">peek_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../option/enum.Option.html" title="enum no_std_compat::option::Option">Option</a>&lt;<a class="struct" href="struct.PeekMut.html" title="struct no_std_compat::collections::binary_heap::PeekMut">PeekMut</a>&lt;'_, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable reference to the greatest item in the binary heap, or
<code>None</code> if it is empty.</p>
<p>Note: If the <code>PeekMut</code> value is leaked, the heap may be in an
inconsistent state.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();
<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">peek_mut</span>().<span class="ident">is_none</span>());

<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">5</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">2</span>);
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">heap</span>.<span class="ident">peek_mut</span>().<span class="ident">unwrap</span>();
    <span class="kw-2">*</span><span class="ident">val</span> <span class="op">=</span> <span class="number">0</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">peek</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));</code></pre></div>
<h5 id="time-complexity-1"><a href="#time-complexity-1">Time complexity</a></h5>
<p>If the item is modified then the worst case time complexity is <em>O</em>(log(<em>n</em>)),
otherwise it’s <em>O</em>(1).</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pop" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#447">source</a></span><a href="#method.pop" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.pop" class="fnname">pop</a>(&amp;mut self) -&gt; <a class="enum" href="../../option/enum.Option.html" title="enum no_std_compat::option::Option">Option</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Removes the greatest item from the binary heap and returns it, or <code>None</code> if it
is empty.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">pop</span>(), <span class="prelude-val">None</span>);</code></pre></div>
<h5 id="time-complexity-2"><a href="#time-complexity-2">Time complexity</a></h5>
<p>The worst case cost of <code>pop</code> on a heap containing <em>n</em> elements is <em>O</em>(log(<em>n</em>)).</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.push" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#491">source</a></span><a href="#method.push" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.push" class="fnname">push</a>(&amp;mut self, item: T)</h4></section></summary><div class="docblock"><p>Pushes an item onto the binary heap.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">3</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">5</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">1</span>);

<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">len</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">peek</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));</code></pre></div>
<h5 id="time-complexity-3"><a href="#time-complexity-3">Time complexity</a></h5>
<p>The expected cost of <code>push</code>, averaged over every possible ordering of
the elements being pushed, and over a sufficiently large number of
pushes, is <em>O</em>(1). This is the most meaningful cost metric when pushing
elements that are <em>not</em> already in any sorted pattern.</p>
<p>The time complexity degrades if elements are pushed in predominantly
ascending order. In the worst case, elements are pushed in ascending
sorted order and the amortized cost per push is <em>O</em>(log(<em>n</em>)) against a heap
containing <em>n</em> elements.</p>
<p>The worst case cost of a <em>single</em> call to <code>push</code> is <em>O</em>(<em>n</em>). The worst case
occurs when capacity is exhausted and needs a resize. The resize cost
has been amortized in the previous figures.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_sorted_vec" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#518">source</a></span><a href="#method.into_sorted_vec" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_sorted_vec" class="fnname">into_sorted_vec</a>(self) -&gt; <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../../alloc/struct.Global.html" title="struct no_std_compat::alloc::Global">Global</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u8.html">u8</a>, A&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;A&gt; <a class="trait" href="../../io/trait.Write.html" title="trait no_std_compat::io::Write">Write</a> for <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u8.html">u8</a>, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../alloc/trait.Allocator.html" title="trait no_std_compat::alloc::Allocator">Allocator</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Consumes the <code>BinaryHeap</code> and returns a vector in sorted
(ascending) order.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>]);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">6</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">3</span>);

<span class="kw">let</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">heap</span>.<span class="ident">into_sorted_vec</span>();
<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.append" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.11.0">1.11.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#737">source</a></span><a href="#method.append" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.append" class="fnname">append</a>(&amp;mut self, other: &amp;mut <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;)</h4></section></summary><div class="docblock"><p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="op">-</span><span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="op">-</span><span class="number">20</span>, <span class="number">5</span>, <span class="number">43</span>]);

<span class="ident">a</span>.<span class="ident">append</span>(<span class="kw-2">&amp;mut</span> <span class="ident">b</span>);

<span class="macro">assert_eq!</span>(<span class="ident">a</span>.<span class="ident">into_sorted_vec</span>(), [<span class="op">-</span><span class="number">20</span>, <span class="op">-</span><span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">43</span>]);
<span class="macro">assert!</span>(<span class="ident">b</span>.<span class="ident">is_empty</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.drain_sorted" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#776">source</a></span><a href="#method.drain_sorted" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.drain_sorted" class="fnname">drain_sorted</a>(&amp;mut self) -&gt; <a class="struct" href="struct.DrainSorted.html" title="struct no_std_compat::collections::binary_heap::DrainSorted">DrainSorted</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.DrainSorted.html" title="struct no_std_compat::collections::binary_heap::DrainSorted">DrainSorted</a>&lt;'_, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'_, T&gt; <a class="trait" href="../../iter/trait.Iterator.html" title="trait no_std_compat::iter::Iterator">Iterator</a> for <a class="struct" href="struct.DrainSorted.html" title="struct no_std_compat::collections::binary_heap::DrainSorted">DrainSorted</a>&lt;'_, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../cmp/trait.Ord.html" title="trait no_std_compat::cmp::Ord">Ord</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="../../iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = T;</span></code></span></span></span></span></h4></section><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>binary_heap_drain_sorted</code>)</div></div></summary><div class="docblock"><p>Clears the binary heap, returning an iterator over the removed elements
in heap order. If the iterator is dropped before being fully consumed,
it drops the remaining elements in heap order.</p>
<p>The returned iterator keeps a mutable borrow on the heap to optimize
its implementation.</p>
<p>Note:</p>
<ul>
<li><code>.drain_sorted()</code> is <em>O</em>(<em>n</em> * log(<em>n</em>)); much slower than <code>.drain()</code>.
You should use the latter for most cases.</li>
</ul>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">binary_heap_drain_sorted</span>)]</span>
<span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">len</span>(), <span class="number">5</span>);

<span class="ident">drop</span>(<span class="ident">heap</span>.<span class="ident">drain_sorted</span>()); <span class="comment">// removes all elements in heap order</span>
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">len</span>(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.retain" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#800-802">source</a></span><a href="#method.retain" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.retain" class="fnname">retain</a>&lt;F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../ops/trait.FnMut.html" title="trait no_std_compat::ops::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>binary_heap_retain</code>)</div></div></summary><div class="docblock"><p>Retains only the elements specified by the predicate.</p>
<p>In other words, remove all elements <code>e</code> for which <code>f(&amp;e)</code> returns
<code>false</code>. The elements are visited in unsorted (and unspecified) order.</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">binary_heap_retain</span>)]</span>
<span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="op">-</span><span class="number">10</span>, <span class="op">-</span><span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">13</span>]);

<span class="ident">heap</span>.<span class="ident">retain</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span> <span class="op">%</span> <span class="number">2</span> <span class="op">==</span> <span class="number">0</span>); <span class="comment">// only keep even numbers</span>

<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">into_sorted_vec</span>(), [<span class="op">-</span><span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>])</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#819-1213">source</a></span><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#837">source</a></span><a href="#method.iter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="struct.Iter.html" title="struct no_std_compat::collections::binary_heap::Iter">Iter</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Iter.html" title="struct no_std_compat::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="../../iter/trait.Iterator.html" title="trait no_std_compat::iter::Iterator">Iterator</a> for <a class="struct" href="struct.Iter.html" title="struct no_std_compat::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</span><span class="where fmt-newline">    type <a href="../../iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;'a </a>T;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator visiting all values in the underlying vector, in
arbitrary order.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);

<span class="comment">// Print 1, 2, 3, 4 in arbitrary order</span>
<span class="kw">for</span> <span class="ident">x</span> <span class="kw">in</span> <span class="ident">heap</span>.<span class="ident">iter</span>() {
    <span class="macro">println!</span>(<span class="string">&quot;{x}&quot;</span>);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter_sorted" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#856">source</a></span><a href="#method.into_iter_sorted" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_iter_sorted" class="fnname">into_iter_sorted</a>(self) -&gt; <a class="struct" href="struct.IntoIterSorted.html" title="struct no_std_compat::collections::binary_heap::IntoIterSorted">IntoIterSorted</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.IntoIterSorted.html" title="struct no_std_compat::collections::binary_heap::IntoIterSorted">IntoIterSorted</a>&lt;T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T&gt; <a class="trait" href="../../iter/trait.Iterator.html" title="trait no_std_compat::iter::Iterator">Iterator</a> for <a class="struct" href="struct.IntoIterSorted.html" title="struct no_std_compat::collections::binary_heap::IntoIterSorted">IntoIterSorted</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../cmp/trait.Ord.html" title="trait no_std_compat::cmp::Ord">Ord</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="../../iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = T;</span></code></span></span></span></span></h4></section><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>binary_heap_into_iter_sorted</code>)</div></div></summary><div class="docblock"><p>Returns an iterator which retrieves elements in heap order.
This method consumes the original heap.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">binary_heap_into_iter_sorted</span>)]</span>
<span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">into_iter_sorted</span>().<span class="ident">take</span>(<span class="number">2</span>).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">5</span>, <span class="number">4</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.peek" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#883">source</a></span><a href="#method.peek" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.peek" class="fnname">peek</a>(&amp;self) -&gt; <a class="enum" href="../../option/enum.Option.html" title="enum no_std_compat::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>T&gt;</h4></section></summary><div class="docblock"><p>Returns the greatest item in the binary heap, or <code>None</code> if it is empty.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">peek</span>(), <span class="prelude-val">None</span>);

<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">5</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">peek</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));
</code></pre></div>
<h5 id="time-complexity-4"><a href="#time-complexity-4">Time complexity</a></h5>
<p>Cost is <em>O</em>(1) in the worst case.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.capacity" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#901">source</a></span><a href="#method.capacity" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.capacity" class="fnname">capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of elements the binary heap can hold without reallocating.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::with_capacity</span>(<span class="number">100</span>);
<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">100</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">4</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reserve_exact" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#930">source</a></span><a href="#method.reserve_exact" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.reserve_exact" class="fnname">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves the minimum capacity for exactly <code>additional</code> more elements to be inserted in the
given <code>BinaryHeap</code>. Does nothing if the capacity is already sufficient.</p>
<p>Note that the allocator may give the collection more space than it requests. Therefore
capacity can not be relied upon to be precisely minimal. Prefer <a href="../struct.BinaryHeap.html#method.reserve"><code>reserve</code></a> if future
insertions are expected.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>Panics if the new capacity overflows <code>usize</code>.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();
<span class="ident">heap</span>.<span class="ident">reserve_exact</span>(<span class="number">100</span>);
<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">100</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">4</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reserve" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#953">source</a></span><a href="#method.reserve" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.reserve" class="fnname">reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves capacity for at least <code>additional</code> more elements to be inserted in the
<code>BinaryHeap</code>. The collection may reserve more space to avoid frequent reallocations.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>Panics if the new capacity overflows <code>usize</code>.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();
<span class="ident">heap</span>.<span class="ident">reserve</span>(<span class="number">100</span>);
<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">100</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">4</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_reserve_exact" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#995">source</a></span><a href="#method.try_reserve_exact" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.try_reserve_exact" class="fnname">try_reserve_exact</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;additional: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a><br>) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum no_std_compat::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.TryReserveError.html" title="struct no_std_compat::collections::TryReserveError">TryReserveError</a>&gt;</h4></section><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>try_reserve_2</code>)</div></div></summary><div class="docblock"><p>Tries to reserve the minimum capacity for exactly <code>additional</code>
elements to be inserted in the given <code>BinaryHeap&lt;T&gt;</code>. After calling
<code>try_reserve_exact</code>, capacity will be greater than or equal to
<code>self.len() + additional</code> if it returns <code>Ok(())</code>.
Does nothing if the capacity is already sufficient.</p>
<p>Note that the allocator may give the collection more space than it
requests. Therefore, capacity can not be relied upon to be precisely
minimal. Prefer <a href="../struct.BinaryHeap.html#method.try_reserve"><code>try_reserve</code></a> if future insertions are expected.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>If the capacity overflows, or the allocator reports a failure, then an error
is returned.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">try_reserve_2</span>)]</span>
<span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">use</span> <span class="ident">std::collections::TryReserveError</span>;

<span class="kw">fn</span> <span class="ident">find_max_slow</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u32</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>, <span class="ident">TryReserveError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();

    <span class="comment">// Pre-reserve the memory, exiting if we can&#39;t</span>
    <span class="ident">heap</span>.<span class="ident">try_reserve_exact</span>(<span class="ident">data</span>.<span class="ident">len</span>())<span class="question-mark">?</span>;

    <span class="comment">// Now we know this can&#39;t OOM in the middle of our complex work</span>
    <span class="ident">heap</span>.<span class="ident">extend</span>(<span class="ident">data</span>.<span class="ident">iter</span>());

    <span class="prelude-val">Ok</span>(<span class="ident">heap</span>.<span class="ident">pop</span>())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_reserve" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1031">source</a></span><a href="#method.try_reserve" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.try_reserve" class="fnname">try_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum no_std_compat::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.TryReserveError.html" title="struct no_std_compat::collections::TryReserveError">TryReserveError</a>&gt;</h4></section><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>try_reserve_2</code>)</div></div></summary><div class="docblock"><p>Tries to reserve capacity for at least <code>additional</code> more elements to be inserted
in the given <code>BinaryHeap&lt;T&gt;</code>. The collection may reserve more space to avoid
frequent reallocations. After calling <code>try_reserve</code>, capacity will be
greater than or equal to <code>self.len() + additional</code>. Does nothing if
capacity is already sufficient.</p>
<h5 id="errors-1"><a href="#errors-1">Errors</a></h5>
<p>If the capacity overflows, or the allocator reports a failure, then an error
is returned.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">try_reserve_2</span>)]</span>
<span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">use</span> <span class="ident">std::collections::TryReserveError</span>;

<span class="kw">fn</span> <span class="ident">find_max_slow</span>(<span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u32</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>, <span class="ident">TryReserveError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();

    <span class="comment">// Pre-reserve the memory, exiting if we can&#39;t</span>
    <span class="ident">heap</span>.<span class="ident">try_reserve</span>(<span class="ident">data</span>.<span class="ident">len</span>())<span class="question-mark">?</span>;

    <span class="comment">// Now we know this can&#39;t OOM in the middle of our complex work</span>
    <span class="ident">heap</span>.<span class="ident">extend</span>(<span class="ident">data</span>.<span class="ident">iter</span>());

    <span class="prelude-val">Ok</span>(<span class="ident">heap</span>.<span class="ident">pop</span>())
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shrink_to_fit" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1050">source</a></span><a href="#method.shrink_to_fit" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.shrink_to_fit" class="fnname">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Discards as much additional capacity as possible.</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span>: <span class="ident">BinaryHeap</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BinaryHeap::with_capacity</span>(<span class="number">100</span>);

<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">100</span>);
<span class="ident">heap</span>.<span class="ident">shrink_to_fit</span>();
<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">capacity</span>() <span class="op">==</span> <span class="number">0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shrink_to" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.56.0">1.56.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1073">source</a></span><a href="#method.shrink_to" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.shrink_to" class="fnname">shrink_to</a>(&amp;mut self, min_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Discards capacity with a lower bound.</p>
<p>The capacity will remain at least as large as both the length
and the supplied value.</p>
<p>If the current capacity is less than the lower limit, this is a no-op.</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span>: <span class="ident">BinaryHeap</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BinaryHeap::with_capacity</span>(<span class="number">100</span>);

<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">100</span>);
<span class="ident">heap</span>.<span class="ident">shrink_to</span>(<span class="number">10</span>);
<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">10</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1095">source</a></span><a href="#method.as_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_slice" class="fnname">as_slice</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.slice.html">&amp;[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.slice.html">]</a></span><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="../../io/trait.Read.html" title="trait no_std_compat::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="../../io/trait.Write.html" title="trait no_std_compat::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.slice.html">]</a></span></code></span></span></span></span></h4></section><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>binary_heap_as_slice</code>)</div></div></summary><div class="docblock"><p>Returns a slice of all values in the underlying vector, in arbitrary
order.</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">feature</span>(<span class="ident">binary_heap_as_slice</span>)]</span>
<span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">use</span> <span class="ident">std::io</span>::{<span class="self">self</span>, <span class="ident">Write</span>};

<span class="kw">let</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);

<span class="ident">io::sink</span>().<span class="ident">write</span>(<span class="ident">heap</span>.<span class="ident">as_slice</span>()).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_vec" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1118">source</a></span><a href="#method.into_vec" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_vec" class="fnname">into_vec</a>(self) -&gt; <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../../alloc/struct.Global.html" title="struct no_std_compat::alloc::Global">Global</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u8.html">u8</a>, A&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;A&gt; <a class="trait" href="../../io/trait.Write.html" title="trait no_std_compat::io::Write">Write</a> for <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u8.html">u8</a>, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../alloc/trait.Allocator.html" title="trait no_std_compat::alloc::Allocator">Allocator</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Consumes the <code>BinaryHeap</code> and returns the underlying vector
in arbitrary order.</p>
<h5 id="examples-21"><a href="#examples-21">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);
<span class="kw">let</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">heap</span>.<span class="ident">into_vec</span>();

<span class="comment">// Will print in some order</span>
<span class="kw">for</span> <span class="ident">x</span> <span class="kw">in</span> <span class="ident">vec</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{x}&quot;</span>);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.len" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1136">source</a></span><a href="#method.len" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of the binary heap.</p>
<h5 id="examples-22"><a href="#examples-22">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert_eq!</span>(<span class="ident">heap</span>.<span class="ident">len</span>(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_empty" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1160">source</a></span><a href="#method.is_empty" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the binary heap is empty.</p>
<h5 id="examples-23"><a href="#examples-23">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::new</span>();

<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">is_empty</span>());

<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">3</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">5</span>);
<span class="ident">heap</span>.<span class="ident">push</span>(<span class="number">1</span>);

<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">heap</span>.<span class="ident">is_empty</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.drain" class="method has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1189">source</a></span><a href="#method.drain" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.drain" class="fnname">drain</a>(&amp;mut self) -&gt; <a class="struct" href="struct.Drain.html" title="struct no_std_compat::collections::binary_heap::Drain">Drain</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Drain.html" title="struct no_std_compat::collections::binary_heap::Drain">Drain</a>&lt;'_, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'_, T&gt; <a class="trait" href="../../iter/trait.Iterator.html" title="trait no_std_compat::iter::Iterator">Iterator</a> for <a class="struct" href="struct.Drain.html" title="struct no_std_compat::collections::binary_heap::Drain">Drain</a>&lt;'_, T&gt;</span><span class="where fmt-newline">    type <a href="../../iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = T;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Clears the binary heap, returning an iterator over the removed elements
in arbitrary order. If the iterator is dropped before being fully
consumed, it drops the remaining elements in arbitrary order.</p>
<p>The returned iterator keeps a mutable borrow on the heap to optimize
its implementation.</p>
<h5 id="examples-24"><a href="#examples-24">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">heap</span>.<span class="ident">is_empty</span>());

<span class="kw">for</span> <span class="ident">x</span> <span class="kw">in</span> <span class="ident">heap</span>.<span class="ident">drain</span>() {
    <span class="macro">println!</span>(<span class="string">&quot;{x}&quot;</span>);
}

<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">is_empty</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clear" class="method has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1210">source</a></span><a href="#method.clear" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.clear" class="fnname">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Drops all items from the binary heap.</p>
<h5 id="examples-25"><a href="#examples-25">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">heap</span>.<span class="ident">is_empty</span>());

<span class="ident">heap</span>.<span class="ident">clear</span>();

<span class="macro">assert!</span>(<span class="ident">heap</span>.<span class="ident">is_empty</span>());</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#329-337">source</a></span><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../clone/trait.Clone.html" title="trait no_std_compat::clone::Clone">Clone</a> for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../clone/trait.Clone.html" title="trait no_std_compat::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#330">source</a></span><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="../../clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class='docblock'><p>Returns a copy of the value. <a href="../../clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#334">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="../../clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: &amp;<a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;)</h4></section></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="../../clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#349-353">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../fmt/trait.Debug.html" title="trait no_std_compat::fmt::Debug">Debug</a> for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../fmt/trait.Debug.html" title="trait no_std_compat::fmt::Debug">Debug</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#350">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="../../fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../fmt/struct.Formatter.html" title="struct no_std_compat::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum no_std_compat::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.unit.html">()</a>, <a class="struct" href="../../fmt/struct.Error.html" title="struct no_std_compat::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="../../fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#340-346">source</a></span><a href="#impl-Default" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../default/trait.Default.html" title="trait no_std_compat::default::Default">Default</a> for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../cmp/trait.Ord.html" title="trait no_std_compat::cmp::Ord">Ord</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#343">source</a></span><a href="#method.default" class="anchor"></a><h4 class="code-header">fn <a href="../../default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates an empty <code>BinaryHeap&lt;T&gt;</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Extend%3C%26%27a%20T%3E" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1697-1711">source</a></span><a href="#impl-Extend%3C%26%27a%20T%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T&gt; <a class="trait" href="../../iter/trait.Extend.html" title="trait no_std_compat::iter::Extend">Extend</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;'a </a>T&gt; for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../cmp/trait.Ord.html" title="trait no_std_compat::cmp::Ord">Ord</a> + <a class="trait" href="../../marker/trait.Copy.html" title="trait no_std_compat::marker::Copy">Copy</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1698">source</a></span><a href="#method.extend-1" class="anchor"></a><h4 class="code-header">fn <a href="../../iter/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../iter/trait.IntoIterator.html" title="trait no_std_compat::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;'a </a>T&gt;,&nbsp;</span></h4></section></summary><div class='docblock'><p>Extends a collection with the contents of an iterator. <a href="../../iter/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_one-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1703">source</a></span><a href="#method.extend_one-1" class="anchor"></a><h4 class="code-header">fn <a href="../../iter/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;'a </a>T)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>)</div></div><div class='docblock'><p>Extends a collection with exactly one element.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_reserve-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1708">source</a></span><a href="#method.extend_reserve-1" class="anchor"></a><h4 class="code-header">fn <a href="../../iter/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>)</div></div><div class='docblock'><p>Reserves capacity in a collection for the given number of additional elements. <a href="../../iter/trait.Extend.html#method.extend_reserve">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Extend%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1648-1663">source</a></span><a href="#impl-Extend%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../iter/trait.Extend.html" title="trait no_std_compat::iter::Extend">Extend</a>&lt;T&gt; for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../cmp/trait.Ord.html" title="trait no_std_compat::cmp::Ord">Ord</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1650">source</a></span><a href="#method.extend" class="anchor"></a><h4 class="code-header">fn <a href="../../iter/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../iter/trait.IntoIterator.html" title="trait no_std_compat::iter::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,&nbsp;</span></h4></section></summary><div class='docblock'><p>Extends a collection with the contents of an iterator. <a href="../../iter/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_one" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1655">source</a></span><a href="#method.extend_one" class="anchor"></a><h4 class="code-header">fn <a href="../../iter/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: T)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>)</div></div><div class='docblock'><p>Extends a collection with exactly one element.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_reserve" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1660">source</a></span><a href="#method.extend_reserve" class="anchor"></a><h4 class="code-header">fn <a href="../../iter/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>)</div></div><div class='docblock'><p>Reserves capacity in a collection for the given number of additional elements. <a href="../../iter/trait.Extend.html#method.extend_reserve">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%5BT%3B%20N%5D%3E" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.56.0">1.56.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1576-1589">source</a></span><a href="#impl-From%3C%5BT%3B%20N%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, const N:&nbsp;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="../../convert/trait.From.html" title="trait no_std_compat::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.array.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.array.html">; N]</a>&gt; for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../cmp/trait.Ord.html" title="trait no_std_compat::cmp::Ord">Ord</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1586">source</a></span><a href="#method.from-2" class="anchor"></a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fnname">from</a>(arr: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.array.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.array.html">; N]</a>) -&gt; <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class="docblock">
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">h1</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">h2</span>: <span class="ident">BinaryHeap</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="ident">into</span>();
<span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">a</span>, <span class="ident">b</span>)) <span class="op">=</span> <span class="ident">h1</span>.<span class="ident">pop</span>().<span class="ident">zip</span>(<span class="ident">h2</span>.<span class="ident">pop</span>()) {
    <span class="macro">assert_eq!</span>(<span class="ident">a</span>, <span class="ident">b</span>);
}</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBinaryHeap%3CT%3E%3E" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1592-1600">source</a></span><a href="#impl-From%3CBinaryHeap%3CT%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait no_std_compat::convert::From">From</a>&lt;<a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;&gt; for <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../../alloc/struct.Global.html" title="struct no_std_compat::alloc::Global">Global</a>&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1597">source</a></span><a href="#method.from-1" class="anchor"></a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fnname">from</a>(heap: <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;) -&gt; <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../../alloc/struct.Global.html" title="struct no_std_compat::alloc::Global">Global</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u8.html">u8</a>, A&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;A&gt; <a class="trait" href="../../io/trait.Write.html" title="trait no_std_compat::io::Write">Write</a> for <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.u8.html">u8</a>, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../../alloc/trait.Allocator.html" title="trait no_std_compat::alloc::Allocator">Allocator</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Converts a <code>BinaryHeap&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.</p>
<p>This conversion requires no data movement or allocation, and has
constant time complexity.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CVec%3CT%2C%20Global%3E%3E" class="impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1564-1573">source</a></span><a href="#impl-From%3CVec%3CT%2C%20Global%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait no_std_compat::convert::From">From</a>&lt;<a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../../alloc/struct.Global.html" title="struct no_std_compat::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../cmp/trait.Ord.html" title="trait no_std_compat::cmp::Ord">Ord</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1568">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fnname">from</a>(vec: <a class="struct" href="../../vec/struct.Vec.html" title="struct no_std_compat::vec::Vec">Vec</a>&lt;T, <a class="struct" href="../../alloc/struct.Global.html" title="struct no_std_compat::alloc::Global">Global</a>&gt;) -&gt; <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Converts a <code>Vec&lt;T&gt;</code> into a <code>BinaryHeap&lt;T&gt;</code>.</p>
<p>This conversion happens in-place, and has <em>O</em>(<em>n</em>) time complexity.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1603-1607">source</a></span><a href="#impl-FromIterator%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../iter/trait.FromIterator.html" title="trait no_std_compat::iter::FromIterator">FromIterator</a>&lt;T&gt; for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../cmp/trait.Ord.html" title="trait no_std_compat::cmp::Ord">Ord</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1604">source</a></span><a href="#method.from_iter" class="anchor"></a><h4 class="code-header">fn <a href="../../iter/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../iter/trait.IntoIterator.html" title="trait no_std_compat::iter::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,&nbsp;</span></h4></section></summary><div class='docblock'><p>Creates a value from an iterator. <a href="../../iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1638-1645">source</a></span><a href="#impl-IntoIterator" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T&gt; <a class="trait" href="../../iter/trait.IntoIterator.html" title="trait no_std_compat::iter::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item" class="type trait-impl has-srclink"><a href="#associatedtype.Item" class="anchor"></a><h4 class="code-header">type <a href="../../iter/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;'a </a>T</h4></section></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter" class="type trait-impl has-srclink"><a href="#associatedtype.IntoIter" class="anchor"></a><h4 class="code-header">type <a href="../../iter/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.Iter.html" title="struct no_std_compat::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</h4></section></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1642">source</a></span><a href="#method.into_iter" class="anchor"></a><h4 class="code-header">fn <a href="../../iter/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="struct.Iter.html" title="struct no_std_compat::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Iter.html" title="struct no_std_compat::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="../../iter/trait.Iterator.html" title="trait no_std_compat::iter::Iterator">Iterator</a> for <a class="struct" href="struct.Iter.html" title="struct no_std_compat::collections::binary_heap::Iter">Iter</a>&lt;'a, T&gt;</span><span class="where fmt-newline">    type <a href="../../iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;'a </a>T;</span></code></span></span></span></span></h4></section></summary><div class='docblock'><p>Creates an iterator from a value. <a href="../../iter/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1610-1635">source</a></span><a href="#impl-IntoIterator-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../iter/trait.IntoIterator.html" title="trait no_std_compat::iter::IntoIterator">IntoIterator</a> for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/collections/binary_heap.rs.html#1632">source</a></span><a href="#method.into_iter-1" class="anchor"></a><h4 class="code-header">fn <a href="../../iter/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="struct.IntoIter.html" title="struct no_std_compat::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.IntoIter.html" title="struct no_std_compat::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T&gt; <a class="trait" href="../../iter/trait.Iterator.html" title="trait no_std_compat::iter::Iterator">Iterator</a> for <a class="struct" href="struct.IntoIter.html" title="struct no_std_compat::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt;</span><span class="where fmt-newline">    type <a href="../../iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = T;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Creates a consuming iterator, that is, one that moves each value out of
the binary heap in arbitrary order. The binary heap cannot be used
after calling this.</p>
<h5 id="examples-26"><a href="#examples-26">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::collections::BinaryHeap</span>;
<span class="kw">let</span> <span class="ident">heap</span> <span class="op">=</span> <span class="ident">BinaryHeap::from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);

<span class="comment">// Print 1, 2, 3, 4 in arbitrary order</span>
<span class="kw">for</span> <span class="ident">x</span> <span class="kw">in</span> <span class="ident">heap</span>.<span class="ident">into_iter</span>() {
    <span class="comment">// x has type i32, not &amp;i32</span>
    <span class="macro">println!</span>(<span class="string">&quot;{x}&quot;</span>);
}</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item-1" class="type trait-impl has-srclink"><a href="#associatedtype.Item-1" class="anchor"></a><h4 class="code-header">type <a href="../../iter/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = T</h4></section></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter-1" class="type trait-impl has-srclink"><a href="#associatedtype.IntoIter-1" class="anchor"></a><h4 class="code-header">type <a href="../../iter/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IntoIter.html" title="struct no_std_compat::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt;</h4></section></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../panic/trait.RefUnwindSafe.html" title="trait no_std_compat::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../panic/trait.RefUnwindSafe.html" title="trait no_std_compat::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></section><section id="impl-Send" class="impl has-srclink"><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../marker/trait.Send.html" title="trait no_std_compat::marker::Send">Send</a> for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../marker/trait.Send.html" title="trait no_std_compat::marker::Send">Send</a>,&nbsp;</span></h3></section><section id="impl-Sync" class="impl has-srclink"><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../marker/trait.Sync.html" title="trait no_std_compat::marker::Sync">Sync</a> for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../marker/trait.Sync.html" title="trait no_std_compat::marker::Sync">Sync</a>,&nbsp;</span></h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../marker/trait.Unpin.html" title="trait no_std_compat::marker::Unpin">Unpin</a> for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../marker/trait.Unpin.html" title="trait no_std_compat::marker::Unpin">Unpin</a>,&nbsp;</span></h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../panic/trait.UnwindSafe.html" title="trait no_std_compat::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../struct.BinaryHeap.html" title="struct no_std_compat::collections::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../panic/trait.UnwindSafe.html" title="trait no_std_compat::panic::UnwindSafe">UnwindSafe</a>,&nbsp;</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/any.rs.html#132-136">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../any/trait.Any.html" title="trait no_std_compat::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="../../marker/trait.Sized.html" title="trait no_std_compat::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/any.rs.html#133">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="../../any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../any/struct.TypeId.html" title="struct no_std_compat::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.Borrow.html" title="trait no_std_compat::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait no_std_compat::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="../../borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="../../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.BorrowMut.html" title="trait no_std_compat::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait no_std_compat::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#557-562">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait no_std_compat::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#559">source</a></span><a href="#method.from-3" class="anchor"></a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#541-552">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.Into.html" title="trait no_std_compat::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../convert/trait.From.html" title="trait no_std_compat::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#549">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="../../convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../../convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/borrow.rs.html#84-96">source</a></span><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.ToOwned.html" title="trait no_std_compat::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../clone/trait.Clone.html" title="trait no_std_compat::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="../../borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/borrow.rs.html#89">source</a></span><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="../../borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="../../borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/alloc/borrow.rs.html#93">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="../../borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="../../borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#598-607">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryFrom.html" title="trait no_std_compat::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../convert/trait.Into.html" title="trait no_std_compat::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="../../convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../../convert/enum.Infallible.html" title="enum no_std_compat::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#604">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="../../convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum no_std_compat::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait no_std_compat::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type no_std_compat::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#583-592">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryInto.html" title="trait no_std_compat::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../convert/trait.TryFrom.html" title="trait no_std_compat::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="../../convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait no_std_compat::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type no_std_compat::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.61.0/src/core/convert/mod.rs.html#589">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="../../convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum no_std_compat::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait no_std_compat::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type no_std_compat::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="no_std_compat" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>