<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Error handling with the `Result` type."><meta name="keywords" content="rust, rustlang, rust-lang, result"><title>nom::lib::std::result - Rust</title><link rel="stylesheet" type="text/css" href="../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../../storage.js"></script><script src="../../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg"><link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../../nom/index.html'><div class='logo-container rust-logo'><img src='../../../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module result</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></div><div id="sidebar-vars" data-name="result" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../../../index.html">nom</a>::<wbr><a href="../../index.html">lib</a>::<wbr><a href="../index.html">std</a>::<wbr><a class="mod" href="#">result</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../../../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="https://doc.rust-lang.org/1.55.0/src/core/lib.rs.html#273" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Error handling with the <code>Result</code> type.</p>
<p><a href="enum.Result.html" title="Result"><code>Result&lt;T, E&gt;</code></a> is the type used for returning and propagating
errors. It is an enum with the variants, <a href="enum.Result.html#variant.Ok"><code>Ok(T)</code></a>, representing
success and containing a value, and <a href="enum.Result.html#variant.Err"><code>Err(E)</code></a>, representing error
and containing an error value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">enum</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">E</span><span class="op">&gt;</span> {
   <span class="prelude-val">Ok</span>(<span class="ident">T</span>),
   <span class="prelude-val">Err</span>(<span class="ident">E</span>),
}</pre></div>
<p>Functions return <a href="enum.Result.html" title="Result"><code>Result</code></a> whenever errors are expected and
recoverable. In the <code>std</code> crate, <a href="enum.Result.html" title="Result"><code>Result</code></a> is most prominently used
for <a href="../../std/io/index.html">I/O</a>.</p>
<p>A simple function returning <a href="enum.Result.html" title="Result"><code>Result</code></a> might be
defined and used like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">Version</span> { <span class="ident">Version1</span>, <span class="ident">Version2</span> }

<span class="kw">fn</span> <span class="ident">parse_version</span>(<span class="ident">header</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Version</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span> {
    <span class="kw">match</span> <span class="ident">header</span>.<span class="ident">get</span>(<span class="number">0</span>) {
        <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Err</span>(<span class="string">&quot;invalid header length&quot;</span>),
        <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Ok</span>(<span class="ident">Version::Version1</span>),
        <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Ok</span>(<span class="ident">Version::Version2</span>),
        <span class="prelude-val">Some</span>(<span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Err</span>(<span class="string">&quot;invalid version&quot;</span>),
    }
}

<span class="kw">let</span> <span class="ident">version</span> <span class="op">=</span> <span class="ident">parse_version</span>(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="kw">match</span> <span class="ident">version</span> {
    <span class="prelude-val">Ok</span>(<span class="ident">v</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">println!</span>(<span class="string">&quot;working with version: {:?}&quot;</span>, <span class="ident">v</span>),
    <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">println!</span>(<span class="string">&quot;error parsing header: {:?}&quot;</span>, <span class="ident">e</span>),
}</pre></div>
<p>Pattern matching on <a href="enum.Result.html" title="Result"><code>Result</code></a>s is clear and straightforward for
simple cases, but <a href="enum.Result.html" title="Result"><code>Result</code></a> comes with some convenience methods
that make working with it more succinct.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">good_result</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Ok</span>(<span class="number">10</span>);
<span class="kw">let</span> <span class="ident">bad_result</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Err</span>(<span class="number">10</span>);

<span class="comment">// The `is_ok` and `is_err` methods do what they say.</span>
<span class="macro">assert!</span>(<span class="ident">good_result</span>.<span class="ident">is_ok</span>() <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">good_result</span>.<span class="ident">is_err</span>());
<span class="macro">assert!</span>(<span class="ident">bad_result</span>.<span class="ident">is_err</span>() <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="ident">bad_result</span>.<span class="ident">is_ok</span>());

<span class="comment">// `map` consumes the `Result` and produces another.</span>
<span class="kw">let</span> <span class="ident">good_result</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">good_result</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> <span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>);
<span class="kw">let</span> <span class="ident">bad_result</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bad_result</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> <span class="ident">i</span> <span class="op">-</span> <span class="number">1</span>);

<span class="comment">// Use `and_then` to continue the computation.</span>
<span class="kw">let</span> <span class="ident">good_result</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">bool</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">good_result</span>.<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> <span class="prelude-val">Ok</span>(<span class="ident">i</span> <span class="op">=</span><span class="op">=</span> <span class="number">11</span>));

<span class="comment">// Use `or_else` to handle the error.</span>
<span class="kw">let</span> <span class="ident">bad_result</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">bad_result</span>.<span class="ident">or_else</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> <span class="prelude-val">Ok</span>(<span class="ident">i</span> <span class="op">+</span> <span class="number">20</span>));

<span class="comment">// Consume the result and return the contents with `unwrap`.</span>
<span class="kw">let</span> <span class="ident">final_awesome_result</span> <span class="op">=</span> <span class="ident">good_result</span>.<span class="ident">unwrap</span>();</pre></div>
<h1 id="results-must-be-used" class="section-header"><a href="#results-must-be-used">Results must be used</a></h1>
<p>A common problem with using return values to indicate errors is
that it is easy to ignore the return value, thus failing to handle
the error. <a href="enum.Result.html" title="Result"><code>Result</code></a> is annotated with the <code>#[must_use]</code> attribute,
which will cause the compiler to issue a warning when a Result
value is ignored. This makes <a href="enum.Result.html" title="Result"><code>Result</code></a> especially useful with
functions that may encounter errors but don’t otherwise return a
useful value.</p>
<p>Consider the <a href="../../std/io/trait.Write.html#method.write_all"><code>write_all</code></a> method defined for I/O types
by the <a href="../../std/io/trait.Write.html"><code>Write</code></a> trait:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::io</span>;

<span class="kw">trait</span> <span class="ident">Write</span> {
    <span class="kw">fn</span> <span class="ident">write_all</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">bytes</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">io::Error</span><span class="op">&gt;</span>;
}</pre></div>
<p><em>Note: The actual definition of <a href="../../std/io/trait.Write.html"><code>Write</code></a> uses <a href="../../std/io/type.Result.html"><code>io::Result</code></a>, which
is just a synonym for <a href="enum.Result.html" title="Result"><code>Result</code></a><code>&lt;T, </code><a href="../../std/io/struct.Error.html"><code>io::Error</code></a><code>&gt;</code>.</em></p>
<p>This method doesn’t produce a value, but the write may
fail. It’s crucial to handle the error case, and <em>not</em> write
something like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::fs::File</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">File::create</span>(<span class="string">&quot;valuable_data.txt&quot;</span>).<span class="ident">unwrap</span>();
<span class="comment">// If `write_all` errors, then we&#39;ll never know, because the return</span>
<span class="comment">// value is ignored.</span>
<span class="ident">file</span>.<span class="ident">write_all</span>(<span class="string">b&quot;important message&quot;</span>);</pre></div>
<p>If you <em>do</em> write that in Rust, the compiler will give you a
warning (by default, controlled by the <code>unused_must_use</code> lint).</p>
<p>You might instead, if you don’t want to handle the error, simply
assert success with <a href="enum.Result.html#method.expect"><code>expect</code></a>. This will panic if the
write fails, providing a marginally useful message indicating why:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::fs::File</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">File::create</span>(<span class="string">&quot;valuable_data.txt&quot;</span>).<span class="ident">unwrap</span>();
<span class="ident">file</span>.<span class="ident">write_all</span>(<span class="string">b&quot;important message&quot;</span>).<span class="ident">expect</span>(<span class="string">&quot;failed to write message&quot;</span>);</pre></div>
<p>You might also simply assert success:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert!</span>(<span class="ident">file</span>.<span class="ident">write_all</span>(<span class="string">b&quot;important message&quot;</span>).<span class="ident">is_ok</span>());</pre></div>
<p>Or propagate the error up the call stack with <a href="../ops/trait.Try.html"><code>?</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">write_message</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">File::create</span>(<span class="string">&quot;valuable_data.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="ident">file</span>.<span class="ident">write_all</span>(<span class="string">b&quot;important message&quot;</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</pre></div>
<h1 id="the-question-mark-operator-" class="section-header"><a href="#the-question-mark-operator-">The question mark operator, <code>?</code></a></h1>
<p>When writing code that calls many functions that return the
<a href="enum.Result.html" title="Result"><code>Result</code></a> type, the error handling can be tedious. The question mark
operator, <a href="../ops/trait.Try.html"><code>?</code></a>, hides some of the boilerplate of propagating errors
up the call stack.</p>
<p>It replaces this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::fs::File</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::io</span>;

<span class="kw">struct</span> <span class="ident">Info</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">age</span>: <span class="ident">i32</span>,
    <span class="ident">rating</span>: <span class="ident">i32</span>,
}

<span class="kw">fn</span> <span class="ident">write_info</span>(<span class="ident">info</span>: <span class="kw-2">&amp;</span><span class="ident">Info</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// Early return on error</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">file</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">File::create</span>(<span class="string">&quot;my_best_friends.txt&quot;</span>) {
           <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>),
           <span class="prelude-val">Ok</span>(<span class="ident">f</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">f</span>,
    };
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span> <span class="ident">file</span>.<span class="ident">write_all</span>(<span class="macro">format!</span>(<span class="string">&quot;name: {}\n&quot;</span>, <span class="ident">info</span>.<span class="ident">name</span>).<span class="ident">as_bytes</span>()) {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>)
    }
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span> <span class="ident">file</span>.<span class="ident">write_all</span>(<span class="macro">format!</span>(<span class="string">&quot;age: {}\n&quot;</span>, <span class="ident">info</span>.<span class="ident">age</span>).<span class="ident">as_bytes</span>()) {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>)
    }
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span> <span class="ident">file</span>.<span class="ident">write_all</span>(<span class="macro">format!</span>(<span class="string">&quot;rating: {}\n&quot;</span>, <span class="ident">info</span>.<span class="ident">rating</span>).<span class="ident">as_bytes</span>()) {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">e</span>)
    }
    <span class="prelude-val">Ok</span>(())
}</pre></div>
<p>With this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::fs::File</span>;
<span class="kw">use</span> <span class="ident">std::io::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::io</span>;

<span class="kw">struct</span> <span class="ident">Info</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">age</span>: <span class="ident">i32</span>,
    <span class="ident">rating</span>: <span class="ident">i32</span>,
}

<span class="kw">fn</span> <span class="ident">write_info</span>(<span class="ident">info</span>: <span class="kw-2">&amp;</span><span class="ident">Info</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">file</span> <span class="op">=</span> <span class="ident">File::create</span>(<span class="string">&quot;my_best_friends.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="comment">// Early return on error</span>
    <span class="ident">file</span>.<span class="ident">write_all</span>(<span class="macro">format!</span>(<span class="string">&quot;name: {}\n&quot;</span>, <span class="ident">info</span>.<span class="ident">name</span>).<span class="ident">as_bytes</span>())<span class="question-mark">?</span>;
    <span class="ident">file</span>.<span class="ident">write_all</span>(<span class="macro">format!</span>(<span class="string">&quot;age: {}\n&quot;</span>, <span class="ident">info</span>.<span class="ident">age</span>).<span class="ident">as_bytes</span>())<span class="question-mark">?</span>;
    <span class="ident">file</span>.<span class="ident">write_all</span>(<span class="macro">format!</span>(<span class="string">&quot;rating: {}\n&quot;</span>, <span class="ident">info</span>.<span class="ident">rating</span>).<span class="ident">as_bytes</span>())<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</pre></div>
<p><em>It’s much nicer!</em></p>
<p>Ending the expression with <a href="../ops/trait.Try.html"><code>?</code></a> will result in the unwrapped
success (<a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a>) value, unless the result is <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a>, in which case
<a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a> is returned early from the enclosing function.</p>
<p><a href="../ops/trait.Try.html"><code>?</code></a> can only be used in functions that return <a href="enum.Result.html" title="Result"><code>Result</code></a> because of the
early return of <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a> that it provides.</p>
<h1 id="method-overview" class="section-header"><a href="#method-overview">Method overview</a></h1>
<p>In addition to working with pattern matching, <a href="enum.Result.html" title="Result"><code>Result</code></a> provides a
wide variety of different methods.</p>
<h2 id="querying-the-variant" class="section-header"><a href="#querying-the-variant">Querying the variant</a></h2>
<p>The <a href="enum.Result.html#method.is_ok"><code>is_ok</code></a> and <a href="enum.Result.html#method.is_err"><code>is_err</code></a> methods return <a href="https://doc.rust-lang.org/1.55.0/std/primitive.bool.html" title="true"><code>true</code></a> if the <a href="enum.Result.html" title="Result"><code>Result</code></a>
is <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a> or <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a>, respectively.</p>
<h2 id="adapters-for-working-with-references" class="section-header"><a href="#adapters-for-working-with-references">Adapters for working with references</a></h2>
<ul>
<li><a href="enum.Result.html#method.as_ref"><code>as_ref</code></a> converts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code></li>
<li><a href="enum.Result.html#method.as_mut"><code>as_mut</code></a> converts from <code>&amp;mut Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>
<li><a href="enum.Result.html#method.as_deref"><code>as_deref</code></a> converts from <code>&amp;Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T::Target, &amp;E&gt;</code></li>
<li><a href="enum.Result.html#method.as_deref_mut"><code>as_deref_mut</code></a> converts from <code>&amp;mut Result&lt;T, E&gt;</code> to
<code>Result&lt;&amp;mut T::Target, &amp;mut E&gt;</code></li>
</ul>
<h2 id="extracting-contained-values" class="section-header"><a href="#extracting-contained-values">Extracting contained values</a></h2>
<p>These methods extract the contained value in a <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a> when it
is the <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a> variant. If the <a href="enum.Result.html" title="Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a>:</p>
<ul>
<li><a href="enum.Result.html#method.expect"><code>expect</code></a> panics with a provided custom message</li>
<li><a href="enum.Result.html#method.unwrap"><code>unwrap</code></a> panics with a generic message</li>
<li><a href="enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a> returns the provided default value</li>
<li><a href="enum.Result.html#method.unwrap_or_default"><code>unwrap_or_default</code></a> returns the default value of the type <code>T</code>
(which must implement the <a href="../prelude/v1/rust_2021/trait.Default.html" title="Default"><code>Default</code></a> trait)</li>
<li><a href="enum.Result.html#method.unwrap_or_else"><code>unwrap_or_else</code></a> returns the result of evaluating the provided
function</li>
</ul>
<p>The panicking methods <a href="enum.Result.html#method.expect"><code>expect</code></a> and <a href="enum.Result.html#method.unwrap"><code>unwrap</code></a> require <code>E</code> to
implement the <a href="../fmt/trait.Debug.html"><code>Debug</code></a> trait.</p>
<p>These methods extract the contained value in a <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a> when it
is the <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a> variant. They require <code>T</code> to implement the <a href="../fmt/trait.Debug.html"><code>Debug</code></a>
trait. If the <a href="enum.Result.html" title="Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a>:</p>
<ul>
<li><a href="enum.Result.html#method.expect_err"><code>expect_err</code></a> panics with a provided custom message</li>
<li><a href="enum.Result.html#method.unwrap_err"><code>unwrap_err</code></a> panics with a generic message</li>
</ul>
<h2 id="transforming-contained-values" class="section-header"><a href="#transforming-contained-values">Transforming contained values</a></h2>
<p>These methods transform <a href="enum.Result.html" title="Result"><code>Result</code></a> to <a href="../option/enum.Option.html" title="Option"><code>Option</code></a>:</p>
<ul>
<li><a href="enum.Result.html#method.err" title="Result::err"><code>err</code></a> transforms <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a> into <a href="../option/enum.Option.html" title="Option&lt;E&gt;"><code>Option&lt;E&gt;</code></a>,
mapping <a href="enum.Result.html#variant.Err"><code>Err(e)</code></a> to <a href="../option/enum.Option.html#variant.Some"><code>Some(e)</code></a> and <a href="enum.Result.html#variant.Ok"><code>Ok(v)</code></a> to <a href="../option/enum.Option.html#variant.None" title="None"><code>None</code></a></li>
<li><a href="enum.Result.html#method.ok" title="Result::ok"><code>ok</code></a> transforms <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a> into <a href="../option/enum.Option.html" title="Option&lt;T&gt;"><code>Option&lt;T&gt;</code></a>,
mapping <a href="enum.Result.html#variant.Ok"><code>Ok(v)</code></a> to <a href="../option/enum.Option.html#variant.Some"><code>Some(v)</code></a> and <a href="enum.Result.html#variant.Err"><code>Err(e)</code></a> to <a href="../option/enum.Option.html#variant.None" title="None"><code>None</code></a></li>
<li><a href="enum.Result.html#method.transpose"><code>transpose</code></a> transposes a <a href="enum.Result.html" title="Result"><code>Result</code></a> of an <a href="../option/enum.Option.html" title="Option"><code>Option</code></a> into an
<a href="../option/enum.Option.html" title="Option"><code>Option</code></a> of a <a href="enum.Result.html" title="Result"><code>Result</code></a></li>
</ul>
<p>This method transforms the contained value of the <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a> variant:</p>
<ul>
<li><a href="enum.Result.html#method.map"><code>map</code></a> transforms <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a> into <a href="enum.Result.html" title="Result&lt;U, E&gt;"><code>Result&lt;U, E&gt;</code></a> by applying
the provided function to the contained value of <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a> and leaving
<a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a> values unchanged</li>
</ul>
<p>This method transforms the contained value of the <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a> variant:</p>
<ul>
<li><a href="enum.Result.html#method.map_err"><code>map_err</code></a> transforms <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a> into <a href="enum.Result.html" title="Result&lt;T, F&gt;"><code>Result&lt;T, F&gt;</code></a> by
applying the provided function to the contained value of <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a> and
leaving <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a> values unchanged</li>
</ul>
<p>These methods transform a <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a> into a value of a possibly
different type <code>U</code>:</p>
<ul>
<li><a href="enum.Result.html#method.map_or"><code>map_or</code></a> applies the provided function to the contained value of
<a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a>, or returns the provided default value if the <a href="enum.Result.html" title="Result"><code>Result</code></a> is
<a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a></li>
<li><a href="enum.Result.html#method.map_or_else"><code>map_or_else</code></a> applies the provided function to the contained value
of <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a>, or applies the provided fallback function to the contained
value of <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a></li>
</ul>
<h2 id="boolean-operators" class="section-header"><a href="#boolean-operators">Boolean operators</a></h2>
<p>These methods treat the <a href="enum.Result.html" title="Result"><code>Result</code></a> as a boolean value, where <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a>
acts like <a href="https://doc.rust-lang.org/1.55.0/std/primitive.bool.html" title="true"><code>true</code></a> and <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a> acts like <a href="https://doc.rust-lang.org/1.55.0/std/primitive.bool.html" title="false"><code>false</code></a>. There are two
categories of these methods: ones that take a <a href="enum.Result.html" title="Result"><code>Result</code></a> as input, and
ones that take a function as input (to be lazily evaluated).</p>
<p>The <a href="enum.Result.html#method.and"><code>and</code></a> and <a href="enum.Result.html#method.or"><code>or</code></a> methods take another <a href="enum.Result.html" title="Result"><code>Result</code></a> as input, and
produce a <a href="enum.Result.html" title="Result"><code>Result</code></a> as output. The <a href="enum.Result.html#method.and"><code>and</code></a> method can produce a
<a href="enum.Result.html" title="Result&lt;U, E&gt;"><code>Result&lt;U, E&gt;</code></a> value having a different inner type <code>U</code> than
<a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a>. The <a href="enum.Result.html#method.or"><code>or</code></a> method can produce a <a href="enum.Result.html" title="Result&lt;T, F&gt;"><code>Result&lt;T, F&gt;</code></a>
value having a different error type <code>F</code> than <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a>.</p>
<table><thead><tr><th>method</th><th>self</th><th>input</th><th>output</th></tr></thead><tbody>
<tr><td><a href="enum.Result.html#method.and"><code>and</code></a></td><td><code>Err(e)</code></td><td>(ignored)</td><td><code>Err(e)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or"><code>or</code></a></td><td><code>Ok(x)</code></td><td>(ignored)</td><td><code>Ok(x)</code></td></tr>
</tbody></table>
<p>The <a href="enum.Result.html#method.and_then"><code>and_then</code></a> and <a href="enum.Result.html#method.or_else"><code>or_else</code></a> methods take a function as input, and
only evaluate the function when they need to produce a new value. The
<a href="enum.Result.html#method.and_then"><code>and_then</code></a> method can produce a <a href="enum.Result.html" title="Result&lt;U, E&gt;"><code>Result&lt;U, E&gt;</code></a> value having a
different inner type <code>U</code> than <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a>. The <a href="enum.Result.html#method.or_else"><code>or_else</code></a> method
can produce a <a href="enum.Result.html" title="Result&lt;T, F&gt;"><code>Result&lt;T, F&gt;</code></a> value having a different error type <code>F</code>
than <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a>.</p>
<table><thead><tr><th>method</th><th>self</th><th>function input</th><th>function result</th><th>output</th></tr></thead><tbody>
<tr><td><a href="enum.Result.html#method.and_then"><code>and_then</code></a></td><td><code>Err(e)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Err(e)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and_then"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and_then"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else"><code>or_else</code></a></td><td><code>Ok(x)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Ok(x)</code></td></tr>
</tbody></table>
<h2 id="iterating-over-result" class="section-header"><a href="#iterating-over-result">Iterating over <code>Result</code></a></h2>
<p>A <a href="enum.Result.html" title="Result"><code>Result</code></a> can be iterated over. This can be helpful if you need an
iterator that is conditionally empty. The iterator will either produce
a single value (when the <a href="enum.Result.html" title="Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a>), or produce no values
(when the <a href="enum.Result.html" title="Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a>). For example, <a href="enum.Result.html#method.into_iter"><code>into_iter</code></a> acts like
<a href="../iter/fn.once.html"><code>once(v)</code></a> if the <a href="enum.Result.html" title="Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Ok"><code>Ok(v)</code></a>, and like <a href="../iter/fn.empty.html"><code>empty()</code></a> if the
<a href="enum.Result.html" title="Result"><code>Result</code></a> is <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a>.</p>
<p>Iterators over <a href="enum.Result.html" title="Result&lt;T, E&gt;"><code>Result&lt;T, E&gt;</code></a> come in three types:</p>
<ul>
<li><a href="enum.Result.html#method.into_iter"><code>into_iter</code></a> consumes the <a href="enum.Result.html" title="Result"><code>Result</code></a> and produces the contained
value</li>
<li><a href="enum.Result.html#method.iter"><code>iter</code></a> produces an immutable reference of type <code>&amp;T</code> to the
contained value</li>
<li><a href="enum.Result.html#method.iter_mut"><code>iter_mut</code></a> produces a mutable reference of type <code>&amp;mut T</code> to the
contained value</li>
</ul>
<p>See <a href="../option/index.html#iterating-over-option">Iterating over <code>Option</code></a> for examples of how this can be useful.</p>
<p>You might want to use an iterator chain to do multiple instances of an
operation that can fail, but would like to ignore failures while
continuing to process the successful results. In this example, we take
advantage of the iterable nature of <a href="enum.Result.html" title="Result"><code>Result</code></a> to select only the
<a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a> values using <a href="../iter/trait.Iterator.html#method.flatten" title="Iterator::flatten"><code>flatten</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">results</span> <span class="op">=</span> <span class="macro">vec!</span>[];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">errs</span> <span class="op">=</span> <span class="macro">vec!</span>[];
<span class="kw">let</span> <span class="ident">nums</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="string">&quot;17&quot;</span>, <span class="string">&quot;not a number&quot;</span>, <span class="string">&quot;99&quot;</span>, <span class="string">&quot;-27&quot;</span>, <span class="string">&quot;768&quot;</span>]
   .<span class="ident">into_iter</span>()
   .<span class="ident">map</span>(<span class="ident">u8::from_str</span>)
   <span class="comment">// Save clones of the raw `Result` values to inspect</span>
   .<span class="ident">inspect</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">results</span>.<span class="ident">push</span>(<span class="ident">x</span>.<span class="ident">clone</span>()))
   <span class="comment">// Challenge: explain how this captures only the `Err` values</span>
   .<span class="ident">inspect</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">errs</span>.<span class="ident">extend</span>(<span class="ident">x</span>.<span class="ident">clone</span>().<span class="ident">err</span>()))
   .<span class="ident">flatten</span>()
   .<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">errs</span>.<span class="ident">len</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">nums</span>, [<span class="number">17</span>, <span class="number">99</span>]);
<span class="macro">println!</span>(<span class="string">&quot;results {:?}&quot;</span>, <span class="ident">results</span>);
<span class="macro">println!</span>(<span class="string">&quot;errs {:?}&quot;</span>, <span class="ident">errs</span>);
<span class="macro">println!</span>(<span class="string">&quot;nums {:?}&quot;</span>, <span class="ident">nums</span>);</pre></div>
<h2 id="collecting-into-result" class="section-header"><a href="#collecting-into-result">Collecting into <code>Result</code></a></h2>
<p><a href="enum.Result.html" title="Result"><code>Result</code></a> implements the <a href="enum.Result.html#impl-FromIterator%3CResult%3CA%2C%20E%3E%3E"><code>FromIterator</code></a> trait,
which allows an iterator over <a href="enum.Result.html" title="Result"><code>Result</code></a> values to be collected into a
<a href="enum.Result.html" title="Result"><code>Result</code></a> of a collection of each contained value of the original
<a href="enum.Result.html" title="Result"><code>Result</code></a> values, or <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a> if any of the elements was <a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;err!&quot;</span>), <span class="prelude-val">Ok</span>(<span class="number">8</span>)];
<span class="kw">let</span> <span class="ident">res</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span>, <span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">into_iter</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">res</span>, <span class="prelude-val">Err</span>(<span class="string">&quot;err!&quot;</span>));
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="prelude-val">Ok</span>(<span class="number">8</span>)];
<span class="kw">let</span> <span class="ident">res</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span>, <span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">into_iter</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">res</span>, <span class="prelude-val">Ok</span>(<span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]));</pre></div>
<p><a href="enum.Result.html" title="Result"><code>Result</code></a> also implements the <a href="enum.Result.html#impl-Product%3CResult%3CU%2C%20E%3E%3E"><code>Product</code></a> and
<a href="enum.Result.html#impl-Sum%3CResult%3CU%2C%20E%3E%3E"><code>Sum</code></a> traits, allowing an iterator over <a href="enum.Result.html" title="Result"><code>Result</code></a> values
to provide the <a href="../iter/trait.Iterator.html#method.product" title="Iterator::product"><code>product</code></a> and
<a href="../iter/trait.Iterator.html#method.sum" title="Iterator::sum"><code>sum</code></a> methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="prelude-val">Err</span>(<span class="string">&quot;error!&quot;</span>), <span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">3</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;foo&quot;</span>)];
<span class="kw">let</span> <span class="ident">res</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">into_iter</span>().<span class="ident">sum</span>();
<span class="macro">assert_eq!</span>(<span class="ident">res</span>, <span class="prelude-val">Err</span>(<span class="string">&quot;error!&quot;</span>));
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">21</span>)];
<span class="kw">let</span> <span class="ident">res</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, <span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">into_iter</span>().<span class="ident">product</span>();
<span class="macro">assert_eq!</span>(<span class="ident">res</span>, <span class="prelude-val">Ok</span>(<span class="number">42</span>));</pre></div>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.IntoIter.html" title="nom::lib::std::result::IntoIter struct">IntoIter</a></div><div class="item-right docblock-short"><p>An iterator over the value in a <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a> variant of a <a href="enum.Result.html" title="Result"><code>Result</code></a>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Iter.html" title="nom::lib::std::result::Iter struct">Iter</a></div><div class="item-right docblock-short"><p>An iterator over a reference to the <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a> variant of a <a href="enum.Result.html" title="Result"><code>Result</code></a>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.IterMut.html" title="nom::lib::std::result::IterMut struct">IterMut</a></div><div class="item-right docblock-short"><p>An iterator over a mutable reference to the <a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a> variant of a <a href="enum.Result.html" title="Result"><code>Result</code></a>.</p>
</div></div><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="enum" href="enum.Result.html" title="nom::lib::std::result::Result enum">Result</a></div><div class="item-right docblock-short"><p><code>Result</code> is a type that represents either success (<a href="enum.Result.html#variant.Ok" title="Ok"><code>Ok</code></a>) or failure (<a href="enum.Result.html#variant.Err" title="Err"><code>Err</code></a>).</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../../" data-current-crate="nom" data-search-index-js="../../../../search-index.js" data-search-js="../../../../search.js"></div>
    <script src="../../../../main.js"></script>
</body></html>