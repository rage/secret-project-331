<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An extensible, strongly-typed implementation of OAuth2 (RFC 6749) including token introspection (RFC 7662) and token revocation (RFC 7009)."><title>oauth2 - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="oauth2" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../oauth2/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../oauth2/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate oauth2</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 4.4.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">oauth2</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/oauth2/lib.rs.html#1-3197">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An extensible, strongly-typed implementation of OAuth2
(<a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a>) including token introspection (<a href="https://tools.ietf.org/html/rfc7662">RFC 7662</a>)
and token revocation (<a href="https://tools.ietf.org/html/rfc7009">RFC 7009</a>).</p>
<h2 id="contents"><a href="#contents">Contents</a></h2>
<ul>
<li><a href="#importing-oauth2-selecting-an-http-client-interface">Importing <code>oauth2</code>: selecting an HTTP client interface</a></li>
<li><a href="#getting-started-authorization-code-grant-w-pkce">Getting started: Authorization Code Grant w/ PKCE</a>
<ul>
<li><a href="#example-synchronous-blocking-api">Example: Synchronous (blocking) API</a></li>
<li><a href="#example-asynchronous-api">Example: Asynchronous API</a></li>
</ul>
</li>
<li><a href="#implicit-grant">Implicit Grant</a></li>
<li><a href="#resource-owner-password-credentials-grant">Resource Owner Password Credentials Grant</a></li>
<li><a href="#client-credentials-grant">Client Credentials Grant</a></li>
<li><a href="#device-code-flow">Device Code Flow</a></li>
<li><a href="#other-examples">Other examples</a>
<ul>
<li><a href="#contributed-examples">Contributed Examples</a></li>
</ul>
</li>
</ul>
<h2 id="importing-oauth2-selecting-an-http-client-interface"><a href="#importing-oauth2-selecting-an-http-client-interface">Importing <code>oauth2</code>: selecting an HTTP client interface</a></h2>
<p>This library offers a flexible HTTP client interface with two modes:</p>
<ul>
<li><strong>Synchronous (blocking)</strong></li>
<li><strong>Asynchronous</strong></li>
</ul>
<p>For the HTTP client modes described above, the following HTTP client implementations can be
used:</p>
<ul>
<li>
<p><strong><a href="reqwest/index.html" title="mod oauth2::reqwest"><code>reqwest</code></a></strong></p>
<p>The <code>reqwest</code> HTTP client supports both the synchronous and asynchronous modes and is enabled
by default.</p>
<p>Synchronous client: <a href="reqwest/fn.http_client.html" title="fn oauth2::reqwest::http_client"><code>reqwest::http_client</code></a></p>
<p>Asynchronous client: <a href="reqwest/fn.async_http_client.html" title="fn oauth2::reqwest::async_http_client"><code>reqwest::async_http_client</code></a></p>
</li>
<li>
<p><strong>[<code>curl</code>]</strong></p>
<p>The <code>curl</code> HTTP client only supports the synchronous HTTP client mode and can be enabled in
<code>Cargo.toml</code> via the <code>curl</code> feature flag.</p>
<p>Synchronous client: [<code>curl::http_client</code>]</p>
</li>
<li>
<p><strong>[<code>ureq</code>]</strong></p>
<p>The <code>ureq</code> HTTP client is a simple HTTP client with minimal dependencies. It only supports
the synchronous HTTP client mode and can be enabled in <code>Cargo.toml</code> via the <code>ureq</code> feature
flag.</p>
</li>
<li>
<p><strong>Custom</strong></p>
<p>In addition to the clients above, users may define their own HTTP clients, which must accept
an <a href="struct.HttpRequest.html" title="struct oauth2::HttpRequest"><code>HttpRequest</code></a> and return an <a href="struct.HttpResponse.html" title="struct oauth2::HttpResponse"><code>HttpResponse</code></a> or error. Users writing their own clients
may wish to disable the default <code>reqwest</code> dependency by specifying
<code>default-features = false</code> in <code>Cargo.toml</code> (replacing <code>...</code> with the desired version of this
crate):</p>
<div class="example-wrap"><pre class="language-toml"><code>oauth2 = { version = &quot;...&quot;, default-features = false }
</code></pre></div>
<p>Synchronous HTTP clients should implement the following trait:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>FnOnce(HttpRequest) -&gt; <span class="prelude-ty">Result</span>&lt;HttpResponse, RE&gt;
<span class="kw">where </span>RE: std::error::Error + <span class="lifetime">&#39;static</span></code></pre></div>
<p>Asynchronous HTTP clients should implement the following trait:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>FnOnce(HttpRequest) -&gt; F
<span class="kw">where
  </span>F: Future&lt;Output = <span class="prelude-ty">Result</span>&lt;HttpResponse, RE&gt;&gt;,
  RE: std::error::Error + <span class="lifetime">&#39;static</span></code></pre></div>
</li>
</ul>
<h2 id="getting-started-authorization-code-grant-w-pkce"><a href="#getting-started-authorization-code-grant-w-pkce">Getting started: Authorization Code Grant w/ PKCE</a></h2>
<p>This is the most common OAuth2 flow. PKCE is recommended whenever the OAuth2 client has no
client secret or has a client secret that cannot remain confidential (e.g., native, mobile, or
client-side web applications).</p>
<h3 id="example-synchronous-blocking-api"><a href="#example-synchronous-blocking-api">Example: Synchronous (blocking) API</a></h3>
<p>This example works with <code>oauth2</code>’s default feature flags, which include <code>reqwest</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>anyhow;
<span class="kw">use </span>oauth2::{
    AuthorizationCode,
    AuthUrl,
    ClientId,
    ClientSecret,
    CsrfToken,
    PkceCodeChallenge,
    RedirectUrl,
    Scope,
    TokenResponse,
    TokenUrl
};
<span class="kw">use </span>oauth2::basic::BasicClient;
<span class="kw">use </span>oauth2::reqwest::http_client;
<span class="kw">use </span>url::Url;

<span class="comment">// Create an OAuth2 client by specifying the client ID, client secret, authorization URL and
// token URL.
</span><span class="kw">let </span>client =
    BasicClient::new(
        ClientId::new(<span class="string">&quot;client_id&quot;</span>.to_string()),
        <span class="prelude-val">Some</span>(ClientSecret::new(<span class="string">&quot;client_secret&quot;</span>.to_string())),
        AuthUrl::new(<span class="string">&quot;http://authorize&quot;</span>.to_string())<span class="question-mark">?</span>,
        <span class="prelude-val">Some</span>(TokenUrl::new(<span class="string">&quot;http://token&quot;</span>.to_string())<span class="question-mark">?</span>)
    )
    <span class="comment">// Set the URL the user will be redirected to after the authorization process.
    </span>.set_redirect_uri(RedirectUrl::new(<span class="string">&quot;http://redirect&quot;</span>.to_string())<span class="question-mark">?</span>);

<span class="comment">// Generate a PKCE challenge.
</span><span class="kw">let </span>(pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

<span class="comment">// Generate the full authorization URL.
</span><span class="kw">let </span>(auth_url, csrf_token) = client
    .authorize_url(CsrfToken::new_random)
    <span class="comment">// Set the desired scopes.
    </span>.add_scope(Scope::new(<span class="string">&quot;read&quot;</span>.to_string()))
    .add_scope(Scope::new(<span class="string">&quot;write&quot;</span>.to_string()))
    <span class="comment">// Set the PKCE code challenge.
    </span>.set_pkce_challenge(pkce_challenge)
    .url();

<span class="comment">// This is the URL you should redirect the user to, in order to trigger the authorization
// process.
</span><span class="macro">println!</span>(<span class="string">&quot;Browse to: {}&quot;</span>, auth_url);

<span class="comment">// Once the user has been redirected to the redirect URL, you&#39;ll have access to the
// authorization code. For security reasons, your code should verify that the `state`
// parameter returned by the server matches `csrf_state`.

// Now you can trade it for an access token.
</span><span class="kw">let </span>token_result =
    client
        .exchange_code(AuthorizationCode::new(<span class="string">&quot;some authorization code&quot;</span>.to_string()))
        <span class="comment">// Set the PKCE code verifier.
        </span>.set_pkce_verifier(pkce_verifier)
        .request(http_client)<span class="question-mark">?</span>;

<span class="comment">// Unwrapping token_result will either produce a Token or a RequestTokenError.</span></code></pre></div>
<h3 id="example-asynchronous-api"><a href="#example-asynchronous-api">Example: Asynchronous API</a></h3>
<p>The example below uses async/await:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>anyhow;
<span class="kw">use </span>oauth2::{
    AuthorizationCode,
    AuthUrl,
    ClientId,
    ClientSecret,
    CsrfToken,
    PkceCodeChallenge,
    RedirectUrl,
    Scope,
    TokenResponse,
    TokenUrl
};
<span class="kw">use </span>oauth2::basic::BasicClient;
<span class="kw">use </span>oauth2::reqwest::async_http_client;
<span class="kw">use </span>url::Url;

<span class="comment">// Create an OAuth2 client by specifying the client ID, client secret, authorization URL and
// token URL.
</span><span class="kw">let </span>client =
    BasicClient::new(
        ClientId::new(<span class="string">&quot;client_id&quot;</span>.to_string()),
        <span class="prelude-val">Some</span>(ClientSecret::new(<span class="string">&quot;client_secret&quot;</span>.to_string())),
        AuthUrl::new(<span class="string">&quot;http://authorize&quot;</span>.to_string())<span class="question-mark">?</span>,
        <span class="prelude-val">Some</span>(TokenUrl::new(<span class="string">&quot;http://token&quot;</span>.to_string())<span class="question-mark">?</span>)
    )
    <span class="comment">// Set the URL the user will be redirected to after the authorization process.
    </span>.set_redirect_uri(RedirectUrl::new(<span class="string">&quot;http://redirect&quot;</span>.to_string())<span class="question-mark">?</span>);

<span class="comment">// Generate a PKCE challenge.
</span><span class="kw">let </span>(pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

<span class="comment">// Generate the full authorization URL.
</span><span class="kw">let </span>(auth_url, csrf_token) = client
    .authorize_url(CsrfToken::new_random)
    <span class="comment">// Set the desired scopes.
    </span>.add_scope(Scope::new(<span class="string">&quot;read&quot;</span>.to_string()))
    .add_scope(Scope::new(<span class="string">&quot;write&quot;</span>.to_string()))
    <span class="comment">// Set the PKCE code challenge.
    </span>.set_pkce_challenge(pkce_challenge)
    .url();

<span class="comment">// This is the URL you should redirect the user to, in order to trigger the authorization
// process.
</span><span class="macro">println!</span>(<span class="string">&quot;Browse to: {}&quot;</span>, auth_url);

<span class="comment">// Once the user has been redirected to the redirect URL, you&#39;ll have access to the
// authorization code. For security reasons, your code should verify that the `state`
// parameter returned by the server matches `csrf_state`.

// Now you can trade it for an access token.
</span><span class="kw">let </span>token_result = client
    .exchange_code(AuthorizationCode::new(<span class="string">&quot;some authorization code&quot;</span>.to_string()))
    <span class="comment">// Set the PKCE code verifier.
    </span>.set_pkce_verifier(pkce_verifier)
    .request_async(async_http_client)
    .<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// Unwrapping token_result will either produce a Token or a RequestTokenError.</span></code></pre></div>
<h2 id="implicit-grant"><a href="#implicit-grant">Implicit Grant</a></h2>
<p>This flow fetches an access token directly from the authorization endpoint. Be sure to
understand the security implications of this flow before using it. In most cases, the
Authorization Code Grant flow is preferable to the Implicit Grant flow.</p>
<h3 id="example"><a href="#example">Example</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>anyhow;
<span class="kw">use </span>oauth2::{
    AuthUrl,
    ClientId,
    ClientSecret,
    CsrfToken,
    RedirectUrl,
    Scope
};
<span class="kw">use </span>oauth2::basic::BasicClient;
<span class="kw">use </span>url::Url;

<span class="kw">let </span>client =
    BasicClient::new(
        ClientId::new(<span class="string">&quot;client_id&quot;</span>.to_string()),
        <span class="prelude-val">Some</span>(ClientSecret::new(<span class="string">&quot;client_secret&quot;</span>.to_string())),
        AuthUrl::new(<span class="string">&quot;http://authorize&quot;</span>.to_string())<span class="question-mark">?</span>,
        <span class="prelude-val">None
    </span>);

<span class="comment">// Generate the full authorization URL.
</span><span class="kw">let </span>(auth_url, csrf_token) = client
    .authorize_url(CsrfToken::new_random)
    .use_implicit_flow()
    .url();

<span class="comment">// This is the URL you should redirect the user to, in order to trigger the authorization
// process.
</span><span class="macro">println!</span>(<span class="string">&quot;Browse to: {}&quot;</span>, auth_url);

<span class="comment">// Once the user has been redirected to the redirect URL, you&#39;ll have the access code.
// For security reasons, your code should verify that the `state` parameter returned by the
// server matches `csrf_state`.
</span></code></pre></div>
<h2 id="resource-owner-password-credentials-grant"><a href="#resource-owner-password-credentials-grant">Resource Owner Password Credentials Grant</a></h2>
<p>You can ask for a <em>password</em> access token by calling the <code>Client::exchange_password</code> method,
while including the username and password.</p>
<h3 id="example-1"><a href="#example-1">Example</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>anyhow;
<span class="kw">use </span>oauth2::{
    AuthUrl,
    ClientId,
    ClientSecret,
    ResourceOwnerPassword,
    ResourceOwnerUsername,
    Scope,
    TokenResponse,
    TokenUrl
};
<span class="kw">use </span>oauth2::basic::BasicClient;
<span class="kw">use </span>oauth2::reqwest::http_client;
<span class="kw">use </span>url::Url;

<span class="kw">let </span>client =
    BasicClient::new(
        ClientId::new(<span class="string">&quot;client_id&quot;</span>.to_string()),
        <span class="prelude-val">Some</span>(ClientSecret::new(<span class="string">&quot;client_secret&quot;</span>.to_string())),
        AuthUrl::new(<span class="string">&quot;http://authorize&quot;</span>.to_string())<span class="question-mark">?</span>,
        <span class="prelude-val">Some</span>(TokenUrl::new(<span class="string">&quot;http://token&quot;</span>.to_string())<span class="question-mark">?</span>)
    );

<span class="kw">let </span>token_result =
    client
        .exchange_password(
            <span class="kw-2">&amp;</span>ResourceOwnerUsername::new(<span class="string">&quot;user&quot;</span>.to_string()),
            <span class="kw-2">&amp;</span>ResourceOwnerPassword::new(<span class="string">&quot;pass&quot;</span>.to_string())
        )
        .add_scope(Scope::new(<span class="string">&quot;read&quot;</span>.to_string()))
        .request(http_client)<span class="question-mark">?</span>;</code></pre></div>
<h2 id="client-credentials-grant"><a href="#client-credentials-grant">Client Credentials Grant</a></h2>
<p>You can ask for a <em>client credentials</em> access token by calling the
<code>Client::exchange_client_credentials</code> method.</p>
<h3 id="example-2"><a href="#example-2">Example</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>anyhow;
<span class="kw">use </span>oauth2::{
    AuthUrl,
    ClientId,
    ClientSecret,
    Scope,
    TokenResponse,
    TokenUrl
};
<span class="kw">use </span>oauth2::basic::BasicClient;
<span class="kw">use </span>oauth2::reqwest::http_client;
<span class="kw">use </span>url::Url;

<span class="kw">let </span>client =
    BasicClient::new(
        ClientId::new(<span class="string">&quot;client_id&quot;</span>.to_string()),
        <span class="prelude-val">Some</span>(ClientSecret::new(<span class="string">&quot;client_secret&quot;</span>.to_string())),
        AuthUrl::new(<span class="string">&quot;http://authorize&quot;</span>.to_string())<span class="question-mark">?</span>,
        <span class="prelude-val">Some</span>(TokenUrl::new(<span class="string">&quot;http://token&quot;</span>.to_string())<span class="question-mark">?</span>),
    );

<span class="kw">let </span>token_result = client
    .exchange_client_credentials()
    .add_scope(Scope::new(<span class="string">&quot;read&quot;</span>.to_string()))
    .request(http_client)<span class="question-mark">?</span>;</code></pre></div>
<h2 id="device-code-flow"><a href="#device-code-flow">Device Code Flow</a></h2>
<p>Device Code Flow allows users to sign in on browserless or input-constrained
devices.  This is a two-stage process; first a user-code and verification
URL are obtained by using the <code>Client::exchange_client_credentials</code>
method. Those are displayed to the user, then are used in a second client
to poll the token endpoint for a token.</p>
<h3 id="example-3"><a href="#example-3">Example</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>anyhow;
<span class="kw">use </span>oauth2::{
    AuthUrl,
    ClientId,
    ClientSecret,
    DeviceAuthorizationUrl,
    Scope,
    TokenResponse,
    TokenUrl
};
<span class="kw">use </span>oauth2::basic::BasicClient;
<span class="kw">use </span>oauth2::devicecode::StandardDeviceAuthorizationResponse;
<span class="kw">use </span>oauth2::reqwest::http_client;
<span class="kw">use </span>url::Url;

<span class="kw">let </span>device_auth_url = DeviceAuthorizationUrl::new(<span class="string">&quot;http://deviceauth&quot;</span>.to_string())<span class="question-mark">?</span>;
<span class="kw">let </span>client =
    BasicClient::new(
        ClientId::new(<span class="string">&quot;client_id&quot;</span>.to_string()),
        <span class="prelude-val">Some</span>(ClientSecret::new(<span class="string">&quot;client_secret&quot;</span>.to_string())),
        AuthUrl::new(<span class="string">&quot;http://authorize&quot;</span>.to_string())<span class="question-mark">?</span>,
        <span class="prelude-val">Some</span>(TokenUrl::new(<span class="string">&quot;http://token&quot;</span>.to_string())<span class="question-mark">?</span>),
    )
    .set_device_authorization_url(device_auth_url);

<span class="kw">let </span>details: StandardDeviceAuthorizationResponse = client
    .exchange_device_code()<span class="question-mark">?
    </span>.add_scope(Scope::new(<span class="string">&quot;read&quot;</span>.to_string()))
    .request(http_client)<span class="question-mark">?</span>;

<span class="macro">println!</span>(
    <span class="string">&quot;Open this URL in your browser:\n{}\nand enter the code: {}&quot;</span>,
    details.verification_uri().to_string(),
    details.user_code().secret().to_string()
);

<span class="kw">let </span>token_result =
    client
    .exchange_device_access_token(<span class="kw-2">&amp;</span>details)
    .request(http_client, std::thread::sleep, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;
</code></pre></div>
<h2 id="other-examples"><a href="#other-examples">Other examples</a></h2>
<p>More specific implementations are available as part of the examples:</p>
<ul>
<li><a href="https://github.com/ramosbugs/oauth2-rs/blob/main/examples/google.rs">Google</a> (includes token revocation)</li>
<li><a href="https://github.com/ramosbugs/oauth2-rs/blob/main/examples/github.rs">Github</a></li>
<li><a href="https://github.com/ramosbugs/oauth2-rs/blob/main/examples/microsoft_devicecode.rs">Microsoft Device Code Flow (async)</a></li>
<li><a href="https://github.com/ramosbugs/oauth2-rs/blob/main/examples/msgraph.rs">Microsoft Graph</a></li>
<li><a href="https://github.com/ramosbugs/oauth2-rs/blob/main/examples/wunderlist.rs">Wunderlist</a></li>
</ul>
<h3 id="contributed-examples"><a href="#contributed-examples">Contributed Examples</a></h3>
<ul>
<li><a href="https://github.com/pka/actix-web-oauth2"><code>actix-web-oauth2</code></a> (version 2.x of this crate)</li>
</ul>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.http"><code>pub use <a class="mod" href="../http/index.html" title="mod http">http</a>;</code></div></li><li><div class="item-name" id="reexport.url"><code>pub use <a class="mod" href="../url/index.html" title="mod url">url</a>;</code></div></li><li><div class="item-name" id="reexport.DeviceAuthorizationResponse"><code>pub use devicecode::<a class="struct" href="devicecode/struct.DeviceAuthorizationResponse.html" title="struct oauth2::devicecode::DeviceAuthorizationResponse">DeviceAuthorizationResponse</a>;</code></div></li><li><div class="item-name" id="reexport.DeviceCodeErrorResponse"><code>pub use devicecode::<a class="type" href="devicecode/type.DeviceCodeErrorResponse.html" title="type oauth2::devicecode::DeviceCodeErrorResponse">DeviceCodeErrorResponse</a>;</code></div></li><li><div class="item-name" id="reexport.DeviceCodeErrorResponseType"><code>pub use devicecode::<a class="enum" href="devicecode/enum.DeviceCodeErrorResponseType.html" title="enum oauth2::devicecode::DeviceCodeErrorResponseType">DeviceCodeErrorResponseType</a>;</code></div></li><li><div class="item-name" id="reexport.EmptyExtraDeviceAuthorizationFields"><code>pub use devicecode::<a class="struct" href="devicecode/struct.EmptyExtraDeviceAuthorizationFields.html" title="struct oauth2::devicecode::EmptyExtraDeviceAuthorizationFields">EmptyExtraDeviceAuthorizationFields</a>;</code></div></li><li><div class="item-name" id="reexport.ExtraDeviceAuthorizationFields"><code>pub use devicecode::<a class="trait" href="devicecode/trait.ExtraDeviceAuthorizationFields.html" title="trait oauth2::devicecode::ExtraDeviceAuthorizationFields">ExtraDeviceAuthorizationFields</a>;</code></div></li><li><div class="item-name" id="reexport.StandardDeviceAuthorizationResponse"><code>pub use devicecode::<a class="type" href="devicecode/type.StandardDeviceAuthorizationResponse.html" title="type oauth2::devicecode::StandardDeviceAuthorizationResponse">StandardDeviceAuthorizationResponse</a>;</code></div></li><li><div class="item-name" id="reexport.RevocableToken"><code>pub use revocation::<a class="trait" href="revocation/trait.RevocableToken.html" title="trait oauth2::revocation::RevocableToken">RevocableToken</a>;</code></div></li><li><div class="item-name" id="reexport.RevocationErrorResponseType"><code>pub use revocation::<a class="enum" href="revocation/enum.RevocationErrorResponseType.html" title="enum oauth2::revocation::RevocationErrorResponseType">RevocationErrorResponseType</a>;</code></div></li><li><div class="item-name" id="reexport.StandardRevocableToken"><code>pub use revocation::<a class="enum" href="revocation/enum.StandardRevocableToken.html" title="enum oauth2::revocation::StandardRevocableToken">StandardRevocableToken</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="basic/index.html" title="mod oauth2::basic">basic</a></div><div class="desc docblock-short">Basic OAuth2 implementation with no extensions
(<a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a>).</div></li><li><div class="item-name"><a class="mod" href="devicecode/index.html" title="mod oauth2::devicecode">devicecode</a></div><div class="desc docblock-short">Device Code Flow OAuth2 implementation
(<a href="https://tools.ietf.org/html/rfc8628">RFC 8628</a>).</div></li><li><div class="item-name"><a class="mod" href="helpers/index.html" title="mod oauth2::helpers">helpers</a></div><div class="desc docblock-short">Helper methods used by OAuth2 implementations/extensions.</div></li><li><div class="item-name"><a class="mod" href="reqwest/index.html" title="mod oauth2::reqwest">reqwest</a></div><div class="desc docblock-short">HTTP client backed by the <a href="https://crates.io/crates/reqwest">reqwest</a> crate.
Requires “reqwest” feature.</div></li><li><div class="item-name"><a class="mod" href="revocation/index.html" title="mod oauth2::revocation">revocation</a></div><div class="desc docblock-short">OAuth 2.0 Token Revocation implementation
(<a href="https://tools.ietf.org/html/rfc7009">RFC 7009</a>).</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AccessToken.html" title="struct oauth2::AccessToken">AccessToken</a></div><div class="desc docblock-short">Access token returned by the token endpoint and used to access protected resources.</div></li><li><div class="item-name"><a class="struct" href="struct.AuthUrl.html" title="struct oauth2::AuthUrl">AuthUrl</a></div><div class="desc docblock-short">URL of the authorization server’s authorization endpoint.</div></li><li><div class="item-name"><a class="struct" href="struct.AuthorizationCode.html" title="struct oauth2::AuthorizationCode">AuthorizationCode</a></div><div class="desc docblock-short">Authorization code returned from the authorization endpoint.</div></li><li><div class="item-name"><a class="struct" href="struct.AuthorizationRequest.html" title="struct oauth2::AuthorizationRequest">AuthorizationRequest</a></div><div class="desc docblock-short">A request to the authorization endpoint</div></li><li><div class="item-name"><a class="struct" href="struct.Client.html" title="struct oauth2::Client">Client</a></div><div class="desc docblock-short">Stores the configuration for an OAuth2 client.</div></li><li><div class="item-name"><a class="struct" href="struct.ClientCredentialsTokenRequest.html" title="struct oauth2::ClientCredentialsTokenRequest">ClientCredentialsTokenRequest</a></div><div class="desc docblock-short">A request to exchange client credentials for an access token.</div></li><li><div class="item-name"><a class="struct" href="struct.ClientId.html" title="struct oauth2::ClientId">ClientId</a></div><div class="desc docblock-short">Client identifier issued to the client during the registration process described by
<a href="https://tools.ietf.org/html/rfc6749#section-2.2">Section 2.2</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ClientSecret.html" title="struct oauth2::ClientSecret">ClientSecret</a></div><div class="desc docblock-short">Client password issued to the client during the registration process described by
<a href="https://tools.ietf.org/html/rfc6749#section-2.2">Section 2.2</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.CodeTokenRequest.html" title="struct oauth2::CodeTokenRequest">CodeTokenRequest</a></div><div class="desc docblock-short">A request to exchange an authorization code for an access token.</div></li><li><div class="item-name"><a class="struct" href="struct.CsrfToken.html" title="struct oauth2::CsrfToken">CsrfToken</a></div><div class="desc docblock-short">Value used for <a href="https://tools.ietf.org/html/rfc6749#section-10.12">CSRF</a> protection
via the <code>state</code> parameter.</div></li><li><div class="item-name"><a class="struct" href="struct.DeviceAccessTokenRequest.html" title="struct oauth2::DeviceAccessTokenRequest">DeviceAccessTokenRequest</a></div><div class="desc docblock-short">The request for an device access token from the authorization server.</div></li><li><div class="item-name"><a class="struct" href="struct.DeviceAuthorizationRequest.html" title="struct oauth2::DeviceAuthorizationRequest">DeviceAuthorizationRequest</a></div><div class="desc docblock-short">The request for a set of verification codes from the authorization server.</div></li><li><div class="item-name"><a class="struct" href="struct.DeviceAuthorizationUrl.html" title="struct oauth2::DeviceAuthorizationUrl">DeviceAuthorizationUrl</a></div><div class="desc docblock-short">URL of the client’s device authorization endpoint.</div></li><li><div class="item-name"><a class="struct" href="struct.DeviceCode.html" title="struct oauth2::DeviceCode">DeviceCode</a></div><div class="desc docblock-short">Device code returned by the device authorization endpoint and used to query the token endpoint.</div></li><li><div class="item-name"><a class="struct" href="struct.EmptyExtraTokenFields.html" title="struct oauth2::EmptyExtraTokenFields">EmptyExtraTokenFields</a></div><div class="desc docblock-short">Empty (default) extra token fields.</div></li><li><div class="item-name"><a class="struct" href="struct.EndUserVerificationUrl.html" title="struct oauth2::EndUserVerificationUrl">EndUserVerificationUrl</a></div><div class="desc docblock-short">URL of the end-user verification URI on the authorization server.</div></li><li><div class="item-name"><a class="struct" href="struct.HttpRequest.html" title="struct oauth2::HttpRequest">HttpRequest</a></div><div class="desc docblock-short">An HTTP request.</div></li><li><div class="item-name"><a class="struct" href="struct.HttpResponse.html" title="struct oauth2::HttpResponse">HttpResponse</a></div><div class="desc docblock-short">An HTTP response.</div></li><li><div class="item-name"><a class="struct" href="struct.IntrospectionRequest.html" title="struct oauth2::IntrospectionRequest">IntrospectionRequest</a></div><div class="desc docblock-short">A request to introspect an access token.</div></li><li><div class="item-name"><a class="struct" href="struct.IntrospectionUrl.html" title="struct oauth2::IntrospectionUrl">IntrospectionUrl</a></div><div class="desc docblock-short">URL of the client’s <a href="https://tools.ietf.org/html/rfc7662">RFC 7662 OAuth 2.0 Token Introspection</a> endpoint.</div></li><li><div class="item-name"><a class="struct" href="struct.PasswordTokenRequest.html" title="struct oauth2::PasswordTokenRequest">PasswordTokenRequest</a></div><div class="desc docblock-short">A request to exchange resource owner credentials for an access token.</div></li><li><div class="item-name"><a class="struct" href="struct.PkceCodeChallenge.html" title="struct oauth2::PkceCodeChallenge">PkceCodeChallenge</a></div><div class="desc docblock-short">Code Challenge used for <a href="https://tools.ietf.org/html/rfc7636">PKCE</a> protection via the
<code>code_challenge</code> parameter.</div></li><li><div class="item-name"><a class="struct" href="struct.PkceCodeChallengeMethod.html" title="struct oauth2::PkceCodeChallengeMethod">PkceCodeChallengeMethod</a></div><div class="desc docblock-short">Code Challenge Method used for <a href="https://tools.ietf.org/html/rfc7636">PKCE</a> protection
via the <code>code_challenge_method</code> parameter.</div></li><li><div class="item-name"><a class="struct" href="struct.PkceCodeVerifier.html" title="struct oauth2::PkceCodeVerifier">PkceCodeVerifier</a></div><div class="desc docblock-short">Code Verifier used for <a href="https://tools.ietf.org/html/rfc7636">PKCE</a> protection via the
<code>code_verifier</code> parameter. The value must have a minimum length of 43 characters and a
maximum length of 128 characters.  Each character must be ASCII alphanumeric or one of
the characters “-” / “.” / “_” / “~”.</div></li><li><div class="item-name"><a class="struct" href="struct.RedirectUrl.html" title="struct oauth2::RedirectUrl">RedirectUrl</a></div><div class="desc docblock-short">URL of the client’s redirection endpoint.</div></li><li><div class="item-name"><a class="struct" href="struct.RefreshToken.html" title="struct oauth2::RefreshToken">RefreshToken</a></div><div class="desc docblock-short">Refresh token used to obtain a new access token (if supported by the authorization server).</div></li><li><div class="item-name"><a class="struct" href="struct.RefreshTokenRequest.html" title="struct oauth2::RefreshTokenRequest">RefreshTokenRequest</a></div><div class="desc docblock-short">A request to exchange a refresh token for an access token.</div></li><li><div class="item-name"><a class="struct" href="struct.ResourceOwnerPassword.html" title="struct oauth2::ResourceOwnerPassword">ResourceOwnerPassword</a></div><div class="desc docblock-short">Resource owner’s password used directly as an authorization grant to obtain an access
token.</div></li><li><div class="item-name"><a class="struct" href="struct.ResourceOwnerUsername.html" title="struct oauth2::ResourceOwnerUsername">ResourceOwnerUsername</a></div><div class="desc docblock-short">Resource owner’s username used directly as an authorization grant to obtain an access
token.</div></li><li><div class="item-name"><a class="struct" href="struct.ResponseType.html" title="struct oauth2::ResponseType">ResponseType</a></div><div class="desc docblock-short">Authorization endpoint response (grant) type defined in
<a href="https://tools.ietf.org/html/rfc6749#section-3.1.1">Section 3.1.1</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RevocationRequest.html" title="struct oauth2::RevocationRequest">RevocationRequest</a></div><div class="desc docblock-short">A request to revoke a token via an <a href="https://tools.ietf.org/html/rfc7009#section-2.1"><code>RFC 7009</code></a> compatible
endpoint.</div></li><li><div class="item-name"><a class="struct" href="struct.RevocationUrl.html" title="struct oauth2::RevocationUrl">RevocationUrl</a></div><div class="desc docblock-short">URL of the authorization server’s RFC 7009 token revocation endpoint.</div></li><li><div class="item-name"><a class="struct" href="struct.Scope.html" title="struct oauth2::Scope">Scope</a></div><div class="desc docblock-short">Access token scope, as defined by the authorization server.</div></li><li><div class="item-name"><a class="struct" href="struct.StandardErrorResponse.html" title="struct oauth2::StandardErrorResponse">StandardErrorResponse</a></div><div class="desc docblock-short">Error response returned by server after requesting an access token.</div></li><li><div class="item-name"><a class="struct" href="struct.StandardTokenIntrospectionResponse.html" title="struct oauth2::StandardTokenIntrospectionResponse">StandardTokenIntrospectionResponse</a></div><div class="desc docblock-short">Standard OAuth2 token introspection response.</div></li><li><div class="item-name"><a class="struct" href="struct.StandardTokenResponse.html" title="struct oauth2::StandardTokenResponse">StandardTokenResponse</a></div><div class="desc docblock-short">Standard OAuth2 token response.</div></li><li><div class="item-name"><a class="struct" href="struct.TokenUrl.html" title="struct oauth2::TokenUrl">TokenUrl</a></div><div class="desc docblock-short">URL of the authorization server’s token endpoint.</div></li><li><div class="item-name"><a class="struct" href="struct.UserCode.html" title="struct oauth2::UserCode">UserCode</a></div><div class="desc docblock-short">User code returned by the device authorization endpoint and used by the user to authorize at
the verification URI.</div></li><li><div class="item-name"><a class="struct" href="struct.VerificationUriComplete.html" title="struct oauth2::VerificationUriComplete">VerificationUriComplete</a></div><div class="desc docblock-short">Verification URI returned by the device authorization endpoint and visited by the user
to authorize.  Contains the user code.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AuthType.html" title="enum oauth2::AuthType">AuthType</a></div><div class="desc docblock-short">Indicates whether requests to the authorization server should use basic authentication or
include the parameters in the request body for requests in which either is valid.</div></li><li><div class="item-name"><a class="enum" href="enum.ConfigurationError.html" title="enum oauth2::ConfigurationError">ConfigurationError</a></div><div class="desc docblock-short">There was a problem configuring the request.</div></li><li><div class="item-name"><a class="enum" href="enum.RequestTokenError.html" title="enum oauth2::RequestTokenError">RequestTokenError</a></div><div class="desc docblock-short">Error encountered while requesting access token.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ErrorResponse.html" title="trait oauth2::ErrorResponse">ErrorResponse</a></div><div class="desc docblock-short">Server Error Response</div></li><li><div class="item-name"><a class="trait" href="trait.ErrorResponseType.html" title="trait oauth2::ErrorResponseType">ErrorResponseType</a></div><div class="desc docblock-short">Error types enum.</div></li><li><div class="item-name"><a class="trait" href="trait.ExtraTokenFields.html" title="trait oauth2::ExtraTokenFields">ExtraTokenFields</a></div><div class="desc docblock-short">Trait for adding extra fields to the <code>TokenResponse</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.TokenIntrospectionResponse.html" title="trait oauth2::TokenIntrospectionResponse">TokenIntrospectionResponse</a></div><div class="desc docblock-short">Common methods shared by all OAuth2 token introspection implementations.</div></li><li><div class="item-name"><a class="trait" href="trait.TokenResponse.html" title="trait oauth2::TokenResponse">TokenResponse</a></div><div class="desc docblock-short">Common methods shared by all OAuth2 token implementations.</div></li><li><div class="item-name"><a class="trait" href="trait.TokenType.html" title="trait oauth2::TokenType">TokenType</a></div><div class="desc docblock-short">Trait for OAuth2 access tokens.</div></li></ul></section></div></main></body></html>