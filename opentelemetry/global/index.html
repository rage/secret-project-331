<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Utilities for working with global telemetry primitives"><meta name="keywords" content="rust, rustlang, rust-lang, global"><title>opentelemetry::global - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../opentelemetry/index.html'><div class='logo-container'><img src='https://raw.githubusercontent.com/open-telemetry/opentelemetry-rust/main/assets/logo.svg' alt='logo'></div></a><p class="location">Module global</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><p class="location"><a href="../index.html">opentelemetry</a></p><div id="sidebar-vars" data-name="global" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">opentelemetry</a>::<wbr><a class="mod" href="">global</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/opentelemetry/global/mod.rs.html#1-161" title="goto source code">[src]</a></span></h1><div class="docblock"><p>Utilities for working with global telemetry primitives</p>
<h2 id="global-trace-api" class="section-header"><a href="#global-trace-api">Global Trace API</a></h2>
<p>The global trace API <strong>provides applications access to their configured
<a href="../trace/trait.TracerProvider.html"><code>TracerProvider</code></a> instance from anywhere in the codebase</strong>. This allows
applications to be less coupled to the specific Open Telemetry SDK while not
manually passing references to each part of the code that needs to create
<a href="../trace/trait.Span.html"><code>Span</code></a>s. Additionally, <strong>3rd party middleware</strong> or <strong>library code</strong> can be
written against this generic API and not constrain users to a specific
implementation choice.</p>
<h3 id="usage-in-applications" class="section-header"><a href="#usage-in-applications">Usage in Applications</a></h3>
<p>Applications configure their tracer either by <a href="crate::sdk::export::trace::stdout::PipelineBuilder::install">installing a trace pipeline</a>,
or calling <a href="fn.set_tracer_provider.html" title="set_tracer_provider"><code>set_tracer_provider</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">opentelemetry::trace</span>::{<span class="ident">Tracer</span>, <span class="ident">NoopTracerProvider</span>};
<span class="kw">use</span> <span class="ident">opentelemetry::global</span>;

<span class="kw">fn</span> <span class="ident">init_tracer</span>() {
    <span class="kw">let</span> <span class="ident">provider</span> <span class="op">=</span> <span class="ident">NoopTracerProvider::new</span>();

    <span class="comment">// Configure the global `TracerProvider` singleton when your app starts</span>
    <span class="comment">// (there is a no-op default if this is not set by your application)</span>
    <span class="kw">let</span> <span class="kw">_</span> <span class="op">=</span> <span class="ident">global::set_tracer_provider</span>(<span class="ident">provider</span>);
}

<span class="kw">fn</span> <span class="ident">do_something_tracked</span>() {
    <span class="comment">// Then you can get a named tracer instance anywhere in your codebase.</span>
    <span class="kw">let</span> <span class="ident">tracer</span> <span class="op">=</span> <span class="ident">global::tracer</span>(<span class="string">&quot;my-component&quot;</span>);

    <span class="ident">tracer</span>.<span class="ident">in_span</span>(<span class="string">&quot;doing_work&quot;</span>, <span class="op">|</span><span class="ident">cx</span><span class="op">|</span> {
        <span class="comment">// Traced app logic here...</span>
    });
}

<span class="comment">// in main or other app start</span>
<span class="kw">let</span> <span class="kw">_</span> <span class="op">=</span> <span class="ident">init_tracer</span>();
<span class="ident">do_something_tracked</span>();</pre></div>
<h3 id="usage-in-libraries" class="section-header"><a href="#usage-in-libraries">Usage in Libraries</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">opentelemetry::trace::Tracer</span>;
<span class="kw">use</span> <span class="ident">opentelemetry::global</span>;

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">my_traced_library_function</span>() {
    <span class="comment">// End users of your library will configure their global tracer provider</span>
    <span class="comment">// so you can use the global tracer without any setup</span>
    <span class="kw">let</span> <span class="ident">tracer</span> <span class="op">=</span> <span class="ident">global::tracer_with_version</span>(<span class="string">&quot;my-library-name&quot;</span>, <span class="macro">env!</span>(<span class="string">&quot;CARGO_PKG_VERSION&quot;</span>));

    <span class="ident">tracer</span>.<span class="ident">in_span</span>(<span class="string">&quot;doing_library_work&quot;</span>, <span class="op">|</span><span class="ident">cx</span><span class="op">|</span> {
        <span class="comment">// Traced library logic here...</span>
    });
}</pre></div>
<h2 id="global-metrics-api" class="section-header"><a href="#global-metrics-api">Global Metrics API</a></h2>
<p>The global metrics API <strong>provides applications access to their configured
<a href="crate::metrics::MeterProvider"><code>MeterProvider</code></a> instance from anywhere in the codebase</strong>. This allows
applications to be less coupled to the specific Open Telemetry SDK while not
manually passing references to each part of the code that needs to create
metric instruments. Additionally, <strong>3rd party middleware</strong> or <strong>library code</strong> can be
written against this generic API and not constrain users to a specific
implementation choice.</p>
<h3 id="usage-in-applications-1" class="section-header"><a href="#usage-in-applications-1">Usage in Applications</a></h3>
<p>Applications configure their tracer either by <a href="crate::sdk::export::metrics::stdout::StdoutExporterBuilder::try_init">installing a metrics pipeline</a>,
or calling <a href="crate::global::set_meter_provider"><code>set_meter_provider</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">opentelemetry::metrics</span>::{<span class="ident">Meter</span>, <span class="ident">noop::NoopMeterProvider</span>};
<span class="kw">use</span> <span class="ident">opentelemetry</span>::{<span class="ident">global</span>, <span class="ident">KeyValue</span>};

<span class="kw">fn</span> <span class="ident">init_meter</span>() {
    <span class="kw">let</span> <span class="ident">provider</span> <span class="op">=</span> <span class="ident">NoopMeterProvider::new</span>();

    <span class="comment">// Configure the global `MeterProvider` singleton when your app starts</span>
    <span class="comment">// (there is a no-op default if this is not set by your application)</span>
    <span class="ident">global::set_meter_provider</span>(<span class="ident">provider</span>)
}

<span class="kw">fn</span> <span class="ident">do_something_instrumented</span>() {
    <span class="comment">// Then you can get a named tracer instance anywhere in your codebase.</span>
    <span class="kw">let</span> <span class="ident">tracer</span> <span class="op">=</span> <span class="ident">global::meter</span>(<span class="string">&quot;my-component&quot;</span>);
    <span class="kw">let</span> <span class="ident">counter</span> <span class="op">=</span> <span class="ident">tracer</span>.<span class="ident">u64_counter</span>(<span class="string">&quot;my_counter&quot;</span>).<span class="ident">init</span>();

    <span class="comment">// record metrics</span>
    <span class="ident">counter</span>.<span class="ident">add</span>(<span class="number">1</span>, <span class="kw-2">&amp;</span>[<span class="ident">KeyValue::new</span>(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;myvalue&quot;</span>)]);
}

<span class="comment">// in main or other app start</span>
<span class="ident">init_meter</span>();
<span class="ident">do_something_instrumented</span>();</pre></div>
<h3 id="usage-in-libraries-1" class="section-header"><a href="#usage-in-libraries-1">Usage in Libraries</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">opentelemetry::trace::Tracer</span>;
<span class="kw">use</span> <span class="ident">opentelemetry</span>::{<span class="ident">global</span>, <span class="ident">KeyValue</span>};

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">my_traced_library_function</span>() {
    <span class="comment">// End users of your library will configure their global meter provider</span>
    <span class="comment">// so you can use the global meter without any setup</span>
    <span class="kw">let</span> <span class="ident">tracer</span> <span class="op">=</span> <span class="ident">global::meter</span>(<span class="string">&quot;my-library-name&quot;</span>);
    <span class="kw">let</span> <span class="ident">counter</span> <span class="op">=</span> <span class="ident">tracer</span>.<span class="ident">u64_counter</span>(<span class="string">&quot;my_counter&quot;</span>).<span class="ident">init</span>();

    <span class="comment">// record metrics</span>
    <span class="ident">counter</span>.<span class="ident">add</span>(<span class="number">1</span>, <span class="kw-2">&amp;</span>[<span class="ident">KeyValue::new</span>(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;myvalue&quot;</span>)]);
}</pre></div>
</div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.BoxedSpan.html" title="opentelemetry::global::BoxedSpan struct">BoxedSpan</a></td><td class="docblock-short"><p>Wraps the <a href="struct.BoxedTracer.html" title="BoxedTracer"><code>BoxedTracer</code></a>’s <a href="../trace/trait.Span.html"><code>Span</code></a> so it can be used generically by
applications without knowing the underlying type.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.BoxedTracer.html" title="opentelemetry::global::BoxedTracer struct">BoxedTracer</a></td><td class="docblock-short"><p>Wraps the <a href="struct.GlobalTracerProvider.html"><code>GlobalTracerProvider</code></a>’s <a href="../trace/trait.Tracer.html"><code>Tracer</code></a> so it can be used generically by
applications without knowing the underlying type.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.GlobalTracerProvider.html" title="opentelemetry::global::GlobalTracerProvider struct">GlobalTracerProvider</a></td><td class="docblock-short"><p>Represents the globally configured <a href="../trace/trait.TracerProvider.html"><code>TracerProvider</code></a> instance for this
application. This allows generic tracing through the returned
<a href="struct.BoxedTracer.html" title="BoxedTracer"><code>BoxedTracer</code></a> instances.</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.GenericTracer.html" title="opentelemetry::global::GenericTracer trait">GenericTracer</a></td><td class="docblock-short"><p>Allows a specific <a href="../trace/trait.Tracer.html"><code>Tracer</code></a> to be used generically by <a href="struct.BoxedTracer.html" title="BoxedTracer"><code>BoxedTracer</code></a>
instances by mirroring the interface and boxing the return types.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.GenericTracerProvider.html" title="opentelemetry::global::GenericTracerProvider trait">GenericTracerProvider</a></td><td class="docblock-short"><p>Allows a specific <a href="../trace/trait.TracerProvider.html"><code>TracerProvider</code></a> to be used generically by the
<a href="struct.GlobalTracerProvider.html"><code>GlobalTracerProvider</code></a> by mirroring the interface and boxing the return types.</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.get_text_map_propagator.html" title="opentelemetry::global::get_text_map_propagator fn">get_text_map_propagator</a></td><td class="docblock-short"><p>Executes a closure with a reference to the current global <a href="../propagation/text_map_propagator/trait.TextMapPropagator.html" title="TextMapPropagator"><code>TextMapPropagator</code></a> propagator.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.handle_error.html" title="opentelemetry::global::handle_error fn">handle_error</a></td><td class="docblock-short"><p>Handle error using the globally configured error handler.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.set_error_handler.html" title="opentelemetry::global::set_error_handler fn">set_error_handler</a></td><td class="docblock-short"><p>Set global error handler.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.set_text_map_propagator.html" title="opentelemetry::global::set_text_map_propagator fn">set_text_map_propagator</a></td><td class="docblock-short"><p>Sets the given <a href="../propagation/text_map_propagator/trait.TextMapPropagator.html" title="TextMapPropagator"><code>TextMapPropagator</code></a> propagator as the current global propagator.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.set_tracer_provider.html" title="opentelemetry::global::set_tracer_provider fn">set_tracer_provider</a></td><td class="docblock-short"><p>Sets the given <a href="../trace/trait.TracerProvider.html"><code>TracerProvider</code></a> instance as the current global provider.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.shutdown_tracer_provider.html" title="opentelemetry::global::shutdown_tracer_provider fn">shutdown_tracer_provider</a></td><td class="docblock-short"><p>Shut down the current tracer provider. This will invoke the shutdown method on all span processors.
span processors should export remaining spans before return</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.tracer.html" title="opentelemetry::global::tracer fn">tracer</a></td><td class="docblock-short"><p>Creates a named instance of <a href="../trace/trait.Tracer.html"><code>Tracer</code></a> via the configured <a href="struct.GlobalTracerProvider.html" title="GlobalTracerProvider"><code>GlobalTracerProvider</code></a>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.tracer_provider.html" title="opentelemetry::global::tracer_provider fn">tracer_provider</a></td><td class="docblock-short"><p>Returns an instance of the currently configured global <a href="../trace/trait.TracerProvider.html"><code>TracerProvider</code></a> through
<a href="struct.GlobalTracerProvider.html"><code>GlobalTracerProvider</code></a>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.tracer_with_version.html" title="opentelemetry::global::tracer_with_version fn">tracer_with_version</a></td><td class="docblock-short"><p>Creates a named instance of <a href="../trace/trait.Tracer.html"><code>Tracer</code></a> with version info via the configured <a href="struct.GlobalTracerProvider.html" title="GlobalTracerProvider"><code>GlobalTracerProvider</code></a></p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="opentelemetry" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script></body></html>