<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Deserialization Flavors"><title>postcard::de_flavors - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="postcard" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../postcard/index.html">postcard</a><span class="version">1.0.8</span></h2></div><h2 class="location"><a href="#">Module de_flavors</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section><h2><a href="../index.html">In crate postcard</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../postcard/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">postcard</a>::<wbr><a class="mod" href="#">de_flavors</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/postcard/de/flavors.rs.html#1-468">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="deserialization-flavors"><a href="#deserialization-flavors">Deserialization Flavors</a></h2>
<p>“Flavors” in <code>postcard</code> are used as modifiers to the serialization or deserialization
process. Flavors typically modify one or both of the following:</p>
<ol>
<li>The source medium of the deserialization, e.g. whether the data is serialized from a <code>[u8]</code> slice, or some other container</li>
<li>The format of the deserialization, such as if the original data is encoded in a COBS format, contains a CRC32 checksum
appended to the message, etc.</li>
</ol>
<p>Flavors are implemented using the <a href="trait.Flavor.html" title="trait postcard::de_flavors::Flavor"><code>Flavor</code></a> trait, which acts as a “middleware” for retrieving the bytes before they
are passed to <code>serde</code> for deserialization</p>
<p>Multiple flavors may be combined to obtain a desired combination of behavior and storage.
When flavors are combined, it is expected that the storage flavor (such as <a href="struct.Slice.html" title="struct postcard::de_flavors::Slice"><code>Slice</code></a>) is the innermost flavor.</p>
<p>Custom flavors may be defined by users of the <code>postcard</code> crate, however some commonly useful flavors have been provided in
this module. If you think your custom flavor would be useful to others, PRs adding flavors are very welcome!</p>
<h3 id="usability"><a href="#usability">Usability</a></h3>
<p>Flavors may not always be convenient to use directly, as they may expose some implementation details of how the
inner workings of the flavor behaves. It is typical to provide a convenience method for using a flavor, to prevent
the user from having to specify generic parameters, setting correct initialization values, or handling the output of
the flavor correctly. See <code>postcard::from_bytes()</code> for an example of this.</p>
<h3 id="when-to-use-multiple-flavors"><a href="#when-to-use-multiple-flavors">When to use (multiple) flavors</a></h3>
<p>Combining flavors are nice for convenience, as they perform potentially multiple steps of
serialization at one time.</p>
<p>This can often be more memory efficient, as intermediate buffers are not typically required.</p>
<h3 id="when-not-to-use-multiple-flavors"><a href="#when-not-to-use-multiple-flavors">When NOT to use (multiple) flavors</a></h3>
<p>The downside of passing deserialization through multiple steps is that it is typically slower than
performing each step serially. Said simply, “cobs decoding while deserializing” is often slower
than “cobs decode then deserialize”, due to the ability to handle longer “runs” of data in each
stage. The downside is that if these stages can not be performed in-place on the buffer, you
will need additional buffers for each stage.</p>
<p>Additionally, deserializating flavors can be more restrictive or difficult to work with than
serialization flavors, as deserialization may require that the deserialized types borrow some
portion of the original message.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3><h4 id="using-a-single-flavor"><a href="#using-a-single-flavor">Using a single flavor</a></h4>
<p>In the first example, we use the <code>Slice</code> flavor, to retrieve the serialized output from a <code>[u8]</code> slice.
No other modification is made to the serialization process.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>postcard::{
    de_flavors::Slice,
    Deserializer,
};
<span class="kw">use </span>serde::Deserialize;

<span class="attr">#[derive(Deserialize, Debug, PartialEq)]
</span><span class="kw">struct </span>Tup(u8, u8, u8);

<span class="kw">let </span>msg = [<span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>];
<span class="kw">let </span>slice = Slice::new(<span class="kw-2">&amp;</span>msg);
<span class="kw">let </span><span class="kw-2">mut </span>deserializer = Deserializer::from_flavor(slice);
<span class="kw">let </span>t = Tup::deserialize(<span class="kw-2">&amp;mut </span>deserializer).unwrap();
<span class="macro">assert_eq!</span>(t, Tup(<span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));
<span class="kw">let </span>remainder = deserializer.finalize().unwrap();
<span class="macro">assert_eq!</span>(remainder, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre></div>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="io/index.html" title="mod postcard::de_flavors::io">io</a></div><div class="desc docblock-short">Support for [std::io] or [embedded-io] traits</div></li></ul><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Slice.html" title="struct postcard::de_flavors::Slice">Slice</a></div><div class="desc docblock-short">A simple <a href="trait.Flavor.html" title="trait postcard::de_flavors::Flavor"><code>Flavor</code></a> representing the deserialization from a borrowed slice</div></li></ul><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Flavor.html" title="trait postcard::de_flavors::Flavor">Flavor</a></div><div class="desc docblock-short">The deserialization Flavor trait</div></li></ul></section></div></main></body></html>