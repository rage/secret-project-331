<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Run the closure on the provided stack."><title>on_stack in psm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="psm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0 (82e1608df 2023-12-21)" data-channel="1.75.0" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../psm/index.html">psm</a><span class="version">0.1.21</span></h2></div><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">psm</a>::<wbr><a class="fn" href="#">on_stack</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/psm/lib.rs.html#181-207">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe fn on_stack&lt;R, F: <a class="trait" href="https://doc.rust-lang.org/1.75.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; R&gt;(
    base: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/core/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.75.0/core/primitive.u8.html">u8</a>,
    size: <a class="primitive" href="https://doc.rust-lang.org/1.75.0/core/primitive.usize.html">usize</a>,
    callback: F
) -&gt; R</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Run the closure on the provided stack.</p>
<p>Once the closure completes its execution, the original stack pointer is restored and execution
returns to the caller.</p>
<p><code>base</code> address must be the low address of the stack memory region, regardless of the stack
growth direction. It is not necessary for the whole region <code>[base; base + size]</code> to be usable
at the time this function called, however it is required that at least the following hold:</p>
<ul>
<li>Both <code>base</code> and <code>base + size</code> are aligned up to the target-specific requirements;</li>
<li>Depending on <code>StackDirection</code> value for the platform, the end of the stack memory region,
which would end up containing the first frame(s), must have sufficient number of pages
allocated to execute code until more pages are commited. The other end should contain a guard
page (not writable, readable or executable) to ensure Rust’s soundness guarantees.</li>
</ul>
<p>Note, that some or all of these considerations are irrelevant to some applications. For
example, Rust’s soundness story relies on all stacks having a guard-page, however if the user
is able to guarantee that the memory region used for stack cannot be exceeded, a guard page may
end up being an expensive unnecessity.</p>
<p>The previous stack may not be deallocated. If an ability to deallocate the old stack is desired
consider <code>replace_stack</code> instead.</p>
<h2 id="guidelines"><a href="#guidelines">Guidelines</a></h2>
<p>Memory regions that are aligned to a single page (usually 4kB) are an extremely portable choice
for stacks.</p>
<p>Allocate at least 4kB of stack. Some architectures (such as SPARC) consume stack memory
significantly faster compared to the more usual architectures such as x86 or ARM. Allocating
less than 4kB of memory may make it impossible to commit more pages without overflowing the
stack later on.</p>
<h2 id="unsafety"><a href="#unsafety">Unsafety</a></h2>
<p>The stack <code>base</code> address must be aligned as appropriate for the target.</p>
<p>The stack <code>size</code> must be a multiple of stack alignment required by target.</p>
<p>The <code>size</code> must not overflow <code>isize</code>.</p>
<p><code>callback</code> must not unwind or return control flow by any other means than directly returning.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::alloc;
<span class="kw">const </span>STACK_ALIGN: usize = <span class="number">4096</span>;
<span class="kw">const </span>STACK_SIZE: usize = <span class="number">4096</span>;
<span class="kw">unsafe </span>{
    <span class="kw">let </span>layout = alloc::Layout::from_size_align(STACK_SIZE, STACK_ALIGN).unwrap();
    <span class="kw">let </span>new_stack = alloc::alloc(layout);
    <span class="macro">assert!</span>(!new_stack.is_null(), <span class="string">&quot;allocations must succeed!&quot;</span>);
    <span class="kw">let </span>(stack, result) = psm::on_stack(new_stack, STACK_SIZE, || {
        (psm::stack_pointer(), <span class="number">4 </span>+ <span class="number">4</span>)
    });
    <span class="macro">println!</span>(<span class="string">&quot;4 + 4 = {} has been calculated on stack {:p}&quot;</span>, result, stack);
}</code></pre></div>
</div></details></section></div></main></body></html>