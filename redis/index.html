<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="redis-rs is a Rust implementation of a client library for Redis.  It exposes a general purpose interface to Redis and also provides specific helpers for commonly used functionality."><title>redis - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="redis" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.1 (e71f9a9a9 2025-01-27)" data-channel="1.84.1" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../redis/index.html">redis</a><span class="version">0.28.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#basic-operation" title="Basic Operation">Basic Operation</a></li><li><a href="#tls--ssl" title="TLS / SSL">TLS / SSL</a><ul><li><a href="#connection-handling" title="Connection Handling">Connection Handling</a></li><li><a href="#connection-pooling" title="Connection Pooling">Connection Pooling</a></li><li><a href="#optional-features" title="Optional Features">Optional Features</a></li><li><a href="#connection-parameters" title="Connection Parameters">Connection Parameters</a></li><li><a href="#executing-low-level-commands" title="Executing Low-Level Commands">Executing Low-Level Commands</a></li><li><a href="#executing-high-level-commands" title="Executing High-Level Commands">Executing High-Level Commands</a></li><li><a href="#type-conversions" title="Type Conversions">Type Conversions</a></li></ul></li><li><a href="#resp3-support" title="RESP3 support">RESP3 support</a></li><li><a href="#iteration-protocol" title="Iteration Protocol">Iteration Protocol</a></li><li><a href="#pipelining" title="Pipelining">Pipelining</a></li><li><a href="#transactions" title="Transactions">Transactions</a></li><li><a href="#pubsub" title="PubSub">PubSub</a><ul><li><a href="#resp3-async-pubsub" title="RESP3 async pubsub">RESP3 async pubsub</a></li></ul></li><li><a href="#scripts" title="Scripts">Scripts</a></li><li><a href="#async" title="Async">Async</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>redis</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/redis/lib.rs.html#1-661">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>redis-rs is a Rust implementation of a client library for Redis.  It exposes
a general purpose interface to Redis and also provides specific helpers for
commonly used functionality.</p>
<p>The crate is called <code>redis</code> and you can depend on it via cargo:</p>
<div class="example-wrap"><pre class="language-ini"><code>[dependencies.redis]
version = &quot;*&quot;</code></pre></div>
<p>If you want to use the git version:</p>
<div class="example-wrap"><pre class="language-ini"><code>[dependencies.redis]
git = &quot;https://github.com/redis-rs/redis-rs.git&quot;</code></pre></div><h2 id="basic-operation"><a class="doc-anchor" href="#basic-operation">§</a>Basic Operation</h2>
<p>redis-rs exposes two API levels: a low- and a high-level part.
The high-level part does not expose all the functionality of redis and
might take some liberties in how it speaks the protocol.  The low-level
part of the API allows you to express any request on the redis level.
You can fluently switch between both API levels at any point.</p>
<h2 id="tls--ssl"><a class="doc-anchor" href="#tls--ssl">§</a>TLS / SSL</h2>
<p>The user can enable TLS support using either RusTLS or native support (usually OpenSSL),
using the <code>tls-rustls</code> or <code>tls-native-tls</code> features respectively. In order to enable TLS
for async usage, the user must enable matching features for their runtime - either <code>tokio-native-tls-comp``, </code>tokio-rustls-comp<code>, </code>async-std-native-tls-comp<code>, or </code>async-std-rustls-comp<code>. Additionally, the </code>tls-rustls-webpki-roots` allows usage of of webpki-roots for the root certificate store.</p>
<h3 id="connection-handling"><a class="doc-anchor" href="#connection-handling">§</a>Connection Handling</h3>
<p>For connecting to redis you can use a client object which then can produce
actual connections.  Connections and clients as well as results of
connections and clients are considered <code>ConnectionLike</code> objects and
can be used anywhere a request is made.</p>
<p>The full canonical way to get a connection is to create a client and
to ask for a connection from it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>redis;

<span class="kw">fn </span>do_something() -&gt; redis::RedisResult&lt;()&gt; {
    <span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>con = client.get_connection()<span class="question-mark">?</span>;

    <span class="comment">/* do something here */

    </span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="connection-pooling"><a class="doc-anchor" href="#connection-pooling">§</a>Connection Pooling</h3>
<p>When using a sync connection, it is recommended to use a connection pool in order to handle
disconnects or multi-threaded usage. This can be done using the <code>r2d2</code> feature.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>redis::Commands;

<span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>).unwrap();
<span class="kw">let </span>pool = r2d2::Pool::builder().build(client).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>conn = pool.get().unwrap();

<span class="kw">let _</span>: () = conn.set(<span class="string">"KEY"</span>, <span class="string">"VALUE"</span>).unwrap();
<span class="kw">let </span>val: String = conn.get(<span class="string">"KEY"</span>).unwrap();</code></pre></div>
<p>For async connections, connection pooling isn’t necessary. The <code>MultiplexedConnection</code> is
cloneable and can be used safely from multiple threads, so a single connection can be easily
reused. For automatic reconnections consider using <code>ConnectionManager</code> with the <code>connection-manager</code> feature.
Async cluster connections also don’t require pooling and are thread-safe and reusable.</p>
<h3 id="optional-features"><a class="doc-anchor" href="#optional-features">§</a>Optional Features</h3>
<p>There are a few features defined that can enable additional functionality
if so desired.  Some of them are turned on by default.</p>
<ul>
<li><code>acl</code>: enables acl support (enabled by default)</li>
<li><code>tokio-comp</code>: enables support for async usage with the Tokio runtime (optional)</li>
<li><code>async-std-comp</code>: enables support for async usage with any runtime which is async-std compliant, such as Smol. (optional)</li>
<li><code>geospatial</code>: enables geospatial support (enabled by default)</li>
<li><code>script</code>: enables script support (enabled by default)</li>
<li><code>streams</code>: enables high-level interface for interaction with Redis streams (enabled by default)</li>
<li><code>r2d2</code>: enables r2d2 connection pool support (optional)</li>
<li><code>ahash</code>: enables ahash map/set support &amp; uses ahash internally (+7-10% performance) (optional)</li>
<li><code>cluster</code>: enables redis cluster support (optional)</li>
<li><code>cluster-async</code>: enables async redis cluster support (optional)</li>
<li><code>connection-manager</code>: enables support for automatic reconnection (optional)</li>
<li><code>keep-alive</code>: enables keep-alive option on socket by means of <code>socket2</code> crate (enabled by default)</li>
<li><code>tcp_nodelay</code>: enables the no-delay flag on  communication sockets (optional)</li>
<li><code>rust_decimal</code>, <code>bigdecimal</code>, <code>num-bigint</code>: enables type conversions to large number representation from different crates (optional)</li>
<li><code>uuid</code>: enables type conversion to UUID (optional)</li>
<li><code>sentinel</code>: enables high-level interfaces for communication with Redis sentinels (optional)</li>
<li><code>json</code>: enables high-level interfaces for communication with the JSON module (optional)</li>
</ul>
<h3 id="connection-parameters"><a class="doc-anchor" href="#connection-parameters">§</a>Connection Parameters</h3>
<p>redis-rs knows different ways to define where a connection should
go.  The parameter to <code>Client::open</code> needs to implement the
<code>IntoConnectionInfo</code> trait of which there are three implementations:</p>
<ul>
<li>string slices in <code>redis://</code> URL format.</li>
<li>URL objects from the redis-url crate.</li>
<li><code>ConnectionInfo</code> objects.</li>
</ul>
<p>The URL format is <code>redis://[&lt;username&gt;][:&lt;password&gt;@]&lt;hostname&gt;[:port][/[&lt;db&gt;][?protocol=&lt;protocol&gt;]]</code></p>
<p>If Unix socket support is available you can use a unix URL in this format:</p>
<p><code>redis+unix:///&lt;path&gt;[?db=&lt;db&gt;[&amp;pass=&lt;password&gt;][&amp;user=&lt;username&gt;][&amp;protocol=&lt;protocol&gt;]]</code></p>
<p>For compatibility with some other libraries for Redis, the “unix” scheme
is also supported:</p>
<p><code>unix:///&lt;path&gt;[?db=&lt;db&gt;][&amp;pass=&lt;password&gt;][&amp;user=&lt;username&gt;][&amp;protocol=&lt;protocol&gt;]]</code></p>
<h3 id="executing-low-level-commands"><a class="doc-anchor" href="#executing-low-level-commands">§</a>Executing Low-Level Commands</h3>
<p>To execute low-level commands you can use the <code>cmd</code> function which allows
you to build redis requests.  Once you have configured a command object
to your liking you can send a query into any <code>ConnectionLike</code> object:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>do_something(con: <span class="kw-2">&amp;mut </span>redis::Connection) -&gt; redis::RedisResult&lt;()&gt; {
    redis::cmd(<span class="string">"SET"</span>).arg(<span class="string">"my_key"</span>).arg(<span class="number">42</span>).exec(con)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Upon querying the return value is a result object.  If you do not care
about the actual return value (other than that it is not a failure)
you can always type annotate it to the unit type <code>()</code>.</p>
<p>Note that commands with a sub-command (like “MEMORY USAGE”, “ACL WHOAMI”,
“LATENCY HISTORY”, etc) must specify the sub-command as a separate <code>arg</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>do_something(con: <span class="kw-2">&amp;mut </span>redis::Connection) -&gt; redis::RedisResult&lt;usize&gt; {
    <span class="comment">// This will result in a server error: "unknown command `MEMORY USAGE`"
    // because "USAGE" is technically a sub-command of "MEMORY".
    </span>redis::cmd(<span class="string">"MEMORY USAGE"</span>).arg(<span class="string">"my_key"</span>).query::&lt;usize&gt;(con)<span class="question-mark">?</span>;

    <span class="comment">// However, this will work as you'd expect
    </span>redis::cmd(<span class="string">"MEMORY"</span>).arg(<span class="string">"USAGE"</span>).arg(<span class="string">"my_key"</span>).query(con)
}</code></pre></div>
<h3 id="executing-high-level-commands"><a class="doc-anchor" href="#executing-high-level-commands">§</a>Executing High-Level Commands</h3>
<p>The high-level interface is similar.  For it to become available you
need to use the <code>Commands</code> trait in which case all <code>ConnectionLike</code>
objects the library provides will also have high-level methods which
make working with the protocol easier:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>redis;
<span class="kw">use </span>redis::Commands;

<span class="kw">fn </span>do_something(con: <span class="kw-2">&amp;mut </span>redis::Connection) -&gt; redis::RedisResult&lt;()&gt; {
    <span class="kw">let _</span>: () = con.set(<span class="string">"my_key"</span>, <span class="number">42</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Note that high-level commands are work in progress and many are still
missing!</p>
<h3 id="type-conversions"><a class="doc-anchor" href="#type-conversions">§</a>Type Conversions</h3>
<p>Because redis inherently is mostly type-less and the protocol is not
exactly friendly to developers, this library provides flexible support
for casting values to the intended results.  This is driven through the <code>FromRedisValue</code> and <code>ToRedisArgs</code> traits.</p>
<p>The <code>arg</code> method of the command will accept a wide range of types through
the <code>ToRedisArgs</code> trait and the <code>query</code> method of a command can convert the
value to what you expect the function to return through the <code>FromRedisValue</code>
trait.  This is quite flexible and allows vectors, tuples, hashsets, hashmaps
as well as optional values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>count : i32 = con.get(<span class="string">"my_counter"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>count = con.get(<span class="string">"my_counter"</span>).unwrap_or(<span class="number">0i32</span>);
<span class="kw">let </span>k : <span class="prelude-ty">Option</span>&lt;String&gt; = con.get(<span class="string">"missing_key"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>name : String = con.get(<span class="string">"my_name"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>bin : Vec&lt;u8&gt; = con.get(<span class="string">"my_binary"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>map : HashMap&lt;String, i32&gt; = con.hgetall(<span class="string">"my_hash"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>keys : Vec&lt;String&gt; = con.hkeys(<span class="string">"my_hash"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>mems : HashSet&lt;i32&gt; = con.smembers(<span class="string">"my_set"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(k1, k2) : (String, String) = con.get(<span class="kw-2">&amp;</span>[<span class="string">"k1"</span>, <span class="string">"k2"</span>])<span class="question-mark">?</span>;</code></pre></div>
<h2 id="resp3-support"><a class="doc-anchor" href="#resp3-support">§</a>RESP3 support</h2>
<p>Since Redis / Valkey version 6, a newer communication protocol called RESP3 is supported.
Using this protocol allows the user both to receive a more varied <code>Value</code> results, for users
who use the low-level <code>Value</code> type, and to receive out of band messages on the same connection. This allows the user to receive PubSub
messages on the same connection, instead of creating a new PubSub connection (see “RESP3 async pubsub”).</p>
<h2 id="iteration-protocol"><a class="doc-anchor" href="#iteration-protocol">§</a>Iteration Protocol</h2>
<p>In addition to sending a single query, iterators are also supported.  When
used with regular bulk responses they don’t give you much over querying and
converting into a vector (both use a vector internally) but they can also
be used with <code>SCAN</code> like commands in which case iteration will send more
queries until the cursor is exhausted:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter : redis::Iter&lt;isize&gt; = redis::cmd(<span class="string">"SSCAN"</span>).arg(<span class="string">"my_set"</span>)
    .cursor_arg(<span class="number">0</span>).clone().iter(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;
<span class="kw">for </span>x <span class="kw">in </span>iter {
    <span class="comment">// do something with the item
</span>}</code></pre></div>
<p>As you can see the cursor argument needs to be defined with <code>cursor_arg</code>
instead of <code>arg</code> so that the library knows which argument needs updating
as the query is run for more items.</p>
<h2 id="pipelining"><a class="doc-anchor" href="#pipelining">§</a>Pipelining</h2>
<p>In addition to simple queries you can also send command pipelines.  This
is provided through the <code>pipe</code> function.  It works very similar to sending
individual commands but you can send more than one in one go.  This also
allows you to ignore individual results so that matching on the end result
is easier:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(k1, k2) : (i32, i32) = redis::pipe()
    .cmd(<span class="string">"SET"</span>).arg(<span class="string">"key_1"</span>).arg(<span class="number">42</span>).ignore()
    .cmd(<span class="string">"SET"</span>).arg(<span class="string">"key_2"</span>).arg(<span class="number">43</span>).ignore()
    .cmd(<span class="string">"GET"</span>).arg(<span class="string">"key_1"</span>)
    .cmd(<span class="string">"GET"</span>).arg(<span class="string">"key_2"</span>).query(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;</code></pre></div>
<p>If you want the pipeline to be wrapped in a <code>MULTI</code>/<code>EXEC</code> block you can
easily do that by switching the pipeline into <code>atomic</code> mode.  From the
caller’s point of view nothing changes, the pipeline itself will take
care of the rest for you:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(k1, k2) : (i32, i32) = redis::pipe()
    .atomic()
    .cmd(<span class="string">"SET"</span>).arg(<span class="string">"key_1"</span>).arg(<span class="number">42</span>).ignore()
    .cmd(<span class="string">"SET"</span>).arg(<span class="string">"key_2"</span>).arg(<span class="number">43</span>).ignore()
    .cmd(<span class="string">"GET"</span>).arg(<span class="string">"key_1"</span>)
    .cmd(<span class="string">"GET"</span>).arg(<span class="string">"key_2"</span>).query(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;</code></pre></div>
<p>You can also use high-level commands on pipelines:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(k1, k2) : (i32, i32) = redis::pipe()
    .atomic()
    .set(<span class="string">"key_1"</span>, <span class="number">42</span>).ignore()
    .set(<span class="string">"key_2"</span>, <span class="number">43</span>).ignore()
    .get(<span class="string">"key_1"</span>)
    .get(<span class="string">"key_2"</span>).query(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;</code></pre></div>
<h2 id="transactions"><a class="doc-anchor" href="#transactions">§</a>Transactions</h2>
<p>Transactions are available through atomic pipelines.  In order to use
them in a more simple way you can use the <code>transaction</code> function of a
connection:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>redis::Commands;
<span class="kw">let </span>key = <span class="string">"the_key"</span>;
<span class="kw">let </span>(new_val,) : (isize,) = redis::transaction(<span class="kw-2">&amp;mut </span>con, <span class="kw-2">&amp;</span>[key], |con, pipe| {
    <span class="kw">let </span>old_val : isize = con.get(key)<span class="question-mark">?</span>;
    pipe
        .set(key, old_val + <span class="number">1</span>).ignore()
        .get(key).query(con)
})<span class="question-mark">?</span>;
<span class="macro">println!</span>(<span class="string">"The incremented number is: {}"</span>, new_val);</code></pre></div>
<p>For more information see the <code>transaction</code> function.</p>
<h2 id="pubsub"><a class="doc-anchor" href="#pubsub">§</a>PubSub</h2>
<p>Pubsub is provided through the <code>PubSub</code> connection object for sync usage, or the <code>aio::PubSub</code>
for async usage.</p>
<p>Example usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>con = client.get_connection()<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>pubsub = con.as_pubsub();
pubsub.subscribe(<span class="string">"channel_1"</span>)<span class="question-mark">?</span>;
pubsub.subscribe(<span class="string">"channel_2"</span>)<span class="question-mark">?</span>;

<span class="kw">loop </span>{
    <span class="kw">let </span>msg = pubsub.get_message()<span class="question-mark">?</span>;
    <span class="kw">let </span>payload : String = msg.get_payload()<span class="question-mark">?</span>;
    <span class="macro">println!</span>(<span class="string">"channel '{}': {}"</span>, msg.get_channel_name(), payload);
}</code></pre></div>
<p>In order to update subscriptions while concurrently waiting for messages, the async PubSub can be split into separate sink &amp; stream components. The sink can be receive subscription requests while the stream is awaited for messages.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_util::StreamExt;
<span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(<span class="kw-2">mut </span>sink, <span class="kw-2">mut </span>stream) = client.get_async_pubsub().<span class="kw">await</span><span class="question-mark">?</span>.split();
sink.subscribe(<span class="string">"channel_1"</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">loop </span>{
    <span class="kw">let </span>msg = stream.next().<span class="kw">await</span>.unwrap();
    <span class="kw">let </span>payload : String = msg.get_payload().unwrap();
    <span class="macro">println!</span>(<span class="string">"channel '{}': {}"</span>, msg.get_channel_name(), payload);
}</code></pre></div>
<h3 id="resp3-async-pubsub"><a class="doc-anchor" href="#resp3-async-pubsub">§</a>RESP3 async pubsub</h3>
<p>If you’re targeting a Redis/Valkey server of version 6 or above, you can receive
pubsub messages from it without creating another connection, by setting a push sender on the connection.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/?protocol=resp3"</span>).unwrap();
<span class="kw">let </span>(tx, <span class="kw-2">mut </span>rx) = tokio::sync::mpsc::unbounded_channel();
<span class="kw">let </span>config = redis::AsyncConnectionConfig::new().set_push_sender(tx);
<span class="kw">let </span><span class="kw-2">mut </span>con = client.get_multiplexed_async_connection_with_config(<span class="kw-2">&amp;</span>config).<span class="kw">await</span><span class="question-mark">?</span>;
con.subscribe(<span class="string">"channel_1"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
con.subscribe(<span class="string">"channel_2"</span>).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">loop </span>{
  <span class="macro">println!</span>(<span class="string">"Received {:?}"</span>, rx.recv().<span class="kw">await</span>.unwrap());
}</code></pre></div>
<h2 id="scripts"><a class="doc-anchor" href="#scripts">§</a>Scripts</h2>
<p>Lua scripts are supported through the <code>Script</code> type in a convenient
way.  It will automatically load the script if it does not exist and invoke it.</p>
<p>Example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>script = redis::Script::new(<span class="string">r"
    return tonumber(ARGV[1]) + tonumber(ARGV[2]);
"</span>);
<span class="kw">let </span>result: isize = script.arg(<span class="number">1</span>).arg(<span class="number">2</span>).invoke(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(result, <span class="number">3</span>);</code></pre></div>
<p>Scripts can also be pipelined:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>script = redis::Script::new(<span class="string">r"
    return tonumber(ARGV[1]) + tonumber(ARGV[2]);
"</span>);
<span class="kw">let </span>(a, b): (isize, isize) = redis::pipe()
    .invoke_script(script.arg(<span class="number">1</span>).arg(<span class="number">2</span>))
    .invoke_script(script.arg(<span class="number">2</span>).arg(<span class="number">3</span>))
    .query(<span class="kw-2">&amp;mut </span>con)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(a, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(b, <span class="number">5</span>);</code></pre></div>
<p>Note: unlike a call to <a href="struct.ScriptInvocation.html#method.invoke" title="method redis::ScriptInvocation::invoke"><code>invoke</code></a>, if the script isn’t loaded during the pipeline operation,
it will not automatically be loaded and retried. The script can be loaded using the
<a href="struct.ScriptInvocation.html#method.load" title="method redis::ScriptInvocation::load"><code>load</code></a> operation.</p>
<h2 id="async"><a class="doc-anchor" href="#async">§</a>Async</h2>
<p>In addition to the synchronous interface that’s been explained above there also exists an
asynchronous interface based on <a href="https://crates.io/crates/futures"><code>futures</code></a> and <a href="https://tokio.rs"><code>tokio</code></a>, or <a href="https://async.rs/"><code>async-std</code></a>.</p>
<p>This interface exists under the <code>aio</code> (async io) module (which requires that the <code>aio</code> feature
is enabled) and largely mirrors the synchronous with a few concessions to make it fit the
constraints of <code>futures</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>redis::AsyncCommands;

<span class="kw">let </span>client = redis::Client::open(<span class="string">"redis://127.0.0.1/"</span>).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>con = client.get_multiplexed_async_connection().<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let _</span>: () = con.set(<span class="string">"key1"</span>, <span class="string">b"foo"</span>).<span class="kw">await</span><span class="question-mark">?</span>;

redis::cmd(<span class="string">"SET"</span>).arg(<span class="kw-2">&amp;</span>[<span class="string">"key2"</span>, <span class="string">"bar"</span>]).exec_async(<span class="kw-2">&amp;mut </span>con).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="kw">let </span>result = redis::cmd(<span class="string">"MGET"</span>)
 .arg(<span class="kw-2">&amp;</span>[<span class="string">"key1"</span>, <span class="string">"key2"</span>])
 .query_async(<span class="kw-2">&amp;mut </span>con)
 .<span class="kw">await</span>;
<span class="macro">assert_eq!</span>(result, <span class="prelude-val">Ok</span>((<span class="string">"foo"</span>.to_string(), <span class="string">b"bar"</span>.to_vec())));</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="acl/index.html" title="mod redis::acl">acl</a></div><div class="desc docblock-short">Defines types to use with the ACL commands.</div></li><li><div class="item-name"><a class="mod" href="aio/index.html" title="mod redis::aio">aio</a></div><div class="desc docblock-short">Adds async IO support to redis.</div></li><li><div class="item-name"><a class="mod" href="geo/index.html" title="mod redis::geo">geo</a></div><div class="desc docblock-short">Defines types to use with the geospatial commands.</div></li><li><div class="item-name"><a class="mod" href="streams/index.html" title="mod redis::streams">streams</a></div><div class="desc docblock-short">Defines types to use with the streams commands.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AsyncConnectionConfig.html" title="struct redis::AsyncConnectionConfig">Async<wbr>Connection<wbr>Config</a></div><div class="desc docblock-short">Options for creation of async connection</div></li><li><div class="item-name"><a class="struct" href="struct.AsyncIter.html" title="struct redis::AsyncIter">Async<wbr>Iter</a></div><div class="desc docblock-short">Represents a redis iterator that can be used with async connections.</div></li><li><div class="item-name"><a class="struct" href="struct.Client.html" title="struct redis::Client">Client</a></div><div class="desc docblock-short">The client type.</div></li><li><div class="item-name"><a class="struct" href="struct.Cmd.html" title="struct redis::Cmd">Cmd</a></div><div class="desc docblock-short">Represents redis commands.</div></li><li><div class="item-name"><a class="struct" href="struct.Connection.html" title="struct redis::Connection">Connection</a></div><div class="desc docblock-short">Represents a stateful redis TCP connection.</div></li><li><div class="item-name"><a class="struct" href="struct.ConnectionInfo.html" title="struct redis::ConnectionInfo">Connection<wbr>Info</a></div><div class="desc docblock-short">Holds the connection information that redis should use for connecting.</div></li><li><div class="item-name"><a class="struct" href="struct.InfoDict.html" title="struct redis::InfoDict">Info<wbr>Dict</a></div><div class="desc docblock-short">An info dictionary type.</div></li><li><div class="item-name"><a class="struct" href="struct.Iter.html" title="struct redis::Iter">Iter</a></div><div class="desc docblock-short">Represents a redis iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.LposOptions.html" title="struct redis::LposOptions">Lpos<wbr>Options</a></div><div class="desc docblock-short">Options for the <a href="https://redis.io/commands/lpos">LPOS</a> command</div></li><li><div class="item-name"><a class="struct" href="struct.Msg.html" title="struct redis::Msg">Msg</a></div><div class="desc docblock-short">Represents a pubsub message.</div></li><li><div class="item-name"><a class="struct" href="struct.Parser.html" title="struct redis::Parser">Parser</a></div><div class="desc docblock-short">The internal redis response parser.</div></li><li><div class="item-name"><a class="struct" href="struct.Pipeline.html" title="struct redis::Pipeline">Pipeline</a></div><div class="desc docblock-short">Represents a redis command pipeline.</div></li><li><div class="item-name"><a class="struct" href="struct.PubSub.html" title="struct redis::PubSub">PubSub</a></div><div class="desc docblock-short">Represents a pubsub connection.</div></li><li><div class="item-name"><a class="struct" href="struct.PushInfo.html" title="struct redis::PushInfo">Push<wbr>Info</a></div><div class="desc docblock-short">A push message from the server.</div></li><li><div class="item-name"><a class="struct" href="struct.RedisConnectionInfo.html" title="struct redis::RedisConnectionInfo">Redis<wbr>Connection<wbr>Info</a></div><div class="desc docblock-short">Redis specific/connection independent information used to establish a connection to redis.</div></li><li><div class="item-name"><a class="struct" href="struct.RedisError.html" title="struct redis::RedisError">Redis<wbr>Error</a></div><div class="desc docblock-short">Represents a redis error.</div></li><li><div class="item-name"><a class="struct" href="struct.ReplicaInfo.html" title="struct redis::ReplicaInfo">Replica<wbr>Info</a></div><div class="desc docblock-short">Replication information for a replica, as returned by the <a href="https://redis.io/docs/latest/commands/role/"><code>ROLE</code></a> command.</div></li><li><div class="item-name"><a class="struct" href="struct.ScanOptions.html" title="struct redis::ScanOptions">Scan<wbr>Options</a></div><div class="desc docblock-short">Options for the <a href="https://redis.io/commands/scan">SCAN</a> command</div></li><li><div class="item-name"><a class="struct" href="struct.Script.html" title="struct redis::Script">Script</a></div><div class="desc docblock-short">Represents a lua script.</div></li><li><div class="item-name"><a class="struct" href="struct.ScriptInvocation.html" title="struct redis::ScriptInvocation">Script<wbr>Invocation</a></div><div class="desc docblock-short">Represents a prepared script call.</div></li><li><div class="item-name"><a class="struct" href="struct.SetOptions.html" title="struct redis::SetOptions">SetOptions</a></div><div class="desc docblock-short">Options for the <a href="https://redis.io/commands/set">SET</a> command</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Arg.html" title="enum redis::Arg">Arg</a></div><div class="desc docblock-short">An argument to a redis command</div></li><li><div class="item-name"><a class="enum" href="enum.ConnectionAddr.html" title="enum redis::ConnectionAddr">Connection<wbr>Addr</a></div><div class="desc docblock-short">Defines the connection address.</div></li><li><div class="item-name"><a class="enum" href="enum.ControlFlow.html" title="enum redis::ControlFlow">Control<wbr>Flow</a></div><div class="desc docblock-short">Allows pubsub callbacks to stop receiving messages.</div></li><li><div class="item-name"><a class="enum" href="enum.Direction.html" title="enum redis::Direction">Direction</a></div><div class="desc docblock-short">Enum for the LEFT | RIGHT args used by some commands</div></li><li><div class="item-name"><a class="enum" href="enum.ErrorKind.html" title="enum redis::ErrorKind">Error<wbr>Kind</a></div><div class="desc docblock-short">An enum of all error kinds.</div></li><li><div class="item-name"><a class="enum" href="enum.ExistenceCheck.html" title="enum redis::ExistenceCheck">Existence<wbr>Check</a></div><div class="desc docblock-short">Helper enum that is used to define existence checks</div></li><li><div class="item-name"><a class="enum" href="enum.ExpireOption.html" title="enum redis::ExpireOption">Expire<wbr>Option</a></div><div class="desc docblock-short">Helper enum that is used to define option for the hash expire commands</div></li><li><div class="item-name"><a class="enum" href="enum.Expiry.html" title="enum redis::Expiry">Expiry</a></div><div class="desc docblock-short">Helper enum that is used to define expiry time</div></li><li><div class="item-name"><a class="enum" href="enum.NumericBehavior.html" title="enum redis::NumericBehavior">Numeric<wbr>Behavior</a></div><div class="desc docblock-short">Helper enum that is used in some situations to describe
the behavior of arguments in a numeric context.</div></li><li><div class="item-name"><a class="enum" href="enum.ProtocolVersion.html" title="enum redis::ProtocolVersion">Protocol<wbr>Version</a></div><div class="desc docblock-short">Enum representing the communication protocol with the server.</div></li><li><div class="item-name"><a class="enum" href="enum.PushKind.html" title="enum redis::PushKind">Push<wbr>Kind</a></div><div class="desc docblock-short"><code>Push</code> type’s currently known kinds.</div></li><li><div class="item-name"><a class="enum" href="enum.RetryMethod.html" title="enum redis::RetryMethod">Retry<wbr>Method</a></div><div class="desc docblock-short">What method should be used if retrying this request.</div></li><li><div class="item-name"><a class="enum" href="enum.Role.html" title="enum redis::Role">Role</a></div><div class="desc docblock-short">High level representation of response to the <a href="https://redis.io/docs/latest/commands/role/"><code>ROLE</code></a> command.</div></li><li><div class="item-name"><a class="enum" href="enum.SetExpiry.html" title="enum redis::SetExpiry">SetExpiry</a></div><div class="desc docblock-short">Helper enum that is used to define expiry time for SET command</div></li><li><div class="item-name"><a class="enum" href="enum.TlsMode.html" title="enum redis::TlsMode">TlsMode</a></div><div class="desc docblock-short">TlsMode indicates use or do not use verification of certification.</div></li><li><div class="item-name"><a class="enum" href="enum.Value.html" title="enum redis::Value">Value</a></div><div class="desc docblock-short">Internal low-level redis value enum.</div></li><li><div class="item-name"><a class="enum" href="enum.VerbatimFormat.html" title="enum redis::VerbatimFormat">Verbatim<wbr>Format</a></div><div class="desc docblock-short"><code>VerbatimString</code>’s format types defined by spec</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AsyncCommands.html" title="trait redis::AsyncCommands">Async<wbr>Commands</a></div><div class="desc docblock-short">Implements common redis commands over asynchronous connections.</div></li><li><div class="item-name"><a class="trait" href="trait.Commands.html" title="trait redis::Commands">Commands</a></div><div class="desc docblock-short">Implements common redis commands for connection like objects.</div></li><li><div class="item-name"><a class="trait" href="trait.ConnectionLike.html" title="trait redis::ConnectionLike">Connection<wbr>Like</a></div><div class="desc docblock-short">Implements the “stateless” part of the connection interface that is used by the
different objects in redis-rs.</div></li><li><div class="item-name"><a class="trait" href="trait.FromRedisValue.html" title="trait redis::FromRedisValue">From<wbr>Redis<wbr>Value</a></div><div class="desc docblock-short">This trait is used to convert a redis value into a more appropriate
type.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoConnectionInfo.html" title="trait redis::IntoConnectionInfo">Into<wbr>Connection<wbr>Info</a></div><div class="desc docblock-short">Converts an object into a connection info struct.  This allows the
constructor of the client to accept connection information in a
range of different formats.</div></li><li><div class="item-name"><a class="trait" href="trait.PubSubCommands.html" title="trait redis::PubSubCommands">PubSub<wbr>Commands</a></div><div class="desc docblock-short">The PubSub trait allows subscribing to one or more channels
and receiving a callback whenever a message arrives.</div></li><li><div class="item-name"><a class="trait" href="trait.RedisWrite.html" title="trait redis::RedisWrite">Redis<wbr>Write</a></div><div class="desc docblock-short">Abstraction trait for redis command abstractions.</div></li><li><div class="item-name"><a class="trait" href="trait.ToRedisArgs.html" title="trait redis::ToRedisArgs">ToRedis<wbr>Args</a></div><div class="desc docblock-short">Used to convert a value into one or multiple redis argument
strings.  Most values will produce exactly one item but in
some cases it might make sense to produce more than one.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.cmd.html" title="fn redis::cmd">cmd</a></div><div class="desc docblock-short">Shortcut function to creating a command with a single argument.</div></li><li><div class="item-name"><a class="fn" href="fn.from_owned_redis_value.html" title="fn redis::from_owned_redis_value">from_<wbr>owned_<wbr>redis_<wbr>value</a></div><div class="desc docblock-short">A shortcut function to invoke <code>FromRedisValue::from_owned_redis_value</code>
to make the API slightly nicer.</div></li><li><div class="item-name"><a class="fn" href="fn.from_redis_value.html" title="fn redis::from_redis_value">from_<wbr>redis_<wbr>value</a></div><div class="desc docblock-short">A shortcut function to invoke <code>FromRedisValue::from_redis_value</code>
to make the API slightly nicer.</div></li><li><div class="item-name"><a class="fn" href="fn.pack_command.html" title="fn redis::pack_command">pack_<wbr>command</a></div><div class="desc docblock-short">Packs a bunch of commands into a request.</div></li><li><div class="item-name"><a class="fn" href="fn.parse_redis_url.html" title="fn redis::parse_redis_url">parse_<wbr>redis_<wbr>url</a></div><div class="desc docblock-short">This function takes a redis URL string and parses it into a URL
as used by rust-url.</div></li><li><div class="item-name"><a class="fn" href="fn.parse_redis_value.html" title="fn redis::parse_redis_value">parse_<wbr>redis_<wbr>value</a></div><div class="desc docblock-short">Parses bytes into a redis value.</div></li><li><div class="item-name"><a class="fn" href="fn.parse_redis_value_async.html" title="fn redis::parse_redis_value_async">parse_<wbr>redis_<wbr>value_<wbr>async</a></div><div class="desc docblock-short">Parses a redis value asynchronously.</div></li><li><div class="item-name"><a class="fn" href="fn.pipe.html" title="fn redis::pipe">pipe</a></div><div class="desc docblock-short">Shortcut for creating a new pipeline.</div></li><li><div class="item-name"><a class="fn" href="fn.transaction.html" title="fn redis::transaction">transaction</a></div><div class="desc docblock-short">This function simplifies transaction management slightly.  What it
does is automatically watching keys and then going into a transaction
loop util it succeeds.  Once it goes through the results are
returned.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.RedisFuture.html" title="type redis::RedisFuture">Redis<wbr>Future</a></div><div class="desc docblock-short">Library generic future type.</div></li><li><div class="item-name"><a class="type" href="type.RedisResult.html" title="type redis::RedisResult">Redis<wbr>Result</a></div><div class="desc docblock-short">Library generic result type.</div></li></ul></section></div></main></body></html>