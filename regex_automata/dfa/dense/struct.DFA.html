<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A dense table-based deterministic finite automaton (DFA)."><title>DFA in regex_automata::dfa::dense - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">DFA</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.alphabet_len">alphabet_len</a></li><li><a href="#method.as_ref">as_ref</a></li><li><a href="#method.from_bytes">from_bytes</a></li><li><a href="#method.from_bytes_unchecked">from_bytes_unchecked</a></li><li><a href="#method.has_starts_for_each_pattern">has_starts_for_each_pattern</a></li><li><a href="#method.memory_usage">memory_usage</a></li><li><a href="#method.stride">stride</a></li><li><a href="#method.stride2">stride2</a></li><li><a href="#method.write_to_big_endian">write_to_big_endian</a></li><li><a href="#method.write_to_len">write_to_len</a></li><li><a href="#method.write_to_little_endian">write_to_little_endian</a></li><li><a href="#method.write_to_native_endian">write_to_native_endian</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Automaton-for-DFA%3CT%3E">Automaton</a></li><li><a href="#impl-Clone-for-DFA%3CT%3E">Clone</a></li><li><a href="#impl-Debug-for-DFA%3CT%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-DFA%3CT%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-DFA%3CT%3E">Send</a></li><li><a href="#impl-Sync-for-DFA%3CT%3E">Sync</a></li><li><a href="#impl-Unpin-for-DFA%3CT%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-DFA%3CT%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-DFA%3CT%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-DFA%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-DFA%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-DFA%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-DFA%3CT%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-DFA%3CT%3E">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-DFA%3CT%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-DFA%3CT%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::dfa::dense</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">dfa</a>::<wbr><a href="index.html">dense</a>::<wbr><a class="struct" href="#">DFA</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/regex_automata/dfa/dense.rs.html#1128-1163">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct DFA&lt;T&gt; { /* private fields */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A dense table-based deterministic finite automaton (DFA).</p>
<p>All dense DFAs have one or more start states, zero or more match states
and a transition table that maps the current state and the current byte
of input to the next state. A DFA can use this information to implement
fast searching. In particular, the use of a dense DFA generally makes the
trade off that match speed is the most valuable characteristic, even if
building the DFA may take significant time <em>and</em> space. (More concretely,
building a DFA takes time and space that is exponential in the size of the
pattern in the worst case.) As such, the processing of every byte of input
is done with a small constant number of operations that does not vary with
the pattern, its size or the size of the alphabet. If your needs don’t line
up with this trade off, then a dense DFA may not be an adequate solution to
your problem.</p>
<p>In contrast, a [<code>sparse::DFA</code>] makes the opposite
trade off: it uses less space but will execute a variable number of
instructions per byte at match time, which makes it slower for matching.
(Note that space usage is still exponential in the size of the pattern in
the worst case.)</p>
<p>A DFA can be built using the default configuration via the
[<code>DFA::new</code>] constructor. Otherwise, one can
configure various aspects via <a href="Builder"><code>dense::Builder</code></a>.</p>
<p>A single DFA fundamentally supports the following operations:</p>
<ol>
<li>Detection of a match.</li>
<li>Location of the end of a match.</li>
<li>In the case of a DFA with multiple patterns, which pattern matched is
reported as well.</li>
</ol>
<p>A notable absence from the above list of capabilities is the location of
the <em>start</em> of a match. In order to provide both the start and end of
a match, <em>two</em> DFAs are required. This functionality is provided by a
<a href="../regex/struct.Regex.html" title="struct regex_automata::dfa::regex::Regex"><code>Regex</code></a>.</p>
<h2 id="type-parameters"><a href="#type-parameters">Type parameters</a></h2>
<p>A <code>DFA</code> has one type parameter, <code>T</code>, which is used to represent state IDs,
pattern IDs and accelerators. <code>T</code> is typically a <code>Vec&lt;u32&gt;</code> or a <code>&amp;[u32]</code>.</p>
<h2 id="the-automaton-trait"><a href="#the-automaton-trait">The <code>Automaton</code> trait</a></h2>
<p>This type implements the <a href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton"><code>Automaton</code></a> trait, which means it can be used
for searching. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch};

<span class="kw">let </span>dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1266-1405">source</a><a href="#impl-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u32.html">u32</a>]&gt;&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1269-1277">source</a><h4 class="code-header">pub fn <a href="#method.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u32.html">u32</a>]&gt;</h4></section></summary><div class="docblock"><p>Cheaply return a borrowed version of this dense DFA. Specifically,
the DFA returned always uses <code>&amp;[u32]</code> for its transition table.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_starts_for_each_pattern" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1304-1306">source</a><h4 class="code-header">pub fn <a href="#method.has_starts_for_each_pattern" class="fn">has_starts_for_each_pattern</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true only if this DFA has starting states for each pattern.</p>
<p>When a DFA has starting states for each pattern, then a search with the
DFA can be configured to only look for anchored matches of a specific
pattern. Specifically, APIs like <a href="../trait.Automaton.html#method.find_earliest_fwd_at" title="method regex_automata::dfa::Automaton::find_earliest_fwd_at"><code>Automaton::find_earliest_fwd_at</code></a>
can accept a non-None <code>pattern_id</code> if and only if this method returns
true. Otherwise, calling <code>find_earliest_fwd_at</code> will panic.</p>
<p>Note that if the DFA has no patterns, this always returns false.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.alphabet_len" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1332-1334">source</a><h4 class="code-header">pub fn <a href="#method.alphabet_len" class="fn">alphabet_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of elements in the alphabet for this DFA.</p>
<p>That is, this returns the total number of transitions that each state
in this DFA must have. Typically, a normal byte oriented DFA would
always have an alphabet size of 256, corresponding to the number of
unique values in a single byte. However, this implementation has two
peculiarities that impact the alphabet length:</p>
<ul>
<li>Every state has a special “EOI” transition that is only followed
after the end of some haystack is reached. This EOI transition is
necessary to account for one byte of look-ahead when implementing
things like <code>\b</code> and <code>$</code>.</li>
<li>Bytes are grouped into equivalence classes such that no two bytes in
the same class can distinguish a match from a non-match. For example,
in the regex <code>^[a-z]+$</code>, the ASCII bytes <code>a-z</code> could all be in the
same equivalence class. This leads to a massive space savings.</li>
</ul>
<p>Note though that the alphabet length does <em>not</em> necessarily equal the
total stride space taken up by a single DFA state in the transition
table. Namely, for performance reasons, the stride is always the
smallest power of two that is greater than or equal to the alphabet
length. For this reason, <a href="struct.DFA.html#method.stride" title="method regex_automata::dfa::dense::DFA::stride"><code>DFA::stride</code></a> or <a href="struct.DFA.html#method.stride2" title="method regex_automata::dfa::dense::DFA::stride2"><code>DFA::stride2</code></a> are
often more useful. The alphabet length is typically useful only for
informational purposes.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stride2" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1356-1358">source</a><h4 class="code-header">pub fn <a href="#method.stride2" class="fn">stride2</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total stride for every state in this DFA, expressed as the
exponent of a power of 2. The stride is the amount of space each state
takes up in the transition table, expressed as a number of transitions.
(Unused transitions map to dead states.)</p>
<p>The stride of a DFA is always equivalent to the smallest power of 2
that is greater than or equal to the DFA’s alphabet length. This
definition uses extra space, but permits faster translation between
premultiplied state identifiers and contiguous indices (by using shifts
instead of relying on integer division).</p>
<p>For example, if the DFA’s stride is 16 transitions, then its <code>stride2</code>
is <code>4</code> since <code>2^4 = 16</code>.</p>
<p>The minimum <code>stride2</code> value is <code>1</code> (corresponding to a stride of <code>2</code>)
while the maximum <code>stride2</code> value is <code>9</code> (corresponding to a stride of
<code>512</code>). The maximum is not <code>8</code> since the maximum alphabet size is <code>257</code>
when accounting for the special EOI transition. However, an alphabet
length of that size is exceptionally rare since the alphabet is shrunk
into equivalence classes.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stride" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1367-1369">source</a><h4 class="code-header">pub fn <a href="#method.stride" class="fn">stride</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total stride for every state in this DFA. This corresponds
to the total number of transitions used by each state in this DFA’s
transition table.</p>
<p>Please see <a href="struct.DFA.html#method.stride2" title="method regex_automata::dfa::dense::DFA::stride2"><code>DFA::stride2</code></a> for more information. In particular, this
returns the stride as the number of transitions, where as <code>stride2</code>
returns it as the exponent of a power of 2.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.memory_usage" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1399-1404">source</a><h4 class="code-header">pub fn <a href="#method.memory_usage" class="fn">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the memory usage, in bytes, of this DFA.</p>
<p>The memory usage is computed based on the number of bytes used to
represent this DFA.</p>
<p>This does <strong>not</strong> include the stack size used up by this DFA. To
compute that, use <code>std::mem::size_of::&lt;dense::DFA&gt;()</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3CT%3E-1" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1409-1789">source</a><a href="#impl-DFA%3CT%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u32.html">u32</a>]&gt;&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="docblock"><p>Routines for converting a dense DFA to other representations, such as
sparse DFAs or raw bytes suitable for persistent storage.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.write_to_little_endian" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1626-1631">source</a><h4 class="code-header">pub fn <a href="#method.write_to_little_endian" class="fn">write_to_little_endian</a>(
    &amp;self,
    dst: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>, <a class="struct" href="../../struct.SerializeError.html" title="struct regex_automata::SerializeError">SerializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to the given slice, in little endian
format. Upon success, the total number of bytes written to <code>dst</code> is
returned.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::dense::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::dense::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<p>Note that unlike the various <code>to_byte_*</code> routines, this does not write
any padding. Callers are responsible for handling alignment correctly.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>This returns an error if the given destination slice is not big enough
to contain the full serialized DFA. If an error occurs, then nothing
is written to <code>dst</code>.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>This example shows how to serialize and deserialize a DFA without
dynamic memory allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Create a 4KB buffer on the stack to store our serialized DFA.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0u8</span>; <span class="number">4 </span>* (<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];
<span class="comment">// N.B. We use native endianness here to make the example work, but
// using write_to_little_endian would work on a little endian target.
</span><span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u32]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_big_endian" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1676-1681">source</a><h4 class="code-header">pub fn <a href="#method.write_to_big_endian" class="fn">write_to_big_endian</a>(
    &amp;self,
    dst: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>, <a class="struct" href="../../struct.SerializeError.html" title="struct regex_automata::SerializeError">SerializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to the given slice, in big endian
format. Upon success, the total number of bytes written to <code>dst</code> is
returned.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::dense::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::dense::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<p>Note that unlike the various <code>to_byte_*</code> routines, this does not write
any padding. Callers are responsible for handling alignment correctly.</p>
<h5 id="errors-1"><a href="#errors-1">Errors</a></h5>
<p>This returns an error if the given destination slice is not big enough
to contain the full serialized DFA. If an error occurs, then nothing
is written to <code>dst</code>.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>This example shows how to serialize and deserialize a DFA without
dynamic memory allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Create a 4KB buffer on the stack to store our serialized DFA.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0u8</span>; <span class="number">4 </span>* (<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];
<span class="comment">// N.B. We use native endianness here to make the example work, but
// using write_to_big_endian would work on a big endian target.
</span><span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u32]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_native_endian" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1733-1738">source</a><h4 class="code-header">pub fn <a href="#method.write_to_native_endian" class="fn">write_to_native_endian</a>(
    &amp;self,
    dst: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>, <a class="struct" href="../../struct.SerializeError.html" title="struct regex_automata::SerializeError">SerializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to the given slice, in native endian
format. Upon success, the total number of bytes written to <code>dst</code> is
returned.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::dense::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::dense::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<p>Generally speaking, native endian format should only be used when
you know that the target you’re compiling the DFA for matches the
endianness of the target on which you’re compiling DFA. For example,
if serialization and deserialization happen in the same process or on
the same machine. Otherwise, when serializing a DFA for use in a
portable environment, you’ll almost certainly want to serialize <em>both</em>
a little endian and a big endian version and then load the correct one
based on the target’s configuration.</p>
<p>Note that unlike the various <code>to_byte_*</code> routines, this does not write
any padding. Callers are responsible for handling alignment correctly.</p>
<h5 id="errors-2"><a href="#errors-2">Errors</a></h5>
<p>This returns an error if the given destination slice is not big enough
to contain the full serialized DFA. If an error occurs, then nothing
is written to <code>dst</code>.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>This example shows how to serialize and deserialize a DFA without
dynamic memory allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Create a 4KB buffer on the stack to store our serialized DFA.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0u8</span>; <span class="number">4 </span>* (<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];
<span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u32]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_len" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1778-1788">source</a><h4 class="code-header">pub fn <a href="#method.write_to_len" class="fn">write_to_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the total number of bytes required to serialize this DFA.</p>
<p>This is useful for determining the size of the buffer required to pass
to one of the serialization routines:</p>
<ul>
<li><a href="struct.DFA.html#method.write_to_little_endian" title="method regex_automata::dfa::dense::DFA::write_to_little_endian"><code>DFA::write_to_little_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_big_endian" title="method regex_automata::dfa::dense::DFA::write_to_big_endian"><code>DFA::write_to_big_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_native_endian" title="method regex_automata::dfa::dense::DFA::write_to_native_endian"><code>DFA::write_to_native_endian</code></a></li>
</ul>
<p>Passing a buffer smaller than the size returned by this method will
result in a serialization error. Serialization routines are guaranteed
to succeed when the buffer is big enough.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>This example shows how to dynamically allocate enough room to serialize
a DFA.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[<span class="number">0</span>; original_dfa.write_to_len()];
<span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u32]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
<p>Note that this example isn’t actually guaranteed to work! In
particular, if <code>buf</code> is not aligned to a 4-byte boundary, then the
<code>DFA::from_bytes</code> call will fail. If you need this to work, then you
either need to deal with adding some initial padding yourself, or use
one of the <code>to_bytes</code> methods, which will do it for you.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3C%26'a+%5Bu32%5D%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1791-2093">source</a><a href="#impl-DFA%3C%26'a+%5Bu32%5D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u32.html">u32</a>]&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_bytes" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1987-2001">source</a><h4 class="code-header">pub fn <a href="#method.from_bytes" class="fn">from_bytes</a>(
    slice: &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u32.html">u32</a>]&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>), <a class="struct" href="../../struct.DeserializeError.html" title="struct regex_automata::DeserializeError">DeserializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Safely deserialize a DFA with a specific state identifier
representation. Upon success, this returns both the deserialized DFA
and the number of bytes read from the given slice. Namely, the contents
of the slice beyond the DFA are not read.</p>
<p>Deserializing a DFA using this routine will never allocate heap memory.
For safety purposes, the DFA’s transition table will be verified such
that every transition points to a valid state. If this verification is
too costly, then a <a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::dense::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a> API is provided, which
will always execute in constant time.</p>
<p>The bytes given must be generated by one of the serialization APIs
of a <code>DFA</code> using a semver compatible release of this crate. Those
include:</p>
<ul>
<li>[<code>DFA::to_bytes_little_endian</code>]</li>
<li>[<code>DFA::to_bytes_big_endian</code>]</li>
<li>[<code>DFA::to_bytes_native_endian</code>]</li>
<li><a href="struct.DFA.html#method.write_to_little_endian" title="method regex_automata::dfa::dense::DFA::write_to_little_endian"><code>DFA::write_to_little_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_big_endian" title="method regex_automata::dfa::dense::DFA::write_to_big_endian"><code>DFA::write_to_big_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_native_endian" title="method regex_automata::dfa::dense::DFA::write_to_native_endian"><code>DFA::write_to_native_endian</code></a></li>
</ul>
<p>The <code>to_bytes</code> methods allocate and return a <code>Vec&lt;u8&gt;</code> for you, along
with handling alignment correctly. The <code>write_to</code> methods do not
allocate and write to an existing slice (which may be on the stack).
Since deserialization always uses the native endianness of the target
platform, the serialization API you use should match the endianness of
the target platform. (It’s often a good idea to generate serialized
DFAs for both forms of endianness and then load the correct one based
on endianness.)</p>
<h5 id="errors-3"><a href="#errors-3">Errors</a></h5>
<p>Generally speaking, it’s easier to state the conditions in which an
error is <em>not</em> returned. All of the following must be true:</p>
<ul>
<li>The bytes given must be produced by one of the serialization APIs
on this DFA, as mentioned above.</li>
<li>The endianness of the target platform matches the endianness used to
serialized the provided DFA.</li>
<li>The slice given must have the same alignment as <code>u32</code>.</li>
</ul>
<p>If any of the above are not true, then an error will be returned.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This routine will never panic for any input.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<p>This example shows how to serialize a DFA to raw bytes, deserialize it
and then use it for searching.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch};

<span class="kw">let </span>initial = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(bytes, <span class="kw">_</span>) = initial.to_bytes_native_endian();
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u32]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
<h5 id="example-dealing-with-alignment-and-padding"><a href="#example-dealing-with-alignment-and-padding">Example: dealing with alignment and padding</a></h5>
<p>In the above example, we used the <code>to_bytes_native_endian</code> method to
serialize a DFA, but we ignored part of its return value corresponding
to padding added to the beginning of the serialized DFA. This is OK
because deserialization will skip this initial padding. What matters
is that the address immediately following the padding has an alignment
that matches <code>u32</code>. That is, the following is an equivalent but
alternative way to write the above example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch};

<span class="kw">let </span>initial = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// Serialization returns the number of leading padding bytes added to
// the returned Vec&lt;u8&gt;.
</span><span class="kw">let </span>(bytes, pad) = initial.to_bytes_native_endian();
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u32]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>bytes[pad..])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
<p>This padding is necessary because Rust’s standard library does
not expose any safe and robust way of creating a <code>Vec&lt;u8&gt;</code> with a
guaranteed alignment other than 1. Now, in practice, the underlying
allocator is likely to provide a <code>Vec&lt;u8&gt;</code> that meets our alignment
requirements, which means <code>pad</code> is zero in practice most of the time.</p>
<p>The purpose of exposing the padding like this is flexibility for the
caller. For example, if one wants to embed a serialized DFA into a
compiled program, then it’s important to guarantee that it starts at a
<code>u32</code>-aligned address. The simplest way to do this is to discard the
padding bytes and set it up so that the serialized DFA itself begins at
a properly aligned address. We can show this in two parts. The first
part is serializing the DFA to a file:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::{Automaton, dense::DFA};

<span class="kw">let </span>dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>(bytes, pad) = dfa.to_bytes_big_endian();
<span class="comment">// Write the contents of the DFA *without* the initial padding.
</span>std::fs::write(<span class="string">&quot;foo.bigendian.dfa&quot;</span>, <span class="kw-2">&amp;</span>bytes[pad..])<span class="question-mark">?</span>;

<span class="comment">// Do it again, but this time for little endian.
</span><span class="kw">let </span>(bytes, pad) = dfa.to_bytes_little_endian();
std::fs::write(<span class="string">&quot;foo.littleendian.dfa&quot;</span>, <span class="kw-2">&amp;</span>bytes[pad..])<span class="question-mark">?</span>;</code></pre></div>
<p>And now the second part is embedding the DFA into the compiled program
and deserializing it at runtime on first use. We use conditional
compilation to choose the correct endianness.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense}, HalfMatch};

<span class="kw">type </span>S = u32;
<span class="kw">type </span>DFA = dense::DFA&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>[S]&gt;;

<span class="kw">fn </span>get_foo() -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>DFA {
    <span class="kw">use </span>std::cell::Cell;
    <span class="kw">use </span>std::mem::MaybeUninit;
    <span class="kw">use </span>std::sync::Once;

    <span class="comment">// This struct with a generic B is used to permit unsizing
    // coercions, specifically, where B winds up being a [u8]. We also
    // need repr(C) to guarantee that _align comes first, which forces
    // a correct alignment.
    </span><span class="attr">#[repr(C)]
    </span><span class="kw">struct </span>Aligned&lt;B: <span class="question-mark">?</span>Sized&gt; {
        _align: [S; <span class="number">0</span>],
        bytes: B,
    }

    <span class="comment">// This assignment is made possible (implicitly) via the
    // CoerceUnsized trait.
    </span><span class="kw">static </span>ALIGNED: <span class="kw-2">&amp;</span>Aligned&lt;[u8]&gt; = <span class="kw-2">&amp;</span>Aligned {
        _align: [],
        <span class="attr">#[cfg(target_endian = <span class="string">&quot;big&quot;</span>)]
        </span>bytes: <span class="kw-2">*</span><span class="macro">include_bytes!</span>(<span class="string">&quot;foo.bigendian.dfa&quot;</span>),
        <span class="attr">#[cfg(target_endian = <span class="string">&quot;little&quot;</span>)]
        </span>bytes: <span class="kw-2">*</span><span class="macro">include_bytes!</span>(<span class="string">&quot;foo.littleendian.dfa&quot;</span>),
    };

    <span class="kw">struct </span>Lazy(Cell&lt;MaybeUninit&lt;DFA&gt;&gt;);
    <span class="comment">// SAFETY: This is safe because DFA impls Sync.
    </span><span class="kw">unsafe impl </span>Sync <span class="kw">for </span>Lazy {}

    <span class="kw">static </span>INIT: Once = Once::new();
    <span class="kw">static </span>DFA: Lazy = Lazy(Cell::new(MaybeUninit::uninit()));

    INIT.call_once(|| {
        <span class="kw">let </span>(dfa, <span class="kw">_</span>) = DFA::from_bytes(<span class="kw-2">&amp;</span>ALIGNED.bytes)
            .expect(<span class="string">&quot;serialized DFA should be valid&quot;</span>);
        <span class="comment">// SAFETY: This is guaranteed to only execute once, and all
        // we do with the pointer is write the DFA to it.
        </span><span class="kw">unsafe </span>{
            (<span class="kw-2">*</span>DFA.<span class="number">0</span>.as_ptr()).as_mut_ptr().write(dfa);
        }
    });
    <span class="comment">// SAFETY: DFA is guaranteed to by initialized via INIT and is
    // stored in static memory.
    </span><span class="kw">unsafe </span>{
        <span class="kw">let </span>dfa = (<span class="kw-2">*</span>DFA.<span class="number">0</span>.as_ptr()).as_ptr();
        std::mem::transmute::&lt;<span class="kw-2">*const </span>DFA, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>DFA&gt;(dfa)
    }
}

<span class="kw">let </span>dfa = get_foo();
<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(expected)), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>));</code></pre></div>
<p>Alternatively, consider using
<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a>
or
<a href="https://crates.io/crates/once_cell"><code>once_cell</code></a>,
which will guarantee safety for you. You will still need to use the
<code>Aligned</code> trick above to force correct alignment, but this is safe to
do and <code>from_bytes</code> will return an error if you get it wrong.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bytes_unchecked" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2030-2061">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_bytes_unchecked" class="fn">from_bytes_unchecked</a>(
    slice: &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u32.html">u32</a>]&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>), <a class="struct" href="../../struct.DeserializeError.html" title="struct regex_automata::DeserializeError">DeserializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Deserialize a DFA with a specific state identifier representation in
constant time by omitting the verification of the validity of the
transition table and other data inside the DFA.</p>
<p>This is just like <a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::dense::DFA::from_bytes"><code>DFA::from_bytes</code></a>, except it can potentially return
a DFA that exhibits undefined behavior if its transition table contains
invalid state identifiers.</p>
<p>This routine is useful if you need to deserialize a DFA cheaply
and cannot afford the transition table validation performed by
<code>from_bytes</code>.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, HalfMatch};

<span class="kw">let </span>initial = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>(bytes, <span class="kw">_</span>) = initial.to_bytes_native_endian();
<span class="comment">// SAFETY: This is guaranteed to be safe since the bytes given come
// directly from a compatible serialization routine.
</span><span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u32]&gt; = <span class="kw">unsafe </span>{ DFA::from_bytes_unchecked(<span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>.<span class="number">0 </span>};

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Automaton-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2691-2802">source</a><a href="#impl-Automaton-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u32.html">u32</a>]&gt;&gt; <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_special_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2693-2695">source</a><a href="#method.is_special_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_special_state" class="fn">is_special_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a
“special” state. A special state is one or more of the following:
a dead state, a quit state, a match state, a start state or an
accelerated state. <a href="../trait.Automaton.html#tymethod.is_special_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_dead_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2698-2700">source</a><a href="#method.is_dead_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_dead_state" class="fn">is_dead_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a dead
state. When a DFA enters a dead state, it is impossible to leave. That
is, every transition on a dead state by definition leads back to the
same dead state. <a href="../trait.Automaton.html#tymethod.is_dead_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_quit_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2703-2705">source</a><a href="#method.is_quit_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_quit_state" class="fn">is_quit_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a quit
state. A quit state is like a dead state (it has no transitions other
than to itself), except it indicates that the DFA failed to complete
the search. When this occurs, callers can neither accept or reject that
a match occurred. <a href="../trait.Automaton.html#tymethod.is_quit_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_match_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2708-2710">source</a><a href="#method.is_match_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_match_state" class="fn">is_match_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a
match state. A match state is also referred to as a “final” state and
indicates that a match has been found. <a href="../trait.Automaton.html#tymethod.is_match_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_start_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2713-2715">source</a><a href="#method.is_start_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_start_state" class="fn">is_start_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a
start state. A start state is a state in which a DFA begins a search.
All searches begin in a start state. Moreover, since all matches are
delayed by one byte, a start state can never be a match state. <a href="../trait.Automaton.html#tymethod.is_start_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_accel_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2718-2720">source</a><a href="#method.is_accel_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_accel_state" class="fn">is_accel_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to an
accelerated state. <a href="../trait.Automaton.html#tymethod.is_accel_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2723-2727">source</a><a href="#method.next_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.next_state" class="fn">next_state</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>) -&gt; StateID</h4></section></summary><div class='docblock'>Transitions from the current state to the next state, given the next
byte of input. <a href="../trait.Automaton.html#tymethod.next_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_state_unchecked" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2730-2738">source</a><a href="#method.next_state_unchecked" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../trait.Automaton.html#tymethod.next_state_unchecked" class="fn">next_state_unchecked</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>) -&gt; StateID</h4></section></summary><div class='docblock'>Transitions from the current state to the next state, given the next
byte of input. <a href="../trait.Automaton.html#tymethod.next_state_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_eoi_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2741-2745">source</a><a href="#method.next_eoi_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.next_eoi_state" class="fn">next_eoi_state</a>(&amp;self, current: StateID) -&gt; StateID</h4></section></summary><div class='docblock'>Transitions from the current state to the next state for the special
EOI symbol. <a href="../trait.Automaton.html#tymethod.next_eoi_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_count" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2748-2750">source</a><a href="#method.pattern_count" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.pattern_count" class="fn">pattern_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the total number of patterns compiled into this DFA. <a href="../trait.Automaton.html#tymethod.pattern_count">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.match_count" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2753-2755">source</a><a href="#method.match_count" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.match_count" class="fn">match_count</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the total number of patterns that match in this state. <a href="../trait.Automaton.html#tymethod.match_count">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.match_pattern" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2758-2769">source</a><a href="#method.match_pattern" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.match_pattern" class="fn">match_pattern</a>(&amp;self, id: StateID, match_index: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></h4></section></summary><div class='docblock'>Returns the pattern ID corresponding to the given match index in the
given state. <a href="../trait.Automaton.html#tymethod.match_pattern">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.start_state_forward" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2772-2781">source</a><a href="#method.start_state_forward" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.start_state_forward" class="fn">start_state_forward</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>
) -&gt; StateID</h4></section></summary><div class='docblock'>Return the ID of the start state for this DFA when executing a forward
search. <a href="../trait.Automaton.html#tymethod.start_state_forward">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.start_state_reverse" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2784-2793">source</a><a href="#method.start_state_reverse" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.start_state_reverse" class="fn">start_state_reverse</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>
) -&gt; StateID</h4></section></summary><div class='docblock'>Return the ID of the start state for this DFA when executing a reverse
search. <a href="../trait.Automaton.html#tymethod.start_state_reverse">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.accelerator" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2796-2801">source</a><a href="#method.accelerator" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.accelerator" class="fn">accelerator</a>(&amp;self, id: StateID) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class='docblock'>Return a slice of bytes to accelerate for the given state, if possible. <a href="../trait.Automaton.html#method.accelerator">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_fwd" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#935-940">source</a><a href="#method.find_earliest_fwd" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_earliest_fwd" class="fn">find_earliest_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a forward search and returns the end position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned. <a href="../trait.Automaton.html#method.find_earliest_fwd">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_rev" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1001-1006">source</a><a href="#method.find_earliest_rev" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_earliest_rev" class="fn">find_earliest_rev</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse search and returns the start position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned. <a href="../trait.Automaton.html#method.find_earliest_rev">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_fwd" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1075-1080">source</a><a href="#method.find_leftmost_fwd" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_leftmost_fwd" class="fn">find_leftmost_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a forward search and returns the end position of the leftmost
match that is found. If no match exists, then <code>None</code> is returned. <a href="../trait.Automaton.html#method.find_leftmost_fwd">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_rev" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1147-1152">source</a><a href="#method.find_leftmost_rev" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_leftmost_rev" class="fn">find_leftmost_rev</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse search and returns the start of the position of the
leftmost match that is found. If no match exists, then <code>None</code> is
returned. <a href="../trait.Automaton.html#method.find_leftmost_rev">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_overlapping_fwd" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1218-1224">source</a><a href="#method.find_overlapping_fwd" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_overlapping_fwd" class="fn">find_overlapping_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>],
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes an overlapping forward search and returns the end position of
matches as they are found. If no match exists, then <code>None</code> is returned. <a href="../trait.Automaton.html#method.find_overlapping_fwd">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_fwd_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1420-1429">source</a><a href="#method.find_earliest_fwd_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_earliest_fwd_at" class="fn">find_earliest_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a forward search and returns the end position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned. <a href="../trait.Automaton.html#method.find_earliest_fwd_at">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_rev_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1460-1468">source</a><a href="#method.find_earliest_rev_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_earliest_rev_at" class="fn">find_earliest_rev_at</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse search and returns the start position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned. <a href="../trait.Automaton.html#method.find_earliest_rev_at">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_fwd_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1495-1504">source</a><a href="#method.find_leftmost_fwd_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_leftmost_fwd_at" class="fn">find_leftmost_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a forward search and returns the end position of the leftmost
match that is found. If no match exists, then <code>None</code> is returned. <a href="../trait.Automaton.html#method.find_leftmost_fwd_at">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_rev_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1532-1540">source</a><a href="#method.find_leftmost_rev_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_leftmost_rev_at" class="fn">find_leftmost_rev_at</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse search and returns the start of the position of the
leftmost match that is found. If no match exists, then <code>None</code> is
returned. <a href="../trait.Automaton.html#method.find_leftmost_rev_at">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_overlapping_fwd_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1584-1596">source</a><a href="#method.find_overlapping_fwd_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_overlapping_fwd_at" class="fn">find_overlapping_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.usize.html">usize</a>,
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.70.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes an overlapping forward search and returns the end position of
matches as they are found. If no match exists, then <code>None</code> is returned. <a href="../trait.Automaton.html#method.find_overlapping_fwd_at">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1127">source</a><a href="#impl-Clone-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1127">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.70.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/clone.rs.html#132-134">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.70.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2633-2689">source</a><a href="#impl-Debug-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.u32.html">u32</a>]&gt;&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/dense.rs.html#2634-2688">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.70.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.70.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.70.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-DFA%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-DFA%3CT%3E" class="impl"><a href="#impl-Send-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</span></h3></section><section id="impl-Sync-for-DFA%3CT%3E" class="impl"><a href="#impl-Sync-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section><section id="impl-Unpin-for-DFA%3CT%3E" class="impl"><a href="#impl-Unpin-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-DFA%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.70.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.70.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/borrow.rs.html#211">source</a><a href="#impl-Borrow%3CT%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/borrow.rs.html#213">source</a></span><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/borrow.rs.html#220">source</a><a href="#impl-BorrowMut%3CT%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.70.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/borrow.rs.html#221">source</a></span><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.70.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#734">source</a><a href="#impl-From%3CT%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#737">source</a></span><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#717">source</a><a href="#impl-Into%3CU%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#726">source</a></span><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/alloc/borrow.rs.html#82">source</a><a href="#impl-ToOwned-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.70.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/alloc/borrow.rs.html#87">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.70.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/alloc/borrow.rs.html#91">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.70.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.70.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#777">source</a><a href="#impl-TryFrom%3CU%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#784">source</a></span><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#761">source</a><a href="#impl-TryInto%3CU%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/core/convert/mod.rs.html#768">source</a></span><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.70.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.70.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><span class=\"where fmt-newline\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.70.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.70.0/std/primitive.u8.html\">u8</a>]</span>"}</script></section></div></main></body></html>