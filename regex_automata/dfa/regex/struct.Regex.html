<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A regular expression that uses deterministic finite automata for fast searching."><title>Regex in regex_automata::dfa::regex - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../../../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../../../static.files/ayu-be46fdc453a55015.css"><script src="../../../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Regex</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.find_earliest">find_earliest</a></li><li><a href="#method.find_earliest_at">find_earliest_at</a></li><li><a href="#method.find_earliest_iter">find_earliest_iter</a></li><li><a href="#method.find_leftmost">find_leftmost</a></li><li><a href="#method.find_leftmost_at">find_leftmost_at</a></li><li><a href="#method.find_leftmost_iter">find_leftmost_iter</a></li><li><a href="#method.find_overlapping">find_overlapping</a></li><li><a href="#method.find_overlapping_at">find_overlapping_at</a></li><li><a href="#method.find_overlapping_iter">find_overlapping_iter</a></li><li><a href="#method.forward">forward</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.is_match_at">is_match_at</a></li><li><a href="#method.pattern_count">pattern_count</a></li><li><a href="#method.prefilter">prefilter</a></li><li><a href="#method.reverse">reverse</a></li><li><a href="#method.try_find_earliest">try_find_earliest</a></li><li><a href="#method.try_find_earliest_at">try_find_earliest_at</a></li><li><a href="#method.try_find_earliest_iter">try_find_earliest_iter</a></li><li><a href="#method.try_find_leftmost">try_find_leftmost</a></li><li><a href="#method.try_find_leftmost_at">try_find_leftmost_at</a></li><li><a href="#method.try_find_leftmost_iter">try_find_leftmost_iter</a></li><li><a href="#method.try_find_overlapping">try_find_overlapping</a></li><li><a href="#method.try_find_overlapping_at">try_find_overlapping_at</a></li><li><a href="#method.try_find_overlapping_iter">try_find_overlapping_iter</a></li><li><a href="#method.try_is_match">try_is_match</a></li><li><a href="#method.try_is_match_at">try_is_match_at</a></li><li><a href="#method.with_prefilter">with_prefilter</a></li><li><a href="#method.without_prefilter">without_prefilter</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Clone-for-Regex%3CA,+P%3E">Clone</a></li><li><a href="#impl-Debug-for-Regex%3CA,+P%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-Regex%3CA,+P%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Regex%3CA,+P%3E">Send</a></li><li><a href="#impl-Sync-for-Regex%3CA,+P%3E">Sync</a></li><li><a href="#impl-Unpin-for-Regex%3CA,+P%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Regex%3CA,+P%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-Regex%3CA,+P%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Regex%3CA,+P%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Regex%3CA,+P%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Regex%3CA,+P%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Regex%3CA,+P%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-Regex%3CA,+P%3E">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Regex%3CA,+P%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Regex%3CA,+P%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::dfa::regex</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">dfa</a>::<wbr><a href="index.html">regex</a>::<wbr><a class="struct" href="#">Regex</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/regex_automata/dfa/regex.rs.html#63-244">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Regex&lt;A, P = None&gt; { /* private fields */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A regular expression that uses deterministic finite automata for fast
searching.</p>
<p>A regular expression is comprised of two DFAs, a “forward” DFA and a
“reverse” DFA. The forward DFA is responsible for detecting the end of
a match while the reverse DFA is responsible for detecting the start
of a match. Thus, in order to find the bounds of any given match, a
forward search must first be run followed by a reverse search. A match
found by the forward DFA guarantees that the reverse DFA will also find
a match.</p>
<p>The type of the DFA used by a <code>Regex</code> corresponds to the <code>A</code> type
parameter, which must satisfy the <a href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton"><code>Automaton</code></a> trait. Typically,
<code>A</code> is either a <a href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a> or a
<a href="../sparse/struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA"><code>sparse::DFA</code></a>, where dense DFAs use more
memory but search faster, while sparse DFAs use less memory but search
more slowly.</p>
<p>By default, a regex’s automaton type parameter is set to
<code>dense::DFA&lt;Vec&lt;u32&gt;&gt;</code> when the <code>alloc</code> feature is enabled. For most
in-memory work loads, this is the most convenient type that gives the
best search performance. When the <code>alloc</code> feature is disabled, no
default type is used.</p>
<p>A <code>Regex</code> also has a <code>P</code> type parameter, which is used to select the
prefilter used during search. By default, no prefilter is enabled by
setting the type to default to [<code>prefilter::None</code>]. A prefilter can be
enabled by using the <a href="struct.Regex.html#method.prefilter" title="method regex_automata::dfa::regex::Regex::prefilter"><code>Regex::prefilter</code></a> method.</p>
<h2 id="when-should-i-use-this"><a href="#when-should-i-use-this">When should I use this?</a></h2>
<p>Generally speaking, if you can afford the overhead of building a full
DFA for your regex, and you don’t need things like capturing groups,
then this is a good choice if you’re looking to optimize for matching
speed. Note however that its speed may be worse than a general purpose
regex engine if you don’t select a good [prefilter].</p>
<h2 id="earliest-vs-leftmost-vs-overlapping"><a href="#earliest-vs-leftmost-vs-overlapping">Earliest vs Leftmost vs Overlapping</a></h2>
<p>The search routines exposed on a <code>Regex</code> reflect three different ways
of searching:</p>
<ul>
<li>“earliest” means to stop as soon as a match has been detected.</li>
<li>“leftmost” means to continue matching until the underlying
automaton cannot advance. This reflects “standard” searching you
might be used to in other regex engines. e.g., This permits
non-greedy and greedy searching to work as you would expect.</li>
<li>“overlapping” means to find all possible matches, even if they
overlap.</li>
</ul>
<p>Generally speaking, when doing an overlapping search, you’ll want to
build your regex DFAs with [<code>MatchKind::All</code>] semantics. Using
[<code>MatchKind::LeftmostFirst</code>] semantics with overlapping searches is
likely to lead to odd behavior since <code>LeftmostFirst</code> specifically omits
some matches that can never be reported due to its semantics.</p>
<p>The following example shows the differences between how these different
types of searches impact looking for matches of <code>[a-z]+</code> in the
haystack <code>abc</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{<span class="self">self</span>, dense}, MatchKind, MultiMatch};

<span class="kw">let </span>pattern = <span class="string">r&quot;[a-z]+&quot;</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;abc&quot;</span>.as_bytes();

<span class="comment">// With leftmost-first semantics, we test &quot;earliest&quot; and &quot;leftmost&quot;.
</span><span class="kw">let </span>re = dfa::regex::Builder::new()
    .dense(dense::Config::new().match_kind(MatchKind::LeftmostFirst))
    .build(pattern)<span class="question-mark">?</span>;

<span class="comment">// &quot;earliest&quot; searching isn&#39;t impacted by greediness
</span><span class="kw">let </span><span class="kw-2">mut </span>it = re.find_earliest_iter(haystack);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());

<span class="comment">// &quot;leftmost&quot; searching supports greediness (and non-greediness)
</span><span class="kw">let </span><span class="kw-2">mut </span>it = re.find_leftmost_iter(haystack);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());

<span class="comment">// For overlapping, we want &quot;all&quot; match kind semantics.
</span><span class="kw">let </span>re = dfa::regex::Builder::new()
    .dense(dense::Config::new().match_kind(MatchKind::All))
    .build(pattern)<span class="question-mark">?</span>;

<span class="comment">// In the overlapping search, we find all three possible matches
// starting at the beginning of the haystack.
</span><span class="kw">let </span><span class="kw-2">mut </span>it = re.find_overlapping_iter(haystack);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());
</code></pre></div>
<h2 id="sparse-dfas"><a href="#sparse-dfas">Sparse DFAs</a></h2>
<p>Since a <code>Regex</code> is generic over the <a href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton"><code>Automaton</code></a> trait, it can be
used with any kind of DFA. While this crate constructs dense DFAs by
default, it is easy enough to build corresponding sparse DFAs, and then
build a regex from them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::regex::Regex;

<span class="comment">// First, build a regex that uses dense DFAs.
</span><span class="kw">let </span>dense_re = Regex::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Second, build sparse DFAs from the forward and reverse dense DFAs.
</span><span class="kw">let </span>fwd = dense_re.forward().to_sparse()<span class="question-mark">?</span>;
<span class="kw">let </span>rev = dense_re.reverse().to_sparse()<span class="question-mark">?</span>;

<span class="comment">// Third, build a new regex from the constituent sparse DFAs.
</span><span class="kw">let </span>sparse_re = Regex::builder().build_from_dfas(fwd, rev);

<span class="comment">// A regex that uses sparse DFAs can be used just like with dense DFAs.
</span><span class="macro">assert_eq!</span>(<span class="bool-val">true</span>, sparse_re.is_match(<span class="string">b&quot;foo123&quot;</span>));
</code></pre></div>
<p>Alternatively, one can use a [<code>Builder</code>] to construct a sparse DFA
more succinctly. (Note though that dense DFAs are still constructed
first internally, and then converted to sparse DFAs, as in the example
above.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::regex::Regex;

<span class="kw">let </span>sparse_re = Regex::builder().build_sparse(<span class="string">r&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// A regex that uses sparse DFAs can be used just like with dense DFAs.
</span><span class="macro">assert!</span>(sparse_re.is_match(<span class="string">b&quot;foo123&quot;</span>));
</code></pre></div>
<h2 id="fallibility"><a href="#fallibility">Fallibility</a></h2>
<p>In non-default configurations, the DFAs generated in this module may
return an error during a search. (Currently, the only way this happens
is if quit bytes are added or Unicode word boundaries are heuristically
enabled, both of which are turned off by default.) For convenience, the
main search routines, like <a href="struct.Regex.html#method.find_leftmost" title="method regex_automata::dfa::regex::Regex::find_leftmost"><code>find_leftmost</code></a>,
will panic if an error occurs. However, if you need to use DFAs
which may produce an error at search time, then there are fallible
equivalents of all search routines. For example, for <code>find_leftmost</code>,
its fallible analog is <a href="struct.Regex.html#method.try_find_leftmost" title="method regex_automata::dfa::regex::Regex::try_find_leftmost"><code>try_find_leftmost</code></a>.
The routines prefixed with <code>try_</code> return <code>Result&lt;Option&lt;MultiMatch&gt;, MatchError&gt;</code>, where as the infallible routines simply return
<code>Option&lt;MultiMatch&gt;</code>.</p>
<h2 id="example"><a href="#example">Example</a></h2>
<p>This example shows how to cause a search to terminate if it sees a
<code>\n</code> byte, and handle the error returned. This could be useful if, for
example, you wanted to prevent a user supplied pattern from matching
across a line boundary.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{<span class="self">self</span>, regex::Regex}, MatchError};

<span class="kw">let </span>re = Regex::builder()
    .dense(dfa::dense::Config::new().quit(<span class="string">b&#39;\n&#39;</span>, <span class="bool-val">true</span>))
    .build(<span class="string">r&quot;foo\p{any}+bar&quot;</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>haystack = <span class="string">&quot;foo\nbar&quot;</span>.as_bytes();
<span class="comment">// Normally this would produce a match, since \p{any} contains &#39;\n&#39;.
// But since we instructed the automaton to enter a quit state if a
// &#39;\n&#39; is observed, this produces a match error instead.
</span><span class="kw">let </span>expected = MatchError::Quit { byte: <span class="number">0x0A</span>, offset: <span class="number">3 </span>};
<span class="kw">let </span>got = re.try_find_leftmost(haystack).unwrap_err();
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#421-702">source</a><a href="#impl-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a>, P: Prefilter&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;</h3></section></summary><div class="docblock"><p>Standard search routines for finding and iterating over matches.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_match" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#448-450">source</a><h4 class="code-header">pub fn <a href="#method.is_match" class="fn">is_match</a>(&amp;self, haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this regex matches the given haystack.</p>
<p>This routine may short circuit if it knows that scanning future input
will never lead to a different result. In particular, if the underlying
DFA enters a match state or a dead state, then this routine will return
<code>true</code> or <code>false</code>, respectively, without inspecting any future input.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>If the underlying DFAs return an error, then this routine panics. This
only occurs in non-default configurations where quit bytes are used or
Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_is_match" title="method regex_automata::dfa::regex::Regex::try_is_match"><code>try_is_match</code></a>.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::regex::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">&quot;foo[0-9]+bar&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="bool-val">true</span>, re.is_match(<span class="string">b&quot;foo12345bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="bool-val">false</span>, re.is_match(<span class="string">b&quot;foobar&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#488-490">source</a><h4 class="code-header">pub fn <a href="#method.find_earliest" class="fn">find_earliest</a>(&amp;self, haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first position at which a match is found.</p>
<p>This routine stops scanning input in precisely the same circumstances
as <code>is_match</code>. The key difference is that this routine returns the
position at which it stopped scanning input if and only if a match
was found. If no match is found, then <code>None</code> is returned.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>If the underlying DFAs return an error, then this routine panics. This
only occurs in non-default configurations where quit bytes are used or
Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_find_earliest" title="method regex_automata::dfa::regex::Regex::try_find_earliest"><code>try_find_earliest</code></a>.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{MultiMatch, dfa::regex::Regex};

<span class="comment">// Normally, the leftmost first match would greedily consume as many
// decimal digits as it could. But a match is detected as soon as one
// digit is seen.
</span><span class="kw">let </span>re = Regex::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>)),
    re.find_earliest(<span class="string">b&quot;foo12345&quot;</span>),
);

<span class="comment">// Normally, the end of the leftmost first match here would be 3,
// but the &quot;earliest&quot; match semantics detect a match earlier.
</span><span class="kw">let </span>re = Regex::new(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)), re.find_earliest(<span class="string">b&quot;abc&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#524-526">source</a><h4 class="code-header">pub fn <a href="#method.find_leftmost" class="fn">find_leftmost</a>(&amp;self, haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end offset of the leftmost match. If no match
exists, then <code>None</code> is returned.</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>If the underlying DFAs return an error, then this routine panics. This
only occurs in non-default configurations where quit bytes are used or
Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_find_leftmost" title="method regex_automata::dfa::regex::Regex::try_find_leftmost"><code>try_find_leftmost</code></a>.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{MultiMatch, dfa::regex::Regex};

<span class="comment">// Greediness is applied appropriately when compared to find_earliest.
</span><span class="kw">let </span>re = Regex::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">3</span>, <span class="number">11</span>)),
    re.find_leftmost(<span class="string">b&quot;zzzfoo12345zzz&quot;</span>),
);

<span class="comment">// Even though a match is found after reading the first byte (`a`),
// the default leftmost-first match semantics demand that we find the
// earliest match that prefers earlier parts of the pattern over latter
// parts.
</span><span class="kw">let </span>re = Regex::new(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>)), re.find_leftmost(<span class="string">b&quot;abc&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_overlapping" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#574-580">source</a><h4 class="code-header">pub fn <a href="#method.find_overlapping" class="fn">find_overlapping</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;</h4></section></summary><div class="docblock"><p>Search for the first overlapping match in <code>haystack</code>.</p>
<p>This routine is principally useful when searching for multiple patterns
on inputs where multiple patterns may match the same regions of text.
In particular, callers must preserve the automaton’s search state from
prior calls so that the implementation knows where the last match
occurred and which pattern was reported.</p>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>If the underlying DFAs return an error, then this routine panics. This
only occurs in non-default configurations where quit bytes are used or
Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_find_overlapping" title="method regex_automata::dfa::regex::Regex::try_find_overlapping"><code>try_find_overlapping</code></a>.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<p>This example shows how to run an overlapping search with multiple
regexes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{<span class="self">self</span>, regex::Regex}, MatchKind, MultiMatch};

<span class="kw">let </span>re = Regex::builder()
    .dense(dfa::dense::Config::new().match_kind(MatchKind::All))
    .build_many(<span class="kw-2">&amp;</span>[<span class="string">r&quot;\w+$&quot;</span>, <span class="string">r&quot;\S+$&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;@foo&quot;</span>.as_bytes();
<span class="kw">let </span><span class="kw-2">mut </span>state = dfa::OverlappingState::start();

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>));
<span class="kw">let </span>got = re.find_overlapping(haystack, <span class="kw-2">&amp;mut </span>state);
<span class="macro">assert_eq!</span>(expected, got);

<span class="comment">// The first pattern also matches at the same position, so re-running
// the search will yield another match. Notice also that the first
// pattern is returned after the second. This is because the second
// pattern begins its match before the first, is therefore an earlier
// match and is thus reported first.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>));
<span class="kw">let </span>got = re.find_overlapping(haystack, <span class="kw-2">&amp;mut </span>state);
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_iter" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#617-622">source</a><h4 class="code-header">pub fn <a href="#method.find_earliest_iter" class="fn">find_earliest_iter</a>&lt;'r, 't&gt;(
    &amp;'r self,
    haystack: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="struct" href="struct.FindEarliestMatches.html" title="struct regex_automata::dfa::regex::FindEarliestMatches">FindEarliestMatches</a>&lt;'r, 't, A, P&gt; <a href="#" class="tooltip" data-notable-ty="FindEarliestMatches&lt;&#39;r, &#39;t, A, P&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping “earliest” matches.</p>
<p>Match positions are reported as soon as a match is known to occur, even
if the standard leftmost match would be longer.</p>
<h5 id="panics-4"><a href="#panics-4">Panics</a></h5>
<p>If the underlying DFAs return an error during iteration, then iteration
panics. This only occurs in non-default configurations where quit bytes
are used or Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_find_earliest_iter" title="method regex_automata::dfa::regex::Regex::try_find_earliest_iter"><code>try_find_earliest_iter</code></a>.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<p>This example shows how to run an “earliest” iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::regex::Regex, MultiMatch};

<span class="kw">let </span>re = Regex::new(<span class="string">&quot;[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;123&quot;</span>.as_bytes();

<span class="comment">// Normally, a standard leftmost iterator would return a single
// match, but since &quot;earliest&quot; detects matches earlier, we get
// three matches.
</span><span class="kw">let </span><span class="kw-2">mut </span>it = re.find_earliest_iter(haystack);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_iter" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#653-658">source</a><h4 class="code-header">pub fn <a href="#method.find_leftmost_iter" class="fn">find_leftmost_iter</a>&lt;'r, 't&gt;(
    &amp;'r self,
    haystack: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="struct" href="struct.FindLeftmostMatches.html" title="struct regex_automata::dfa::regex::FindLeftmostMatches">FindLeftmostMatches</a>&lt;'r, 't, A, P&gt; <a href="#" class="tooltip" data-notable-ty="FindLeftmostMatches&lt;&#39;r, &#39;t, A, P&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping leftmost matches in the
given bytes. If no match exists, then the iterator yields no elements.</p>
<p>This corresponds to the “standard” regex search iterator.</p>
<h5 id="panics-5"><a href="#panics-5">Panics</a></h5>
<p>If the underlying DFAs return an error during iteration, then iteration
panics. This only occurs in non-default configurations where quit bytes
are used or Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_find_leftmost_iter" title="method regex_automata::dfa::regex::Regex::try_find_leftmost_iter"><code>try_find_leftmost_iter</code></a>.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{MultiMatch, dfa::regex::Regex};

<span class="kw">let </span>re = Regex::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>text = <span class="string">b&quot;foo1 foo12 foo123&quot;</span>;
<span class="kw">let </span>matches: Vec&lt;MultiMatch&gt; = re.find_leftmost_iter(text).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[
    MultiMatch::must(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>),
    MultiMatch::must(<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>),
    MultiMatch::must(<span class="number">0</span>, <span class="number">11</span>, <span class="number">17</span>),
]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_overlapping_iter" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#696-701">source</a><h4 class="code-header">pub fn <a href="#method.find_overlapping_iter" class="fn">find_overlapping_iter</a>&lt;'r, 't&gt;(
    &amp;'r self,
    haystack: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="struct" href="struct.FindOverlappingMatches.html" title="struct regex_automata::dfa::regex::FindOverlappingMatches">FindOverlappingMatches</a>&lt;'r, 't, A, P&gt; <a href="#" class="tooltip" data-notable-ty="FindOverlappingMatches&lt;&#39;r, &#39;t, A, P&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all overlapping matches in the given haystack.</p>
<p>This routine is principally useful when searching for multiple patterns
on inputs where multiple patterns may match the same regions of text.
The iterator takes care of handling the overlapping state that must be
threaded through every search.</p>
<h5 id="panics-6"><a href="#panics-6">Panics</a></h5>
<p>If the underlying DFAs return an error during iteration, then iteration
panics. This only occurs in non-default configurations where quit bytes
are used or Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_find_overlapping_iter" title="method regex_automata::dfa::regex::Regex::try_find_overlapping_iter"><code>try_find_overlapping_iter</code></a>.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<p>This example shows how to run an overlapping search with multiple
regexes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{<span class="self">self</span>, regex::Regex}, MatchKind, MultiMatch};

<span class="kw">let </span>re = Regex::builder()
    .dense(dfa::dense::Config::new().match_kind(MatchKind::All))
    .build_many(<span class="kw-2">&amp;</span>[<span class="string">r&quot;\w+$&quot;</span>, <span class="string">r&quot;\S+$&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;@foo&quot;</span>.as_bytes();

<span class="kw">let </span><span class="kw-2">mut </span>it = re.find_overlapping_iter(haystack);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(MultiMatch::must(<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());
</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CA,+P%3E-1" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#709-856">source</a><a href="#impl-Regex%3CA,+P%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a>, P: Prefilter&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;</h3></section></summary><div class="docblock"><p>Lower level infallible search routines that permit controlling where
the search starts and ends in a particular sequence. This is useful for
executing searches that need to take surrounding context into account. This
is required for correctly implementing iteration because of look-around
operators (<code>^</code>, <code>$</code>, <code>\b</code>).</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_match_at" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#734-741">source</a><h4 class="code-header">pub fn <a href="#method.is_match_at" class="fn">is_match_at</a>(&amp;self, haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>, end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this regex matches the given haystack.</p>
<p>This routine may short circuit if it knows that scanning future input
will never lead to a different result. In particular, if the underlying
DFA enters a match state or a dead state, then this routine will return
<code>true</code> or <code>false</code>, respectively, without inspecting any future input.</p>
<h5 id="searching-a-substring-of-the-haystack"><a href="#searching-a-substring-of-the-haystack">Searching a substring of the haystack</a></h5>
<p>Being an “at” search routine, this permits callers to search a
substring of <code>haystack</code> by specifying a range in <code>haystack</code>.
Why expose this as an API instead of just asking callers to use
<code>&amp;input[start..end]</code>? The reason is that regex matching often wants
to take the surrounding context into account in order to handle
look-around (<code>^</code>, <code>$</code> and <code>\b</code>).</p>
<h5 id="panics-7"><a href="#panics-7">Panics</a></h5>
<p>If the underlying DFAs return an error, then this routine panics. This
only occurs in non-default configurations where quit bytes are used or
Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_is_match_at" title="method regex_automata::dfa::regex::Regex::try_is_match_at"><code>try_is_match_at</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_at" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#771-778">source</a><h4 class="code-header">pub fn <a href="#method.find_earliest_at" class="fn">find_earliest_at</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first position at which a match is found.</p>
<p>This routine stops scanning input in precisely the same circumstances
as <code>is_match</code>. The key difference is that this routine returns the
position at which it stopped scanning input if and only if a match
was found. If no match is found, then <code>None</code> is returned.</p>
<h5 id="searching-a-substring-of-the-haystack-1"><a href="#searching-a-substring-of-the-haystack-1">Searching a substring of the haystack</a></h5>
<p>Being an “at” search routine, this permits callers to search a
substring of <code>haystack</code> by specifying a range in <code>haystack</code>.
Why expose this as an API instead of just asking callers to use
<code>&amp;input[start..end]</code>? The reason is that regex matching often wants
to take the surrounding context into account in order to handle
look-around (<code>^</code>, <code>$</code> and <code>\b</code>).</p>
<p>This is useful when implementing an iterator over matches
within the same haystack, which cannot be done correctly by simply
providing a subslice of <code>haystack</code>.</p>
<h5 id="panics-8"><a href="#panics-8">Panics</a></h5>
<p>If the underlying DFAs return an error, then this routine panics. This
only occurs in non-default configurations where quit bytes are used or
Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_find_earliest_at" title="method regex_automata::dfa::regex::Regex::try_find_earliest_at"><code>try_find_earliest_at</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_at" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#808-815">source</a><h4 class="code-header">pub fn <a href="#method.find_leftmost_at" class="fn">find_leftmost_at</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the same as <code>find_leftmost</code>, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, if the DFA is anchored, then
a match can only occur when <code>start == 0</code>.</p>
<h5 id="searching-a-substring-of-the-haystack-2"><a href="#searching-a-substring-of-the-haystack-2">Searching a substring of the haystack</a></h5>
<p>Being an “at” search routine, this permits callers to search a
substring of <code>haystack</code> by specifying a range in <code>haystack</code>.
Why expose this as an API instead of just asking callers to use
<code>&amp;input[start..end]</code>? The reason is that regex matching often wants
to take the surrounding context into account in order to handle
look-around (<code>^</code>, <code>$</code> and <code>\b</code>).</p>
<p>This is useful when implementing an iterator over matches within the
same haystack, which cannot be done correctly by simply providing a
subslice of <code>haystack</code>.</p>
<h5 id="panics-9"><a href="#panics-9">Panics</a></h5>
<p>If the underlying DFAs return an error, then this routine panics. This
only occurs in non-default configurations where quit bytes are used or
Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_find_leftmost_at" title="method regex_automata::dfa::regex::Regex::try_find_leftmost_at"><code>try_find_leftmost_at</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_overlapping_at" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#847-855">source</a><h4 class="code-header">pub fn <a href="#method.find_overlapping_at" class="fn">find_overlapping_at</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;</h4></section></summary><div class="docblock"><p>Search for the first overlapping match within a given range of
<code>haystack</code>.</p>
<p>This routine is principally useful when searching for multiple patterns
on inputs where multiple patterns may match the same regions of text.
In particular, callers must preserve the automaton’s search state from
prior calls so that the implementation knows where the last match
occurred and which pattern was reported.</p>
<h5 id="searching-a-substring-of-the-haystack-3"><a href="#searching-a-substring-of-the-haystack-3">Searching a substring of the haystack</a></h5>
<p>Being an “at” search routine, this permits callers to search a
substring of <code>haystack</code> by specifying a range in <code>haystack</code>.
Why expose this as an API instead of just asking callers to use
<code>&amp;input[start..end]</code>? The reason is that regex matching often wants
to take the surrounding context into account in order to handle
look-around (<code>^</code>, <code>$</code> and <code>\b</code>).</p>
<p>This is useful when implementing an iterator over matches
within the same haystack, which cannot be done correctly by simply
providing a subslice of <code>haystack</code>.</p>
<h5 id="panics-10"><a href="#panics-10">Panics</a></h5>
<p>If the underlying DFAs return an error, then this routine panics. This
only occurs in non-default configurations where quit bytes are used or
Unicode word boundaries are heuristically enabled.</p>
<p>The fallible version of this routine is
<a href="struct.Regex.html#method.try_find_overlapping_at" title="method regex_automata::dfa::regex::Regex::try_find_overlapping_at"><code>try_find_overlapping_at</code></a>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CA,+P%3E-2" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#868-1041">source</a><a href="#impl-Regex%3CA,+P%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a>, P: Prefilter&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;</h3></section></summary><div class="docblock"><p>Fallible search routines. These may return an error when the underlying
DFAs have been configured in a way that permits them to fail during a
search.</p>
<p>Errors during search only occur when the DFA has been explicitly
configured to do so, usually by specifying one or more “quit” bytes or by
heuristically enabling Unicode word boundaries.</p>
<p>Errors will never be returned using the default configuration. So these
fallible routines are only needed for particular configurations.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_is_match" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#888-890">source</a><h4 class="code-header">pub fn <a href="#method.try_is_match" class="fn">try_is_match</a>(&amp;self, haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a>, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns true if and only if this regex matches the given haystack.</p>
<p>This routine may short circuit if it knows that scanning future input
will never lead to a different result. In particular, if the underlying
DFA enters a match state or a dead state, then this routine will return
<code>true</code> or <code>false</code>, respectively, without inspecting any future input.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.is_match" title="method regex_automata::dfa::regex::Regex::is_match"><code>is_match</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_earliest" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#911-916">source</a><h4 class="code-header">pub fn <a href="#method.try_find_earliest" class="fn">try_find_earliest</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first position at which a match is found.</p>
<p>This routine stops scanning input in precisely the same circumstances
as <code>is_match</code>. The key difference is that this routine returns the
position at which it stopped scanning input if and only if a match
was found. If no match is found, then <code>None</code> is returned.</p>
<h5 id="errors-1"><a href="#errors-1">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.find_earliest" title="method regex_automata::dfa::regex::Regex::find_earliest"><code>find_earliest</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_leftmost" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#933-938">source</a><h4 class="code-header">pub fn <a href="#method.try_find_leftmost" class="fn">try_find_leftmost</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end offset of the leftmost match. If no match
exists, then <code>None</code> is returned.</p>
<h5 id="errors-2"><a href="#errors-2">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.find_leftmost" title="method regex_automata::dfa::regex::Regex::find_leftmost"><code>find_leftmost</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_overlapping" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#960-966">source</a><h4 class="code-header">pub fn <a href="#method.try_find_overlapping" class="fn">try_find_overlapping</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Search for the first overlapping match in <code>haystack</code>.</p>
<p>This routine is principally useful when searching for multiple patterns
on inputs where multiple patterns may match the same regions of text.
In particular, callers must preserve the automaton’s search state from
prior calls so that the implementation knows where the last match
occurred and which pattern was reported.</p>
<h5 id="errors-3"><a href="#errors-3">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.find_overlapping" title="method regex_automata::dfa::regex::Regex::find_overlapping"><code>find_overlapping</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_earliest_iter" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#985-990">source</a><h4 class="code-header">pub fn <a href="#method.try_find_earliest_iter" class="fn">try_find_earliest_iter</a>&lt;'r, 't&gt;(
    &amp;'r self,
    haystack: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="struct" href="struct.TryFindEarliestMatches.html" title="struct regex_automata::dfa::regex::TryFindEarliestMatches">TryFindEarliestMatches</a>&lt;'r, 't, A, P&gt; <a href="#" class="tooltip" data-notable-ty="TryFindEarliestMatches&lt;&#39;r, &#39;t, A, P&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping “earliest” matches.</p>
<p>Match positions are reported as soon as a match is known to occur, even
if the standard leftmost match would be longer.</p>
<h5 id="errors-4"><a href="#errors-4">Errors</a></h5>
<p>This iterator only yields errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.find_earliest_iter" title="method regex_automata::dfa::regex::Regex::find_earliest_iter"><code>find_earliest_iter</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_leftmost_iter" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1009-1014">source</a><h4 class="code-header">pub fn <a href="#method.try_find_leftmost_iter" class="fn">try_find_leftmost_iter</a>&lt;'r, 't&gt;(
    &amp;'r self,
    haystack: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="struct" href="struct.TryFindLeftmostMatches.html" title="struct regex_automata::dfa::regex::TryFindLeftmostMatches">TryFindLeftmostMatches</a>&lt;'r, 't, A, P&gt; <a href="#" class="tooltip" data-notable-ty="TryFindLeftmostMatches&lt;&#39;r, &#39;t, A, P&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping leftmost matches in the
given bytes. If no match exists, then the iterator yields no elements.</p>
<p>This corresponds to the “standard” regex search iterator.</p>
<h5 id="errors-5"><a href="#errors-5">Errors</a></h5>
<p>This iterator only yields errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.find_leftmost_iter" title="method regex_automata::dfa::regex::Regex::find_leftmost_iter"><code>find_leftmost_iter</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_overlapping_iter" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1035-1040">source</a><h4 class="code-header">pub fn <a href="#method.try_find_overlapping_iter" class="fn">try_find_overlapping_iter</a>&lt;'r, 't&gt;(
    &amp;'r self,
    haystack: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="struct" href="struct.TryFindOverlappingMatches.html" title="struct regex_automata::dfa::regex::TryFindOverlappingMatches">TryFindOverlappingMatches</a>&lt;'r, 't, A, P&gt; <a href="#" class="tooltip" data-notable-ty="TryFindOverlappingMatches&lt;&#39;r, &#39;t, A, P&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all overlapping matches in the given haystack.</p>
<p>This routine is principally useful when searching for multiple patterns
on inputs where multiple patterns may match the same regions of text.
The iterator takes care of handling the overlapping state that must be
threaded through every search.</p>
<h5 id="errors-6"><a href="#errors-6">Errors</a></h5>
<p>This iterator only yields errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.find_overlapping_iter" title="method regex_automata::dfa::regex::Regex::find_overlapping_iter"><code>find_overlapping_iter</code></a>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CA,+P%3E-3" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1045-1354">source</a><a href="#impl-Regex%3CA,+P%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a>, P: Prefilter&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;</h3></section></summary><div class="docblock"><p>Lower level fallible search routines that permit controlling where the
search starts and ends in a particular sequence.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_is_match_at" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1075-1090">source</a><h4 class="code-header">pub fn <a href="#method.try_is_match_at" class="fn">try_is_match_at</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a>, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns true if and only if this regex matches the given haystack.</p>
<p>This routine may short circuit if it knows that scanning future input
will never lead to a different result. In particular, if the underlying
DFA enters a match state or a dead state, then this routine will return
<code>true</code> or <code>false</code>, respectively, without inspecting any future input.</p>
<h5 id="searching-a-substring-of-the-haystack-4"><a href="#searching-a-substring-of-the-haystack-4">Searching a substring of the haystack</a></h5>
<p>Being an “at” search routine, this permits callers to search a
substring of <code>haystack</code> by specifying a range in <code>haystack</code>.
Why expose this as an API instead of just asking callers to use
<code>&amp;input[start..end]</code>? The reason is that regex matching often wants
to take the surrounding context into account in order to handle
look-around (<code>^</code>, <code>$</code> and <code>\b</code>).</p>
<h5 id="errors-7"><a href="#errors-7">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used, Unicode word boundaries are heuristically
enabled or limits are set on the number of times the lazy DFA’s cache
may be cleared.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.is_match_at" title="method regex_automata::dfa::regex::Regex::is_match_at"><code>is_match_at</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_earliest_at" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1124-1136">source</a><h4 class="code-header">pub fn <a href="#method.try_find_earliest_at" class="fn">try_find_earliest_at</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first position at which a match is found.</p>
<p>This routine stops scanning input in precisely the same circumstances
as <code>is_match</code>. The key difference is that this routine returns the
position at which it stopped scanning input if and only if a match
was found. If no match is found, then <code>None</code> is returned.</p>
<h5 id="searching-a-substring-of-the-haystack-5"><a href="#searching-a-substring-of-the-haystack-5">Searching a substring of the haystack</a></h5>
<p>Being an “at” search routine, this permits callers to search a
substring of <code>haystack</code> by specifying a range in <code>haystack</code>.
Why expose this as an API instead of just asking callers to use
<code>&amp;input[start..end]</code>? The reason is that regex matching often wants
to take the surrounding context into account in order to handle
look-around (<code>^</code>, <code>$</code> and <code>\b</code>).</p>
<p>This is useful when implementing an iterator over matches
within the same haystack, which cannot be done correctly by simply
providing a subslice of <code>haystack</code>.</p>
<h5 id="errors-8"><a href="#errors-8">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.find_earliest_at" title="method regex_automata::dfa::regex::Regex::find_earliest_at"><code>find_earliest_at</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_leftmost_at" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1203-1215">source</a><h4 class="code-header">pub fn <a href="#method.try_find_leftmost_at" class="fn">try_find_leftmost_at</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end offset of the leftmost match. If no match
exists, then <code>None</code> is returned.</p>
<h5 id="searching-a-substring-of-the-haystack-6"><a href="#searching-a-substring-of-the-haystack-6">Searching a substring of the haystack</a></h5>
<p>Being an “at” search routine, this permits callers to search a
substring of <code>haystack</code> by specifying a range in <code>haystack</code>.
Why expose this as an API instead of just asking callers to use
<code>&amp;input[start..end]</code>? The reason is that regex matching often wants
to take the surrounding context into account in order to handle
look-around (<code>^</code>, <code>$</code> and <code>\b</code>).</p>
<p>This is useful when implementing an iterator over matches
within the same haystack, which cannot be done correctly by simply
providing a subslice of <code>haystack</code>.</p>
<h5 id="errors-9"><a href="#errors-9">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.find_leftmost_at" title="method regex_automata::dfa::regex::Regex::find_leftmost_at"><code>find_leftmost_at</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_overlapping_at" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1290-1304">source</a><h4 class="code-header">pub fn <a href="#method.try_find_overlapping_at" class="fn">try_find_overlapping_at</a>(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.MultiMatch.html" title="struct regex_automata::MultiMatch">MultiMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Search for the first overlapping match within a given range of
<code>haystack</code>.</p>
<p>This routine is principally useful when searching for multiple patterns
on inputs where multiple patterns may match the same regions of text.
In particular, callers must preserve the automaton’s search state from
prior calls so that the implementation knows where the last match
occurred and which pattern was reported.</p>
<h5 id="searching-a-substring-of-the-haystack-7"><a href="#searching-a-substring-of-the-haystack-7">Searching a substring of the haystack</a></h5>
<p>Being an “at” search routine, this permits callers to search a
substring of <code>haystack</code> by specifying a range in <code>haystack</code>.
Why expose this as an API instead of just asking callers to use
<code>&amp;input[start..end]</code>? The reason is that regex matching often wants
to take the surrounding context into account in order to handle
look-around (<code>^</code>, <code>$</code> and <code>\b</code>).</p>
<p>This is useful when implementing an iterator over matches
within the same haystack, which cannot be done correctly by simply
providing a subslice of <code>haystack</code>.</p>
<h5 id="errors-10"><a href="#errors-10">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFA-based regexes, this only occurs in a non-default configuration
where quit bytes are used or Unicode word boundaries are heuristically
enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<p>The infallible (panics on error) version of this routine is
<a href="struct.Regex.html#method.find_overlapping_at" title="method regex_automata::dfa::regex::Regex::find_overlapping_at"><code>find_overlapping_at</code></a>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CA,+P%3E-4" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1358-1431">source</a><a href="#impl-Regex%3CA,+P%3E-4" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a>, P: Prefilter&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;</h3></section></summary><div class="docblock"><p>Non-search APIs for querying information about the regex and setting a
prefilter.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_prefilter" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1360-1367">source</a><h4 class="code-header">pub fn <a href="#method.with_prefilter" class="fn">with_prefilter</a>&lt;Q: Prefilter&gt;(self, prefilter: Q) -&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, Q&gt;</h4></section></summary><div class="docblock"><p>Attach the given prefilter to this regex.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.without_prefilter" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1370-1377">source</a><h4 class="code-header">pub fn <a href="#method.without_prefilter" class="fn">without_prefilter</a>(self) -&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;</h4></section></summary><div class="docblock"><p>Remove any prefilter from this regex.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.forward" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1384-1386">source</a><h4 class="code-header">pub fn <a href="#method.forward" class="fn">forward</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;A</a></h4></section></summary><div class="docblock"><p>Return the underlying DFA responsible for forward matching.</p>
<p>This is useful for accessing the underlying DFA and converting it to
some other format or size. See the [<code>Builder::build_from_dfas</code>] docs
for an example of where this might be useful.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reverse" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1393-1395">source</a><h4 class="code-header">pub fn <a href="#method.reverse" class="fn">reverse</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;A</a></h4></section></summary><div class="docblock"><p>Return the underlying DFA responsible for reverse matching.</p>
<p>This is useful for accessing the underlying DFA and converting it to
some other format or size. See the [<code>Builder::build_from_dfas</code>] docs
for an example of where this might be useful.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_count" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1408-1414">source</a><h4 class="code-header">pub fn <a href="#method.pattern_count" class="fn">pattern_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of patterns matched by this regex.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{MultiMatch, dfa::regex::Regex};

<span class="kw">let </span>re = Regex::new_many(<span class="kw-2">&amp;</span>[<span class="string">r&quot;[a-z]+&quot;</span>, <span class="string">r&quot;[0-9]+&quot;</span>, <span class="string">r&quot;\w+&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="number">3</span>, re.pattern_count());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prefilter" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#1420-1425">source</a><h4 class="code-header">pub fn <a href="#method.prefilter" class="fn">prefilter</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;dyn Prefilter&gt;</h4></section></summary><div class="docblock"><p>Convenience function for returning this regex’s prefilter as a trait
object.</p>
<p>If this regex doesn’t have a prefilter, then <code>None</code> is returned.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#243">source</a><a href="#impl-Clone-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>, P: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#243">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/clone.rs.html#132-134">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#243">source</a><a href="#impl-Debug-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>, P: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/regex.rs.html#243">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.69.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.69.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.69.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Regex%3CA,+P%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;<span class="where fmt-newline">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-Regex%3CA,+P%3E" class="impl"><a href="#impl-Send-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;<span class="where fmt-newline">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</span></h3></section><section id="impl-Sync-for-Regex%3CA,+P%3E" class="impl"><a href="#impl-Sync-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;<span class="where fmt-newline">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section><section id="impl-Unpin-for-Regex%3CA,+P%3E" class="impl"><a href="#impl-Unpin-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;<span class="where fmt-newline">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-Regex%3CA,+P%3E" class="impl"><a href="#impl-UnwindSafe-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A, P&gt;<span class="where fmt-newline">where
    A: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.69.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.69.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/borrow.rs.html#211">source</a><a href="#impl-Borrow%3CT%3E-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/borrow.rs.html#213">source</a></span><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/borrow.rs.html#220">source</a><a href="#impl-BorrowMut%3CT%3E-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/borrow.rs.html#221">source</a></span><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#733">source</a><a href="#impl-From%3CT%3E-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#736">source</a></span><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#717">source</a><a href="#impl-Into%3CU%3E-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#725">source</a></span><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/alloc/borrow.rs.html#82">source</a><a href="#impl-ToOwned-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/alloc/borrow.rs.html#87">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/alloc/borrow.rs.html#91">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#775">source</a><a href="#impl-TryFrom%3CU%3E-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#781">source</a></span><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Regex%3CA,+P%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#760">source</a><a href="#impl-TryInto%3CU%3E-for-Regex%3CA,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#766">source</a></span><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"FindEarliestMatches<'r, 't, A, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.FindEarliestMatches.html\" title=\"struct regex_automata::dfa::regex::FindEarliestMatches\">FindEarliestMatches</a>&lt;'r, 't, A, P&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'r, 't, A: <a class=\"trait\" href=\"../trait.Automaton.html\" title=\"trait regex_automata::dfa::Automaton\">Automaton</a>, P: Prefilter&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FindEarliestMatches.html\" title=\"struct regex_automata::dfa::regex::FindEarliestMatches\">FindEarliestMatches</a>&lt;'r, 't, A, P&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../../struct.MultiMatch.html\" title=\"struct regex_automata::MultiMatch\">MultiMatch</a>;</span>","FindLeftmostMatches<'r, 't, A, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.FindLeftmostMatches.html\" title=\"struct regex_automata::dfa::regex::FindLeftmostMatches\">FindLeftmostMatches</a>&lt;'r, 't, A, P&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'r, 't, A: <a class=\"trait\" href=\"../trait.Automaton.html\" title=\"trait regex_automata::dfa::Automaton\">Automaton</a>, P: Prefilter&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FindLeftmostMatches.html\" title=\"struct regex_automata::dfa::regex::FindLeftmostMatches\">FindLeftmostMatches</a>&lt;'r, 't, A, P&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../../struct.MultiMatch.html\" title=\"struct regex_automata::MultiMatch\">MultiMatch</a>;</span>","FindOverlappingMatches<'r, 't, A, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.FindOverlappingMatches.html\" title=\"struct regex_automata::dfa::regex::FindOverlappingMatches\">FindOverlappingMatches</a>&lt;'r, 't, A, P&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'r, 't, A: <a class=\"trait\" href=\"../trait.Automaton.html\" title=\"trait regex_automata::dfa::Automaton\">Automaton</a>, P: Prefilter&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FindOverlappingMatches.html\" title=\"struct regex_automata::dfa::regex::FindOverlappingMatches\">FindOverlappingMatches</a>&lt;'r, 't, A, P&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../../struct.MultiMatch.html\" title=\"struct regex_automata::MultiMatch\">MultiMatch</a>;</span>","TryFindEarliestMatches<'r, 't, A, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TryFindEarliestMatches.html\" title=\"struct regex_automata::dfa::regex::TryFindEarliestMatches\">TryFindEarliestMatches</a>&lt;'r, 't, A, P&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'r, 't, A: <a class=\"trait\" href=\"../trait.Automaton.html\" title=\"trait regex_automata::dfa::Automaton\">Automaton</a>, P: Prefilter&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TryFindEarliestMatches.html\" title=\"struct regex_automata::dfa::regex::TryFindEarliestMatches\">TryFindEarliestMatches</a>&lt;'r, 't, A, P&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../../struct.MultiMatch.html\" title=\"struct regex_automata::MultiMatch\">MultiMatch</a>, <a class=\"enum\" href=\"../../enum.MatchError.html\" title=\"enum regex_automata::MatchError\">MatchError</a>&gt;;</span>","TryFindLeftmostMatches<'r, 't, A, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TryFindLeftmostMatches.html\" title=\"struct regex_automata::dfa::regex::TryFindLeftmostMatches\">TryFindLeftmostMatches</a>&lt;'r, 't, A, P&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'r, 't, A: <a class=\"trait\" href=\"../trait.Automaton.html\" title=\"trait regex_automata::dfa::Automaton\">Automaton</a>, P: Prefilter&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TryFindLeftmostMatches.html\" title=\"struct regex_automata::dfa::regex::TryFindLeftmostMatches\">TryFindLeftmostMatches</a>&lt;'r, 't, A, P&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../../struct.MultiMatch.html\" title=\"struct regex_automata::MultiMatch\">MultiMatch</a>, <a class=\"enum\" href=\"../../enum.MatchError.html\" title=\"enum regex_automata::MatchError\">MatchError</a>&gt;;</span>","TryFindOverlappingMatches<'r, 't, A, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TryFindOverlappingMatches.html\" title=\"struct regex_automata::dfa::regex::TryFindOverlappingMatches\">TryFindOverlappingMatches</a>&lt;'r, 't, A, P&gt;</code></h3><pre><code><span class=\"where fmt-newline\">impl&lt;'r, 't, A: <a class=\"trait\" href=\"../trait.Automaton.html\" title=\"trait regex_automata::dfa::Automaton\">Automaton</a>, P: Prefilter&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TryFindOverlappingMatches.html\" title=\"struct regex_automata::dfa::regex::TryFindOverlappingMatches\">TryFindOverlappingMatches</a>&lt;'r, 't, A, P&gt;</span><span class=\"where fmt-newline\">    type <a href=\"https://doc.rust-lang.org/1.69.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"../../struct.MultiMatch.html\" title=\"struct regex_automata::MultiMatch\">MultiMatch</a>, <a class=\"enum\" href=\"../../enum.MatchError.html\" title=\"enum regex_automata::MatchError\">MatchError</a>&gt;;</span>"}</script></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0 (84c898d65 2023-04-16)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>