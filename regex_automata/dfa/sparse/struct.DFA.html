<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A sparse deterministic finite automaton (DFA) with variable sized states."><title>DFA in regex_automata::dfa::sparse - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../../../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../../../static.files/ayu-be46fdc453a55015.css"><script src="../../../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../regex_automata/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">DFA</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.as_ref">as_ref</a></li><li><a href="#method.from_bytes">from_bytes</a></li><li><a href="#method.from_bytes_unchecked">from_bytes_unchecked</a></li><li><a href="#method.has_starts_for_each_pattern">has_starts_for_each_pattern</a></li><li><a href="#method.memory_usage">memory_usage</a></li><li><a href="#method.write_to_big_endian">write_to_big_endian</a></li><li><a href="#method.write_to_len">write_to_len</a></li><li><a href="#method.write_to_little_endian">write_to_little_endian</a></li><li><a href="#method.write_to_native_endian">write_to_native_endian</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Automaton-for-DFA%3CT%3E">Automaton</a></li><li><a href="#impl-Clone-for-DFA%3CT%3E">Clone</a></li><li><a href="#impl-Debug-for-DFA%3CT%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-DFA%3CT%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-DFA%3CT%3E">Send</a></li><li><a href="#impl-Sync-for-DFA%3CT%3E">Sync</a></li><li><a href="#impl-Unpin-for-DFA%3CT%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-DFA%3CT%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-DFA%3CT%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-DFA%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-DFA%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-DFA%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-DFA%3CT%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-DFA%3CT%3E">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-DFA%3CT%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-DFA%3CT%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::dfa::sparse</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">dfa</a>::<wbr><a href="index.html">sparse</a>::<wbr><a class="struct" href="#">DFA</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/regex_automata/dfa/sparse.rs.html#121-136">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct DFA&lt;T&gt; { /* private fields */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A sparse deterministic finite automaton (DFA) with variable sized states.</p>
<p>In contrast to a <a href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">dense::DFA</a>, a sparse DFA uses
a more space efficient representation for its transitions. Consequently,
sparse DFAs may use much less memory than dense DFAs, but this comes at a
price. In particular, reading the more space efficient transitions takes
more work, and consequently, searching using a sparse DFA is typically
slower than a dense DFA.</p>
<p>A sparse DFA can be built using the default configuration via the
[<code>DFA::new</code>] constructor. Otherwise, one can configure various aspects
of a dense DFA via <a href="crate::dfa::dense::Builder"><code>dense::Builder</code></a>,
and then convert a dense DFA to a sparse DFA using
<a href="crate::dfa::dense::DFA::to_sparse"><code>dense::DFA::to_sparse</code></a>.</p>
<p>In general, a sparse DFA supports all the same search operations as a dense
DFA.</p>
<p>Making the choice between a dense and sparse DFA depends on your specific
work load. If you can sacrifice a bit of search time performance, then a
sparse DFA might be the best choice. In particular, while sparse DFAs are
probably always slower than dense DFAs, you may find that they are easily
fast enough for your purposes!</p>
<h2 id="type-parameters"><a href="#type-parameters">Type parameters</a></h2>
<p>A <code>DFA</code> has one type parameter, <code>T</code>, which is used to represent the parts
of a sparse DFA. <code>T</code> is typically a <code>Vec&lt;u8&gt;</code> or a <code>&amp;[u8]</code>.</p>
<h2 id="the-automaton-trait"><a href="#the-automaton-trait">The <code>Automaton</code> trait</a></h2>
<p>This type implements the <a href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton"><code>Automaton</code></a> trait, which means it can be used
for searching. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse::DFA},
    HalfMatch,
};

<span class="kw">let </span>dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#417-465">source</a><a href="#impl-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#420-426">source</a><h4 class="code-header">pub fn <a href="#method.as_ref" class="fn">as_ref</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Cheaply return a borrowed version of this sparse DFA. Specifically, the
DFA returned always uses <code>&amp;[u8]</code> for its transitions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.memory_usage" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#449-451">source</a><h4 class="code-header">pub fn <a href="#method.memory_usage" class="fn">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the memory usage, in bytes, of this DFA.</p>
<p>The memory usage is computed based on the number of bytes used to
represent this DFA.</p>
<p>This does <strong>not</strong> include the stack size used up by this DFA. To
compute that, use <code>std::mem::size_of::&lt;sparse::DFA&gt;()</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_starts_for_each_pattern" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#462-464">source</a><h4 class="code-header">pub fn <a href="#method.has_starts_for_each_pattern" class="fn">has_starts_for_each_pattern</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true only if this DFA has starting states for each pattern.</p>
<p>When a DFA has starting states for each pattern, then a search with the
DFA can be configured to only look for anchored matches of a specific
pattern. Specifically, APIs like <a href="../trait.Automaton.html#method.find_earliest_fwd_at" title="method regex_automata::dfa::Automaton::find_earliest_fwd_at"><code>Automaton::find_earliest_fwd_at</code></a>
can accept a non-None <code>pattern_id</code> if and only if this method returns
true. Otherwise, calling <code>find_earliest_fwd_at</code> will panic.</p>
<p>Note that if the DFA is empty, this always returns false.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3CT%3E-1" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#469-845">source</a><a href="#impl-DFA%3CT%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="docblock"><p>Routines for converting a sparse DFA to other representations, such as raw
bytes suitable for persistent storage.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.write_to_little_endian" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#667-672">source</a><h4 class="code-header">pub fn <a href="#method.write_to_little_endian" class="fn">write_to_little_endian</a>(
    &amp;self,
    dst: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>, <a class="struct" href="../../struct.SerializeError.html" title="struct regex_automata::SerializeError">SerializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to the given slice, in little endian
format. Upon success, the total number of bytes written to <code>dst</code> is
returned.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>This returns an error if the given destination slice is not big enough
to contain the full serialized DFA. If an error occurs, then nothing
is written to <code>dst</code>.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>This example shows how to serialize and deserialize a DFA without
dynamic memory allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse::DFA},
    HalfMatch,
};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Create a 4KB buffer on the stack to store our serialized DFA.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0u8</span>; <span class="number">4 </span>* (<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];
<span class="comment">// N.B. We use native endianness here to make the example work, but
// using write_to_little_endian would work on a little endian target.
</span><span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_big_endian" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#717-722">source</a><h4 class="code-header">pub fn <a href="#method.write_to_big_endian" class="fn">write_to_big_endian</a>(
    &amp;self,
    dst: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>, <a class="struct" href="../../struct.SerializeError.html" title="struct regex_automata::SerializeError">SerializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to the given slice, in big endian
format. Upon success, the total number of bytes written to <code>dst</code> is
returned.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<h5 id="errors-1"><a href="#errors-1">Errors</a></h5>
<p>This returns an error if the given destination slice is not big enough
to contain the full serialized DFA. If an error occurs, then nothing
is written to <code>dst</code>.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>This example shows how to serialize and deserialize a DFA without
dynamic memory allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse::DFA},
    HalfMatch,
};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Create a 4KB buffer on the stack to store our serialized DFA.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0u8</span>; <span class="number">4 </span>* (<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];
<span class="comment">// N.B. We use native endianness here to make the example work, but
// using write_to_big_endian would work on a big endian target.
</span><span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_native_endian" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#774-779">source</a><h4 class="code-header">pub fn <a href="#method.write_to_native_endian" class="fn">write_to_native_endian</a>(
    &amp;self,
    dst: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>, <a class="struct" href="../../struct.SerializeError.html" title="struct regex_automata::SerializeError">SerializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to the given slice, in native endian
format. Upon success, the total number of bytes written to <code>dst</code> is
returned.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<p>Generally speaking, native endian format should only be used when
you know that the target you’re compiling the DFA for matches the
endianness of the target on which you’re compiling DFA. For example,
if serialization and deserialization happen in the same process or on
the same machine. Otherwise, when serializing a DFA for use in a
portable environment, you’ll almost certainly want to serialize <em>both</em>
a little endian and a big endian version and then load the correct one
based on the target’s configuration.</p>
<h5 id="errors-2"><a href="#errors-2">Errors</a></h5>
<p>This returns an error if the given destination slice is not big enough
to contain the full serialized DFA. If an error occurs, then nothing
is written to <code>dst</code>.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>This example shows how to serialize and deserialize a DFA without
dynamic memory allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse::DFA},
    HalfMatch,
};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Create a 4KB buffer on the stack to store our serialized DFA.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0u8</span>; <span class="number">4 </span>* (<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];
<span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_len" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#836-844">source</a><h4 class="code-header">pub fn <a href="#method.write_to_len" class="fn">write_to_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the total number of bytes required to serialize this DFA.</p>
<p>This is useful for determining the size of the buffer required to pass
to one of the serialization routines:</p>
<ul>
<li><a href="struct.DFA.html#method.write_to_little_endian" title="method regex_automata::dfa::sparse::DFA::write_to_little_endian"><code>DFA::write_to_little_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_big_endian" title="method regex_automata::dfa::sparse::DFA::write_to_big_endian"><code>DFA::write_to_big_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_native_endian" title="method regex_automata::dfa::sparse::DFA::write_to_native_endian"><code>DFA::write_to_native_endian</code></a></li>
</ul>
<p>Passing a buffer smaller than the size returned by this method will
result in a serialization error.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>This example shows how to dynamically allocate enough room to serialize
a sparse DFA.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse::DFA},
    HalfMatch,
};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[<span class="number">0</span>; original_dfa.write_to_len()];
<span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3C%26'a+%5Bu8%5D%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#847-1088">source</a><a href="#impl-DFA%3C%26'a+%5Bu8%5D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_bytes" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1005-1017">source</a><h4 class="code-header">pub fn <a href="#method.from_bytes" class="fn">from_bytes</a>(
    slice: &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>), <a class="struct" href="../../struct.DeserializeError.html" title="struct regex_automata::DeserializeError">DeserializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Safely deserialize a sparse DFA with a specific state identifier
representation. Upon success, this returns both the deserialized DFA
and the number of bytes read from the given slice. Namely, the contents
of the slice beyond the DFA are not read.</p>
<p>Deserializing a DFA using this routine will never allocate heap memory.
For safety purposes, the DFA’s transitions will be verified such that
every transition points to a valid state. If this verification is too
costly, then a <a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a> API is provided, which
will always execute in constant time.</p>
<p>The bytes given must be generated by one of the serialization APIs
of a <code>DFA</code> using a semver compatible release of this crate. Those
include:</p>
<ul>
<li>[<code>DFA::to_bytes_little_endian</code>]</li>
<li>[<code>DFA::to_bytes_big_endian</code>]</li>
<li>[<code>DFA::to_bytes_native_endian</code>]</li>
<li><a href="struct.DFA.html#method.write_to_little_endian" title="method regex_automata::dfa::sparse::DFA::write_to_little_endian"><code>DFA::write_to_little_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_big_endian" title="method regex_automata::dfa::sparse::DFA::write_to_big_endian"><code>DFA::write_to_big_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_native_endian" title="method regex_automata::dfa::sparse::DFA::write_to_native_endian"><code>DFA::write_to_native_endian</code></a></li>
</ul>
<p>The <code>to_bytes</code> methods allocate and return a <code>Vec&lt;u8&gt;</code> for you. The
<code>write_to</code> methods do not allocate and write to an existing slice
(which may be on the stack). Since deserialization always uses the
native endianness of the target platform, the serialization API you use
should match the endianness of the target platform. (It’s often a good
idea to generate serialized DFAs for both forms of endianness and then
load the correct one based on endianness.)</p>
<h5 id="errors-3"><a href="#errors-3">Errors</a></h5>
<p>Generally speaking, it’s easier to state the conditions in which an
error is <em>not</em> returned. All of the following must be true:</p>
<ul>
<li>The bytes given must be produced by one of the serialization APIs
on this DFA, as mentioned above.</li>
<li>The endianness of the target platform matches the endianness used to
serialized the provided DFA.</li>
</ul>
<p>If any of the above are not true, then an error will be returned.</p>
<p>Note that unlike deserializing a
<a href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>, deserializing a sparse DFA has
no alignment requirements. That is, an alignment of <code>1</code> is valid.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This routine will never panic for any input.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<p>This example shows how to serialize a DFA to raw bytes, deserialize it
and then use it for searching.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse::DFA},
    HalfMatch,
};

<span class="kw">let </span>initial = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>bytes = initial.to_bytes_native_endian();
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
<h5 id="example-loading-a-dfa-from-static-memory"><a href="#example-loading-a-dfa-from-static-memory">Example: loading a DFA from static memory</a></h5>
<p>One use case this library supports is the ability to serialize a
DFA to disk and then use <code>include_bytes!</code> to store it in a compiled
Rust program. Those bytes can then be cheaply deserialized into a
<code>DFA</code> structure at runtime and used for searching without having to
re-compile the DFA (which can be quite costly).</p>
<p>We can show this in two parts. The first part is serializing the DFA to
a file:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::{Automaton, sparse::DFA};

<span class="kw">let </span>dfa = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Write a big endian serialized version of this DFA to a file.
</span><span class="kw">let </span>bytes = dfa.to_bytes_big_endian();
std::fs::write(<span class="string">&quot;foo.bigendian.dfa&quot;</span>, <span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>;

<span class="comment">// Do it again, but this time for little endian.
</span><span class="kw">let </span>bytes = dfa.to_bytes_little_endian();
std::fs::write(<span class="string">&quot;foo.littleendian.dfa&quot;</span>, <span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>;</code></pre></div>
<p>And now the second part is embedding the DFA into the compiled program
and deserializing it at runtime on first use. We use conditional
compilation to choose the correct endianness. As mentioned above, we
do not need to employ any special tricks to ensure a proper alignment,
since a sparse DFA has no alignment requirements.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse},
    HalfMatch,
};

<span class="kw">type </span>DFA = sparse::DFA&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>[u8]&gt;;

<span class="kw">fn </span>get_foo() -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>DFA {
    <span class="kw">use </span>std::cell::Cell;
    <span class="kw">use </span>std::mem::MaybeUninit;
    <span class="kw">use </span>std::sync::Once;

    <span class="attr">#[cfg(target_endian = <span class="string">&quot;big&quot;</span>)]
    </span><span class="kw">static </span>BYTES: <span class="kw-2">&amp;</span>[u8] = <span class="macro">include_bytes!</span>(<span class="string">&quot;foo.bigendian.dfa&quot;</span>);
    <span class="attr">#[cfg(target_endian = <span class="string">&quot;little&quot;</span>)]
    </span><span class="kw">static </span>BYTES: <span class="kw-2">&amp;</span>[u8] = <span class="macro">include_bytes!</span>(<span class="string">&quot;foo.littleendian.dfa&quot;</span>);

    <span class="kw">struct </span>Lazy(Cell&lt;MaybeUninit&lt;DFA&gt;&gt;);
    <span class="comment">// SAFETY: This is safe because DFA impls Sync.
    </span><span class="kw">unsafe impl </span>Sync <span class="kw">for </span>Lazy {}

    <span class="kw">static </span>INIT: Once = Once::new();
    <span class="kw">static </span>DFA: Lazy = Lazy(Cell::new(MaybeUninit::uninit()));

    INIT.call_once(|| {
        <span class="kw">let </span>(dfa, <span class="kw">_</span>) = DFA::from_bytes(BYTES)
            .expect(<span class="string">&quot;serialized DFA should be valid&quot;</span>);
        <span class="comment">// SAFETY: This is guaranteed to only execute once, and all
        // we do with the pointer is write the DFA to it.
        </span><span class="kw">unsafe </span>{
            (<span class="kw-2">*</span>DFA.<span class="number">0</span>.as_ptr()).as_mut_ptr().write(dfa);
        }
    });
    <span class="comment">// SAFETY: DFA is guaranteed to by initialized via INIT and is
    // stored in static memory.
    </span><span class="kw">unsafe </span>{
        <span class="kw">let </span>dfa = (<span class="kw-2">*</span>DFA.<span class="number">0</span>.as_ptr()).as_ptr();
        std::mem::transmute::&lt;<span class="kw-2">*const </span>DFA, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>DFA&gt;(dfa)
    }
}

<span class="kw">let </span>dfa = get_foo();
<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(expected)), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>));</code></pre></div>
<p>Alternatively, consider using
<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a>
or
<a href="https://crates.io/crates/once_cell"><code>once_cell</code></a>,
which will guarantee safety for you.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bytes_unchecked" class="method"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1060-1087">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_bytes_unchecked" class="fn">from_bytes_unchecked</a>(
    slice: &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>), <a class="struct" href="../../struct.DeserializeError.html" title="struct regex_automata::DeserializeError">DeserializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Deserialize a DFA with a specific state identifier representation in
constant time by omitting the verification of the validity of the
sparse transitions.</p>
<p>This is just like <a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a>, except it can potentially return
a DFA that exhibits undefined behavior if its transitions contains
invalid state identifiers.</p>
<p>This routine is useful if you need to deserialize a DFA cheaply and
cannot afford the transition validation performed by <code>from_bytes</code>.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>This routine is unsafe because it permits callers to provide
arbitrary transitions with possibly incorrect state identifiers. While
the various serialization routines will never return an incorrect
DFA, there is no guarantee that the bytes provided here
are correct. While <code>from_bytes_unchecked</code> will still do several forms
of basic validation, this routine does not check that the transitions
themselves are correct. Given an incorrect transition table, it is
possible for the search routines to access out-of-bounds memory because
of explicit bounds check elision.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse::DFA},
    HalfMatch,
};

<span class="kw">let </span>initial = DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>bytes = initial.to_bytes_native_endian();
<span class="comment">// SAFETY: This is guaranteed to be safe since the bytes given come
// directly from a compatible serialization routine.
</span><span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="kw">unsafe </span>{ DFA::from_bytes_unchecked(<span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>.<span class="number">0 </span>};

<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Automaton-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1115-1219">source</a><a href="#impl-Automaton-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_special_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1117-1119">source</a><a href="#method.is_special_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_special_state" class="fn">is_special_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a
“special” state. A special state is one or more of the following:
a dead state, a quit state, a match state, a start state or an
accelerated state. <a href="../trait.Automaton.html#tymethod.is_special_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_dead_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1122-1124">source</a><a href="#method.is_dead_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_dead_state" class="fn">is_dead_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a dead
state. When a DFA enters a dead state, it is impossible to leave. That
is, every transition on a dead state by definition leads back to the
same dead state. <a href="../trait.Automaton.html#tymethod.is_dead_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_quit_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1127-1129">source</a><a href="#method.is_quit_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_quit_state" class="fn">is_quit_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a quit
state. A quit state is like a dead state (it has no transitions other
than to itself), except it indicates that the DFA failed to complete
the search. When this occurs, callers can neither accept or reject that
a match occurred. <a href="../trait.Automaton.html#tymethod.is_quit_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_match_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1132-1134">source</a><a href="#method.is_match_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_match_state" class="fn">is_match_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a
match state. A match state is also referred to as a “final” state and
indicates that a match has been found. <a href="../trait.Automaton.html#tymethod.is_match_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_start_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1137-1139">source</a><a href="#method.is_start_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_start_state" class="fn">is_start_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a
start state. A start state is a state in which a DFA begins a search.
All searches begin in a start state. Moreover, since all matches are
delayed by one byte, a start state can never be a match state. <a href="../trait.Automaton.html#tymethod.is_start_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_accel_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1142-1144">source</a><a href="#method.is_accel_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_accel_state" class="fn">is_accel_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to an
accelerated state. <a href="../trait.Automaton.html#tymethod.is_accel_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1149-1152">source</a><a href="#method.next_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.next_state" class="fn">next_state</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>) -&gt; StateID</h4></section></summary><div class='docblock'>Transitions from the current state to the next state, given the next
byte of input. <a href="../trait.Automaton.html#tymethod.next_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_state_unchecked" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1155-1161">source</a><a href="#method.next_state_unchecked" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../trait.Automaton.html#tymethod.next_state_unchecked" class="fn">next_state_unchecked</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>) -&gt; StateID</h4></section></summary><div class='docblock'>Transitions from the current state to the next state, given the next
byte of input. <a href="../trait.Automaton.html#tymethod.next_state_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_eoi_state" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1164-1166">source</a><a href="#method.next_eoi_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.next_eoi_state" class="fn">next_eoi_state</a>(&amp;self, current: StateID) -&gt; StateID</h4></section></summary><div class='docblock'>Transitions from the current state to the next state for the special
EOI symbol. <a href="../trait.Automaton.html#tymethod.next_eoi_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_count" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1169-1171">source</a><a href="#method.pattern_count" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.pattern_count" class="fn">pattern_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the total number of patterns compiled into this DFA. <a href="../trait.Automaton.html#tymethod.pattern_count">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.match_count" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1174-1176">source</a><a href="#method.match_count" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.match_count" class="fn">match_count</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the total number of patterns that match in this state. <a href="../trait.Automaton.html#tymethod.match_count">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.match_pattern" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1179-1189">source</a><a href="#method.match_pattern" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.match_pattern" class="fn">match_pattern</a>(&amp;self, id: StateID, match_index: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></h4></section></summary><div class='docblock'>Returns the pattern ID corresponding to the given match index in the
given state. <a href="../trait.Automaton.html#tymethod.match_pattern">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.start_state_forward" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1192-1201">source</a><a href="#method.start_state_forward" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.start_state_forward" class="fn">start_state_forward</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; StateID</h4></section></summary><div class='docblock'>Return the ID of the start state for this DFA when executing a forward
search. <a href="../trait.Automaton.html#tymethod.start_state_forward">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.start_state_reverse" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1204-1213">source</a><a href="#method.start_state_reverse" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.start_state_reverse" class="fn">start_state_reverse</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; StateID</h4></section></summary><div class='docblock'>Return the ID of the start state for this DFA when executing a reverse
search. <a href="../trait.Automaton.html#tymethod.start_state_reverse">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.accelerator" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1216-1218">source</a><a href="#method.accelerator" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.accelerator" class="fn">accelerator</a>(&amp;self, id: StateID) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class='docblock'>Return a slice of bytes to accelerate for the given state, if possible. <a href="../trait.Automaton.html#method.accelerator">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_fwd" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#935-940">source</a><a href="#method.find_earliest_fwd" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_earliest_fwd" class="fn">find_earliest_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a forward search and returns the end position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned. <a href="../trait.Automaton.html#method.find_earliest_fwd">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_rev" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1001-1006">source</a><a href="#method.find_earliest_rev" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_earliest_rev" class="fn">find_earliest_rev</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse search and returns the start position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned. <a href="../trait.Automaton.html#method.find_earliest_rev">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_fwd" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1075-1080">source</a><a href="#method.find_leftmost_fwd" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_leftmost_fwd" class="fn">find_leftmost_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a forward search and returns the end position of the leftmost
match that is found. If no match exists, then <code>None</code> is returned. <a href="../trait.Automaton.html#method.find_leftmost_fwd">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_rev" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1147-1152">source</a><a href="#method.find_leftmost_rev" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_leftmost_rev" class="fn">find_leftmost_rev</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse search and returns the start of the position of the
leftmost match that is found. If no match exists, then <code>None</code> is
returned. <a href="../trait.Automaton.html#method.find_leftmost_rev">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_overlapping_fwd" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1218-1224">source</a><a href="#method.find_overlapping_fwd" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_overlapping_fwd" class="fn">find_overlapping_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes an overlapping forward search and returns the end position of
matches as they are found. If no match exists, then <code>None</code> is returned. <a href="../trait.Automaton.html#method.find_overlapping_fwd">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_fwd_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1420-1429">source</a><a href="#method.find_earliest_fwd_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_earliest_fwd_at" class="fn">find_earliest_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a forward search and returns the end position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned. <a href="../trait.Automaton.html#method.find_earliest_fwd_at">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_rev_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1460-1468">source</a><a href="#method.find_earliest_rev_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_earliest_rev_at" class="fn">find_earliest_rev_at</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse search and returns the start position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned. <a href="../trait.Automaton.html#method.find_earliest_rev_at">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_fwd_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1495-1504">source</a><a href="#method.find_leftmost_fwd_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_leftmost_fwd_at" class="fn">find_leftmost_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a forward search and returns the end position of the leftmost
match that is found. If no match exists, then <code>None</code> is returned. <a href="../trait.Automaton.html#method.find_leftmost_fwd_at">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_rev_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1532-1540">source</a><a href="#method.find_leftmost_rev_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_leftmost_rev_at" class="fn">find_leftmost_rev_at</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse search and returns the start of the position of the
leftmost match that is found. If no match exists, then <code>None</code> is
returned. <a href="../trait.Automaton.html#method.find_leftmost_rev_at">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_overlapping_fwd_at" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1584-1596">source</a><a href="#method.find_overlapping_fwd_at" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.find_overlapping_fwd_at" class="fn">find_overlapping_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes an overlapping forward search and returns the end position of
matches as they are found. If no match exists, then <code>None</code> is returned. <a href="../trait.Automaton.html#method.find_overlapping_fwd_at">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#120">source</a><a href="#impl-Clone-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#120">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/clone.rs.html#132-134">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1090-1113">source</a><a href="#impl-Debug-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1091-1112">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.69.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.69.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.69.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-DFA%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-DFA%3CT%3E" class="impl"><a href="#impl-Send-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</span></h3></section><section id="impl-Sync-for-DFA%3CT%3E" class="impl"><a href="#impl-Sync-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section><section id="impl-Unpin-for-DFA%3CT%3E" class="impl"><a href="#impl-Unpin-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-DFA%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.69.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.69.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/borrow.rs.html#211">source</a><a href="#impl-Borrow%3CT%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/borrow.rs.html#213">source</a></span><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/borrow.rs.html#220">source</a><a href="#impl-BorrowMut%3CT%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.69.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/borrow.rs.html#221">source</a></span><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.69.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#733">source</a><a href="#impl-From%3CT%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#736">source</a></span><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#717">source</a><a href="#impl-Into%3CU%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#725">source</a></span><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/alloc/borrow.rs.html#82">source</a><a href="#impl-ToOwned-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/alloc/borrow.rs.html#87">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/alloc/borrow.rs.html#91">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.69.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#775">source</a><a href="#impl-TryFrom%3CU%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#781">source</a></span><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#760">source</a><a href="#impl-TryInto%3CU%3E-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.69.0/src/core/convert/mod.rs.html#766">source</a></span><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.69.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><span class=\"where fmt-newline\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.69.0/std/primitive.u8.html\">u8</a>]</span><span class=\"where fmt-newline\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.69.0/std/primitive.u8.html\">u8</a>]</span>"}</script></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0 (84c898d65 2023-04-16)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>