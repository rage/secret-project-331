<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait describing the interface of a deterministic finite automaton (DFA)."><title>Automaton in regex_automata::dfa - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../../static.files/ayu-be46fdc453a55015.css"><script src="../../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../regex_automata/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../regex_automata/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Automaton</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.is_accel_state">is_accel_state</a></li><li><a href="#tymethod.is_dead_state">is_dead_state</a></li><li><a href="#tymethod.is_match_state">is_match_state</a></li><li><a href="#tymethod.is_quit_state">is_quit_state</a></li><li><a href="#tymethod.is_special_state">is_special_state</a></li><li><a href="#tymethod.is_start_state">is_start_state</a></li><li><a href="#tymethod.match_count">match_count</a></li><li><a href="#tymethod.match_pattern">match_pattern</a></li><li><a href="#tymethod.next_eoi_state">next_eoi_state</a></li><li><a href="#tymethod.next_state">next_state</a></li><li><a href="#tymethod.next_state_unchecked">next_state_unchecked</a></li><li><a href="#tymethod.pattern_count">pattern_count</a></li><li><a href="#tymethod.start_state_forward">start_state_forward</a></li><li><a href="#tymethod.start_state_reverse">start_state_reverse</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.accelerator">accelerator</a></li><li><a href="#method.find_earliest_fwd">find_earliest_fwd</a></li><li><a href="#method.find_earliest_fwd_at">find_earliest_fwd_at</a></li><li><a href="#method.find_earliest_rev">find_earliest_rev</a></li><li><a href="#method.find_earliest_rev_at">find_earliest_rev_at</a></li><li><a href="#method.find_leftmost_fwd">find_leftmost_fwd</a></li><li><a href="#method.find_leftmost_fwd_at">find_leftmost_fwd_at</a></li><li><a href="#method.find_leftmost_rev">find_leftmost_rev</a></li><li><a href="#method.find_leftmost_rev_at">find_leftmost_rev_at</a></li><li><a href="#method.find_overlapping_fwd">find_overlapping_fwd</a></li><li><a href="#method.find_overlapping_fwd_at">find_overlapping_fwd_at</a></li></ul><h3><a href="#foreign-impls">Implementations on Foreign Types</a></h3><ul class="block"><li><a href="#impl-Automaton-for-%26'a+T">&amp;&#39;a T</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In regex_automata::dfa</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../index.html">regex_automata</a>::<wbr><a href="index.html">dfa</a>::<wbr><a class="trait" href="#">Automaton</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/regex_automata/dfa/automaton.rs.html#100-1597">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe trait Automaton {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 25 methods</span></summary>    // Required methods
    fn <a href="#tymethod.next_state" class="fn">next_state</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>) -&gt; StateID;
<span class="item-spacer"></span>    unsafe fn <a href="#tymethod.next_state_unchecked" class="fn">next_state_unchecked</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>) -&gt; StateID;
<span class="item-spacer"></span>    fn <a href="#tymethod.next_eoi_state" class="fn">next_eoi_state</a>(&amp;self, current: StateID) -&gt; StateID;
<span class="item-spacer"></span>    fn <a href="#tymethod.start_state_forward" class="fn">start_state_forward</a>(
        &amp;self,
        pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
        start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
        end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
    ) -&gt; StateID;
<span class="item-spacer"></span>    fn <a href="#tymethod.start_state_reverse" class="fn">start_state_reverse</a>(
        &amp;self,
        pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
        start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
        end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
    ) -&gt; StateID;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_special_state" class="fn">is_special_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_dead_state" class="fn">is_dead_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_quit_state" class="fn">is_quit_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_match_state" class="fn">is_match_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_start_state" class="fn">is_start_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_accel_state" class="fn">is_accel_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.pattern_count" class="fn">pattern_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.match_count" class="fn">match_count</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.match_pattern" class="fn">match_pattern</a>(&amp;self, id: StateID, index: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>;

    // Provided methods
    fn <a href="#method.accelerator" class="fn">accelerator</a>(&amp;self, _id: StateID) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_earliest_fwd" class="fn">find_earliest_fwd</a>(
        &amp;self,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_earliest_rev" class="fn">find_earliest_rev</a>(
        &amp;self,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_leftmost_fwd" class="fn">find_leftmost_fwd</a>(
        &amp;self,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_leftmost_rev" class="fn">find_leftmost_rev</a>(
        &amp;self,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_overlapping_fwd" class="fn">find_overlapping_fwd</a>(
        &amp;self,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
        state: &amp;mut <a class="struct" href="struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_earliest_fwd_at" class="fn">find_earliest_fwd_at</a>(
        &amp;self,
        pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
        pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
        start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
        end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_earliest_rev_at" class="fn">find_earliest_rev_at</a>(
        &amp;self,
        pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
        start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
        end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_leftmost_fwd_at" class="fn">find_leftmost_fwd_at</a>(
        &amp;self,
        pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
        pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
        start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
        end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_leftmost_rev_at" class="fn">find_leftmost_rev_at</a>(
        &amp;self,
        pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
        start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
        end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_overlapping_fwd_at" class="fn">find_overlapping_fwd_at</a>(
        &amp;self,
        pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
        pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
        bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
        start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
        end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
        state: &amp;mut <a class="struct" href="struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt; { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait describing the interface of a deterministic finite automaton (DFA).</p>
<p>The complexity of this trait probably means that it’s unlikely for others
to implement it. The primary purpose of the trait is to provide for a way
of abstracting over different types of DFAs. In this crate, that means
dense DFAs and sparse DFAs. (Dense DFAs are fast but memory hungry, where
as sparse DFAs are slower but come with a smaller memory footprint. But
they otherwise provide exactly equivalent expressive power.) For example, a
<a href="regex/struct.Regex.html" title="struct regex_automata::dfa::regex::Regex"><code>dfa::regex::Regex</code></a> is generic over this trait.</p>
<p>Normally, a DFA’s execution model is very simple. You might have a single
start state, zero or more final or “match” states and a function that
transitions from one state to the next given the next byte of input.
Unfortunately, the interface described by this trait is significantly
more complicated than this. The complexity has a number of different
reasons, mostly motivated by performance, functionality or space savings:</p>
<ul>
<li>A DFA can search for multiple patterns simultaneously. This
means extra information is returned when a match occurs. Namely,
a match is not just an offset, but an offset plus a pattern ID.
<a href="trait.Automaton.html#tymethod.pattern_count" title="method regex_automata::dfa::Automaton::pattern_count"><code>Automaton::pattern_count</code></a> returns the number of patterns compiled into
the DFA, <a href="trait.Automaton.html#tymethod.match_count" title="method regex_automata::dfa::Automaton::match_count"><code>Automaton::match_count</code></a> returns the total number of patterns
that match in a particular state and <a href="trait.Automaton.html#tymethod.match_pattern" title="method regex_automata::dfa::Automaton::match_pattern"><code>Automaton::match_pattern</code></a> permits
iterating over the patterns that match in a particular state.</li>
<li>A DFA can have multiple start states, and the choice of which start
state to use depends on the content of the string being searched and
position of the search, as well as whether the search is an anchored
search for a specific pattern in the DFA. Moreover, computing the start
state also depends on whether you’re doing a forward or a reverse search.
<a href="trait.Automaton.html#tymethod.start_state_forward" title="method regex_automata::dfa::Automaton::start_state_forward"><code>Automaton::start_state_forward</code></a> and <a href="trait.Automaton.html#tymethod.start_state_reverse" title="method regex_automata::dfa::Automaton::start_state_reverse"><code>Automaton::start_state_reverse</code></a>
are used to compute the start state for forward and reverse searches,
respectively.</li>
<li>All matches are delayed by one byte to support things like <code>$</code> and <code>\b</code>
at the end of a pattern. Therefore, every use of a DFA is required to use
<a href="trait.Automaton.html#tymethod.next_eoi_state" title="method regex_automata::dfa::Automaton::next_eoi_state"><code>Automaton::next_eoi_state</code></a>
at the end of the search to compute the final transition.</li>
<li>For optimization reasons, some states are treated specially. Every
state is either special or not, which can be determined via the
<a href="trait.Automaton.html#tymethod.is_special_state" title="method regex_automata::dfa::Automaton::is_special_state"><code>Automaton::is_special_state</code></a> method. If it’s special, then the state
must be at least one of a few possible types of states. (Note that some
types can overlap, for example, a match state can also be an accel state.
But some types can’t. If a state is a dead state, then it can never be any
other type of state.) Those types are:
<ul>
<li>A dead state. A dead state means the DFA will never enter a match
state. This can be queried via the <a href="trait.Automaton.html#tymethod.is_dead_state" title="method regex_automata::dfa::Automaton::is_dead_state"><code>Automaton::is_dead_state</code></a> method.</li>
<li>A quit state. A quit state occurs if the DFA had to stop the search
prematurely for some reason. This can be queried via the
<a href="trait.Automaton.html#tymethod.is_quit_state" title="method regex_automata::dfa::Automaton::is_quit_state"><code>Automaton::is_quit_state</code></a> method.</li>
<li>A match state. A match state occurs when a match is found. When a DFA
enters a match state, the search may stop immediately (when looking
for the earliest match), or it may continue to find the leftmost-first
match. This can be queried via the <a href="trait.Automaton.html#tymethod.is_match_state" title="method regex_automata::dfa::Automaton::is_match_state"><code>Automaton::is_match_state</code></a>
method.</li>
<li>A start state. A start state is where a search begins. For every
search, there is exactly one start state that is used, however, a
DFA may contain many start states. When the search is in a start
state, it may use a prefilter to quickly skip to candidate matches
without executing the DFA on every byte. This can be queried via the
<a href="trait.Automaton.html#tymethod.is_start_state" title="method regex_automata::dfa::Automaton::is_start_state"><code>Automaton::is_start_state</code></a> method.</li>
<li>An accel state. An accel state is a state that is accelerated.
That is, it is a state where <em>most</em> of its transitions loop back to
itself and only a small number of transitions lead to other states.
This kind of state is said to be accelerated because a search routine
can quickly look for the bytes leading out of the state instead of
continuing to execute the DFA on each byte. This can be queried via the
<a href="trait.Automaton.html#tymethod.is_accel_state" title="method regex_automata::dfa::Automaton::is_accel_state"><code>Automaton::is_accel_state</code></a> method. And the bytes that lead out of
the state can be queried via the <a href="trait.Automaton.html#method.accelerator" title="method regex_automata::dfa::Automaton::accelerator"><code>Automaton::accelerator</code></a> method.</li>
</ul>
</li>
</ul>
<p>There are a number of provided methods on this trait that implement
efficient searching (for forwards and backwards) with a DFA using all of
the above features of this trait. In particular, given the complexity of
all these features, implementing a search routine in this trait is not
straight forward. If you need to do this for specialized reasons, then
it’s recommended to look at the source of this crate. It is intentionally
well commented to help with this. With that said, it is possible to
somewhat simplify the search routine. For example, handling accelerated
states is strictly optional, since it is always correct to assume that
<code>Automaton::is_accel_state</code> returns false. However, one complex part of
writing a search routine using this trait is handling the 1-byte delay of a
match. That is not optional.</p>
<h2 id="safety"><a href="#safety">Safety</a></h2>
<p>This trait is unsafe to implement because DFA searching may rely on the
correctness of the implementation for memory safety. For example, DFA
searching may use explicit bounds check elision, which will in turn rely
on the correctness of every function that returns a state ID.</p>
<p>When implementing this trait, one must uphold the documented correctness
guarantees. Otherwise, undefined behavior may occur.</p>
</div></details><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.next_state" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#142">source</a><h4 class="code-header">fn <a href="#tymethod.next_state" class="fn">next_state</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>) -&gt; StateID</h4></section></summary><div class="docblock"><p>Transitions from the current state to the next state, given the next
byte of input.</p>
<p>Implementations must guarantee that the returned ID is always a valid
ID when <code>current</code> refers to a valid ID. Moreover, the transition
function must be defined for all possible values of <code>input</code>.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>If the given ID does not refer to a valid state, then this routine
may panic but it also may not panic and instead return an invalid ID.
However, if the caller provides an invalid ID then this must never
sacrifice memory safety.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>This shows a simplistic example for walking a DFA for a given haystack
by using the <code>next_state</code> method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::{Automaton, dense};

<span class="kw">let </span>dfa = dense::DFA::new(<span class="string">r&quot;[a-z]+r&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;bar&quot;</span>.as_bytes();

<span class="comment">// The start state is determined by inspecting the position and the
// initial bytes of the haystack.
</span><span class="kw">let </span><span class="kw-2">mut </span>state = dfa.start_state_forward(
    <span class="prelude-val">None</span>, haystack, <span class="number">0</span>, haystack.len(),
);
<span class="comment">// Walk all the bytes in the haystack.
</span><span class="kw">for </span><span class="kw-2">&amp;</span>b <span class="kw">in </span>haystack {
    state = dfa.next_state(state, b);
}
<span class="comment">// Matches are always delayed by 1 byte, so we must explicitly walk the
// special &quot;EOI&quot; transition at the end of the search.
</span>state = dfa.next_eoi_state(state);
<span class="macro">assert!</span>(dfa.is_match_state(state));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.next_state_unchecked" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#159-163">source</a><h4 class="code-header">unsafe fn <a href="#tymethod.next_state_unchecked" class="fn">next_state_unchecked</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>) -&gt; StateID</h4></section></summary><div class="docblock"><p>Transitions from the current state to the next state, given the next
byte of input.</p>
<p>Unlike <a href="trait.Automaton.html#tymethod.next_state" title="method regex_automata::dfa::Automaton::next_state"><code>Automaton::next_state</code></a>, implementations may implement this
more efficiently by assuming that the <code>current</code> state ID is valid.
Typically, this manifests by eliding bounds checks.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>Callers of this method must guarantee that <code>current</code> refers to a valid
state ID. If <code>current</code> is not a valid state ID for this automaton, then
calling this routine may result in undefined behavior.</p>
<p>If <code>current</code> is valid, then implementations must guarantee that the ID
returned is valid for all possible values of <code>input</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.next_eoi_state" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#221">source</a><h4 class="code-header">fn <a href="#tymethod.next_eoi_state" class="fn">next_eoi_state</a>(&amp;self, current: StateID) -&gt; StateID</h4></section></summary><div class="docblock"><p>Transitions from the current state to the next state for the special
EOI symbol.</p>
<p>Implementations must guarantee that the returned ID is always a valid
ID when <code>current</code> refers to a valid ID.</p>
<p>This routine must be called at the end of every search in a correct
implementation of search. Namely, DFAs in this crate delay matches
by one byte in order to support look-around operators. Thus, after
reaching the end of a haystack, a search implementation must follow one
last EOI transition.</p>
<p>It is best to think of EOI as an additional symbol in the alphabet of
a DFA that is distinct from every other symbol. That is, the alphabet
of DFAs in this crate has a logical size of 257 instead of 256, where
256 corresponds to every possible inhabitant of <code>u8</code>. (In practice, the
physical alphabet size may be smaller because of alphabet compression
via equivalence classes, but EOI is always represented somehow in the
alphabet.)</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>If the given ID does not refer to a valid state, then this routine
may panic but it also may not panic and instead return an invalid ID.
However, if the caller provides an invalid ID then this must never
sacrifice memory safety.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>This shows a simplistic example for walking a DFA for a given haystack,
and then finishing the search with the final EOI transition.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::{Automaton, dense};

<span class="kw">let </span>dfa = dense::DFA::new(<span class="string">r&quot;[a-z]+r&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;bar&quot;</span>.as_bytes();

<span class="comment">// The start state is determined by inspecting the position and the
// initial bytes of the haystack.
</span><span class="kw">let </span><span class="kw-2">mut </span>state = dfa.start_state_forward(
    <span class="prelude-val">None</span>, haystack, <span class="number">0</span>, haystack.len(),
);
<span class="comment">// Walk all the bytes in the haystack.
</span><span class="kw">for </span><span class="kw-2">&amp;</span>b <span class="kw">in </span>haystack {
    state = dfa.next_state(state, b);
}
<span class="comment">// Matches are always delayed by 1 byte, so we must explicitly walk
// the special &quot;EOI&quot; transition at the end of the search. Without this
// final transition, the assert below will fail since the DFA will not
// have entered a match state yet!
</span>state = dfa.next_eoi_state(state);
<span class="macro">assert!</span>(dfa.is_match_state(state));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.start_state_forward" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#252-258">source</a><h4 class="code-header">fn <a href="#tymethod.start_state_forward" class="fn">start_state_forward</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; StateID</h4></section></summary><div class="docblock"><p>Return the ID of the start state for this DFA when executing a forward
search.</p>
<p>Unlike typical DFA implementations, the start state for DFAs in this
crate is dependent on a few different factors:</p>
<ul>
<li>The pattern ID, if present. When the underlying DFA has been compiled
with multiple patterns <em>and</em> the DFA has been configured to compile
an anchored start state for each pattern, then a pattern ID may be
specified to execute an anchored search for that specific pattern.
If <code>pattern_id</code> is invalid or if the DFA doesn’t have start states
compiled for each pattern, then implementations must panic. DFAs in
this crate can be configured to compile start states for each pattern
via
<a href="crate::dfa::dense::Config::starts_for_each_pattern"><code>dense::Config::starts_for_each_pattern</code></a>.</li>
<li>When <code>start &gt; 0</code>, the byte at index <code>start - 1</code> may influence the
start state if the regex uses <code>^</code> or <code>\b</code>.</li>
<li>Similarly, when <code>start == 0</code>, it may influence the start state when
the regex uses <code>^</code> or <code>\A</code>.</li>
<li>Currently, <code>end</code> is unused.</li>
<li>Whether the search is a forward or reverse search. This routine can
only be used for forward searches.</li>
</ul>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>Implementations must panic if <code>start..end</code> is not a valid sub-slice of
<code>bytes</code>. Implementations must also panic if <code>pattern_id</code> is non-None
and does not refer to a valid pattern, or if the DFA was not compiled
with anchored start states for each pattern.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.start_state_reverse" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#288-294">source</a><h4 class="code-header">fn <a href="#tymethod.start_state_reverse" class="fn">start_state_reverse</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; StateID</h4></section></summary><div class="docblock"><p>Return the ID of the start state for this DFA when executing a reverse
search.</p>
<p>Unlike typical DFA implementations, the start state for DFAs in this
crate is dependent on a few different factors:</p>
<ul>
<li>The pattern ID, if present. When the underlying DFA has been compiled
with multiple patterns <em>and</em> the DFA has been configured to compile an
anchored start state for each pattern, then a pattern ID may be
specified to execute an anchored search for that specific pattern. If
<code>pattern_id</code> is invalid or if the DFA doesn’t have start states compiled
for each pattern, then implementations must panic. DFAs in this crate
can be configured to compile start states for each pattern via
<a href="crate::dfa::dense::Config::starts_for_each_pattern"><code>dense::Config::starts_for_each_pattern</code></a>.</li>
<li>When <code>end &lt; bytes.len()</code>, the byte at index <code>end</code> may influence the
start state if the regex uses <code>$</code> or <code>\b</code>.</li>
<li>Similarly, when <code>end == bytes.len()</code>, it may influence the start
state when the regex uses <code>$</code> or <code>\z</code>.</li>
<li>Currently, <code>start</code> is unused.</li>
<li>Whether the search is a forward or reverse search. This routine can
only be used for reverse searches.</li>
</ul>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>Implementations must panic if <code>start..end</code> is not a valid sub-slice of
<code>bytes</code>. Implementations must also panic if <code>pattern_id</code> is non-None
and does not refer to a valid pattern, or if the DFA was not compiled
with anchored start states for each pattern.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_special_state" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#417">source</a><h4 class="code-header">fn <a href="#tymethod.is_special_state" class="fn">is_special_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to a
“special” state. A special state is one or more of the following:
a dead state, a quit state, a match state, a start state or an
accelerated state.</p>
<p>A correct implementation <em>may</em> always return false for states that
are either start states or accelerated states, since that information
is only intended to be used for optimization purposes. Correct
implementations must return true if the state is a dead, quit or match
state. This is because search routines using this trait must be able
to rely on <code>is_special_state</code> as an indicator that a state may need
special treatment. (For example, when a search routine sees a dead
state, it must terminate.)</p>
<p>This routine permits search implementations to use a single branch to
check whether a state needs special attention before executing the next
transition. The example below shows how to do this.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>This example shows how <code>is_special_state</code> can be used to implement a
correct search routine with minimal branching. In particular, this
search routine implements “leftmost” matching, which means that it
doesn’t immediately stop once a match is found. Instead, it continues
until it reaches a dead state.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, dense},
    HalfMatch, MatchError, PatternID,
};

<span class="kw">fn </span>find_leftmost_first&lt;A: Automaton&gt;(
    dfa: <span class="kw-2">&amp;</span>A,
    haystack: <span class="kw-2">&amp;</span>[u8],
) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Option</span>&lt;HalfMatch&gt;, MatchError&gt; {
    <span class="comment">// The start state is determined by inspecting the position and the
    // initial bytes of the haystack. Note that start states can never
    // be match states (since DFAs in this crate delay matches by 1
    // byte), so we don&#39;t need to check if the start state is a match.
    </span><span class="kw">let </span><span class="kw-2">mut </span>state = dfa.start_state_forward(
        <span class="prelude-val">None</span>, haystack, <span class="number">0</span>, haystack.len(),
    );
    <span class="kw">let </span><span class="kw-2">mut </span>last_match = <span class="prelude-val">None</span>;
    <span class="comment">// Walk all the bytes in the haystack. We can quit early if we see
    // a dead or a quit state. The former means the automaton will
    // never transition to any other state. The latter means that the
    // automaton entered a condition in which its search failed.
    </span><span class="kw">for </span>(i, <span class="kw-2">&amp;</span>b) <span class="kw">in </span>haystack.iter().enumerate() {
        state = dfa.next_state(state, b);
        <span class="kw">if </span>dfa.is_special_state(state) {
            <span class="kw">if </span>dfa.is_match_state(state) {
                last_match = <span class="prelude-val">Some</span>(HalfMatch::new(
                    dfa.match_pattern(state, <span class="number">0</span>),
                    i,
                ));
            } <span class="kw">else if </span>dfa.is_dead_state(state) {
                <span class="kw">return </span><span class="prelude-val">Ok</span>(last_match);
            } <span class="kw">else if </span>dfa.is_quit_state(state) {
                <span class="comment">// It is possible to enter into a quit state after
                // observing a match has occurred. In that case, we
                // should return the match instead of an error.
                </span><span class="kw">if </span>last_match.is_some() {
                    <span class="kw">return </span><span class="prelude-val">Ok</span>(last_match);
                }
                <span class="kw">return </span><span class="prelude-val">Err</span>(MatchError::Quit { byte: b, offset: i });
            }
            <span class="comment">// Implementors may also want to check for start or accel
            // states and handle them differently for performance
            // reasons. But it is not necessary for correctness.
        </span>}
    }
    <span class="comment">// Matches are always delayed by 1 byte, so we must explicitly walk
    // the special &quot;EOI&quot; transition at the end of the search.
    </span>state = dfa.next_eoi_state(state);
    <span class="kw">if </span>dfa.is_match_state(state) {
        last_match = <span class="prelude-val">Some</span>(HalfMatch::new(
            dfa.match_pattern(state, <span class="number">0</span>),
            haystack.len(),
        ));
    }
    <span class="prelude-val">Ok</span>(last_match)
}

<span class="comment">// We use a greedy &#39;+&#39; operator to show how the search doesn&#39;t just
// stop once a match is detected. It continues extending the match.
// Using &#39;[a-z]+?&#39; would also work as expected and stop the search
// early. Greediness is built into the automaton.
</span><span class="kw">let </span>dfa = dense::DFA::new(<span class="string">r&quot;[a-z]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;123 foobar 4567&quot;</span>.as_bytes();
<span class="kw">let </span>mat = find_leftmost_first(<span class="kw-2">&amp;</span>dfa, haystack)<span class="question-mark">?</span>.unwrap();
<span class="macro">assert_eq!</span>(mat.pattern().as_usize(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(mat.offset(), <span class="number">10</span>);

<span class="comment">// Here&#39;s another example that tests our handling of the special EOI
// transition. This will fail to find a match if we don&#39;t call
// &#39;next_eoi_state&#39; at the end of the search since the match isn&#39;t
// found until the final byte in the haystack.
</span><span class="kw">let </span>dfa = dense::DFA::new(<span class="string">r&quot;[0-9]{4}&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;123 foobar 4567&quot;</span>.as_bytes();
<span class="kw">let </span>mat = find_leftmost_first(<span class="kw-2">&amp;</span>dfa, haystack)<span class="question-mark">?</span>.unwrap();
<span class="macro">assert_eq!</span>(mat.pattern().as_usize(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(mat.offset(), <span class="number">15</span>);

<span class="comment">// And note that our search implementation above automatically works
// with multi-DFAs. Namely, `dfa.match_pattern(match_state, 0)` selects
// the appropriate pattern ID for us.
</span><span class="kw">let </span>dfa = dense::DFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">r&quot;[a-z]+&quot;</span>, <span class="string">r&quot;[0-9]+&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;123 foobar 4567&quot;</span>.as_bytes();
<span class="kw">let </span>mat = find_leftmost_first(<span class="kw-2">&amp;</span>dfa, haystack)<span class="question-mark">?</span>.unwrap();
<span class="macro">assert_eq!</span>(mat.pattern().as_usize(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(mat.offset(), <span class="number">3</span>);
<span class="kw">let </span>mat = find_leftmost_first(<span class="kw-2">&amp;</span>dfa, <span class="kw-2">&amp;</span>haystack[<span class="number">3</span>..])<span class="question-mark">?</span>.unwrap();
<span class="macro">assert_eq!</span>(mat.pattern().as_usize(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(mat.offset(), <span class="number">7</span>);
<span class="kw">let </span>mat = find_leftmost_first(<span class="kw-2">&amp;</span>dfa, <span class="kw-2">&amp;</span>haystack[<span class="number">10</span>..])<span class="question-mark">?</span>.unwrap();
<span class="macro">assert_eq!</span>(mat.pattern().as_usize(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(mat.offset(), <span class="number">5</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_dead_state" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#448">source</a><h4 class="code-header">fn <a href="#tymethod.is_dead_state" class="fn">is_dead_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to a dead
state. When a DFA enters a dead state, it is impossible to leave. That
is, every transition on a dead state by definition leads back to the
same dead state.</p>
<p>In practice, the dead state always corresponds to the identifier <code>0</code>.
Moreover, in practice, there is only one dead state.</p>
<p>The existence of a dead state is not strictly required in the classical
model of finite state machines, where one generally only cares about
the question of whether an input sequence matches or not. Dead states
are not needed to answer that question, since one can immediately quit
as soon as one enters a final or “match” state. However, we don’t just
care about matches but also care about the location of matches, and
more specifically, care about semantics like “greedy” matching.</p>
<p>For example, given the pattern <code>a+</code> and the input <code>aaaz</code>, the dead
state won’t be entered until the state machine reaches <code>z</code> in the
input, at which point, the search routine can quit. But without the
dead state, the search routine wouldn’t know when to quit. In a
classical representation, the search routine would stop after seeing
the first <code>a</code> (which is when the search would enter a match state). But
this wouldn’t implement “greedy” matching where <code>a+</code> matches as many
<code>a</code>’s as possible.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>See the example for <a href="trait.Automaton.html#tymethod.is_special_state" title="method regex_automata::dfa::Automaton::is_special_state"><code>Automaton::is_special_state</code></a> for how to use this
method correctly.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_quit_state" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#485">source</a><h4 class="code-header">fn <a href="#tymethod.is_quit_state" class="fn">is_quit_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to a quit
state. A quit state is like a dead state (it has no transitions other
than to itself), except it indicates that the DFA failed to complete
the search. When this occurs, callers can neither accept or reject that
a match occurred.</p>
<p>In practice, the quit state always corresponds to the state immediately
following the dead state. (Which is not usually represented by <code>1</code>,
since state identifiers are pre-multiplied by the state machine’s
alphabet stride, and the alphabet stride varies between DFAs.)</p>
<p>By default, state machines created by this crate will never enter a
quit state. Since entering a quit state is the only way for a DFA
in this crate to fail at search time, it follows that the default
configuration can never produce a match error. Nevertheless, handling
quit states is necessary to correctly support all configurations in
this crate.</p>
<p>The typical way in which a quit state can occur is when heuristic
support for Unicode word boundaries is enabled via the
<a href="crate::dfa::dense::Config::unicode_word_boundary"><code>dense::Config::unicode_word_boundary</code></a>
option. But other options, like the lower level
<a href="crate::dfa::dense::Config::quit"><code>dense::Config::quit</code></a>
configuration, can also result in a quit state being entered. The
purpose of the quit state is to provide a way to execute a fast DFA
in common cases while delegating to slower routines when the DFA quits.</p>
<p>The default search implementations provided by this crate will return
a <a href="../enum.MatchError.html#variant.Quit" title="variant regex_automata::MatchError::Quit"><code>MatchError::Quit</code></a> error when a quit state
is entered.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<p>See the example for <a href="trait.Automaton.html#tymethod.is_special_state" title="method regex_automata::dfa::Automaton::is_special_state"><code>Automaton::is_special_state</code></a> for how to use this
method correctly.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_match_state" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#514">source</a><h4 class="code-header">fn <a href="#tymethod.is_match_state" class="fn">is_match_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to a
match state. A match state is also referred to as a “final” state and
indicates that a match has been found.</p>
<p>If all you care about is whether a particular pattern matches in the
input sequence, then a search routine can quit early as soon as the
machine enters a match state. However, if you’re looking for the
standard “leftmost-first” match location, then search <em>must</em> continue
until either the end of the input or until the machine enters a dead
state. (Since either condition implies that no other useful work can
be done.) Namely, when looking for the location of a match, then
search implementations should record the most recent location in
which a match state was entered, but otherwise continue executing the
search as normal. (The search may even leave the match state.) Once
the termination condition is reached, the most recently recorded match
location should be returned.</p>
<p>Finally, one additional power given to match states in this crate
is that they are always associated with a specific pattern in order
to support multi-DFAs. See <a href="trait.Automaton.html#tymethod.match_pattern" title="method regex_automata::dfa::Automaton::match_pattern"><code>Automaton::match_pattern</code></a> for more
details and an example for how to query the pattern associated with a
particular match state.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<p>See the example for <a href="trait.Automaton.html#tymethod.is_special_state" title="method regex_automata::dfa::Automaton::is_special_state"><code>Automaton::is_special_state</code></a> for how to use this
method correctly.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_start_state" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#642">source</a><h4 class="code-header">fn <a href="#tymethod.is_start_state" class="fn">is_start_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to a
start state. A start state is a state in which a DFA begins a search.
All searches begin in a start state. Moreover, since all matches are
delayed by one byte, a start state can never be a match state.</p>
<p>The main role of a start state is, as mentioned, to be a starting
point for a DFA. This starting point is determined via one of
<a href="trait.Automaton.html#tymethod.start_state_forward" title="method regex_automata::dfa::Automaton::start_state_forward"><code>Automaton::start_state_forward</code></a> or
<a href="trait.Automaton.html#tymethod.start_state_reverse" title="method regex_automata::dfa::Automaton::start_state_reverse"><code>Automaton::start_state_reverse</code></a>, depending on whether one is doing
a forward or a reverse search, respectively.</p>
<p>A secondary use of start states is for prefix acceleration. Namely,
while executing a search, if one detects that you’re in a start state,
then it may be faster to look for the next match of a prefix of the
pattern, if one exists. If a prefix exists and since all matches must
begin with that prefix, then skipping ahead to occurrences of that
prefix may be much faster than executing the DFA.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<p>This example shows how to implement your own search routine that does
a prefix search whenever the search enters a start state.</p>
<p>Note that you do not need to implement your own search routine to
make use of prefilters like this. The search routines provided
by this crate already implement prefilter support via the
<a href="crate::util::prefilter::Prefilter"><code>Prefilter</code></a> trait. The various
<code>find_*_at</code> routines on this trait support the <code>Prefilter</code> trait
through <a href="crate::util::prefilter::Scanner"><code>Scanner</code></a>s. This example is
meant to show how you might deal with prefilters in a simplified case
if you are implementing your own search routine.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    MatchError, PatternID,
    dfa::{Automaton, dense},
    HalfMatch,
};

<span class="kw">fn </span>find_byte(slice: <span class="kw-2">&amp;</span>[u8], at: usize, byte: u8) -&gt; <span class="prelude-ty">Option</span>&lt;usize&gt; {
    <span class="comment">// Would be faster to use the memchr crate, but this is still
    // faster than running through the DFA.
    </span>slice[at..].iter().position(|<span class="kw-2">&amp;</span>b| b == byte).map(|i| at + i)
}

<span class="kw">fn </span>find_leftmost_first&lt;A: Automaton&gt;(
    dfa: <span class="kw-2">&amp;</span>A,
    haystack: <span class="kw-2">&amp;</span>[u8],
    prefix_byte: <span class="prelude-ty">Option</span>&lt;u8&gt;,
) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Option</span>&lt;HalfMatch&gt;, MatchError&gt; {
    <span class="comment">// See the Automaton::is_special_state example for similar code
    // with more comments.

    </span><span class="kw">let </span><span class="kw-2">mut </span>state = dfa.start_state_forward(
        <span class="prelude-val">None</span>, haystack, <span class="number">0</span>, haystack.len(),
    );
    <span class="kw">let </span><span class="kw-2">mut </span>last_match = <span class="prelude-val">None</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>pos = <span class="number">0</span>;
    <span class="kw">while </span>pos &lt; haystack.len() {
        <span class="kw">let </span>b = haystack[pos];
        state = dfa.next_state(state, b);
        pos += <span class="number">1</span>;
        <span class="kw">if </span>dfa.is_special_state(state) {
            <span class="kw">if </span>dfa.is_match_state(state) {
                last_match = <span class="prelude-val">Some</span>(HalfMatch::new(
                    dfa.match_pattern(state, <span class="number">0</span>),
                    pos - <span class="number">1</span>,
                ));
            } <span class="kw">else if </span>dfa.is_dead_state(state) {
                <span class="kw">return </span><span class="prelude-val">Ok</span>(last_match);
            } <span class="kw">else if </span>dfa.is_quit_state(state) {
                <span class="comment">// It is possible to enter into a quit state after
                // observing a match has occurred. In that case, we
                // should return the match instead of an error.
                </span><span class="kw">if </span>last_match.is_some() {
                    <span class="kw">return </span><span class="prelude-val">Ok</span>(last_match);
                }
                <span class="kw">return </span><span class="prelude-val">Err</span>(MatchError::Quit {
                    byte: b, offset: pos - <span class="number">1</span>,
                });
            } <span class="kw">else if </span>dfa.is_start_state(state) {
                <span class="comment">// If we&#39;re in a start state and know all matches begin
                // with a particular byte, then we can quickly skip to
                // candidate matches without running the DFA through
                // every byte inbetween.
                </span><span class="kw">if let </span><span class="prelude-val">Some</span>(prefix_byte) = prefix_byte {
                    pos = <span class="kw">match </span>find_byte(haystack, pos, prefix_byte) {
                        <span class="prelude-val">Some</span>(pos) =&gt; pos,
                        <span class="prelude-val">None </span>=&gt; <span class="kw">break</span>,
                    };
                }
            }
        }
    }
    <span class="comment">// Matches are always delayed by 1 byte, so we must explicitly walk
    // the special &quot;EOI&quot; transition at the end of the search.
    </span>state = dfa.next_eoi_state(state);
    <span class="kw">if </span>dfa.is_match_state(state) {
        last_match = <span class="prelude-val">Some</span>(HalfMatch::new(
            dfa.match_pattern(state, <span class="number">0</span>),
            haystack.len(),
        ));
    }
    <span class="prelude-val">Ok</span>(last_match)
}

<span class="comment">// In this example, it&#39;s obvious that all occurrences of our pattern
// begin with &#39;Z&#39;, so we pass in &#39;Z&#39;.
</span><span class="kw">let </span>dfa = dense::DFA::new(<span class="string">r&quot;Z[a-z]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;123 foobar Zbaz quux&quot;</span>.as_bytes();
<span class="kw">let </span>mat = find_leftmost_first(<span class="kw-2">&amp;</span>dfa, haystack, <span class="prelude-val">Some</span>(<span class="string">b&#39;Z&#39;</span>))<span class="question-mark">?</span>.unwrap();
<span class="macro">assert_eq!</span>(mat.pattern().as_usize(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(mat.offset(), <span class="number">15</span>);

<span class="comment">// But note that we don&#39;t need to pass in a prefix byte. If we don&#39;t,
// then the search routine does no acceleration.
</span><span class="kw">let </span>mat = find_leftmost_first(<span class="kw-2">&amp;</span>dfa, haystack, <span class="prelude-val">None</span>)<span class="question-mark">?</span>.unwrap();
<span class="macro">assert_eq!</span>(mat.pattern().as_usize(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(mat.offset(), <span class="number">15</span>);

<span class="comment">// However, if we pass an incorrect byte, then the prefix search will
// result in incorrect results.
</span><span class="macro">assert_eq!</span>(find_leftmost_first(<span class="kw-2">&amp;</span>dfa, haystack, <span class="prelude-val">Some</span>(<span class="string">b&#39;X&#39;</span>))<span class="question-mark">?</span>, <span class="prelude-val">None</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_accel_state" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#690">source</a><h4 class="code-header">fn <a href="#tymethod.is_accel_state" class="fn">is_accel_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to an
accelerated state.</p>
<p>An accelerated state is a special optimization
trick implemented by this crate. Namely, if
<a href="crate::dfa::dense::Config::accelerate"><code>dense::Config::accelerate</code></a> is
enabled (and it is by default), then DFAs generated by this crate will
tag states meeting certain characteristics as accelerated. States meet
this criteria whenever most of their transitions are self-transitions.
That is, transitions that loop back to the same state. When a small
number of transitions aren’t self-transitions, then it follows that
there are only a small number of bytes that can cause the DFA to leave
that state. Thus, there is an opportunity to look for those bytes
using more optimized routines rather than continuing to run through
the DFA. This trick is similar to the prefilter idea described in
the documentation of <a href="trait.Automaton.html#tymethod.is_start_state" title="method regex_automata::dfa::Automaton::is_start_state"><code>Automaton::is_start_state</code></a> with two main
differences:</p>
<ol>
<li>It is more limited since acceleration only applies to single bytes.
This means states are rarely accelerated when Unicode mode is enabled
(which is enabled by default).</li>
<li>It can occur anywhere in the DFA, which increases optimization
opportunities.</li>
</ol>
<p>Like the prefilter idea, the main downside (and a possible reason to
disable it) is that it can lead to worse performance in some cases.
Namely, if a state is accelerated for very common bytes, then the
overhead of checking for acceleration and using the more optimized
routines to look for those bytes can cause overall performance to be
worse than if acceleration wasn’t enabled at all.</p>
<p>A simple example of a regex that has an accelerated state is
<code>(?-u)[^a]+a</code>. Namely, the <code>[^a]+</code> sub-expression gets compiled down
into a single state where all transitions except for <code>a</code> loop back to
itself, and where <code>a</code> is the only transition (other than the special
EOI transition) that goes to some other state. Thus, this state can
be accelerated and implemented more efficiently by calling an
optimized routine like <code>memchr</code> with <code>a</code> as the needle. Notice that
the <code>(?-u)</code> to disable Unicode is necessary here, as without it,
<code>[^a]</code> will match any UTF-8 encoding of any Unicode scalar value other
than <code>a</code>. This more complicated expression compiles down to many DFA
states and the simple acceleration optimization is no longer available.</p>
<p>Typically, this routine is used to guard calls to
<a href="trait.Automaton.html#method.accelerator" title="method regex_automata::dfa::Automaton::accelerator"><code>Automaton::accelerator</code></a>, which returns the accelerated bytes for
the specified state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.pattern_count" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#727">source</a><h4 class="code-header">fn <a href="#tymethod.pattern_count" class="fn">pattern_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of patterns compiled into this DFA.</p>
<p>In the case of a DFA that contains no patterns, this must return <code>0</code>.</p>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<p>This example shows the pattern count for a DFA that never matches:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::{Automaton, dense::DFA};

<span class="kw">let </span>dfa: DFA&lt;Vec&lt;u32&gt;&gt; = DFA::never_match()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dfa.pattern_count(), <span class="number">0</span>);</code></pre></div>
<p>And another example for a DFA that matches at every position:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::{Automaton, dense::DFA};

<span class="kw">let </span>dfa: DFA&lt;Vec&lt;u32&gt;&gt; = DFA::always_match()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dfa.pattern_count(), <span class="number">1</span>);</code></pre></div>
<p>And finally, a DFA that was constructed from multiple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::{Automaton, dense::DFA};

<span class="kw">let </span>dfa = DFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;[0-9]+&quot;</span>, <span class="string">&quot;[a-z]+&quot;</span>, <span class="string">&quot;[A-Z]+&quot;</span>])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(dfa.pattern_count(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.match_count" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#802">source</a><h4 class="code-header">fn <a href="#tymethod.match_count" class="fn">match_count</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of patterns that match in this state.</p>
<p>If the given state is not a match state, then implementations may
panic.</p>
<p>If the DFA was compiled with one pattern, then this must necessarily
always return <code>1</code> for all match states.</p>
<p>Implementations must guarantee that <a href="trait.Automaton.html#tymethod.match_pattern" title="method regex_automata::dfa::Automaton::match_pattern"><code>Automaton::match_pattern</code></a> can
be called with indices up to (but not including) the count returned by
this routine without panicking.</p>
<h5 id="panics-4"><a href="#panics-4">Panics</a></h5>
<p>Implementations are permitted to panic if the provided state ID does
not correspond to a match state.</p>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<p>This example shows a simple instance of implementing overlapping
matches. In particular, it shows not only how to determine how many
patterns have matched in a particular state, but also how to access
which specific patterns have matched.</p>
<p>Notice that we must use <a href="../enum.MatchKind.html#variant.All" title="variant regex_automata::MatchKind::All"><code>MatchKind::All</code></a>
when building the DFA. If we used
<a href="../enum.MatchKind.html#variant.LeftmostFirst" title="variant regex_automata::MatchKind::LeftmostFirst"><code>MatchKind::LeftmostFirst</code></a>
instead, then the DFA would not be constructed in a way that supports
overlapping matches. (It would only report a single pattern that
matches at any particular point in time.)</p>
<p>Another thing to take note of is the patterns used and the order in
which the pattern IDs are reported. In the example below, pattern <code>3</code>
is yielded first. Why? Because it corresponds to the match that
appears first. Namely, the <code>@</code> symbol is part of <code>\S+</code> but not part
of any of the other patterns. Since the <code>\S+</code> pattern has a match that
starts to the left of any other pattern, its ID is returned before any
other.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, dense},
    MatchKind,
};

<span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new().match_kind(MatchKind::All))
    .build_many(<span class="kw-2">&amp;</span>[
        <span class="string">r&quot;\w+&quot;</span>, <span class="string">r&quot;[a-z]+&quot;</span>, <span class="string">r&quot;[A-Z]+&quot;</span>, <span class="string">r&quot;\S+&quot;</span>,
    ])<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;@bar&quot;</span>.as_bytes();

<span class="comment">// The start state is determined by inspecting the position and the
// initial bytes of the haystack.
</span><span class="kw">let </span><span class="kw-2">mut </span>state = dfa.start_state_forward(
    <span class="prelude-val">None</span>, haystack, <span class="number">0</span>, haystack.len(),
);
<span class="comment">// Walk all the bytes in the haystack.
</span><span class="kw">for </span><span class="kw-2">&amp;</span>b <span class="kw">in </span>haystack {
    state = dfa.next_state(state, b);
}
state = dfa.next_eoi_state(state);

<span class="macro">assert!</span>(dfa.is_match_state(state));
<span class="macro">assert_eq!</span>(dfa.match_count(state), <span class="number">3</span>);
<span class="comment">// The following calls are guaranteed to not panic since `match_count`
// returned `3` above.
</span><span class="macro">assert_eq!</span>(dfa.match_pattern(state, <span class="number">0</span>).as_usize(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(dfa.match_pattern(state, <span class="number">1</span>).as_usize(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(dfa.match_pattern(state, <span class="number">2</span>).as_usize(), <span class="number">1</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.match_pattern" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#823">source</a><h4 class="code-header">fn <a href="#tymethod.match_pattern" class="fn">match_pattern</a>(&amp;self, id: StateID, index: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></h4></section></summary><div class="docblock"><p>Returns the pattern ID corresponding to the given match index in the
given state.</p>
<p>See <a href="trait.Automaton.html#tymethod.match_count" title="method regex_automata::dfa::Automaton::match_count"><code>Automaton::match_count</code></a> for an example of how to use this
method correctly. Note that if you know your DFA is compiled with a
single pattern, then this routine is never necessary since it will
always return a pattern ID of <code>0</code> for an index of <code>0</code> when <code>id</code>
corresponds to a match state.</p>
<p>Typically, this routine is used when implementing an overlapping
search, as the example for <code>Automaton::match_count</code> does.</p>
<h5 id="panics-5"><a href="#panics-5">Panics</a></h5>
<p>If the state ID is not a match state or if the match index is out
of bounds for the given state, then this routine may either panic
or produce an incorrect result. If the state ID is correct and the
match index is correct, then this routine must always produce a valid
<code>PatternID</code>.</p>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.accelerator" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#878-880">source</a><h4 class="code-header">fn <a href="#method.accelerator" class="fn">accelerator</a>(&amp;self, _id: StateID) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Return a slice of bytes to accelerate for the given state, if possible.</p>
<p>If the given state has no accelerator, then an empty slice must be
returned. If <code>Automaton::is_accel_state</code> returns true for the given
ID, then this routine <em>must</em> return a non-empty slice, but it is not
required to do so.</p>
<p>If the given ID is not a valid state ID for this automaton, then
implementations may panic or produce incorrect results.</p>
<p>See <a href="trait.Automaton.html#tymethod.is_accel_state" title="method regex_automata::dfa::Automaton::is_accel_state"><code>Automaton::is_accel_state</code></a> for more details on state
acceleration.</p>
<p>By default, this method will always return an empty slice.</p>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<p>This example shows a contrived case in which we build a regex that we
know is accelerated and extract the accelerator from a state.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson,
    dfa::{Automaton, dense},
    util::id::StateID,
    SyntaxConfig,
};

<span class="kw">let </span>dfa = dense::Builder::new()
    <span class="comment">// We disable Unicode everywhere and permit the regex to match
    // invalid UTF-8. e.g., `[^abc]` matches `\xFF`, which is not valid
    // UTF-8.
    </span>.syntax(SyntaxConfig::new().unicode(<span class="bool-val">false</span>).utf8(<span class="bool-val">false</span>))
    <span class="comment">// This makes the implicit `(?s:.)*?` prefix added to the regex
    // match through arbitrary bytes instead of being UTF-8 aware. This
    // isn&#39;t necessary to get acceleration to work in this case, but
    // it does make the DFA substantially simpler.
    </span>.thompson(thompson::Config::new().utf8(<span class="bool-val">false</span>))
    .build(<span class="string">&quot;[^abc]+a&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Here we just pluck out the state that we know is accelerated.
// While the stride calculations are something that can be relied
// on by callers, the specific position of the accelerated state is
// implementation defined.
//
// N.B. We get &#39;3&#39; by inspecting the state machine using &#39;regex-cli&#39;.
// e.g., try `regex-cli debug dfa dense &#39;[^abc]+a&#39; -BbUC`.
</span><span class="kw">let </span>id = StateID::new(<span class="number">3 </span>* dfa.stride()).unwrap();
<span class="kw">let </span>accelerator = dfa.accelerator(id);
<span class="comment">// The `[^abc]+` sub-expression permits [a, b, c] to be accelerated.
</span><span class="macro">assert_eq!</span>(accelerator, <span class="kw-2">&amp;</span>[<span class="string">b&#39;a&#39;</span>, <span class="string">b&#39;b&#39;</span>, <span class="string">b&#39;c&#39;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_fwd" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#935-940">source</a><h4 class="code-header">fn <a href="#method.find_earliest_fwd" class="fn">find_earliest_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a forward search and returns the end position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned.</p>
<p>This routine stops scanning input as soon as the search observes a
match state. This is useful for implementing boolean <code>is_match</code>-like
routines, where as little work is done as possible.</p>
<p>See <a href="trait.Automaton.html#method.find_earliest_fwd_at" title="method regex_automata::dfa::Automaton::find_earliest_fwd_at"><code>Automaton::find_earliest_fwd_at</code></a> for additional functionality,
such as providing a prefilter, a specific pattern to match and the
bounds of the search within the haystack. This routine is meant as
a convenience for common cases where the additional functionality is
not needed.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<p>This example shows how to use this method with a
<a href="dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>. In particular, it demonstrates
how the position returned might differ from what one might expect when
executing a traditional leftmost search.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, dense},
    HalfMatch,
};

<span class="kw">let </span>dfa = dense::DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// Normally, the end of the leftmost first match here would be 8,
// corresponding to the end of the input. But the &quot;earliest&quot; semantics
// this routine cause it to stop as soon as a match is known, which
// occurs once &#39;foo[0-9]&#39; has matched.
</span><span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_earliest_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);

<span class="kw">let </span>dfa = dense::DFA::new(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// Normally, the end of the leftmost first match here would be 3,
// but the shortest match semantics detect a match earlier.
</span><span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_earliest_fwd(<span class="string">b&quot;abc&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_rev" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1001-1006">source</a><h4 class="code-header">fn <a href="#method.find_earliest_rev" class="fn">find_earliest_rev</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a reverse search and returns the start position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned.</p>
<p>This routine stops scanning input as soon as the search observes a
match state.</p>
<p>Note that while it is not technically necessary to build a reverse
automaton to use a reverse search, it is likely that you’ll want to do
so. Namely, the typical use of a reverse search is to find the starting
location of a match once its end is discovered from a forward search. A
reverse DFA automaton can be built by configuring the intermediate NFA
to be reversed via
<a href="crate::nfa::thompson::Config::reverse"><code>nfa::thompson::Config::reverse</code></a>.</p>
<h5 id="errors-1"><a href="#errors-1">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<p>This example shows how to use this method with a
<a href="dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>. In particular, it demonstrates
how the position returned might differ from what one might expect when
executing a traditional leftmost reverse search.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson,
    dfa::{Automaton, dense},
    HalfMatch,
};

<span class="kw">let </span>dfa = dense::Builder::new()
    .thompson(thompson::Config::new().reverse(<span class="bool-val">true</span>))
    .build(<span class="string">&quot;[a-z]+[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// Normally, the end of the leftmost first match here would be 0,
// corresponding to the beginning of the input. But the &quot;earliest&quot;
// semantics of this routine cause it to stop as soon as a match is
// known, which occurs once &#39;[a-z][0-9]+&#39; has matched.
</span><span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_earliest_rev(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);

<span class="kw">let </span>dfa = dense::Builder::new()
    .thompson(thompson::Config::new().reverse(<span class="bool-val">true</span>))
    .build(<span class="string">&quot;abc|c&quot;</span>)<span class="question-mark">?</span>;
<span class="comment">// Normally, the end of the leftmost first match here would be 0,
// but the shortest match semantics detect a match earlier.
</span><span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_earliest_rev(<span class="string">b&quot;abc&quot;</span>)<span class="question-mark">?</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_fwd" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1075-1080">source</a><h4 class="code-header">fn <a href="#method.find_leftmost_fwd" class="fn">find_leftmost_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a forward search and returns the end position of the leftmost
match that is found. If no match exists, then <code>None</code> is returned.</p>
<h5 id="errors-2"><a href="#errors-2">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="notes-for-implementors"><a href="#notes-for-implementors">Notes for implementors</a></h5>
<p>Implementors of this trait are not required to implement any particular
match semantics (such as leftmost-first), which are instead manifest in
the DFA’s transitions.</p>
<p>In particular, this method must continue searching even after it enters
a match state. The search should only terminate once it has reached
the end of the input or when it has entered a dead or quit state. Upon
termination, the position of the last byte seen while still in a match
state is returned.</p>
<p>Since this trait provides an implementation for this method by default,
it’s unlikely that one will need to implement this.</p>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<p>This example shows how to use this method with a
<a href="dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>. By default, a dense DFA uses
“leftmost first” match semantics.</p>
<p>Leftmost first match semantics corresponds to the match with the
smallest starting offset, but where the end offset is determined by
preferring earlier branches in the original regular expression. For
example, <code>Sam|Samwise</code> will match <code>Sam</code> in <code>Samwise</code>, but <code>Samwise|Sam</code>
will match <code>Samwise</code> in <code>Samwise</code>.</p>
<p>Generally speaking, the “leftmost first” match is how most backtracking
regular expressions tend to work. This is in contrast to POSIX-style
regular expressions that yield “leftmost longest” matches. Namely,
both <code>Sam|Samwise</code> and <code>Samwise|Sam</code> match <code>Samwise</code> when using
leftmost longest semantics. (This crate does not currently support
leftmost longest semantics.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, dense},
    HalfMatch,
};

<span class="kw">let </span>dfa = dense::DFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);

<span class="comment">// Even though a match is found after reading the first byte (`a`),
// the leftmost first match semantics demand that we find the earliest
// match that prefers earlier parts of the pattern over latter parts.
</span><span class="kw">let </span>dfa = dense::DFA::new(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_fwd(<span class="string">b&quot;abc&quot;</span>)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_rev" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1147-1152">source</a><h4 class="code-header">fn <a href="#method.find_leftmost_rev" class="fn">find_leftmost_rev</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a reverse search and returns the start of the position of the
leftmost match that is found. If no match exists, then <code>None</code> is
returned.</p>
<h5 id="errors-3"><a href="#errors-3">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="notes-for-implementors-1"><a href="#notes-for-implementors-1">Notes for implementors</a></h5>
<p>Implementors of this trait are not required to implement any particular
match semantics (such as leftmost-first), which are instead manifest in
the DFA’s transitions.</p>
<p>In particular, this method must continue searching even after it enters
a match state. The search should only terminate once it has reached
the end of the input or when it has entered a dead or quit state. Upon
termination, the position of the last byte seen while still in a match
state is returned.</p>
<p>Since this trait provides an implementation for this method by default,
it’s unlikely that one will need to implement this.</p>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<p>This example shows how to use this method with a
<a href="dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>. In particular, this routine
is principally useful when used in conjunction with the
<a href="crate::nfa::thompson::Config::reverse"><code>nfa::thompson::Config::reverse</code></a>
configuration. In general, it’s unlikely to be correct to use both
<code>find_leftmost_fwd</code> and <code>find_leftmost_rev</code> with the same DFA since any
particular DFA will only support searching in one direction with
respect to the pattern.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson,
    dfa::{Automaton, dense},
    HalfMatch,
};

<span class="kw">let </span>dfa = dense::Builder::new()
    .thompson(thompson::Config::new().reverse(<span class="bool-val">true</span>))
    .build(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_rev(<span class="string">b&quot;foo12345&quot;</span>)<span class="question-mark">?</span>);

<span class="comment">// Even though a match is found after reading the last byte (`c`),
// the leftmost first match semantics demand that we find the earliest
// match that prefers earlier parts of the pattern over latter parts.
</span><span class="kw">let </span>dfa = dense::Builder::new()
    .thompson(thompson::Config::new().reverse(<span class="bool-val">true</span>))
    .build(<span class="string">&quot;abc|c&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.find_leftmost_rev(<span class="string">b&quot;abc&quot;</span>)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_overlapping_fwd" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1218-1224">source</a><h4 class="code-header">fn <a href="#method.find_overlapping_fwd" class="fn">find_overlapping_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    state: &amp;mut <a class="struct" href="struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes an overlapping forward search and returns the end position of
matches as they are found. If no match exists, then <code>None</code> is returned.</p>
<p>This routine is principally only useful when searching for multiple
patterns on inputs where multiple patterns may match the same regions
of text. In particular, callers must preserve the automaton’s search
state from prior calls so that the implementation knows where the last
match occurred.</p>
<h5 id="errors-4"><a href="#errors-4">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<p>This example shows how to run a basic overlapping search with a
<a href="dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>. Notice that we build the
automaton with a <code>MatchKind::All</code> configuration. Overlapping searches
are unlikely to work as one would expect when using the default
<code>MatchKind::LeftmostFirst</code> match semantics, since leftmost-first
matching is fundamentally incompatible with overlapping searches.
Namely, overlapping searches need to report matches as they are seen,
where as leftmost-first searches will continue searching even after a
match has been observed in order to find the conventional end position
of the match. More concretely, leftmost-first searches use dead states
to terminate a search after a specific match can no longer be extended.
Overlapping searches instead do the opposite by continuing the search
to find totally new matches (potentially of other patterns).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, OverlappingState, dense},
    HalfMatch,
    MatchKind,
};

<span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new().match_kind(MatchKind::All))
    .build_many(<span class="kw-2">&amp;</span>[<span class="string">r&quot;\w+$&quot;</span>, <span class="string">r&quot;\S+$&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;@foo&quot;</span>.as_bytes();
<span class="kw">let </span><span class="kw-2">mut </span>state = OverlappingState::start();

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">1</span>, <span class="number">4</span>));
<span class="kw">let </span>got = dfa.find_overlapping_fwd(haystack, <span class="kw-2">&amp;mut </span>state)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, got);

<span class="comment">// The first pattern also matches at the same position, so re-running
// the search will yield another match. Notice also that the first
// pattern is returned after the second. This is because the second
// pattern begins its match before the first, is therefore an earlier
// match and is thus reported first.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">4</span>));
<span class="kw">let </span>got = dfa.find_overlapping_fwd(haystack, <span class="kw-2">&amp;mut </span>state)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_fwd_at" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1420-1429">source</a><h4 class="code-header">fn <a href="#method.find_earliest_fwd_at" class="fn">find_earliest_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a forward search and returns the end position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned.</p>
<p>This routine stops scanning input as soon as the search observes a
match state. This is useful for implementing boolean <code>is_match</code>-like
routines, where as little work is done as possible.</p>
<p>This is like <a href="trait.Automaton.html#method.find_earliest_fwd" title="method regex_automata::dfa::Automaton::find_earliest_fwd"><code>Automaton::find_earliest_fwd</code></a>, except it provides some
additional control over how the search is executed:</p>
<ul>
<li><code>pre</code> is a prefilter scanner that, when given, is used whenever the
DFA enters its starting state. This is meant to speed up searches where
one or a small number of literal prefixes are known.</li>
<li><code>pattern_id</code> specifies a specific pattern in the DFA to run an
anchored search for. If not given, then a search for any pattern is
performed. For DFAs built by this crate,
<a href="crate::dfa::dense::Config::starts_for_each_pattern"><code>dense::Config::starts_for_each_pattern</code></a>
must be enabled to use this functionality.</li>
<li><code>start</code> and <code>end</code> permit searching a specific region of the haystack
<code>bytes</code>. This is useful when implementing an iterator over matches
within the same haystack, which cannot be done correctly by simply
providing a subslice of <code>bytes</code>. (Because the existence of look-around
operations such as <code>\b</code>, <code>^</code> and <code>$</code> need to take the surrounding
context into account. This cannot be done if the haystack doesn’t
contain it.)</li>
</ul>
<p>The examples below demonstrate each of these additional parameters.</p>
<h5 id="errors-5"><a href="#errors-5">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="panics-6"><a href="#panics-6">Panics</a></h5>
<p>This routine must panic if a <code>pattern_id</code> is given and the underlying
DFA does not support specific pattern searches.</p>
<p>It must also panic if the given haystack range is not valid.</p>
<h5 id="example-prefilter"><a href="#example-prefilter">Example: prefilter</a></h5>
<p>This example shows how to provide a prefilter for a pattern where all
matches start with a <code>z</code> byte.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, dense},
    util::prefilter::{Candidate, Prefilter, Scanner, State},
    HalfMatch,
};

<span class="attr">#[derive(Debug)]
</span><span class="kw">pub struct </span>ZPrefilter;

<span class="kw">impl </span>Prefilter <span class="kw">for </span>ZPrefilter {
    <span class="kw">fn </span>next_candidate(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>State,
        haystack: <span class="kw-2">&amp;</span>[u8],
        at: usize,
    ) -&gt; Candidate {
        <span class="comment">// Try changing b&#39;z&#39; to b&#39;q&#39; and observe this test fail since
        // the prefilter will skip right over the match.
        </span><span class="kw">match </span>haystack.iter().position(|<span class="kw-2">&amp;</span>b| b == <span class="string">b&#39;z&#39;</span>) {
            <span class="prelude-val">None </span>=&gt; Candidate::None,
            <span class="prelude-val">Some</span>(i) =&gt; Candidate::PossibleStartOfMatch(at + i),
        }
    }

    <span class="kw">fn </span>heap_bytes(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="number">0
    </span>}
}

<span class="kw">let </span>dfa = dense::DFA::new(<span class="string">&quot;z[0-9]{3}&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;foobar z123 q123&quot;</span>.as_bytes();
<span class="comment">// A scanner executes a prefilter while tracking some state that helps
// determine whether a prefilter is still &quot;effective&quot; or not.
</span><span class="kw">let </span><span class="kw-2">mut </span>scanner = Scanner::new(<span class="kw-2">&amp;</span>ZPrefilter);

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">11</span>));
<span class="kw">let </span>got = dfa.find_earliest_fwd_at(
    <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span>scanner),
    <span class="prelude-val">None</span>,
    haystack,
    <span class="number">0</span>,
    haystack.len(),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
<h5 id="example-specific-pattern-search"><a href="#example-specific-pattern-search">Example: specific pattern search</a></h5>
<p>This example shows how to build a multi-DFA that permits searching for
specific patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, dense},
    HalfMatch,
    PatternID,
};

<span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new().starts_for_each_pattern(<span class="bool-val">true</span>))
    .build_many(<span class="kw-2">&amp;</span>[<span class="string">&quot;[a-z0-9]{6}&quot;</span>, <span class="string">&quot;[a-z][a-z0-9]{5}&quot;</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;foo123&quot;</span>.as_bytes();

<span class="comment">// Since we are using the default leftmost-first match and both
// patterns match at the same starting position, only the first pattern
// will be returned in this case when doing a search for any of the
// patterns.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">6</span>));
<span class="kw">let </span>got = dfa.find_earliest_fwd_at(
    <span class="prelude-val">None</span>,
    <span class="prelude-val">None</span>,
    haystack,
    <span class="number">0</span>,
    haystack.len(),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, got);

<span class="comment">// But if we want to check whether some other pattern matches, then we
// can provide its pattern ID.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">1</span>, <span class="number">6</span>));
<span class="kw">let </span>got = dfa.find_earliest_fwd_at(
    <span class="prelude-val">None</span>,
    <span class="prelude-val">Some</span>(PatternID::must(<span class="number">1</span>)),
    haystack,
    <span class="number">0</span>,
    haystack.len(),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
<h5 id="example-specifying-the-bounds-of-a-search"><a href="#example-specifying-the-bounds-of-a-search">Example: specifying the bounds of a search</a></h5>
<p>This example shows how providing the bounds of a search can produce
different results than simply sub-slicing the haystack.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, dense},
    HalfMatch,
};

<span class="comment">// N.B. We disable Unicode here so that we use a simple ASCII word
// boundary. Alternatively, we could enable heuristic support for
// Unicode word boundaries.
</span><span class="kw">let </span>dfa = dense::DFA::new(<span class="string">r&quot;(?-u)\b[0-9]{3}\b&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">&quot;foo123bar&quot;</span>.as_bytes();

<span class="comment">// Since we sub-slice the haystack, the search doesn&#39;t know about the
// larger context and assumes that `123` is surrounded by word
// boundaries. And of course, the match position is reported relative
// to the sub-slice as well, which means we get `3` instead of `6`.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">3</span>));
<span class="kw">let </span>got = dfa.find_earliest_fwd_at(
    <span class="prelude-val">None</span>,
    <span class="prelude-val">None</span>,
    <span class="kw-2">&amp;</span>haystack[<span class="number">3</span>..<span class="number">6</span>],
    <span class="number">0</span>,
    haystack[<span class="number">3</span>..<span class="number">6</span>].len(),
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, got);

<span class="comment">// But if we provide the bounds of the search within the context of the
// entire haystack, then the search can take the surrounding context
// into account. (And if we did find a match, it would be reported
// as a valid offset into `haystack` instead of its sub-slice.)
</span><span class="kw">let </span>expected = <span class="prelude-val">None</span>;
<span class="kw">let </span>got = dfa.find_earliest_fwd_at(
    <span class="prelude-val">None</span>,
    <span class="prelude-val">None</span>,
    haystack,
    <span class="number">3</span>,
    <span class="number">6</span>,
)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_earliest_rev_at" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1460-1468">source</a><h4 class="code-header">fn <a href="#method.find_earliest_rev_at" class="fn">find_earliest_rev_at</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a reverse search and returns the start position of the first
match that is found as early as possible. If no match exists, then
<code>None</code> is returned.</p>
<p>This routine stops scanning input as soon as the search observes a
match state.</p>
<p>This is like <a href="trait.Automaton.html#method.find_earliest_rev" title="method regex_automata::dfa::Automaton::find_earliest_rev"><code>Automaton::find_earliest_rev</code></a>, except it provides some
additional control over how the search is executed. See the
documentation of <a href="trait.Automaton.html#method.find_earliest_fwd_at" title="method regex_automata::dfa::Automaton::find_earliest_fwd_at"><code>Automaton::find_earliest_fwd_at</code></a> for more details
on the additional parameters along with examples of their usage.</p>
<h5 id="errors-6"><a href="#errors-6">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="panics-7"><a href="#panics-7">Panics</a></h5>
<p>This routine must panic if a <code>pattern_id</code> is given and the underlying
DFA does not support specific pattern searches.</p>
<p>It must also panic if the given haystack range is not valid.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_fwd_at" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1495-1504">source</a><h4 class="code-header">fn <a href="#method.find_leftmost_fwd_at" class="fn">find_leftmost_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a forward search and returns the end position of the leftmost
match that is found. If no match exists, then <code>None</code> is returned.</p>
<p>This is like <a href="trait.Automaton.html#method.find_leftmost_fwd" title="method regex_automata::dfa::Automaton::find_leftmost_fwd"><code>Automaton::find_leftmost_fwd</code></a>, except it provides some
additional control over how the search is executed. See the
documentation of <a href="trait.Automaton.html#method.find_earliest_fwd_at" title="method regex_automata::dfa::Automaton::find_earliest_fwd_at"><code>Automaton::find_earliest_fwd_at</code></a> for more details
on the additional parameters along with examples of their usage.</p>
<h5 id="errors-7"><a href="#errors-7">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="panics-8"><a href="#panics-8">Panics</a></h5>
<p>This routine must panic if a <code>pattern_id</code> is given and the underlying
DFA does not support specific pattern searches.</p>
<p>It must also panic if the given haystack range is not valid.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_leftmost_rev_at" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1532-1540">source</a><h4 class="code-header">fn <a href="#method.find_leftmost_rev_at" class="fn">find_leftmost_rev_at</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes a reverse search and returns the start of the position of the
leftmost match that is found. If no match exists, then <code>None</code> is
returned.</p>
<p>This is like <a href="trait.Automaton.html#method.find_leftmost_rev" title="method regex_automata::dfa::Automaton::find_leftmost_rev"><code>Automaton::find_leftmost_rev</code></a>, except it provides some
additional control over how the search is executed. See the
documentation of <a href="trait.Automaton.html#method.find_earliest_fwd_at" title="method regex_automata::dfa::Automaton::find_earliest_fwd_at"><code>Automaton::find_earliest_fwd_at</code></a> for more details
on the additional parameters along with examples of their usage.</p>
<h5 id="errors-8"><a href="#errors-8">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="panics-9"><a href="#panics-9">Panics</a></h5>
<p>This routine must panic if a <code>pattern_id</code> is given and the underlying
DFA does not support specific pattern searches.</p>
<p>It must also panic if the given haystack range is not valid.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_overlapping_fwd_at" class="method"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1584-1596">source</a><h4 class="code-header">fn <a href="#method.find_overlapping_fwd_at" class="fn">find_overlapping_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    state: &amp;mut <a class="struct" href="struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes an overlapping forward search and returns the end position of
matches as they are found. If no match exists, then <code>None</code> is returned.</p>
<p>This routine is principally only useful when searching for multiple
patterns on inputs where multiple patterns may match the same regions
of text. In particular, callers must preserve the automaton’s search
state from prior calls so that the implementation knows where the last
match occurred.</p>
<p>This is like <a href="trait.Automaton.html#method.find_overlapping_fwd" title="method regex_automata::dfa::Automaton::find_overlapping_fwd"><code>Automaton::find_overlapping_fwd</code></a>, except it provides
some additional control over how the search is executed. See the
documentation of <a href="trait.Automaton.html#method.find_earliest_fwd_at" title="method regex_automata::dfa::Automaton::find_earliest_fwd_at"><code>Automaton::find_earliest_fwd_at</code></a> for more details
on the additional parameters along with examples of their usage.</p>
<p>When using this routine to implement an iterator of overlapping
matches, the <code>start</code> of the search should always be set to the end
of the last match. If more patterns match at the previous location,
then they will be immediately returned. (This is tracked by the given
overlapping state.) Otherwise, the search continues at the starting
position given.</p>
<p>If for some reason you want the search to forget about its previous
state and restart the search at a particular position, then setting the
state to <a href="struct.OverlappingState.html#method.start" title="associated function regex_automata::dfa::OverlappingState::start"><code>OverlappingState::start</code></a> will accomplish that.</p>
<h5 id="errors-9"><a href="#errors-9">Errors</a></h5>
<p>This routine only errors if the search could not complete. For
DFAs generated by this crate, this only occurs in a non-default
configuration where quit bytes are used or Unicode word boundaries are
heuristically enabled.</p>
<p>When a search cannot complete, callers cannot know whether a match
exists or not.</p>
<h5 id="panics-10"><a href="#panics-10">Panics</a></h5>
<p>This routine must panic if a <code>pattern_id</code> is given and the underlying
DFA does not support specific pattern searches.</p>
<p>It must also panic if the given haystack range is not valid.</p>
</div></details></div><h2 id="foreign-impls" class="small-section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor">§</a></h2><details class="toggle implementors-toggle"><summary><section id="impl-Automaton-for-%26'a+T" class="impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1599-1791">source</a><a href="#impl-Automaton-for-%26'a+T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T: <a class="trait" href="trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a>&gt; <a class="trait" href="trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a> for <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.reference.html">&amp;'a T</a></h3></section></summary><div class="impl-items"><section id="method.next_state" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1601-1603">source</a><a href="#method.next_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.next_state" class="fn">next_state</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>) -&gt; StateID</h4></section><section id="method.next_state_unchecked" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1606-1612">source</a><a href="#method.next_state_unchecked" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="#tymethod.next_state_unchecked" class="fn">next_state_unchecked</a>(&amp;self, current: StateID, input: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>) -&gt; StateID</h4></section><section id="method.next_eoi_state" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1615-1617">source</a><a href="#method.next_eoi_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.next_eoi_state" class="fn">next_eoi_state</a>(&amp;self, current: StateID) -&gt; StateID</h4></section><section id="method.start_state_forward" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1620-1628">source</a><a href="#method.start_state_forward" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.start_state_forward" class="fn">start_state_forward</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; StateID</h4></section><section id="method.start_state_reverse" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1631-1639">source</a><a href="#method.start_state_reverse" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.start_state_reverse" class="fn">start_state_reverse</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; StateID</h4></section><section id="method.is_special_state" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1642-1644">source</a><a href="#method.is_special_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_special_state" class="fn">is_special_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section><section id="method.is_dead_state" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1647-1649">source</a><a href="#method.is_dead_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_dead_state" class="fn">is_dead_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section><section id="method.is_quit_state" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1652-1654">source</a><a href="#method.is_quit_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_quit_state" class="fn">is_quit_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section><section id="method.is_match_state" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1657-1659">source</a><a href="#method.is_match_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_match_state" class="fn">is_match_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section><section id="method.is_start_state" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1662-1664">source</a><a href="#method.is_start_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_start_state" class="fn">is_start_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section><section id="method.is_accel_state" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1667-1669">source</a><a href="#method.is_accel_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_accel_state" class="fn">is_accel_state</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.bool.html">bool</a></h4></section><section id="method.pattern_count" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1672-1674">source</a><a href="#method.pattern_count" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.pattern_count" class="fn">pattern_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a></h4></section><section id="method.match_count" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1677-1679">source</a><a href="#method.match_count" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.match_count" class="fn">match_count</a>(&amp;self, id: StateID) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a></h4></section><section id="method.match_pattern" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1682-1684">source</a><a href="#method.match_pattern" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.match_pattern" class="fn">match_pattern</a>(&amp;self, id: StateID, index: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></h4></section><section id="method.accelerator-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1687-1689">source</a><a href="#method.accelerator-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.accelerator" class="fn">accelerator</a>(&amp;self, id: StateID) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section><section id="method.find_earliest_fwd-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1692-1697">source</a><a href="#method.find_earliest_fwd-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_earliest_fwd" class="fn">find_earliest_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section><section id="method.find_earliest_rev-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1700-1705">source</a><a href="#method.find_earliest_rev-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_earliest_rev" class="fn">find_earliest_rev</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section><section id="method.find_leftmost_fwd-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1708-1713">source</a><a href="#method.find_leftmost_fwd-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_leftmost_fwd" class="fn">find_leftmost_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section><section id="method.find_leftmost_rev-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1716-1721">source</a><a href="#method.find_leftmost_rev-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_leftmost_rev" class="fn">find_leftmost_rev</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section><section id="method.find_overlapping_fwd-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1724-1730">source</a><a href="#method.find_overlapping_fwd-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_overlapping_fwd" class="fn">find_overlapping_fwd</a>(
    &amp;self,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    state: &amp;mut <a class="struct" href="struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section><section id="method.find_earliest_fwd_at-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1733-1742">source</a><a href="#method.find_earliest_fwd_at-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_earliest_fwd_at" class="fn">find_earliest_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section><section id="method.find_earliest_rev_at-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1745-1753">source</a><a href="#method.find_earliest_rev_at-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_earliest_rev_at" class="fn">find_earliest_rev_at</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section><section id="method.find_leftmost_fwd_at-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1756-1765">source</a><a href="#method.find_leftmost_fwd_at-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_leftmost_fwd_at" class="fn">find_leftmost_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section><section id="method.find_leftmost_rev_at-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1768-1776">source</a><a href="#method.find_leftmost_rev_at-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_leftmost_rev_at" class="fn">find_leftmost_rev_at</a>(
    &amp;self,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section><section id="method.find_overlapping_fwd_at-1" class="method trait-impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/automaton.rs.html#1779-1790">source</a><a href="#method.find_overlapping_fwd_at-1" class="anchor">§</a><h4 class="code-header">fn <a href="#method.find_overlapping_fwd_at" class="fn">find_overlapping_fwd_at</a>(
    &amp;self,
    pre: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Scanner&lt;'_&gt;&gt;,
    pattern_id: <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>],
    start: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    end: <a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.usize.html">usize</a>,
    state: &amp;mut <a class="struct" href="struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.69.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.69.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="enum" href="../enum.MatchError.html" title="enum regex_automata::MatchError">MatchError</a>&gt;</h4></section></div></details><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-Automaton-for-DFA%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/sparse.rs.html#1115-1219">source</a><a href="#impl-Automaton-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="trait" href="trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a> for regex_automata::dfa::sparse::<a class="struct" href="sparse/struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section><section id="impl-Automaton-for-DFA%3CT%3E-1" class="impl"><a class="srclink rightside" href="../../src/regex_automata/dfa/dense.rs.html#2691-2802">source</a><a href="#impl-Automaton-for-DFA%3CT%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/1.69.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.69.0/std/primitive.u32.html">u32</a>]&gt;&gt; <a class="trait" href="trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a> for regex_automata::dfa::dense::<a class="struct" href="dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;T&gt;</h3></section></div><script src="../../implementors/regex_automata/dfa/automaton/trait.Automaton.js" async></script><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.69.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><span class=\"where fmt-newline\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.69.0/std/primitive.u8.html\">u8</a>]</span><span class=\"where fmt-newline\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.69.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.69.0/std/primitive.u8.html\">u8</a>]</span>"}</script></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0 (84c898d65 2023-04-16)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>