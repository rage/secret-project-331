<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait describing the interface of a deterministic finite automaton (DFA)."><meta name="keywords" content="rust, rustlang, rust-lang, DFA"><title>DFA in regex_automata - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../regex_automata/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Trait DFA</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#associated-types">Associated Types</a></h3><div class="sidebar-links"><a href="#associatedtype.ID">ID</a></div><h3 class="sidebar-title"><a href="#required-methods">Required Methods</a></h3><div class="sidebar-links"><a href="#tymethod.is_anchored">is_anchored</a><a href="#tymethod.is_dead_state">is_dead_state</a><a href="#tymethod.is_match_or_dead_state">is_match_or_dead_state</a><a href="#tymethod.is_match_state">is_match_state</a><a href="#tymethod.next_state">next_state</a><a href="#tymethod.next_state_unchecked">next_state_unchecked</a><a href="#tymethod.start_state">start_state</a></div><h3 class="sidebar-title"><a href="#provided-methods">Provided Methods</a></h3><div class="sidebar-links"><a href="#method.find">find</a><a href="#method.find_at">find_at</a><a href="#method.is_match">is_match</a><a href="#method.is_match_at">is_match_at</a><a href="#method.rfind">rfind</a><a href="#method.rfind_at">rfind_at</a><a href="#method.shortest_match">shortest_match</a><a href="#method.shortest_match_at">shortest_match_at</a></div><h3 class="sidebar-title"><a href="#foreign-impls">Implementations on Foreign Types</a></h3><div class="sidebar-links"><a href="#impl-DFA-for-%26%27a%20T">&amp;&#39;a T</a></div><h3 class="sidebar-title"><a href="#implementors">Implementors</a></h3></div><h2 class="location">Other items in<br><a href="index.html">regex_automata</a></h2><div id="sidebar-vars" data-name="DFA" data-ty="trait" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Trait <a href="index.html">regex_automata</a>::<wbr><a class="trait" href="#">DFA</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/regex_automata/dfa.rs.html#19-320" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust trait"><code>pub trait DFA {
    type <a href="#associatedtype.ID" class="type">ID</a>: <a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>;
<details class="rustdoc-toggle type-contents-toggle"><summary class="hideme"><span>Show 15 methods</span></summary>    fn <a href="#tymethod.start_state" class="fnname">start_state</a>(&amp;self) -&gt; Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.is_match_state" class="fnname">is_match_state</a>(&amp;self, id: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.is_dead_state" class="fnname">is_dead_state</a>(&amp;self, id: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.is_match_or_dead_state" class="fnname">is_match_or_dead_state</a>(&amp;self, id: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.is_anchored" class="fnname">is_anchored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a>;
<div class="item-spacer"></div>    fn <a href="#tymethod.next_state" class="fnname">next_state</a>(&amp;self, current: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a>) -&gt; Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>;
<div class="item-spacer"></div>    unsafe fn <a href="#tymethod.next_state_unchecked" class="fnname">next_state_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>;

    fn <a href="#method.is_match" class="fnname">is_match</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a> { ... }
<div class="item-spacer"></div>    fn <a href="#method.shortest_match" class="fnname">shortest_match</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt; { ... }
<div class="item-spacer"></div>    fn <a href="#method.find" class="fnname">find</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt; { ... }
<div class="item-spacer"></div>    fn <a href="#method.rfind" class="fnname">rfind</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt; { ... }
<div class="item-spacer"></div>    fn <a href="#method.is_match_at" class="fnname">is_match_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a> { ... }
<div class="item-spacer"></div>    fn <a href="#method.shortest_match_at" class="fnname">shortest_match_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt; { ... }
<div class="item-spacer"></div>    fn <a href="#method.find_at" class="fnname">find_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt; { ... }
<div class="item-spacer"></div>    fn <a href="#method.rfind_at" class="fnname">rfind_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt; { ... }
</details>}</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait describing the interface of a deterministic finite automaton (DFA).</p>
<p>Every DFA has exactly one start state and at least one dead state (which
may be the same, as in the case of an empty DFA). In all cases, a state
identifier of <code>0</code> must be a dead state such that <code>DFA::is_dead_state(0)</code>
always returns <code>true</code>.</p>
<p>Every DFA also has zero or more match states, such that
<code>DFA::is_match_state(id)</code> returns <code>true</code> if and only if <code>id</code> corresponds to
a match state.</p>
<p>In general, users of this trait likely will only need to use the search
routines such as <code>is_match</code>, <code>shortest_match</code>, <code>find</code> or <code>rfind</code>. The other
methods are lower level and are used for walking the transitions of a DFA
manually. In particular, the aforementioned search routines are implemented
generically in terms of the lower level transition walking routines.</p>
</div></details><h2 id="associated-types" class="small-section-header">Associated Types<a href="#associated-types" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open><summary><div id="associatedtype.ID" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#23" title="goto source code">[src]</a></div><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a>: <a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a></h4></div></summary><div class="docblock"><p>The representation used for state identifiers in this DFA.</p>
<p>Typically, this is one of <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code> or <code>usize</code>.</p>
</div></details></div><h2 id="required-methods" class="small-section-header">Required methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open><summary><div id="tymethod.start_state" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#26" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.start_state" class="fnname">start_state</a>(&amp;self) -&gt; Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></div></summary><div class="docblock"><p>Return the identifier of this DFA’s start state.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.is_match_state" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#30" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.is_match_state" class="fnname">is_match_state</a>(&amp;self, id: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to a match
state.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.is_dead_state" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#35" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.is_dead_state" class="fnname">is_dead_state</a>(&amp;self, id: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to a dead
state. When a DFA enters a dead state, it is impossible to leave and
thus can never lead to a match.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.is_match_or_dead_state" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#45" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.is_match_or_dead_state" class="fnname">is_match_or_dead_state</a>(&amp;self, id: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to either
a dead state or a match state, such that one of <code>is_match_state(id)</code>
or <code>is_dead_state(id)</code> must return true.</p>
<p>Depending on the implementation of the DFA, this routine can be used
to save a branch in the core matching loop. Nevertheless,
<code>is_match_state(id) || is_dead_state(id)</code> is always a valid
implementation.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.is_anchored" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#51" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.is_anchored" class="fnname">is_anchored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Returns true if and only if this DFA is anchored.</p>
<p>When a DFA is anchored, it is only allowed to report matches that
start at index <code>0</code>.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.next_state" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#56" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#tymethod.next_state" class="fnname">next_state</a>(&amp;self, current: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a>) -&gt; Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></div></summary><div class="docblock"><p>Given the current state that this DFA is in and the next input byte,
this method returns the identifier of the next state. The identifier
returned is always valid, but it may correspond to a dead state.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="tymethod.next_state_unchecked" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#63-67" title="goto source code">[src]</a></div><h4 class="code-header">unsafe fn <a href="#tymethod.next_state_unchecked" class="fnname">next_state_unchecked</a>(&amp;self, current: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a>) -&gt; Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></div></summary><div class="docblock"><p>Like <code>next_state</code>, but its implementation may look up the next state
without memory safety checks such as bounds checks. As such, callers
must ensure that the given identifier corresponds to a valid DFA
state. Implementors must, in turn, ensure that this routine is safe
for all valid state identifiers and for all possible <code>u8</code> values.</p>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided methods<a href="#provided-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle" open><summary><div id="method.is_match" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#91-93" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.is_match" class="fnname">is_match</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Returns true if and only if the given bytes match this DFA.</p>
<p>This routine may short circuit if it knows that scanning future input
will never lead to a different result. In particular, if a DFA enters
a match state or a dead state, then this routine will return <code>true</code> or
<code>false</code>, respectively, without inspecting any future input.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<p>This example shows how to use this method with a
<a href="enum.DenseDFA.html"><code>DenseDFA</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">DFA</span>, <span class="ident">DenseDFA</span>};

<span class="kw">let</span> <span class="ident">dfa</span> <span class="op">=</span> <span class="ident">DenseDFA::new</span>(<span class="string">&quot;foo[0-9]+bar&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="bool-val">true</span>, <span class="ident">dfa</span>.<span class="ident">is_match</span>(<span class="string">b&quot;foo12345bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="bool-val">false</span>, <span class="ident">dfa</span>.<span class="ident">is_match</span>(<span class="string">b&quot;foobar&quot;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.shortest_match" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#121-123" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.shortest_match" class="fnname">shortest_match</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the first position at which a match is found.</p>
<p>This routine stops scanning input in precisely the same circumstances
as <code>is_match</code>. The key difference is that this routine returns the
position at which it stopped scanning input if and only if a match
was found. If no match is found, then <code>None</code> is returned.</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<p>This example shows how to use this method with a
<a href="enum.DenseDFA.html"><code>DenseDFA</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">DFA</span>, <span class="ident">DenseDFA</span>};

<span class="kw">let</span> <span class="ident">dfa</span> <span class="op">=</span> <span class="ident">DenseDFA::new</span>(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), <span class="ident">dfa</span>.<span class="ident">shortest_match</span>(<span class="string">b&quot;foo12345&quot;</span>));

<span class="comment">// Normally, the end of the leftmost first match here would be 3,</span>
<span class="comment">// but the shortest match semantics detect a match earlier.</span>
<span class="kw">let</span> <span class="ident">dfa</span> <span class="op">=</span> <span class="ident">DenseDFA::new</span>(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), <span class="ident">dfa</span>.<span class="ident">shortest_match</span>(<span class="string">b&quot;abc&quot;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.find" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#171-173" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.find" class="fnname">find</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the end offset of the longest match. If no match exists,
then <code>None</code> is returned.</p>
<p>Implementors of this trait are not required to implement any particular
match semantics (such as leftmost-first), which are instead manifest in
the DFA’s topology itself.</p>
<p>In particular, this method must continue searching even after it
enters a match state. The search should only terminate once it has
reached the end of the input or when it has entered a dead state. Upon
termination, the position of the last byte seen while still in a match
state is returned.</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example</a></h1>
<p>This example shows how to use this method with a
<a href="enum.DenseDFA.html"><code>DenseDFA</code></a>. By default, a dense DFA uses
“leftmost first” match semantics.</p>
<p>Leftmost first match semantics corresponds to the match with the
smallest starting offset, but where the end offset is determined by
preferring earlier branches in the original regular expression. For
example, <code>Sam|Samwise</code> will match <code>Sam</code> in <code>Samwise</code>, but <code>Samwise|Sam</code>
will match <code>Samwise</code> in <code>Samwise</code>.</p>
<p>Generally speaking, the “leftmost first” match is how most backtracking
regular expressions tend to work. This is in contrast to POSIX-style
regular expressions that yield “leftmost longest” matches. Namely,
both <code>Sam|Samwise</code> and <code>Samwise|Sam</code> match <code>Samwise</code> when using
leftmost longest semantics.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">DFA</span>, <span class="ident">DenseDFA</span>};

<span class="kw">let</span> <span class="ident">dfa</span> <span class="op">=</span> <span class="ident">DenseDFA::new</span>(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">8</span>), <span class="ident">dfa</span>.<span class="ident">find</span>(<span class="string">b&quot;foo12345&quot;</span>));

<span class="comment">// Even though a match is found after reading the first byte (`a`),</span>
<span class="comment">// the leftmost first match semantics demand that we find the earliest</span>
<span class="comment">// match that prefers earlier parts of the pattern over latter parts.</span>
<span class="kw">let</span> <span class="ident">dfa</span> <span class="op">=</span> <span class="ident">DenseDFA::new</span>(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), <span class="ident">dfa</span>.<span class="ident">find</span>(<span class="string">b&quot;abc&quot;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.rfind" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#199-201" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.rfind" class="fnname">rfind</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the start offset of the longest match in reverse, by searching
from the end of the input towards the start of the input. If no match
exists, then <code>None</code> is returned. In other words, this has the same
match semantics as <code>find</code>, but in reverse.</p>
<h1 id="example-3" class="section-header"><a href="#example-3">Example</a></h1>
<p>This example shows how to use this method with a
<a href="enum.DenseDFA.html"><code>DenseDFA</code></a>. In particular, this routine
is principally useful when used in conjunction with the
<a href="dense/struct.Builder.html#method.reverse"><code>dense::Builder::reverse</code></a>
configuration knob. In general, it’s unlikely to be correct to use both
<code>find</code> and <code>rfind</code> with the same DFA since any particular DFA will only
support searching in one direction.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">dense</span>, <span class="ident">DFA</span>};

<span class="kw">let</span> <span class="ident">dfa</span> <span class="op">=</span> <span class="ident">dense::Builder::new</span>().<span class="ident">reverse</span>(<span class="bool-val">true</span>).<span class="ident">build</span>(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), <span class="ident">dfa</span>.<span class="ident">rfind</span>(<span class="string">b&quot;foo12345&quot;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.is_match_at" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#210-226" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.is_match_at" class="fnname">is_match_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Returns the same as <code>is_match</code>, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, if the DFA is anchored, then
a match can only occur when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.shortest_match_at" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#235-255" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.shortest_match_at" class="fnname">shortest_match_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the same as <code>shortest_match</code>, but starts the search at the
given offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, if the DFA is anchored, then
a match can only occur when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.find_at" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#264-287" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.find_at" class="fnname">find_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the same as <code>find</code>, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, if the DFA is anchored, then
a match can only occur when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="method.rfind_at" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#296-319" title="goto source code">[src]</a></div><h4 class="code-header">fn <a href="#method.rfind_at" class="fnname">rfind_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.56.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.usize.html">usize</a>&gt;</h4></div></summary><div class="docblock"><p>Returns the same as <code>rfind</code>, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, if the DFA is anchored, then
a match can only occur when <code>start == bytes.len()</code>.</p>
</div></details></div><h2 id="foreign-impls" class="small-section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-DFA-for-%26%27a%20T" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#322-363" title="goto source code">[src]</a></div><a href="#impl-DFA-for-%26%27a%20T" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T:&nbsp;<a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.reference.html">&amp;'a </a>T</h3></div></summary><div class="impl-items"><div id="associatedtype.ID-1" class="type trait-impl has-srclink"><a href="#associatedtype.ID-1" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a> = T::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></div><div id="method.start_state" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#326-328" title="goto source code">[src]</a></div><a href="#method.start_state" class="anchor"></a><h4 class="code-header">fn <a href="#tymethod.start_state" class="fnname">start_state</a>(&amp;self) -&gt; Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></div><div id="method.is_match_state" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#331-333" title="goto source code">[src]</a></div><a href="#method.is_match_state" class="anchor"></a><h4 class="code-header">fn <a href="#tymethod.is_match_state" class="fnname">is_match_state</a>(&amp;self, id: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div><div id="method.is_match_or_dead_state" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#336-338" title="goto source code">[src]</a></div><a href="#method.is_match_or_dead_state" class="anchor"></a><h4 class="code-header">fn <a href="#tymethod.is_match_or_dead_state" class="fnname">is_match_or_dead_state</a>(&amp;self, id: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div><div id="method.is_dead_state" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#341-343" title="goto source code">[src]</a></div><a href="#method.is_dead_state" class="anchor"></a><h4 class="code-header">fn <a href="#tymethod.is_dead_state" class="fnname">is_dead_state</a>(&amp;self, id: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div><div id="method.is_anchored" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#346-348" title="goto source code">[src]</a></div><a href="#method.is_anchored" class="anchor"></a><h4 class="code-header">fn <a href="#tymethod.is_anchored" class="fnname">is_anchored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.bool.html">bool</a></h4></div><div id="method.next_state" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#351-353" title="goto source code">[src]</a></div><a href="#method.next_state" class="anchor"></a><h4 class="code-header">fn <a href="#tymethod.next_state" class="fnname">next_state</a>(&amp;self, current: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a>) -&gt; Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></div><div id="method.next_state_unchecked" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dfa.rs.html#356-362" title="goto source code">[src]</a></div><a href="#method.next_state_unchecked" class="anchor"></a><h4 class="code-header">unsafe fn <a href="#tymethod.next_state_unchecked" class="fnname">next_state_unchecked</a>(&amp;self, current: Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a>) -&gt; Self::<a class="type" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></div></div></details><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div class="item-list" id="implementors-list"><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-DFA" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/sparse.rs.html#415-499" title="goto source code">[src]</a></div><a href="#impl-DFA" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.56.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="enum" href="sparse/enum.SparseDFA.html" title="enum regex_automata::sparse::SparseDFA">SparseDFA</a>&lt;T, S&gt;</h3></div></summary><div class="impl-items"><div id="associatedtype.ID-2" class="type trait-impl has-srclink"><a href="#associatedtype.ID-2" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a> = S</h4></div></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-DFA-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/sparse.rs.html#573-611" title="goto source code">[src]</a></div><a href="#impl-DFA-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.56.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for regex_automata::sparse::<a class="struct" href="sparse/struct.ByteClass.html" title="struct regex_automata::sparse::ByteClass">ByteClass</a>&lt;T, S&gt;</h3></div></summary><div class="impl-items"><div id="associatedtype.ID-3" class="type trait-impl has-srclink"><a href="#associatedtype.ID-3" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a> = S</h4></div></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-DFA-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/sparse.rs.html#512-549" title="goto source code">[src]</a></div><a href="#impl-DFA-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.56.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for regex_automata::sparse::<a class="struct" href="sparse/struct.Standard.html" title="struct regex_automata::sparse::Standard">Standard</a>&lt;T, S&gt;</h3></div></summary><div class="impl-items"><div id="associatedtype.ID-4" class="type trait-impl has-srclink"><a href="#associatedtype.ID-4" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a> = S</h4></div></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-DFA-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dense.rs.html#546-662" title="goto source code">[src]</a></div><a href="#impl-DFA-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.56.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">[</a>S<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="enum" href="dense/enum.DenseDFA.html" title="enum regex_automata::dense::DenseDFA">DenseDFA</a>&lt;T, S&gt;</h3></div></summary><div class="impl-items"><div id="associatedtype.ID-5" class="type trait-impl has-srclink"><a href="#associatedtype.ID-5" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a> = S</h4></div></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-DFA-4" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dense.rs.html#735-776" title="goto source code">[src]</a></div><a href="#impl-DFA-4" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.56.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">[</a>S<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for regex_automata::dense::<a class="struct" href="dense/struct.ByteClass.html" title="struct regex_automata::dense::ByteClass">ByteClass</a>&lt;T, S&gt;</h3></div></summary><div class="impl-items"><div id="associatedtype.ID-6" class="type trait-impl has-srclink"><a href="#associatedtype.ID-6" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a> = S</h4></div></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-DFA-5" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dense.rs.html#796-835" title="goto source code">[src]</a></div><a href="#impl-DFA-5" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.56.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">[</a>S<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="struct" href="dense/struct.Premultiplied.html" title="struct regex_automata::dense::Premultiplied">Premultiplied</a>&lt;T, S&gt;</h3></div></summary><div class="impl-items"><div id="associatedtype.ID-7" class="type trait-impl has-srclink"><a href="#associatedtype.ID-7" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a> = S</h4></div></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-DFA-6" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dense.rs.html#849-890" title="goto source code">[src]</a></div><a href="#impl-DFA-6" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.56.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">[</a>S<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="struct" href="dense/struct.PremultipliedByteClass.html" title="struct regex_automata::dense::PremultipliedByteClass">PremultipliedByteClass</a>&lt;T, S&gt;</h3></div></summary><div class="impl-items"><div id="associatedtype.ID-8" class="type trait-impl has-srclink"><a href="#associatedtype.ID-8" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a> = S</h4></div></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-DFA-7" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/regex_automata/dense.rs.html#675-714" title="goto source code">[src]</a></div><a href="#impl-DFA-7" class="anchor"></a><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.56.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">[</a>S<a class="primitive" href="https://doc.rust-lang.org/1.56.1/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for regex_automata::dense::<a class="struct" href="dense/struct.Standard.html" title="struct regex_automata::dense::Standard">Standard</a>&lt;T, S&gt;</h3></div></summary><div class="impl-items"><div id="associatedtype.ID-9" class="type trait-impl has-srclink"><a href="#associatedtype.ID-9" class="anchor"></a><h4 class="code-header">type <a href="#associatedtype.ID" class="type">ID</a> = S</h4></div></div></details></div><script type="text/javascript" src="../implementors/regex_automata/trait.DFA.js" async></script></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="regex_automata" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>