window.SIDEBAR_ITEMS = {"struct":[["Accepted","Represents a `ClientHello` message received through the [`Acceptor`]."],["Acceptor","Handle on a server-side connection before configuration is available."],["AllowAnyAnonymousOrAuthenticatedClient","A `ClientCertVerifier` that will allow both anonymous and authenticated clients, without any name checking."],["AllowAnyAuthenticatedClient","A `ClientCertVerifier` that will ensure that every client provides a trusted certificate, without any name checking."],["ClientCertVerified","Zero-sized marker type representing verification of a client cert chain."],["ClientHello","A struct representing the received Client Hello"],["DnsName","A type which encapsulates a string that is a syntactically valid DNS name."],["NoClientAuth","Turns off client authentication."],["NoServerSessionStorage","Something which never stores sessions."],["ReadEarlyData","Allows reading of early data in resumed TLS1.3 connections."],["ResolvesServerCertUsingSni","Something that resolves do different cert chains/keys based on client-supplied server name (via SNI)."],["ServerConfig","Common configuration for a set of server sessions."],["ServerConnection","This represents a single TLS server connection."],["ServerConnectionData","State associated with a server connection."],["ServerSessionMemoryCache","An implementer of `StoresServerSessions` that stores everything in memory.  If enforces a limit on the number of stored sessions to bound memory usage."],["WantsServerCert","A config builder state where the caller must supply how to provide a server certificate to the connecting peer."]],"trait":[["ClientCertVerifier","Something that can verify a client certificate chain"],["ProducesTickets","A trait for the ability to encrypt and decrypt tickets."],["ResolvesServerCert","How to choose a certificate chain and signing key for use in server authentication."],["StoresServerSessions","A trait for the ability to store server session data."]]};