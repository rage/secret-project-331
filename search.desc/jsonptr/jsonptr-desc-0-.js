searchState.loadedDescShard("jsonptr", 0, "jsonptr - JSON Pointers (RFC 6901) for Rust\nA single <code>Token</code> or the root of a JSON Pointer\nAn iterator over the <code>Component</code>s of a JSON Pointer\nA token within a json pointer contained invalid encoding (<code>~</code>…\nRepresents the specific type of invalid encoding error.\n<code>Pointer</code> contained invalid encoding (e.g. <code>~</code> not followed by …\nDeprecated alias for <code>EncodingError</code>.\n<code>Pointer</code> did not start with a slash (<code>&#39;/&#39;</code>).\nIndicates that a <code>Pointer</code> was malformed and unable to be …\nA JSON Pointer is a string containing a sequence of zero …\nAn owned, mutable <code>Pointer</code> (akin to <code>String</code>).\nA rich error type that includes the original string that …\nThe document root\nnon-encoded <code>/</code> found in token\n<code>~</code> not followed by <code>0</code> or <code>1</code>\nA <code>Token</code> is a segment of a JSON <code>Pointer</code>, preceded by <code>&#39;/&#39;</code> (…\nA segment of a JSON Pointer\nAn iterator over the <code>Token</code>s of a <code>Pointer</code>.\nMerges two <code>Pointer</code>s by appending <code>other</code> onto <code>self</code>.\nCoerces to a Pointer slice.\nThe encoded string representation of this <code>Pointer</code>\nAssign values based on JSON <code>Pointer</code>s\nAttempts to assign <code>src</code> to <code>dest</code> based on the path in this …\nReturns the last <code>Token</code> in the <code>Pointer</code>.\nClears the <code>Pointer</code>, setting it to root (<code>&quot;&quot;</code>).\nOffset of the first invalid encoding from within the …\nReturns <code>Components</code> of this JSON Pointer.\nCreates an owned <code>PointerBuf</code> like <code>self</code> but with <code>other</code> …\nReturns the number of tokens in the <code>Pointer</code>.\nReturns the decoded string representation of the <code>Token</code>.\nDelete values based on JSON Pointers\nAttempts to delete a <code>serde_json::Value</code> based upon the path …\nError reporting data structures and miette integration.\nReturns the encoded string representation of the <code>Token</code>.\nReturns whether <code>self</code> has a suffix of <code>other</code>.\nReturns the first <code>Token</code> in the <code>Pointer</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a <code>Token</code> from an RFC 6901 encoded string.\nCreates a static <code>Pointer</code> from a string.\nCreates a new <code>PointerBuf</code> from a slice of non-encoded …\nReturns the first <code>Token</code> in the <code>Pointer</code>.\nAttempts to get a <code>Token</code> by the index. Returns <code>None</code> if the …\nAbstract index representation for RFC 6901.\nFinds the commonality between this and another <code>Pointer</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a <code>Box&lt;Pointer&gt;</code> into a <code>PointerBuf</code> without copying …\nConverts into an owned copy of this token.\nLength of the invalid encoding\nReturns <code>true</code> if the <code>Pointer</code> is empty (i.e. root).\nReturns <code>true</code> if this error is <code>InvalidEncoding</code>\nReturns if the <code>Token</code> is <code>-</code>, which stands for the next array …\nReturns <code>true</code> if this error is <code>NoLeadingSlash</code>\nReturns <code>true</code> if this error is <code>NoLeadingSlash</code>\nReturns <code>true</code> if the JSON Pointer equals <code>&quot;&quot;</code>.\nReturns the last token in the <code>Pointer</code>.\nThis length expresses the byte count of the underlying …\nCreates a new <code>PointerBuf</code> pointing to a document root.\nConstructs a <code>Token</code> from an arbitrary string.\nCreate a <code>Pointer</code> from a string that is known to be …\nCreate a <code>PointerBuf</code> from a string that is known to be …\nOffset of the partial pointer starting with the token that …\noffset of the erroneous <code>~</code> from within the <code>Token</code>\noffset of the erroneous <code>~</code> from within the <code>Token</code>\nA pointer to the parent of the current path.\nAttempts to parse a string into a <code>Pointer</code>.\nAttempts to parse a string into a <code>PointerBuf</code>.\nOffset of the partial pointer starting with the token …\nRemoves and returns the last <code>Token</code> in the <code>Pointer</code> if it …\nRemoves and returns the first <code>Token</code> in the <code>Pointer</code> if it …\nPushes a <code>Token</code> onto the back of this <code>Pointer</code>.\nPushes a <code>Token</code> onto the front of this <code>Pointer</code>.\nAttempts to replace a <code>Token</code> by the index, returning the …\nResolve values based on JSON <code>Pointer</code>s\nAttempts to resolve a <code>R::Value</code> based on the path in this …\nAttempts to resolve a mutable <code>R::Value</code> based on the path …\nConstant reference to a root pointer\nCreates a new <code>PointerBuf</code> pointing to a document root.\nthe specific encoding error\nthe specific encoding error\nOffset of the character index from within the first token …\nSplits the <code>Pointer</code> at the given index if the character at …\nSplits the <code>Pointer</code> into the parent path and the last <code>Token</code>.\nSplits the <code>Pointer</code> into the first <code>Token</code> and a remainder …\nReturns whether <code>self</code> has a prefix of <code>other.</code>\nReturns the pointer stripped of the given prefix.\nReturns the pointer stripped of the given suffix.\nConverts into an owned <code>PointerBuf</code>\nAttempts to parse the given <code>Token</code> as an array index.\nReturns a <code>serde_json::Value</code> representation of this <code>Pointer</code>\nExtracts an owned copy of this token.\nReturns an iterator of <code>Token</code>s in the <code>Pointer</code>.\nCreates an owned <code>PointerBuf</code> like <code>self</code> but with <code>token</code> …\nCreates an owned <code>PointerBuf</code> like <code>self</code> but with <code>token</code> …\nOffset of the partial pointer starting with the token that …\nThe source <code>InvalidEncodingError</code>\nImplemented by types which can internally assign a (<code>Value</code>) …\nAlias for <code>Error</code> - indicates a value assignment failed.\nPossible error returned from <code>Assign</code> implementations for …\nError associated with <code>Assign</code>\nA <code>Token</code> within the <code>Pointer</code> failed to be parsed as an array …\nA <code>Token</code> within the <code>Pointer</code> failed to be parsed as an array …\nA <code>Token</code> within the <code>Pointer</code> contains an <code>Index</code> which is out …\nA <code>Token</code> within the <code>Pointer</code> contains an <code>Index</code> which is out …\nThe type of value that this implementation can operate on.\nAssigns a value of based on the path provided by a JSON …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the error is <code>FailedToParseIndex</code>.\nReturns <code>true</code> if the error is <code>OutOfBounds</code>.\nOffset (in bytes) of the partial pointer starting with the …\nThe position (token index) of the <code>Token</code> which was out of …\nOffset of the partial pointer starting with the invalid …\nOffset of the partial pointer starting with the invalid …\nPosition (index) of the token which failed to parse as an …\nPosition (index) of the token which failed to parse as an …\nThe source <code>ParseIndexError</code>\nThe source <code>OutOfBoundsError</code>\nOffset of the partial pointer starting with the invalid …\nOffset of the partial pointer starting with the invalid …\nPosition (index) of the token which failed to parse as an …\nPosition (index) of the token which failed to parse as an …\nThe source <code>ParseIndexError</code>\nThe source <code>OutOfBoundsError</code>\nDelete is implemented by types which can internally remove …\nThe type of value that this implementation can operate on.\nAttempts to internally delete a value based upon a Pointer.\nAn extension trait for <code>Result&lt;_, E&gt;</code>, where <code>E</code> is an …\nImplemented by errors which can be converted into a <code>Report</code>.\nThe error type returned from <code>diagnose</code> and <code>diagnose_with</code>.\nA label for a span within a json pointer or malformed …\nAn enriched error wrapper which captures the original …\nThe value which caused the error.\nThe original parts of the <code>Report</code>.\nIf the <code>Result</code> is an <code>Err</code>, converts the error into a <code>Report</code> …\nIf the <code>Result</code> is an <code>Err</code>, converts the error into a <code>Report</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the <code>Report</code> and returns the original error <code>T</code>.\nCombine the error with its subject to generate a <code>Report</code>.\nReturns the label for the given [<code>Subject</code>] if applicable.\nCreates a new instance of a <code>Label</code> from its parts\nThe error which occurred.\nThe value which caused the error.\nThe docs.rs URL for this error\nRepresents an abstract index into an array.\nThe Token contains a non-digit character.\nIndicates that a non-digit character was found when …\nThe Token does not represent a valid integer.\nThe Token contains leading zeros.\nThe <code>-</code> token, the position of the next would-be item in the …\nA non-negative integer value\nIndicates that an <code>Index</code> is not within the given bounds.\nIndicates that the <code>Token</code> could not be parsed as valid RFC …\nReturns the offending character.\nBounds the index for a given array length (exclusive).\nBounds the index for a given array length (inclusive).\nResolves the index for a given array length.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe resolved numerical index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe provided array length.\nReturns the offset of the character in the string.\nReturns the source string.\nIndicates that the <code>Pointer</code> could not be resolved.\nError associated with <code>Resolve</code>\nError associated with <code>ResolveMut</code>\n<code>Pointer</code> could not be resolved because a <code>Token</code> for an array …\n<code>Pointer</code> could not be resolved because a <code>Token</code> for an array …\n<code>Pointer</code> could not be resolved as a segment of the path was …\n<code>Pointer</code> could not be resolved as a segment of the path was …\nA <code>Token</code> within the <code>Pointer</code> contains an [<code>Index</code>] which is …\nA <code>Token</code> within the <code>Pointer</code> contains an [<code>Index</code>] which is …\nA trait implemented by types which can resolve a reference …\nAlias for <code>Error</code>.\nA trait implemented by types which can resolve a mutable …\n<code>Pointer</code> could not be resolved as the path contains a …\n<code>Pointer</code> could not be resolved as the path contains a …\nThe type of value that this implementation can operate on.\nThe type of value that is being resolved.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this error is <code>FailedToParseIndex</code>; …\nReturns <code>true</code> if this error is <code>FailedToParseIndex</code>; …\nReturns <code>true</code> if this error is <code>FailedToParseIndex</code>; …\nReturns <code>true</code> if this error is <code>FailedToParseIndex</code>; …\nOffset of the partial pointer starting with the token …\nPosition (index) of the token which caused the error.\nResolve a reference to <code>Self::Value</code> based on the path in a …\nResolve a mutable reference to a <code>serde_json::Value</code> based …\nOffset of the partial pointer starting with the invalid …\nOffset of the partial pointer starting with the invalid …\nOffset of the pointer starting with the <code>Token</code> which was …\nOffset of the pointer which was unreachable.\nPosition (index) of the token which failed to parse as an …\nPosition (index) of the token which failed to parse as an …\nPosition (index) of the token which was not found.\nPosition (index) of the token which was unreachable.\nThe source <code>ParseIndexError</code>\nThe source <code>OutOfBoundsError</code>\nOffset of the partial pointer starting with the invalid …\nOffset of the partial pointer starting with the invalid …\nOffset of the pointer starting with the <code>Token</code> which was …\nOffset of the pointer which was unreachable.\nPosition (index) of the token which failed to parse as an …\nPosition (index) of the token which failed to parse as an …\nPosition (index) of the token which was not found.\nPosition (index) of the token which was unreachable.\nThe source <code>ParseIndexError</code>\nThe source <code>OutOfBoundsError</code>")