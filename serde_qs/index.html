<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Serde support for querystring-style strings"><title>serde_qs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="serde_qs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../serde_qs/index.html">serde_<wbr>qs</a><span class="version">0.8.5</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">serde_qs</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/serde_qs/lib.rs.html#1-187">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Serde support for querystring-style strings</p>
<p>Querystrings are not formally defined and loosely take the form of
<em>nested</em> urlencoded queries.</p>
<p>This library aims for compatability with the syntax of
<a href="https://github.com/ljharb/qs">qs</a> and also of the
<a href="http://www.rubydoc.info/github/rack/rack/Rack/Utils#parse_nested_query-class_method"><code>Rack::Utils::parse_nested_query</code></a>
implementation.</p>
<p>For users who do <em>not</em> require nested URL parameters, it is highly
recommended that the <code>serde_urlencoded</code> crate is used instead, which
will almost certainly perform better for deserializing simple inputs.</p>
<h3 id="supported-types"><a class="doc-anchor" href="#supported-types">§</a>Supported Types</h3>
<p>At the <strong>top level</strong>, <code>serde_qs</code> only supports <code>struct</code>, <code>map</code>, and <code>enum</code>.
These are the only top-level structs which can be de/serialized since
Querystrings rely on having a (key, value) pair for each field, which
necessitates this kind of structure.</p>
<p>However, after the top level you should find all supported types can be
de/serialized.</p>
<p>Note that integer keys are reserved for array indices. That is, a string of
the form <code>a[0]=1&amp;a[1]=3</code> will deserialize to the ordered sequence <code>a = [1,3]</code>.</p>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3>
<p>See the examples folder for a more detailed introduction.</p>
<p>Serializing/Deserializing is designed to work with maps and structs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>serde_derive;
<span class="kw">extern crate </span>serde_qs <span class="kw">as </span>qs;

<span class="attr">#[derive(Debug, PartialEq, Deserialize, Serialize)]
</span><span class="kw">struct </span>Address {
    city: String,
    postcode: String,
}
<span class="attr">#[derive(Debug, PartialEq, Deserialize, Serialize)]
</span><span class="kw">struct </span>QueryParams {
    id: u8,
    name: String,
    address: Address,
    phone: u32,
    user_ids: Vec&lt;u8&gt;,
}

<span class="kw">let </span>params = QueryParams {
    id: <span class="number">42</span>,
    name: <span class="string">"Acme"</span>.to_string(),
    phone: <span class="number">12345</span>,
    address: Address {
        city: <span class="string">"Carrot City"</span>.to_string(),
        postcode: <span class="string">"12345"</span>.to_string(),
    },
    user_ids: <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],
};
<span class="kw">let </span>rec_params: QueryParams = qs::from_str(<span class="string">"\
    name=Acme&amp;id=42&amp;phone=12345&amp;address[postcode]=12345&amp;\
    address[city]=Carrot+City&amp;user_ids[0]=1&amp;user_ids[1]=2&amp;\
    user_ids[2]=3&amp;user_ids[3]=4"</span>)
    .unwrap();
<span class="macro">assert_eq!</span>(rec_params, params);
</code></pre></div>
<h3 id="strict-vs-non-strict-modes"><a class="doc-anchor" href="#strict-vs-non-strict-modes">§</a>Strict vs Non-Strict modes</h3>
<p><code>serde_qs</code> supports two operating modes, which can be specified using
<a href="struct.Config.html"><code>Config</code></a>, and is all about how <code>serde_qs</code> handles square brackets.</p>
<p>Techncially, square brackets should be encoded in URLs as <code>%5B</code> and <code>%5D</code>.
However, they are often used in their raw format to specify querystrings
such as <code>a[b]=123</code>.</p>
<p>In strict mode, <code>serde_qs</code> will only tolerate unencoded square brackets
to denote nested keys. So <code>a[b]=123</code> will decode as <code>{"a": {"b": 123}}</code>.
This means that encoded square brackets can actually be part of the key.
<code>a[b%5Bc%5D]=123</code> becomes <code>{"a": {"b[c]": 123}}</code>.</p>
<p>However, since some implementations will automatically encode everything
in the URL, we also have a non-strict mode. This means that <code>serde_qs</code>
will assume that any encoded square brackets in the string were meant to
be taken as nested keys. From the example before, <code>a[b%5Bc%5D]=123</code> will
now become <code>{"a": {"b": {"c": 123 }}}</code>.</p>
<p>Non-strict mode can be useful when, as said before, some middleware
automatically encodes the brackets. But care must be taken to avoid
using keys with square brackets in them, or unexpected things can
happen.</p>
<h3 id="flatten-workaround"><a class="doc-anchor" href="#flatten-workaround">§</a>Flatten workaround</h3>
<p>A current <a href="https://github.com/serde-rs/serde/issues/1183">known limitation</a>
in <code>serde</code> is deserializing <code>#[serde(flatten)]</code> structs for formats which
are not self-describing. This includes query strings: <code>12</code> can be an integer
or a string, for example.</p>
<p>We suggest the following workaround:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>serde;
<span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>serde_derive;
<span class="kw">extern crate </span>serde_qs <span class="kw">as </span>qs;
<span class="kw">extern crate </span>serde_with;

<span class="kw">use </span>serde_with::rust::display_fromstr::deserialize <span class="kw">as </span>deserialize_fromstr;

<span class="attr">#[derive(Deserialize, Serialize, Debug, PartialEq)]
</span><span class="kw">struct </span>Query {
    a: u8,
    <span class="attr">#[serde(flatten)]
    </span>common: CommonParams,
}

<span class="attr">#[derive(Deserialize, Serialize, Debug, PartialEq)]
</span><span class="kw">struct </span>CommonParams {
    <span class="attr">#[serde(deserialize_with=<span class="string">"deserialize_fromstr"</span>)]
    </span>limit: u64,
    <span class="attr">#[serde(deserialize_with=<span class="string">"deserialize_fromstr"</span>)]
    </span>offset: u64,
    <span class="attr">#[serde(deserialize_with=<span class="string">"deserialize_fromstr"</span>)]
    </span>remaining: bool,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>params = <span class="string">"a=1&amp;limit=100&amp;offset=50&amp;remaining=true"</span>;
    <span class="kw">let </span>query = Query { a: <span class="number">1</span>, common: CommonParams { limit: <span class="number">100</span>, offset: <span class="number">50</span>, remaining: <span class="bool-val">true </span>} };
    <span class="kw">let </span>rec_query: <span class="prelude-ty">Result</span>&lt;Query, <span class="kw">_</span>&gt; = qs::from_str(params);
    <span class="macro">assert_eq!</span>(rec_query.unwrap(), query);
}</code></pre></div>
<h3 id="use-with-actix_web-extractors"><a class="doc-anchor" href="#use-with-actix_web-extractors">§</a>Use with <code>actix_web</code> extractors</h3>
<p>The <code>actix</code> feature enables the use of <code>serde_qs::actix::QsQuery</code>, which
is a direct substitute for the <code>actix_web::Query</code> and can be used as an extractor:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>index(info: QsQuery&lt;Info&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;String&gt; {
    <span class="prelude-val">Ok</span>(<span class="macro">format!</span>(<span class="string">"Welcome {}!"</span>, info.username))
}</code></pre></div>
<p>Support for <code>actix-web 2.0.0</code> is available via the <code>actix2</code> feature.</p>
<h3 id="use-with-warp-filters"><a class="doc-anchor" href="#use-with-warp-filters">§</a>Use with <code>warp</code> filters</h3>
<p>The <code>warp</code> feature enables the use of <code>serde_qs::warp::query()</code>, which
is a substitute for the <code>warp::query::query()</code> filter and can be used like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>serde_qs::warp::query(Config::default())
    .and_then(|info| <span class="kw">async move </span>{
        <span class="prelude-val">Ok</span>::&lt;<span class="kw">_</span>, Rejection&gt;(<span class="macro">format!</span>(<span class="string">"Welcome {}!"</span>, info.username))
    })
    .recover(serde_qs::warp::recover_fn);</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct serde_qs::Config">Config</a></div><div class="desc docblock-short">To override the default serialization parameters, first construct a new
Config.</div></li><li><div class="item-name"><a class="struct" href="struct.QsSerializer.html" title="struct serde_qs::QsSerializer">QsSerializer</a></div><div class="desc docblock-short">A serializer for the querystring format.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum serde_qs::Error">Error</a></div><div class="desc docblock-short">Error type for <code>serde_qs</code>.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.from_bytes.html" title="fn serde_qs::from_bytes">from_<wbr>bytes</a></div><div class="desc docblock-short">Deserializes a querystring from a <code>&amp;[u8]</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.from_str.html" title="fn serde_qs::from_str">from_<wbr>str</a></div><div class="desc docblock-short">Deserializes a querystring from a <code>&amp;str</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.to_string.html" title="fn serde_qs::to_string">to_<wbr>string</a></div><div class="desc docblock-short">Serializes a value into a querystring.</div></li><li><div class="item-name"><a class="fn" href="fn.to_writer.html" title="fn serde_qs::to_writer">to_<wbr>writer</a></div><div class="desc docblock-short">Serializes a value into a generic writer object.</div></li></ul></section></div></main></body></html>