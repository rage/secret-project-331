import { css } from "@emotion/css"
import { useTranslation } from "react-i18next"

import { BlockRendererProps } from "../../.."
import {
  ButtonAttributes,
  ButtonsAttributes,
} from "../../../../../../types/GutenbergBlockAttributes"
import colorMapper from "../../../../../styles/colorMapper"
import { fontSizeMapper } from "../../../../../styles/fontSizeMapper"

import Button from "@/shared-module/common/components/Button"
import withErrorBoundary from "@/shared-module/common/utils/withErrorBoundary"

// Layout looks like this:
// export interface Layout {
//   justifyContent: string
//   orientation: string
//   type: string
// }

const ButtonsBlock: React.FC<React.PropsWithChildren<BlockRendererProps<ButtonsAttributes>>> = ({
  data,
}) => {
  const { t } = useTranslation()
  const { anchor } = data.attributes

  const orientation = data.attributes.layout?.orientation as string | undefined | null
  const contentJustification = data.attributes.layout?.justifyContent as string | undefined | null

  const getContentJustification = (contentJustification: string) => {
    if (contentJustification === "center") {
      return "justify-content: center; align-items: center;"
    } else if (contentJustification === "right") {
      return "justify-content: flex-end; align-items: flex-end;"
    } else if (contentJustification === "space-between") {
      return "justify-content: space-between;"
    } else {
      return "justify-content: flex-start; align-items: flex-start;"
    }
  }

  // TODO: Fetch the variant by extending CMS button attribute object, rather than using className generated by Gutenberg
  const getButtonTypeFromClassName = (className: string | undefined) => {
    const PRIMARY = "primary"
    const SECONDARY = "secondary"
    const TERTIARY = "tertiary"
    if (!className) {
      return PRIMARY
    }

    if (className.includes("is-style-material-primary-button")) {
      return PRIMARY
    } else if (className.includes("is-style-material-secondary-button")) {
      return SECONDARY
    } else if (className.includes("is-style-material-tertiary-button")) {
      return TERTIARY
    }
    return PRIMARY
  }

  const mappedButtons = data.innerBlocks.map((button) => {
    const {
      // align,
      anchor,
      backgroundColor,
      className,
      fontSize,
      fontFamily,
      gradient,
      linkTarget,
      placeholder,
      rel,
      // style,
      text,
      textColor,
      // title
      url,
      width,
    } = button.attributes as ButtonAttributes

    const ENSURE_REL_NO_OPENER_IF_TARGET_BLANK =
      linkTarget && linkTarget.includes("_blank")
        ? rel && !rel.includes("noopener")
          ? rel.split(" ").join(" ").concat(" noopener")
          : "noopener"
        : rel

    return (
      <a
        key={button.clientId}
        rel={ENSURE_REL_NO_OPENER_IF_TARGET_BLANK}
        href={url}
        target={linkTarget}
        className={css`
          ${width && `width: ${width}%;`}
        `}
      >
        <Button
          className={css`
            ${backgroundColor && `background: ${colorMapper(backgroundColor)} !important;`}
            ${gradient && `background: ${colorMapper(gradient)} !important;`}
            ${textColor &&
            `color: ${colorMapper(textColor)} !important; border-color: ${colorMapper(
              textColor,
            )} !important;`}
            ${fontSize && `font-size: ${fontSizeMapper(fontSize)} !important;`}
            ${width && `width: calc(100% - ${1 - width / 100}rem);`}
            ${fontFamily && `font-family: ${fontFamily};`}
            margin: 0.5rem 0rem;
            margin-right: 0.5rem;
          `}
          variant={getButtonTypeFromClassName(className)}
          size="medium"
          {...(anchor && { id: anchor })}
          dangerouslySetInnerHTML={{ __html: text ?? placeholder ?? "BUTTON" }}
        />
        {linkTarget && linkTarget.includes("_blank") && (
          <span className="screen-reader-only">{t("screen-reader-opens-in-new-tab")}</span>
        )}
      </a>
    )
  })
  return (
    <div
      className={css`
        display: flex;
        flex-wrap: wrap;
        ${orientation === "vertical" ? "flex-direction: column;" : "flex-direction: row;"}
        ${contentJustification && getContentJustification(contentJustification)}
      `}
      {...(anchor && { id: anchor })}
    >
      {mappedButtons}
    </div>
  )
}

export default withErrorBoundary(ButtonsBlock)
