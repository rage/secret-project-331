-- Add up migration script here
ALTER table pages
ADD COLUMN content_search tsvector;
COMMENT ON COLUMN pages.content_search IS 'Used to perform full text searches on the title of the page and the content of the page. Content is considered to be any value in the page content schema with the key "content" or "title". Page title is ranked higher in the search results as the content. The value of this is autogenerated with trigger trigger_set_pages_content_search.';
ALTER table pages
ADD COLUMN content_search_original_text TEXT;
COMMENT ON COLUMN pages.content_search_original_text IS 'Contains the extracted text from pages.content that has been used to construct the full text search  tsvector column content_search. The content_search column also indexes the pages.title but that has been left out of this colum for redundancy. Automatically generated with trigger trigger_set_pages_content_search. Used for search previews with the Postgres function ts_headline.';
ALTER TABLE pages
ADD COLUMN content_search_language REGCONFIG NOT NULL DEFAULT 'simple';
COMMENT ON COLUMN pages.content_search_original_text IS 'Language that will be used for stemming for full text search. Has to be a value from pg_ts_config.cfgname. The same value can be also determined from a courses.content_search_language but the string is duplicated here because the triggers generating text pages.content_search need to have this also in this table.';
ALTER TABLE courses
ADD COLUMN content_search_language REGCONFIG NOT NULL DEFAULT 'simple';
COMMENT ON COLUMN courses.content_search_language IS 'Language that will be used for stemming for full text search. Copied to pages.content_search_language where it''s used in triggers. Has to be a value from pg_ts_config.cfgname.';
CREATE FUNCTION extract_searchable_text_from_document_schema(content jsonb) RETURNS setof jsonb AS $$ BEGIN RETURN QUERY WITH RECURSIVE recursive_search_operation(key, value) AS (
  SELECT NULL as key,
    jsonb_array_elements(content) AS value
  UNION ALL
  SELECT p.key,
    p.value
  FROM recursive_search_operation,
    jsonb_each(
      CASE
        WHEN jsonb_typeof(recursive_search_operation.value) <> 'object' THEN '{}'::jsonb
        ELSE recursive_search_operation.value
      END
    ) as p
)
SELECT value
FROM recursive_search_operation
WHERE jsonb_typeof(recursive_search_operation.value) <> 'object'
  AND (
    recursive_search_operation.key = 'content'
    OR recursive_search_operation.key = 'title'
    OR recursive_search_operation.key = 'subtitle'
  );
END;
$$ language 'plpgsql';
CREATE FUNCTION trigger_set_pages_content_search() RETURNS TRIGGER AS $$ BEGIN IF (
  (
    row (NEW.content) IS DISTINCT
    FROM row (OLD.content)
  )
  OR OLD.content_search IS NULL
  OR NEW.content_search IS NULL
) THEN
declare begin NEW.content_search = setweight(
    to_tsvector(NEW.content_search_language, NEW.title),
    'A'
  ) || setweight (
    (
      SELECT coalesce(
          to_tsvector(NEW.content_search_language, jsonb_agg(value)),
          to_tsvector('')
        )
      FROM (
          SELECT *
          FROM extract_searchable_text_from_document_schema(NEW.content)
        ) as value
    ),
    'B'
  );
NEW.content_search_original_text = (
  SELECT string_agg(res.value->>0, ' ') as original_text
  FROM (
      SELECT extract_searchable_text_from_document_schema(NEW.content) as value
    ) as res
);
end;
END IF;
RETURN NEW;
END $$ language 'plpgsql';
-- trigger
CREATE trigger trigger_set_pages_content_search BEFORE
INSERT
  OR
UPDATE ON pages FOR EACH ROW EXECUTE PROCEDURE trigger_set_pages_content_search();
-- Update all pages to run the trigger for existing records
UPDATE pages
SET updated_at = now();
-- index for making search fast
CREATE INDEX pages_content_search ON pages USING GIN (content_search);
