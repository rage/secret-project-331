<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A variant of `query!` which takes a path to an explicitly defined struct as the output type."><title>query_as in sqlx - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="sqlx" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../sqlx/index.html">sqlx</a><span class="version">0.8.3</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="index.html">sqlx</a>::<wbr><a class="macro" href="#">query_as</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/sqlx/macros/mod.rs.html#571-578">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><span class="macro">macro_rules!</span> query_as {
    (<span class="macro-nonterminal">$out_struct</span>:path, <span class="macro-nonterminal">$query</span>:expr) =&gt; { ... };
    (<span class="macro-nonterminal">$out_struct</span>:path, <span class="macro-nonterminal">$query</span>:expr, $(<span class="macro-nonterminal">$args</span>:tt)<span class="kw-2">*</span>) =&gt; { ... };
}</pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A variant of <a href="macro.query.html" title="macro sqlx::query"><code>query!</code></a> which takes a path to an explicitly defined struct
as the output type.</p>
<p>This lets you return the struct from a function or add your own trait implementations.</p>
<p><strong>This macro does not use <a href="trait.FromRow.html" title="trait sqlx::FromRow"><code>FromRow</code></a></strong>; in fact, no trait implementations are
required at all, though this may change in future versions.</p>
<p>The macro maps rows using a struct literal where the names of columns in the query are expected
to be the same as the fields of the struct (but the order does not need to be the same).
The types of the columns are based on the query and not the corresponding fields of the struct,
so this is type-safe as well.</p>
<p>This enforces a few things:</p>
<ul>
<li>The query must output at least one column.</li>
<li>The column names of the query must match the field names of the struct.</li>
<li>The field types must be the Rust equivalent of their SQL counterparts; see the corresponding
module for your database for mappings:
<ul>
<li>Postgres: <a href="postgres/types/index.html" title="mod sqlx::postgres::types">crate::postgres::types</a></li>
<li>MySQL: [crate::mysql::types]
<ul>
<li>Note: due to wire protocol limitations, the query macros do not know when
a column should be decoded as <code>bool</code>. It will be inferred to be <code>i8</code> instead.
See the link above for details.</li>
</ul>
</li>
<li>SQLite: [crate::sqlite::types]</li>
</ul>
</li>
<li>If a column may be <code>NULL</code>, the corresponding field’s type must be wrapped in <code>Option&lt;_&gt;</code>.</li>
<li>Neither the query nor the struct may have unused fields.</li>
</ul>
<p>The only modification to the <code>query!()</code> syntax is that the struct name is given before the SQL
string:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug)]
</span><span class="kw">struct </span>Account {
    id: i32,
    name: String
}

<span class="comment">// let mut conn = &lt;impl sqlx::Executor&gt;;
</span><span class="kw">let </span>account = <span class="macro">sqlx::query_as!</span>(
        Account,
        <span class="string">"select * from (select (1) as id, 'Herp Derpinson' as name) accounts where id = ?"</span>,
        <span class="number">1i32
    </span>)
    .fetch_one(<span class="kw-2">&amp;mut </span>conn)
    .<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">println!</span>(<span class="string">"{account:?}"</span>);
<span class="macro">println!</span>(<span class="string">"{}: {}"</span>, account.id, account.name);
</code></pre></div>
<p><strong>The method you want to call depends on how many rows you’re expecting.</strong></p>
<div><table><thead><tr><th>Number of Rows</th><th>Method to Call*</th><th>Returns (<code>T</code> being the given struct)</th><th>Notes</th></tr></thead><tbody>
<tr><td>Zero or One</td><td><code>.fetch_optional(...).await</code></td><td><code>sqlx::Result&lt;Option&lt;T&gt;&gt;</code></td><td>Extra rows are ignored.</td></tr>
<tr><td>Exactly One</td><td><code>.fetch_one(...).await</code></td><td><code>sqlx::Result&lt;T&gt;</code></td><td>Errors if no rows were returned. Extra rows are ignored. Aggregate queries, use this.</td></tr>
<tr><td>At Least One</td><td><code>.fetch(...)</code></td><td><code>impl Stream&lt;Item = sqlx::Result&lt;T&gt;&gt;</code></td><td>Call <code>.try_next().await</code> to get each row result.</td></tr>
<tr><td>Multiple</td><td><code>.fetch_all(...)</code></td><td><code>sqlx::Result&lt;Vec&lt;T&gt;&gt;</code></td><td></td></tr>
</tbody></table>
</div>
<p>* All methods accept one of <code>&amp;mut {connection type}</code>, <code>&amp;mut Transaction</code> or <code>&amp;Pool</code>.
(<code>.execute()</code> is omitted as this macro requires at least one column to be returned.)</p>
<h4 id="column-type-override-infer-from-struct-field"><a class="doc-anchor" href="#column-type-override-infer-from-struct-field">§</a>Column Type Override: Infer from Struct Field</h4>
<p>In addition to the column type overrides supported by <a href="macro.query.html" title="macro sqlx::query"><code>query!</code></a>,
<a href="macro.query_as.html" title="macro sqlx::query_as"><code>query_as!()</code></a> supports an
additional override option:</p>
<p>If you select a column <code>foo as "foo: _"</code> (Postgres/SQLite) or <code>foo as `foo: _`</code> (MySQL)
it causes that column to be inferred based on the type of the corresponding field in the given
record struct. Runtime type-checking is still done so an error will be emitted if the types
are not compatible.</p>
<p>This allows you to override the inferred type of a column to instead use a custom-defined type:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(sqlx::Type)]
#[sqlx(transparent)]
</span><span class="kw">struct </span>MyInt4(i32);

<span class="kw">struct </span>Record {
    id: MyInt4,
}

<span class="kw">let </span>my_int = MyInt4(<span class="number">1</span>);

<span class="comment">// Postgres/SQLite
</span><span class="macro">sqlx::query_as!</span>(Record, <span class="string">r#"select 1 as "id: _""#</span>) <span class="comment">// MySQL: use "select 1 as `id: _`" instead
    </span>.fetch_one(<span class="kw-2">&amp;mut </span>conn)
    .<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(record.id, MyInt4(<span class="number">1</span>));</code></pre></div>
<h4 id="troubleshooting-error-mismatched-types"><a class="doc-anchor" href="#troubleshooting-error-mismatched-types">§</a>Troubleshooting: “error: mismatched types”</h4>
<p>If you get a “mismatched types” error from an invocation of this macro and the error
isn’t pointing specifically at a parameter.</p>
<p>For example, code like this (using a Postgres database):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Account {
    id: i32,
    name: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">let </span>account = <span class="macro">sqlx::query_as!</span>(
    Account,
    <span class="string">r#"SELECT id, name from (VALUES (1, 'Herp Derpinson')) accounts(id, name)"#</span>,
)
    .fetch_one(<span class="kw-2">&amp;mut </span>conn)
    .<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div>
<p>Might produce an error like this:</p>
<div class="example-wrap"><pre class="language-text"><code>error[E0308]: mismatched types
   --&gt; tests/postgres/macros.rs:126:19
    |
126 |       let account = sqlx::query_as!(
    |  ___________________^
127 | |         Account,
128 | |         r#&quot;SELECT id, name from (VALUES (1, &#39;Herp Derpinson&#39;)) accounts(id, name)&quot;#,
129 | |     )
    | |_____^ expected `i32`, found enum `std::option::Option`
    |
    = note: expected type `i32`
               found enum `std::option::Option&lt;i32&gt;`
</code></pre></div>
<p>This means that you need to check that any field of the “expected” type (here, <code>i32</code>) matches
the Rust type mapping for its corresponding SQL column (see the <code>types</code> module of your database,
listed above, for mappings). The “found” type is the SQL-&gt;Rust mapping that the macro chose.</p>
<p>In the above example, the returned column is inferred to be nullable because it’s being
returned from a <code>VALUES</code> statement in Postgres, so the macro inferred the field to be nullable
and so used <code>Option&lt;i32&gt;</code> instead of <code>i32</code>. <strong>In this specific case</strong> we could use
<code>select id as "id!"</code> to override the inferred nullability because we know in practice
that column will never be <code>NULL</code> and it will fix the error.</p>
<p>Nullability inference and type overrides are discussed in detail in the docs for
<a href="macro.query.html" title="macro sqlx::query"><code>query!</code></a>.</p>
<p>It unfortunately doesn’t appear to be possible right now to make the error specifically mention
the field; this probably requires the <code>const-panic</code> feature (still unstable as of Rust 1.45).</p>
</div></details></section></div></main></body></html>