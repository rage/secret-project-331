<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.19.5/src/order.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>order.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../bitvec/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">/*! Ordering of bits within register elements.

`bitvec` structures are parametric over any ordering of bits within a register.
The `BitOrder` trait maps a cursor position (indicated by the `BitIdx` type) to an
electrical position (indicated by the `BitPos` type) within that element, and
also defines the order of traversal over a register.

The only requirement on implementors of `BitOrder` is that the transform function
from cursor (`BitIdx`) to position (`BitPos`) is *total* (every integer in the
domain `0 .. T::BITS` is used) and *unique* (each cursor maps to one and only
one position, and each position is mapped by one and only one cursor).
Contiguity is not required.

`BitOrder` is a stateless trait, and implementors should be zero-sized types.
!*/</span>

<span class="kw">use</span> <span class="kw">crate</span><span class="ident">::index</span>::{
	<span class="ident">BitIdx</span>,
	<span class="ident">BitMask</span>,
	<span class="ident">BitPos</span>,
	<span class="ident">BitRegister</span>,
	<span class="ident">BitSel</span>,
	<span class="ident">BitTail</span>,
};

<span class="doccomment">/** An ordering over a register.

# Usage

`bitvec` structures store and operate on semantic counts, not bit positions. The
`BitOrder::at` function takes a semantic ordering, `BitIdx`, and produces an
electrical position, `BitPos`.

# Safety

If your implementation violates any of the requirements on these functions, then
the program will become incorrect and have unspecified behavior. The best-case
scenario is that operations relying on your implementation will crash the
program; the worst-case is that memory access will silently become corrupt.

You are responsible for adhering to the requirements of these functions. In the
future, a verification function may be provided for your test suite; however, it
is not yet possible to verify your implementation at compile-time.

This is an `unsafe trait` to implement, because you are responsible for
upholding the state requirements. The types you manipulate have `unsafe fn`
constructors, because they require you to maintain correct and consistent
processes in order for the rest of the library to use them.

The implementations of `BitOrder` are trusted to drive safe code, and once data
leaves a `BitOrder` implementation, it is considered safe to use as the basis
for interaction with memory.

# Verification

Rust currently lacks Zig’s compile-time computation capability. This means that
`bitvec` cannot fail a compile if it detects that a `BitOrder` implementation is
invalid and breaks the stated requirements. `bitvec` does offer a function,
[`verify`], which ensures the correctness of an implementation. When Rust gains
the capability to run this function in generic `const` contexts, `bitvec` will
use it to prevent at compile-time the construction of data structures that use
incorrect ordering implementations.

The verifier function panics when it detects invalid behavior, with an error
message intended to clearly indicate the broken requirement.

```rust
use bitvec::{
  index::{BitIdx, BitPos, BitRegister},
  order::{self, BitOrder},
};
# use bitvec::{index::*, order::Lsb0};

pub struct Custom;
unsafe impl BitOrder for Custom {
  fn at&lt;R: BitRegister&gt;(idx: BitIdx&lt;R&gt;) -&gt; BitPos&lt;R&gt; {
  // impl
  # return Lsb0::at::&lt;R&gt;(idx);
  }
}

#[test]
#[cfg(test)]
fn prove_custom() {
  order::verify::&lt;Custom&gt;();
}
```

[`verify`]: fn.verify.html
**/</span>
<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">trait</span> <span class="ident">BitOrder</span> {
	<span class="doccomment">/// Converts a semantic bit index into an electrical bit position.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function is the basis of the trait, and must adhere to a number of</span>
	<span class="doccomment">/// requirements in order for an implementation to be considered correct.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `index`: The semantic index of a bit within a register `R`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The electrical position of the indexed bit within a register `R`. See</span>
	<span class="doccomment">/// the `BitPos` documentation for what electrical positions are considered</span>
	<span class="doccomment">/// to mean.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `R`: The register type which the index and position describe.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Requirements</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function must satisfy the following requirements for all possible</span>
	<span class="doccomment">/// input and output values for all possible type parameters:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ## Totality</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function must be able to accept every input in the `BitIdx&lt;R&gt;`</span>
	<span class="doccomment">/// value range, and produce a corresponding `BitPos&lt;R&gt;`. It must not abort</span>
	<span class="doccomment">/// the program or return an invalid `BitPos&lt;R&gt;` for any input value in the</span>
	<span class="doccomment">/// `BitIdx&lt;R&gt;` range.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ## Bijection</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// There must be an exactly one-to-one correspondence between input value</span>
	<span class="doccomment">/// and output value. No input index may select from a set of more than one</span>
	<span class="doccomment">/// output position, and no output position may be produced by more than one</span>
	<span class="doccomment">/// input index.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ## Purity</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The translation from index to position must be consistent for the</span>
	<span class="doccomment">/// lifetime of the program. This function *may* refer to global state, but</span>
	<span class="doccomment">/// that state **must** be immutable for the program lifetime, and must not</span>
	<span class="doccomment">/// be used to violate the totality or bijection requirements.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ## Output Validity</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The produced `BitPos&lt;R&gt;` must be within the valid range of that type.</span>
	<span class="doccomment">/// Call sites of this function will not take any steps to constrain the</span>
	<span class="doccomment">/// output value. If you use `unsafe` code to produce an invalid</span>
	<span class="doccomment">/// `BitPos&lt;R&gt;`, the program is permanently incorrect, and will likely</span>
	<span class="doccomment">/// crash.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Usage</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function will only ever be called with input values in the valid</span>
	<span class="doccomment">/// `BitIdx&lt;R&gt;` range. Implementors are not required to consider any values</span>
	<span class="doccomment">/// outside this range in their function body.</span>
	<span class="kw">fn</span> <span class="ident">at</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitPos</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">R</span>: <span class="ident">BitRegister</span>;

	<span class="doccomment">/// Converts a semantic bit index into a one-hot selector mask.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is an optional function; a default implementation is provided for</span>
	<span class="doccomment">/// you.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The default implementation of this function calls `Self::at` to produce</span>
	<span class="doccomment">/// an electrical position, then turns that into a selector mask by setting</span>
	<span class="doccomment">/// the `n`th bit more significant than the least significant bit of the</span>
	<span class="doccomment">/// element. `BitOrder` implementations may choose to provide a faster mask</span>
	<span class="doccomment">/// production here, but they must satisfy the requirements listed below.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `index`: The semantic index of a bit within a register `R`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A one-hot selector mask for the bit indicated by the index value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `R`: The storage type for which the mask will be calculated. The mask</span>
	<span class="doccomment">///   must also be this type, as it will be applied to a register of `R` in</span>
	<span class="doccomment">///   order to set, clear, or test a single bit.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Requirements</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A one-hot encoding means that there is exactly one bit set in the</span>
	<span class="doccomment">/// produced value. It must be equivalent to `1 &lt;&lt; Self::at::&lt;R&gt;(place)`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// As with `at`, this function must produce a unique mapping from each</span>
	<span class="doccomment">/// legal index in the `R` domain to a one-hot value of `R`.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">select</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitSel</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">R</span>: <span class="ident">BitRegister</span> {
		<span class="self">Self</span><span class="ident">::at</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">index</span>).<span class="ident">select</span>()
	}

	<span class="doccomment">/// Constructs a multi-bit selector mask for batch operations on a single</span>
	<span class="doccomment">/// register `R`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The default implementation of this function traverses the index range,</span>
	<span class="doccomment">/// converting each index into a single-bit selector with `Self::select` and</span>
	<span class="doccomment">/// accumulating into a combined register value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `from`: The inclusive starting index for the mask.</span>
	<span class="doccomment">/// - `upto`: The exclusive ending index for the mask.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A bit-mask with all bits corresponding to the input index range set high</span>
	<span class="doccomment">/// and all others set low.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `R`: The storage type for which the mask will be calculated. The mask</span>
	<span class="doccomment">///   must also be this type, as it will be applied to a register of `R` in</span>
	<span class="doccomment">///   order to set, clear, or test all the selected bits.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Requirements</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function must always be equivalent to</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust,ignore</span>
	<span class="doccomment">/// (from .. upto)</span>
	<span class="doccomment">///   .map(1 &lt;&lt; Self::at::&lt;R&gt;)</span>
	<span class="doccomment">///   .fold(0, |mask, sel| mask | sel)</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">mask</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(
		<span class="ident">from</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>,
		<span class="ident">upto</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>,
	) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
	<span class="kw">where</span>
		<span class="ident">R</span>: <span class="ident">BitRegister</span>,
	{
		<span class="kw">let</span> (<span class="ident">from</span>, <span class="ident">upto</span>) <span class="op">=</span> <span class="kw">match</span> (<span class="ident">from</span>.<span class="ident">into</span>(), <span class="ident">upto</span>.<span class="ident">into</span>()) {
			(<span class="prelude-val">None</span>, <span class="prelude-val">None</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="kw">return</span> <span class="ident">BitMask::ALL</span>,
			(<span class="prelude-val">Some</span>(<span class="ident">from</span>), <span class="prelude-val">None</span>) <span class="op">=</span><span class="op">&gt;</span> (<span class="ident">from</span>, <span class="ident">BitTail</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="ident">::END</span>),
			(<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="ident">upto</span>)) <span class="op">=</span><span class="op">&gt;</span> (<span class="ident">BitIdx</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="ident">::ZERO</span>, <span class="ident">upto</span>),
			(<span class="prelude-val">Some</span>(<span class="ident">from</span>), <span class="prelude-val">Some</span>(<span class="ident">upto</span>)) <span class="op">=</span><span class="op">&gt;</span> (<span class="ident">from</span>, <span class="ident">upto</span>),
		};
		<span class="ident">BitIdx</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="ident">::range</span>(<span class="ident">from</span>, <span class="ident">upto</span>).<span class="ident">map</span>(<span class="self">Self</span><span class="ident">::select</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>).<span class="ident">sum</span>()
	}
}

<span class="doccomment">/// Traverses a register from `MSbit` to `LSbit`.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>, <span class="ident">Ord</span>, <span class="ident">PartialEq</span>, <span class="ident">PartialOrd</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Msb0</span>;

<span class="kw">unsafe</span> <span class="kw">impl</span> <span class="ident">BitOrder</span> <span class="kw">for</span> <span class="ident">Msb0</span> {
	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>), <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
	<span class="kw">fn</span> <span class="ident">at</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitPos</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">R</span>: <span class="ident">BitRegister</span> {
		<span class="kw">unsafe</span> { <span class="ident">BitPos::new_unchecked</span>(<span class="ident">R::MASK</span> <span class="op">-</span> <span class="ident">index</span>.<span class="ident">value</span>()) }
	}

	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>), <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
	<span class="kw">fn</span> <span class="ident">select</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitSel</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">R</span>: <span class="ident">BitRegister</span> {
		<span class="comment">/* Set the MSbit, then shift it down. The left expr is const-folded.
		Note: this is not equivalent to `1 &lt;&lt; (mask - index)`, because that
		requires a runtime subtraction, but the expression below is only a
		single right-shift.
		*/</span>
		<span class="kw">unsafe</span> { <span class="ident">BitSel::new_unchecked</span>((<span class="ident">R::ONE</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">R::MASK</span>) <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">index</span>.<span class="ident">value</span>()) }
	}

	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">mask</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(
		<span class="ident">from</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>,
		<span class="ident">upto</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>,
	) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
	<span class="kw">where</span>
		<span class="ident">R</span>: <span class="ident">BitRegister</span>,
	{
		<span class="kw">let</span> <span class="ident">from</span> <span class="op">=</span> <span class="ident">from</span>.<span class="ident">into</span>().<span class="ident">unwrap_or</span>(<span class="ident">BitIdx::ZERO</span>).<span class="ident">value</span>();
		<span class="kw">let</span> <span class="ident">upto</span> <span class="op">=</span> <span class="ident">upto</span>.<span class="ident">into</span>().<span class="ident">unwrap_or</span>(<span class="ident">BitTail::END</span>).<span class="ident">value</span>();
		<span class="macro">debug_assert!</span>(<span class="ident">upto</span> <span class="op">&gt;</span><span class="op">=</span> <span class="ident">from</span>, <span class="string">&quot;Ranges must run from low index to high&quot;</span>);
		<span class="kw">let</span> <span class="ident">ct</span> <span class="op">=</span> <span class="ident">upto</span> <span class="op">-</span> <span class="ident">from</span>;
		<span class="kw">if</span> <span class="ident">ct</span> <span class="op">=</span><span class="op">=</span> <span class="ident">R::BITS</span> {
			<span class="kw">return</span> <span class="ident">BitMask::ALL</span>;
		}
		<span class="comment">//  1. Set all bits high.</span>
		<span class="comment">//  2. Shift right by the number of bits in the mask. These are now low.</span>
		<span class="comment">//  3. Invert. The mask bits (at MSedge) are high; the rest are low.</span>
		<span class="comment">//  4. Shift right by the distance from MSedge.</span>
		<span class="kw">unsafe</span> { <span class="ident">BitMask::new</span>(<span class="op">!</span>(<span class="ident">R::ALL</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">ct</span>) <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">from</span>) }
	}
}

<span class="doccomment">/// Traverses a register from `LSbit` to `MSbit`.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>, <span class="ident">Ord</span>, <span class="ident">PartialEq</span>, <span class="ident">PartialOrd</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Lsb0</span>;

<span class="kw">unsafe</span> <span class="kw">impl</span> <span class="ident">BitOrder</span> <span class="kw">for</span> <span class="ident">Lsb0</span> {
	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">tarpaulin</span>), <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
	<span class="kw">fn</span> <span class="ident">at</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitPos</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">R</span>: <span class="ident">BitRegister</span> {
		<span class="kw">unsafe</span> { <span class="ident">BitPos::new_unchecked</span>(<span class="ident">index</span>.<span class="ident">value</span>()) }
	}

	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">tarpaulin</span>), <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
	<span class="kw">fn</span> <span class="ident">select</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitSel</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">R</span>: <span class="ident">BitRegister</span> {
		<span class="kw">unsafe</span> { <span class="ident">BitSel::new_unchecked</span>(<span class="ident">R::ONE</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">index</span>.<span class="ident">value</span>()) }
	}

	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">mask</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(
		<span class="ident">from</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>,
		<span class="ident">upto</span>: <span class="kw">impl</span> <span class="ident">Into</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>,
	) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
	<span class="kw">where</span>
		<span class="ident">R</span>: <span class="ident">BitRegister</span>,
	{
		<span class="kw">let</span> <span class="ident">from</span> <span class="op">=</span> <span class="ident">from</span>.<span class="ident">into</span>().<span class="ident">unwrap_or</span>(<span class="ident">BitIdx::ZERO</span>).<span class="ident">value</span>();
		<span class="kw">let</span> <span class="ident">upto</span> <span class="op">=</span> <span class="ident">upto</span>.<span class="ident">into</span>().<span class="ident">unwrap_or</span>(<span class="ident">BitTail::END</span>).<span class="ident">value</span>();
		<span class="macro">debug_assert!</span>(<span class="ident">upto</span> <span class="op">&gt;</span><span class="op">=</span> <span class="ident">from</span>, <span class="string">&quot;Ranges must run from low index to high&quot;</span>);
		<span class="kw">let</span> <span class="ident">ct</span> <span class="op">=</span> <span class="ident">upto</span> <span class="op">-</span> <span class="ident">from</span>;
		<span class="kw">if</span> <span class="ident">ct</span> <span class="op">=</span><span class="op">=</span> <span class="ident">R::BITS</span> {
			<span class="kw">return</span> <span class="ident">BitMask::ALL</span>;
		}
		<span class="comment">//  1. Set all bits high.</span>
		<span class="comment">//  2. Shift left by the number of bits in the mask. These are now low.</span>
		<span class="comment">//  3. Invert. The mask bits at LSedge are high; the rest are low.</span>
		<span class="comment">//  4. Shift left by the distance from LSedge.</span>
		<span class="kw">unsafe</span> { <span class="ident">BitMask::new</span>(<span class="op">!</span>(<span class="ident">R::ALL</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">ct</span>) <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">from</span>) }
	}
}

<span class="doccomment">/** A default bit ordering.

Typically, your platform’s C compiler uses most-significant-bit-first ordering
for bitfields. The Msb0 bit ordering and big-endian byte ordering are otherwise
completely unrelated.
**/</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_endian</span> <span class="op">=</span> <span class="string">&quot;big&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">LocalBits</span> <span class="op">=</span> <span class="ident">Msb0</span>;

<span class="doccomment">/** A default bit ordering.

Typically, your platform’s C compiler uses least-significant-bit-first ordering
for bitfields. The Lsb0 bit ordering and little-endian byte ordering are
otherwise completely unrelated.
**/</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_endian</span> <span class="op">=</span> <span class="string">&quot;little&quot;</span>)]</span>
<span class="kw">pub</span> <span class="kw">type</span> <span class="ident">LocalBits</span> <span class="op">=</span> <span class="ident">Lsb0</span>;

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">any</span>(<span class="ident">target_endian</span> <span class="op">=</span> <span class="string">&quot;big&quot;</span>, <span class="ident">target_endian</span> <span class="op">=</span> <span class="string">&quot;little&quot;</span>)))]</span>
<span class="macro">compile_fail!</span>(<span class="macro">concat!</span>(
	<span class="string">&quot;This architecture is currently not supported. File an issue at &quot;</span>,
	<span class="macro">env!</span>(<span class="ident">CARGO_PKG_REPOSITORY</span>)
));

<span class="doccomment">/** Verifies a `BitOrder` implementation’s adherence to the stated rules.

This function checks some `BitOrder` implementation’s behavior on each of the
`BitRegister` types it must handle, and reports any violation of the rules that
it detects.

# Type Parameters

- `O`: The `BitOrder` implementation to test.

# Parameters

- `verbose`: Sets whether the test should print diagnostic information to
  `stdout`.

# Panics

This panics if it detects any violation of the `BitOrder` implementation rules
for `O`.
**/</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">verify</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="ident">verbose</span>: <span class="ident">bool</span>)
<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
	<span class="ident">verify_for_type</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">u8</span><span class="op">&gt;</span>(<span class="ident">verbose</span>);
	<span class="ident">verify_for_type</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">u16</span><span class="op">&gt;</span>(<span class="ident">verbose</span>);
	<span class="ident">verify_for_type</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">u32</span><span class="op">&gt;</span>(<span class="ident">verbose</span>);
	<span class="ident">verify_for_type</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">usize</span><span class="op">&gt;</span>(<span class="ident">verbose</span>);

	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>)]</span>
	<span class="ident">verify_for_type</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">u64</span><span class="op">&gt;</span>(<span class="ident">verbose</span>);
}

<span class="doccomment">/** Verifies a `BitOrder` implementation’s adherence to the stated rules, for
one register type.

This function checks some `BitOrder` implementation against only one of the
`BitRegister` types that it will encounter. This is useful if you are
implementing an ordering that only needs to be concerned with a subset of the
types, and you know that you will never use it with the types it does not
support.

# Type Parameters

- `O`: The `BitOrder` implementation to test.
- `R`: The `BitRegister` type for which to test `O`.

# Parameters

- `verbose`: Sets whether the test should print diagnostic information to
  `stdout`.

# Panics

This panics if it detects any violation of the `BitOrder` implementation rules
for the combination of input types and index values.
**/</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">verify_for_type</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">verbose</span>: <span class="ident">bool</span>)
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">R</span>: <span class="ident">BitRegister</span>,
{
	<span class="kw">use</span> <span class="ident">core::any::type_name</span>;
	<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">accum</span> <span class="op">=</span> <span class="ident">BitMask</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="ident">::ZERO</span>;

	<span class="kw">let</span> <span class="ident">oname</span> <span class="op">=</span> <span class="ident">type_name</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>();
	<span class="kw">let</span> <span class="ident">mname</span> <span class="op">=</span> <span class="ident">type_name</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>();

	<span class="kw">for</span> <span class="ident">n</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">R::BITS</span> {
		<span class="comment">//  Wrap the counter as an index.</span>
		<span class="kw">let</span> <span class="ident">idx</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">BitIdx</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="ident">::new_unchecked</span>(<span class="ident">n</span>) };

		<span class="comment">//  Compute the bit position for the index.</span>
		<span class="kw">let</span> <span class="ident">pos</span> <span class="op">=</span> <span class="ident">O::at</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">idx</span>);
		<span class="kw">if</span> <span class="ident">verbose</span> {
			<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
			<span class="macro">println!</span>(
				<span class="string">&quot;`&lt;{} as BitOrder&gt;::at::&lt;{}&gt;({})` produces {}&quot;</span>,
				<span class="ident">oname</span>,
				<span class="ident">mname</span>,
				<span class="ident">n</span>,
				<span class="ident">pos</span>.<span class="ident">value</span>(),
			);
		}

		<span class="comment">//  If the computed position exceeds the valid range, fail.</span>
		<span class="macro">assert!</span>(
			<span class="ident">pos</span>.<span class="ident">value</span>() <span class="op">&lt;</span> <span class="ident">R::BITS</span>,
			<span class="string">&quot;Error when verifying the implementation of `BitOrder` for `{}`: \
			 Index {} produces a bit position ({}) that exceeds the type width \
			 {}&quot;</span>,
			<span class="ident">oname</span>,
			<span class="ident">n</span>,
			<span class="ident">pos</span>.<span class="ident">value</span>(),
			<span class="ident">R::BITS</span>,
		);

		<span class="comment">//  Check `O`’s implementation of `select`</span>
		<span class="kw">let</span> <span class="ident">sel</span> <span class="op">=</span> <span class="ident">O::select</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">idx</span>);
		<span class="kw">if</span> <span class="ident">verbose</span> {
			<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
			<span class="macro">println!</span>(
				<span class="string">&quot;`&lt;{} as BitOrder&gt;::select::&lt;{}&gt;({})` produces {:b}&quot;</span>,
				<span class="ident">oname</span>, <span class="ident">mname</span>, <span class="ident">n</span>, <span class="ident">sel</span>,
			);
		}

		<span class="comment">//  If the selector bit is not one-hot, fail.</span>
		<span class="macro">assert_eq!</span>(
			<span class="ident">sel</span>.<span class="ident">value</span>().<span class="ident">count_ones</span>(),
			<span class="number">1</span>,
			<span class="string">&quot;Error when verifying the implementation of `BitOrder` for `{}`: \
			 Index {} produces a bit selector ({:b}) that is not a one-hot mask&quot;</span>,
			<span class="ident">oname</span>,
			<span class="ident">n</span>,
			<span class="ident">sel</span>,
		);

		<span class="comment">//  Check that the selection computed from the index matches the</span>
		<span class="comment">//  selection computed from the position.</span>
		<span class="kw">let</span> <span class="ident">shl</span> <span class="op">=</span> <span class="ident">pos</span>.<span class="ident">select</span>();
		<span class="comment">//  If `O::select(idx)` does not produce `1 &lt;&lt; pos`, fail.</span>
		<span class="macro">assert_eq!</span>(
			<span class="ident">sel</span>,
			<span class="ident">shl</span>,
			<span class="string">&quot;Error when verifying the implementation of `BitOrder` for `{}`: \
			 Index {} produces a bit selector ({:b}) that is not equal to `1 \
			 &lt;&lt; {}` ({:b})&quot;</span>,
			<span class="ident">oname</span>,
			<span class="ident">n</span>,
			<span class="ident">sel</span>,
			<span class="ident">pos</span>.<span class="ident">value</span>(),
			<span class="ident">shl</span>,
		);

		<span class="comment">//  Check that the produced selector bit has not already been added to</span>
		<span class="comment">//  the accumulator.</span>
		<span class="macro">assert!</span>(
			<span class="op">!</span><span class="ident">accum</span>.<span class="ident">test</span>(<span class="ident">sel</span>),
			<span class="string">&quot;Error when verifying the implementation of `BitOrder` for `{}`: \
			 Index {} produces a bit position ({}) that has already been \
			 produced by a prior index&quot;</span>,
			<span class="ident">oname</span>,
			<span class="ident">n</span>,
			<span class="ident">pos</span>.<span class="ident">value</span>(),
		);
		<span class="ident">accum</span>.<span class="ident">insert</span>(<span class="ident">sel</span>);
		<span class="kw">if</span> <span class="ident">verbose</span> {
			<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;std&quot;</span>)]</span>
			<span class="macro">println!</span>(
				<span class="string">&quot;`&lt;{} as BitOrder&gt;::at::&lt;{}&gt;({})` accumulates  {:b}&quot;</span>,
				<span class="ident">oname</span>, <span class="ident">mname</span>, <span class="ident">n</span>, <span class="ident">accum</span>,
			);
		}
	}

	<span class="comment">//  Check that all indices produced all positions.</span>
	<span class="macro">assert_eq!</span>(
		<span class="ident">accum</span>,
		<span class="ident">BitMask::ALL</span>,
		<span class="string">&quot;Error when verifying the implementation of `BitOrder` for `{}`: The \
		 bit positions marked with a `0` here were never produced from an \
		 index, despite all possible indices being passed in for translation: \
		 {:b}&quot;</span>,
		<span class="ident">oname</span>,
		<span class="ident">accum</span>,
	);

	<span class="comment">//  Check that `O::mask` is correct for all range combinations.</span>
	<span class="kw">for</span> <span class="ident">from</span> <span class="kw">in</span> <span class="ident">BitIdx</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="ident">::range_all</span>() {
		<span class="kw">for</span> <span class="ident">upto</span> <span class="kw">in</span> <span class="ident">BitTail</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="ident">::range_from</span>(<span class="ident">from</span>) {
			<span class="kw">let</span> <span class="ident">mask</span> <span class="op">=</span> <span class="ident">O::mask</span>(<span class="ident">from</span>, <span class="ident">upto</span>);
			<span class="kw">let</span> <span class="ident">check</span> <span class="op">=</span> <span class="ident">BitIdx</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="ident">::range</span>(<span class="ident">from</span>, <span class="ident">upto</span>)
				.<span class="ident">map</span>(<span class="ident">O::at</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>)
				.<span class="ident">map</span>(<span class="ident">BitPos</span>::<span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="ident">::select</span>)
				.<span class="ident">sum</span>::<span class="op">&lt;</span><span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span><span class="op">&gt;</span>();
			<span class="macro">assert_eq!</span>(
				<span class="ident">mask</span>,
				<span class="ident">check</span>,
				<span class="string">&quot;Error when verifying the implementation of `BitOrder` for \
				 `{o}`: `{o}::mask::&lt;{m}&gt;({f}, {u})` produced {bad:b}, but \
				 expected {good:b}&quot;</span>,
				<span class="ident">o</span> <span class="op">=</span> <span class="ident">oname</span>,
				<span class="ident">m</span> <span class="op">=</span> <span class="ident">mname</span>,
				<span class="ident">f</span> <span class="op">=</span> <span class="ident">from</span>,
				<span class="ident">u</span> <span class="op">=</span> <span class="ident">upto</span>,
				<span class="ident">bad</span> <span class="op">=</span> <span class="ident">mask</span>,
				<span class="ident">good</span> <span class="op">=</span> <span class="ident">check</span>,
			);
		}
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">all</span>(<span class="ident">test</span>, <span class="ident">not</span>(<span class="ident">miri</span>)))]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
	<span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">verify_impls</span>() {
		<span class="ident">verify</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>(<span class="macro">cfg!</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;testing&quot;</span>));
		<span class="ident">verify</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>(<span class="macro">cfg!</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;testing&quot;</span>));

		<span class="kw">struct</span> <span class="ident">DefaultImpl</span>;
		<span class="kw">unsafe</span> <span class="kw">impl</span> <span class="ident">BitOrder</span> <span class="kw">for</span> <span class="ident">DefaultImpl</span> {
			<span class="kw">fn</span> <span class="ident">at</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitPos</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>
			<span class="kw">where</span> <span class="ident">R</span>: <span class="ident">BitRegister</span> {
				<span class="kw">unsafe</span> { <span class="ident">BitPos::new_unchecked</span>(<span class="ident">index</span>.<span class="ident">value</span>()) }
			}
		}

		<span class="ident">verify</span>::<span class="op">&lt;</span><span class="ident">DefaultImpl</span><span class="op">&gt;</span>(<span class="macro">cfg!</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;testing&quot;</span>));
	}
}
</pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script></body></html>