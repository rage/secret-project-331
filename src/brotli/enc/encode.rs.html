<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/brotli-3.3.4/src/enc/encode.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>encode.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../brotli/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../brotli/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../brotli/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
<span id="797">797</span>
<span id="798">798</span>
<span id="799">799</span>
<span id="800">800</span>
<span id="801">801</span>
<span id="802">802</span>
<span id="803">803</span>
<span id="804">804</span>
<span id="805">805</span>
<span id="806">806</span>
<span id="807">807</span>
<span id="808">808</span>
<span id="809">809</span>
<span id="810">810</span>
<span id="811">811</span>
<span id="812">812</span>
<span id="813">813</span>
<span id="814">814</span>
<span id="815">815</span>
<span id="816">816</span>
<span id="817">817</span>
<span id="818">818</span>
<span id="819">819</span>
<span id="820">820</span>
<span id="821">821</span>
<span id="822">822</span>
<span id="823">823</span>
<span id="824">824</span>
<span id="825">825</span>
<span id="826">826</span>
<span id="827">827</span>
<span id="828">828</span>
<span id="829">829</span>
<span id="830">830</span>
<span id="831">831</span>
<span id="832">832</span>
<span id="833">833</span>
<span id="834">834</span>
<span id="835">835</span>
<span id="836">836</span>
<span id="837">837</span>
<span id="838">838</span>
<span id="839">839</span>
<span id="840">840</span>
<span id="841">841</span>
<span id="842">842</span>
<span id="843">843</span>
<span id="844">844</span>
<span id="845">845</span>
<span id="846">846</span>
<span id="847">847</span>
<span id="848">848</span>
<span id="849">849</span>
<span id="850">850</span>
<span id="851">851</span>
<span id="852">852</span>
<span id="853">853</span>
<span id="854">854</span>
<span id="855">855</span>
<span id="856">856</span>
<span id="857">857</span>
<span id="858">858</span>
<span id="859">859</span>
<span id="860">860</span>
<span id="861">861</span>
<span id="862">862</span>
<span id="863">863</span>
<span id="864">864</span>
<span id="865">865</span>
<span id="866">866</span>
<span id="867">867</span>
<span id="868">868</span>
<span id="869">869</span>
<span id="870">870</span>
<span id="871">871</span>
<span id="872">872</span>
<span id="873">873</span>
<span id="874">874</span>
<span id="875">875</span>
<span id="876">876</span>
<span id="877">877</span>
<span id="878">878</span>
<span id="879">879</span>
<span id="880">880</span>
<span id="881">881</span>
<span id="882">882</span>
<span id="883">883</span>
<span id="884">884</span>
<span id="885">885</span>
<span id="886">886</span>
<span id="887">887</span>
<span id="888">888</span>
<span id="889">889</span>
<span id="890">890</span>
<span id="891">891</span>
<span id="892">892</span>
<span id="893">893</span>
<span id="894">894</span>
<span id="895">895</span>
<span id="896">896</span>
<span id="897">897</span>
<span id="898">898</span>
<span id="899">899</span>
<span id="900">900</span>
<span id="901">901</span>
<span id="902">902</span>
<span id="903">903</span>
<span id="904">904</span>
<span id="905">905</span>
<span id="906">906</span>
<span id="907">907</span>
<span id="908">908</span>
<span id="909">909</span>
<span id="910">910</span>
<span id="911">911</span>
<span id="912">912</span>
<span id="913">913</span>
<span id="914">914</span>
<span id="915">915</span>
<span id="916">916</span>
<span id="917">917</span>
<span id="918">918</span>
<span id="919">919</span>
<span id="920">920</span>
<span id="921">921</span>
<span id="922">922</span>
<span id="923">923</span>
<span id="924">924</span>
<span id="925">925</span>
<span id="926">926</span>
<span id="927">927</span>
<span id="928">928</span>
<span id="929">929</span>
<span id="930">930</span>
<span id="931">931</span>
<span id="932">932</span>
<span id="933">933</span>
<span id="934">934</span>
<span id="935">935</span>
<span id="936">936</span>
<span id="937">937</span>
<span id="938">938</span>
<span id="939">939</span>
<span id="940">940</span>
<span id="941">941</span>
<span id="942">942</span>
<span id="943">943</span>
<span id="944">944</span>
<span id="945">945</span>
<span id="946">946</span>
<span id="947">947</span>
<span id="948">948</span>
<span id="949">949</span>
<span id="950">950</span>
<span id="951">951</span>
<span id="952">952</span>
<span id="953">953</span>
<span id="954">954</span>
<span id="955">955</span>
<span id="956">956</span>
<span id="957">957</span>
<span id="958">958</span>
<span id="959">959</span>
<span id="960">960</span>
<span id="961">961</span>
<span id="962">962</span>
<span id="963">963</span>
<span id="964">964</span>
<span id="965">965</span>
<span id="966">966</span>
<span id="967">967</span>
<span id="968">968</span>
<span id="969">969</span>
<span id="970">970</span>
<span id="971">971</span>
<span id="972">972</span>
<span id="973">973</span>
<span id="974">974</span>
<span id="975">975</span>
<span id="976">976</span>
<span id="977">977</span>
<span id="978">978</span>
<span id="979">979</span>
<span id="980">980</span>
<span id="981">981</span>
<span id="982">982</span>
<span id="983">983</span>
<span id="984">984</span>
<span id="985">985</span>
<span id="986">986</span>
<span id="987">987</span>
<span id="988">988</span>
<span id="989">989</span>
<span id="990">990</span>
<span id="991">991</span>
<span id="992">992</span>
<span id="993">993</span>
<span id="994">994</span>
<span id="995">995</span>
<span id="996">996</span>
<span id="997">997</span>
<span id="998">998</span>
<span id="999">999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
<span id="1158">1158</span>
<span id="1159">1159</span>
<span id="1160">1160</span>
<span id="1161">1161</span>
<span id="1162">1162</span>
<span id="1163">1163</span>
<span id="1164">1164</span>
<span id="1165">1165</span>
<span id="1166">1166</span>
<span id="1167">1167</span>
<span id="1168">1168</span>
<span id="1169">1169</span>
<span id="1170">1170</span>
<span id="1171">1171</span>
<span id="1172">1172</span>
<span id="1173">1173</span>
<span id="1174">1174</span>
<span id="1175">1175</span>
<span id="1176">1176</span>
<span id="1177">1177</span>
<span id="1178">1178</span>
<span id="1179">1179</span>
<span id="1180">1180</span>
<span id="1181">1181</span>
<span id="1182">1182</span>
<span id="1183">1183</span>
<span id="1184">1184</span>
<span id="1185">1185</span>
<span id="1186">1186</span>
<span id="1187">1187</span>
<span id="1188">1188</span>
<span id="1189">1189</span>
<span id="1190">1190</span>
<span id="1191">1191</span>
<span id="1192">1192</span>
<span id="1193">1193</span>
<span id="1194">1194</span>
<span id="1195">1195</span>
<span id="1196">1196</span>
<span id="1197">1197</span>
<span id="1198">1198</span>
<span id="1199">1199</span>
<span id="1200">1200</span>
<span id="1201">1201</span>
<span id="1202">1202</span>
<span id="1203">1203</span>
<span id="1204">1204</span>
<span id="1205">1205</span>
<span id="1206">1206</span>
<span id="1207">1207</span>
<span id="1208">1208</span>
<span id="1209">1209</span>
<span id="1210">1210</span>
<span id="1211">1211</span>
<span id="1212">1212</span>
<span id="1213">1213</span>
<span id="1214">1214</span>
<span id="1215">1215</span>
<span id="1216">1216</span>
<span id="1217">1217</span>
<span id="1218">1218</span>
<span id="1219">1219</span>
<span id="1220">1220</span>
<span id="1221">1221</span>
<span id="1222">1222</span>
<span id="1223">1223</span>
<span id="1224">1224</span>
<span id="1225">1225</span>
<span id="1226">1226</span>
<span id="1227">1227</span>
<span id="1228">1228</span>
<span id="1229">1229</span>
<span id="1230">1230</span>
<span id="1231">1231</span>
<span id="1232">1232</span>
<span id="1233">1233</span>
<span id="1234">1234</span>
<span id="1235">1235</span>
<span id="1236">1236</span>
<span id="1237">1237</span>
<span id="1238">1238</span>
<span id="1239">1239</span>
<span id="1240">1240</span>
<span id="1241">1241</span>
<span id="1242">1242</span>
<span id="1243">1243</span>
<span id="1244">1244</span>
<span id="1245">1245</span>
<span id="1246">1246</span>
<span id="1247">1247</span>
<span id="1248">1248</span>
<span id="1249">1249</span>
<span id="1250">1250</span>
<span id="1251">1251</span>
<span id="1252">1252</span>
<span id="1253">1253</span>
<span id="1254">1254</span>
<span id="1255">1255</span>
<span id="1256">1256</span>
<span id="1257">1257</span>
<span id="1258">1258</span>
<span id="1259">1259</span>
<span id="1260">1260</span>
<span id="1261">1261</span>
<span id="1262">1262</span>
<span id="1263">1263</span>
<span id="1264">1264</span>
<span id="1265">1265</span>
<span id="1266">1266</span>
<span id="1267">1267</span>
<span id="1268">1268</span>
<span id="1269">1269</span>
<span id="1270">1270</span>
<span id="1271">1271</span>
<span id="1272">1272</span>
<span id="1273">1273</span>
<span id="1274">1274</span>
<span id="1275">1275</span>
<span id="1276">1276</span>
<span id="1277">1277</span>
<span id="1278">1278</span>
<span id="1279">1279</span>
<span id="1280">1280</span>
<span id="1281">1281</span>
<span id="1282">1282</span>
<span id="1283">1283</span>
<span id="1284">1284</span>
<span id="1285">1285</span>
<span id="1286">1286</span>
<span id="1287">1287</span>
<span id="1288">1288</span>
<span id="1289">1289</span>
<span id="1290">1290</span>
<span id="1291">1291</span>
<span id="1292">1292</span>
<span id="1293">1293</span>
<span id="1294">1294</span>
<span id="1295">1295</span>
<span id="1296">1296</span>
<span id="1297">1297</span>
<span id="1298">1298</span>
<span id="1299">1299</span>
<span id="1300">1300</span>
<span id="1301">1301</span>
<span id="1302">1302</span>
<span id="1303">1303</span>
<span id="1304">1304</span>
<span id="1305">1305</span>
<span id="1306">1306</span>
<span id="1307">1307</span>
<span id="1308">1308</span>
<span id="1309">1309</span>
<span id="1310">1310</span>
<span id="1311">1311</span>
<span id="1312">1312</span>
<span id="1313">1313</span>
<span id="1314">1314</span>
<span id="1315">1315</span>
<span id="1316">1316</span>
<span id="1317">1317</span>
<span id="1318">1318</span>
<span id="1319">1319</span>
<span id="1320">1320</span>
<span id="1321">1321</span>
<span id="1322">1322</span>
<span id="1323">1323</span>
<span id="1324">1324</span>
<span id="1325">1325</span>
<span id="1326">1326</span>
<span id="1327">1327</span>
<span id="1328">1328</span>
<span id="1329">1329</span>
<span id="1330">1330</span>
<span id="1331">1331</span>
<span id="1332">1332</span>
<span id="1333">1333</span>
<span id="1334">1334</span>
<span id="1335">1335</span>
<span id="1336">1336</span>
<span id="1337">1337</span>
<span id="1338">1338</span>
<span id="1339">1339</span>
<span id="1340">1340</span>
<span id="1341">1341</span>
<span id="1342">1342</span>
<span id="1343">1343</span>
<span id="1344">1344</span>
<span id="1345">1345</span>
<span id="1346">1346</span>
<span id="1347">1347</span>
<span id="1348">1348</span>
<span id="1349">1349</span>
<span id="1350">1350</span>
<span id="1351">1351</span>
<span id="1352">1352</span>
<span id="1353">1353</span>
<span id="1354">1354</span>
<span id="1355">1355</span>
<span id="1356">1356</span>
<span id="1357">1357</span>
<span id="1358">1358</span>
<span id="1359">1359</span>
<span id="1360">1360</span>
<span id="1361">1361</span>
<span id="1362">1362</span>
<span id="1363">1363</span>
<span id="1364">1364</span>
<span id="1365">1365</span>
<span id="1366">1366</span>
<span id="1367">1367</span>
<span id="1368">1368</span>
<span id="1369">1369</span>
<span id="1370">1370</span>
<span id="1371">1371</span>
<span id="1372">1372</span>
<span id="1373">1373</span>
<span id="1374">1374</span>
<span id="1375">1375</span>
<span id="1376">1376</span>
<span id="1377">1377</span>
<span id="1378">1378</span>
<span id="1379">1379</span>
<span id="1380">1380</span>
<span id="1381">1381</span>
<span id="1382">1382</span>
<span id="1383">1383</span>
<span id="1384">1384</span>
<span id="1385">1385</span>
<span id="1386">1386</span>
<span id="1387">1387</span>
<span id="1388">1388</span>
<span id="1389">1389</span>
<span id="1390">1390</span>
<span id="1391">1391</span>
<span id="1392">1392</span>
<span id="1393">1393</span>
<span id="1394">1394</span>
<span id="1395">1395</span>
<span id="1396">1396</span>
<span id="1397">1397</span>
<span id="1398">1398</span>
<span id="1399">1399</span>
<span id="1400">1400</span>
<span id="1401">1401</span>
<span id="1402">1402</span>
<span id="1403">1403</span>
<span id="1404">1404</span>
<span id="1405">1405</span>
<span id="1406">1406</span>
<span id="1407">1407</span>
<span id="1408">1408</span>
<span id="1409">1409</span>
<span id="1410">1410</span>
<span id="1411">1411</span>
<span id="1412">1412</span>
<span id="1413">1413</span>
<span id="1414">1414</span>
<span id="1415">1415</span>
<span id="1416">1416</span>
<span id="1417">1417</span>
<span id="1418">1418</span>
<span id="1419">1419</span>
<span id="1420">1420</span>
<span id="1421">1421</span>
<span id="1422">1422</span>
<span id="1423">1423</span>
<span id="1424">1424</span>
<span id="1425">1425</span>
<span id="1426">1426</span>
<span id="1427">1427</span>
<span id="1428">1428</span>
<span id="1429">1429</span>
<span id="1430">1430</span>
<span id="1431">1431</span>
<span id="1432">1432</span>
<span id="1433">1433</span>
<span id="1434">1434</span>
<span id="1435">1435</span>
<span id="1436">1436</span>
<span id="1437">1437</span>
<span id="1438">1438</span>
<span id="1439">1439</span>
<span id="1440">1440</span>
<span id="1441">1441</span>
<span id="1442">1442</span>
<span id="1443">1443</span>
<span id="1444">1444</span>
<span id="1445">1445</span>
<span id="1446">1446</span>
<span id="1447">1447</span>
<span id="1448">1448</span>
<span id="1449">1449</span>
<span id="1450">1450</span>
<span id="1451">1451</span>
<span id="1452">1452</span>
<span id="1453">1453</span>
<span id="1454">1454</span>
<span id="1455">1455</span>
<span id="1456">1456</span>
<span id="1457">1457</span>
<span id="1458">1458</span>
<span id="1459">1459</span>
<span id="1460">1460</span>
<span id="1461">1461</span>
<span id="1462">1462</span>
<span id="1463">1463</span>
<span id="1464">1464</span>
<span id="1465">1465</span>
<span id="1466">1466</span>
<span id="1467">1467</span>
<span id="1468">1468</span>
<span id="1469">1469</span>
<span id="1470">1470</span>
<span id="1471">1471</span>
<span id="1472">1472</span>
<span id="1473">1473</span>
<span id="1474">1474</span>
<span id="1475">1475</span>
<span id="1476">1476</span>
<span id="1477">1477</span>
<span id="1478">1478</span>
<span id="1479">1479</span>
<span id="1480">1480</span>
<span id="1481">1481</span>
<span id="1482">1482</span>
<span id="1483">1483</span>
<span id="1484">1484</span>
<span id="1485">1485</span>
<span id="1486">1486</span>
<span id="1487">1487</span>
<span id="1488">1488</span>
<span id="1489">1489</span>
<span id="1490">1490</span>
<span id="1491">1491</span>
<span id="1492">1492</span>
<span id="1493">1493</span>
<span id="1494">1494</span>
<span id="1495">1495</span>
<span id="1496">1496</span>
<span id="1497">1497</span>
<span id="1498">1498</span>
<span id="1499">1499</span>
<span id="1500">1500</span>
<span id="1501">1501</span>
<span id="1502">1502</span>
<span id="1503">1503</span>
<span id="1504">1504</span>
<span id="1505">1505</span>
<span id="1506">1506</span>
<span id="1507">1507</span>
<span id="1508">1508</span>
<span id="1509">1509</span>
<span id="1510">1510</span>
<span id="1511">1511</span>
<span id="1512">1512</span>
<span id="1513">1513</span>
<span id="1514">1514</span>
<span id="1515">1515</span>
<span id="1516">1516</span>
<span id="1517">1517</span>
<span id="1518">1518</span>
<span id="1519">1519</span>
<span id="1520">1520</span>
<span id="1521">1521</span>
<span id="1522">1522</span>
<span id="1523">1523</span>
<span id="1524">1524</span>
<span id="1525">1525</span>
<span id="1526">1526</span>
<span id="1527">1527</span>
<span id="1528">1528</span>
<span id="1529">1529</span>
<span id="1530">1530</span>
<span id="1531">1531</span>
<span id="1532">1532</span>
<span id="1533">1533</span>
<span id="1534">1534</span>
<span id="1535">1535</span>
<span id="1536">1536</span>
<span id="1537">1537</span>
<span id="1538">1538</span>
<span id="1539">1539</span>
<span id="1540">1540</span>
<span id="1541">1541</span>
<span id="1542">1542</span>
<span id="1543">1543</span>
<span id="1544">1544</span>
<span id="1545">1545</span>
<span id="1546">1546</span>
<span id="1547">1547</span>
<span id="1548">1548</span>
<span id="1549">1549</span>
<span id="1550">1550</span>
<span id="1551">1551</span>
<span id="1552">1552</span>
<span id="1553">1553</span>
<span id="1554">1554</span>
<span id="1555">1555</span>
<span id="1556">1556</span>
<span id="1557">1557</span>
<span id="1558">1558</span>
<span id="1559">1559</span>
<span id="1560">1560</span>
<span id="1561">1561</span>
<span id="1562">1562</span>
<span id="1563">1563</span>
<span id="1564">1564</span>
<span id="1565">1565</span>
<span id="1566">1566</span>
<span id="1567">1567</span>
<span id="1568">1568</span>
<span id="1569">1569</span>
<span id="1570">1570</span>
<span id="1571">1571</span>
<span id="1572">1572</span>
<span id="1573">1573</span>
<span id="1574">1574</span>
<span id="1575">1575</span>
<span id="1576">1576</span>
<span id="1577">1577</span>
<span id="1578">1578</span>
<span id="1579">1579</span>
<span id="1580">1580</span>
<span id="1581">1581</span>
<span id="1582">1582</span>
<span id="1583">1583</span>
<span id="1584">1584</span>
<span id="1585">1585</span>
<span id="1586">1586</span>
<span id="1587">1587</span>
<span id="1588">1588</span>
<span id="1589">1589</span>
<span id="1590">1590</span>
<span id="1591">1591</span>
<span id="1592">1592</span>
<span id="1593">1593</span>
<span id="1594">1594</span>
<span id="1595">1595</span>
<span id="1596">1596</span>
<span id="1597">1597</span>
<span id="1598">1598</span>
<span id="1599">1599</span>
<span id="1600">1600</span>
<span id="1601">1601</span>
<span id="1602">1602</span>
<span id="1603">1603</span>
<span id="1604">1604</span>
<span id="1605">1605</span>
<span id="1606">1606</span>
<span id="1607">1607</span>
<span id="1608">1608</span>
<span id="1609">1609</span>
<span id="1610">1610</span>
<span id="1611">1611</span>
<span id="1612">1612</span>
<span id="1613">1613</span>
<span id="1614">1614</span>
<span id="1615">1615</span>
<span id="1616">1616</span>
<span id="1617">1617</span>
<span id="1618">1618</span>
<span id="1619">1619</span>
<span id="1620">1620</span>
<span id="1621">1621</span>
<span id="1622">1622</span>
<span id="1623">1623</span>
<span id="1624">1624</span>
<span id="1625">1625</span>
<span id="1626">1626</span>
<span id="1627">1627</span>
<span id="1628">1628</span>
<span id="1629">1629</span>
<span id="1630">1630</span>
<span id="1631">1631</span>
<span id="1632">1632</span>
<span id="1633">1633</span>
<span id="1634">1634</span>
<span id="1635">1635</span>
<span id="1636">1636</span>
<span id="1637">1637</span>
<span id="1638">1638</span>
<span id="1639">1639</span>
<span id="1640">1640</span>
<span id="1641">1641</span>
<span id="1642">1642</span>
<span id="1643">1643</span>
<span id="1644">1644</span>
<span id="1645">1645</span>
<span id="1646">1646</span>
<span id="1647">1647</span>
<span id="1648">1648</span>
<span id="1649">1649</span>
<span id="1650">1650</span>
<span id="1651">1651</span>
<span id="1652">1652</span>
<span id="1653">1653</span>
<span id="1654">1654</span>
<span id="1655">1655</span>
<span id="1656">1656</span>
<span id="1657">1657</span>
<span id="1658">1658</span>
<span id="1659">1659</span>
<span id="1660">1660</span>
<span id="1661">1661</span>
<span id="1662">1662</span>
<span id="1663">1663</span>
<span id="1664">1664</span>
<span id="1665">1665</span>
<span id="1666">1666</span>
<span id="1667">1667</span>
<span id="1668">1668</span>
<span id="1669">1669</span>
<span id="1670">1670</span>
<span id="1671">1671</span>
<span id="1672">1672</span>
<span id="1673">1673</span>
<span id="1674">1674</span>
<span id="1675">1675</span>
<span id="1676">1676</span>
<span id="1677">1677</span>
<span id="1678">1678</span>
<span id="1679">1679</span>
<span id="1680">1680</span>
<span id="1681">1681</span>
<span id="1682">1682</span>
<span id="1683">1683</span>
<span id="1684">1684</span>
<span id="1685">1685</span>
<span id="1686">1686</span>
<span id="1687">1687</span>
<span id="1688">1688</span>
<span id="1689">1689</span>
<span id="1690">1690</span>
<span id="1691">1691</span>
<span id="1692">1692</span>
<span id="1693">1693</span>
<span id="1694">1694</span>
<span id="1695">1695</span>
<span id="1696">1696</span>
<span id="1697">1697</span>
<span id="1698">1698</span>
<span id="1699">1699</span>
<span id="1700">1700</span>
<span id="1701">1701</span>
<span id="1702">1702</span>
<span id="1703">1703</span>
<span id="1704">1704</span>
<span id="1705">1705</span>
<span id="1706">1706</span>
<span id="1707">1707</span>
<span id="1708">1708</span>
<span id="1709">1709</span>
<span id="1710">1710</span>
<span id="1711">1711</span>
<span id="1712">1712</span>
<span id="1713">1713</span>
<span id="1714">1714</span>
<span id="1715">1715</span>
<span id="1716">1716</span>
<span id="1717">1717</span>
<span id="1718">1718</span>
<span id="1719">1719</span>
<span id="1720">1720</span>
<span id="1721">1721</span>
<span id="1722">1722</span>
<span id="1723">1723</span>
<span id="1724">1724</span>
<span id="1725">1725</span>
<span id="1726">1726</span>
<span id="1727">1727</span>
<span id="1728">1728</span>
<span id="1729">1729</span>
<span id="1730">1730</span>
<span id="1731">1731</span>
<span id="1732">1732</span>
<span id="1733">1733</span>
<span id="1734">1734</span>
<span id="1735">1735</span>
<span id="1736">1736</span>
<span id="1737">1737</span>
<span id="1738">1738</span>
<span id="1739">1739</span>
<span id="1740">1740</span>
<span id="1741">1741</span>
<span id="1742">1742</span>
<span id="1743">1743</span>
<span id="1744">1744</span>
<span id="1745">1745</span>
<span id="1746">1746</span>
<span id="1747">1747</span>
<span id="1748">1748</span>
<span id="1749">1749</span>
<span id="1750">1750</span>
<span id="1751">1751</span>
<span id="1752">1752</span>
<span id="1753">1753</span>
<span id="1754">1754</span>
<span id="1755">1755</span>
<span id="1756">1756</span>
<span id="1757">1757</span>
<span id="1758">1758</span>
<span id="1759">1759</span>
<span id="1760">1760</span>
<span id="1761">1761</span>
<span id="1762">1762</span>
<span id="1763">1763</span>
<span id="1764">1764</span>
<span id="1765">1765</span>
<span id="1766">1766</span>
<span id="1767">1767</span>
<span id="1768">1768</span>
<span id="1769">1769</span>
<span id="1770">1770</span>
<span id="1771">1771</span>
<span id="1772">1772</span>
<span id="1773">1773</span>
<span id="1774">1774</span>
<span id="1775">1775</span>
<span id="1776">1776</span>
<span id="1777">1777</span>
<span id="1778">1778</span>
<span id="1779">1779</span>
<span id="1780">1780</span>
<span id="1781">1781</span>
<span id="1782">1782</span>
<span id="1783">1783</span>
<span id="1784">1784</span>
<span id="1785">1785</span>
<span id="1786">1786</span>
<span id="1787">1787</span>
<span id="1788">1788</span>
<span id="1789">1789</span>
<span id="1790">1790</span>
<span id="1791">1791</span>
<span id="1792">1792</span>
<span id="1793">1793</span>
<span id="1794">1794</span>
<span id="1795">1795</span>
<span id="1796">1796</span>
<span id="1797">1797</span>
<span id="1798">1798</span>
<span id="1799">1799</span>
<span id="1800">1800</span>
<span id="1801">1801</span>
<span id="1802">1802</span>
<span id="1803">1803</span>
<span id="1804">1804</span>
<span id="1805">1805</span>
<span id="1806">1806</span>
<span id="1807">1807</span>
<span id="1808">1808</span>
<span id="1809">1809</span>
<span id="1810">1810</span>
<span id="1811">1811</span>
<span id="1812">1812</span>
<span id="1813">1813</span>
<span id="1814">1814</span>
<span id="1815">1815</span>
<span id="1816">1816</span>
<span id="1817">1817</span>
<span id="1818">1818</span>
<span id="1819">1819</span>
<span id="1820">1820</span>
<span id="1821">1821</span>
<span id="1822">1822</span>
<span id="1823">1823</span>
<span id="1824">1824</span>
<span id="1825">1825</span>
<span id="1826">1826</span>
<span id="1827">1827</span>
<span id="1828">1828</span>
<span id="1829">1829</span>
<span id="1830">1830</span>
<span id="1831">1831</span>
<span id="1832">1832</span>
<span id="1833">1833</span>
<span id="1834">1834</span>
<span id="1835">1835</span>
<span id="1836">1836</span>
<span id="1837">1837</span>
<span id="1838">1838</span>
<span id="1839">1839</span>
<span id="1840">1840</span>
<span id="1841">1841</span>
<span id="1842">1842</span>
<span id="1843">1843</span>
<span id="1844">1844</span>
<span id="1845">1845</span>
<span id="1846">1846</span>
<span id="1847">1847</span>
<span id="1848">1848</span>
<span id="1849">1849</span>
<span id="1850">1850</span>
<span id="1851">1851</span>
<span id="1852">1852</span>
<span id="1853">1853</span>
<span id="1854">1854</span>
<span id="1855">1855</span>
<span id="1856">1856</span>
<span id="1857">1857</span>
<span id="1858">1858</span>
<span id="1859">1859</span>
<span id="1860">1860</span>
<span id="1861">1861</span>
<span id="1862">1862</span>
<span id="1863">1863</span>
<span id="1864">1864</span>
<span id="1865">1865</span>
<span id="1866">1866</span>
<span id="1867">1867</span>
<span id="1868">1868</span>
<span id="1869">1869</span>
<span id="1870">1870</span>
<span id="1871">1871</span>
<span id="1872">1872</span>
<span id="1873">1873</span>
<span id="1874">1874</span>
<span id="1875">1875</span>
<span id="1876">1876</span>
<span id="1877">1877</span>
<span id="1878">1878</span>
<span id="1879">1879</span>
<span id="1880">1880</span>
<span id="1881">1881</span>
<span id="1882">1882</span>
<span id="1883">1883</span>
<span id="1884">1884</span>
<span id="1885">1885</span>
<span id="1886">1886</span>
<span id="1887">1887</span>
<span id="1888">1888</span>
<span id="1889">1889</span>
<span id="1890">1890</span>
<span id="1891">1891</span>
<span id="1892">1892</span>
<span id="1893">1893</span>
<span id="1894">1894</span>
<span id="1895">1895</span>
<span id="1896">1896</span>
<span id="1897">1897</span>
<span id="1898">1898</span>
<span id="1899">1899</span>
<span id="1900">1900</span>
<span id="1901">1901</span>
<span id="1902">1902</span>
<span id="1903">1903</span>
<span id="1904">1904</span>
<span id="1905">1905</span>
<span id="1906">1906</span>
<span id="1907">1907</span>
<span id="1908">1908</span>
<span id="1909">1909</span>
<span id="1910">1910</span>
<span id="1911">1911</span>
<span id="1912">1912</span>
<span id="1913">1913</span>
<span id="1914">1914</span>
<span id="1915">1915</span>
<span id="1916">1916</span>
<span id="1917">1917</span>
<span id="1918">1918</span>
<span id="1919">1919</span>
<span id="1920">1920</span>
<span id="1921">1921</span>
<span id="1922">1922</span>
<span id="1923">1923</span>
<span id="1924">1924</span>
<span id="1925">1925</span>
<span id="1926">1926</span>
<span id="1927">1927</span>
<span id="1928">1928</span>
<span id="1929">1929</span>
<span id="1930">1930</span>
<span id="1931">1931</span>
<span id="1932">1932</span>
<span id="1933">1933</span>
<span id="1934">1934</span>
<span id="1935">1935</span>
<span id="1936">1936</span>
<span id="1937">1937</span>
<span id="1938">1938</span>
<span id="1939">1939</span>
<span id="1940">1940</span>
<span id="1941">1941</span>
<span id="1942">1942</span>
<span id="1943">1943</span>
<span id="1944">1944</span>
<span id="1945">1945</span>
<span id="1946">1946</span>
<span id="1947">1947</span>
<span id="1948">1948</span>
<span id="1949">1949</span>
<span id="1950">1950</span>
<span id="1951">1951</span>
<span id="1952">1952</span>
<span id="1953">1953</span>
<span id="1954">1954</span>
<span id="1955">1955</span>
<span id="1956">1956</span>
<span id="1957">1957</span>
<span id="1958">1958</span>
<span id="1959">1959</span>
<span id="1960">1960</span>
<span id="1961">1961</span>
<span id="1962">1962</span>
<span id="1963">1963</span>
<span id="1964">1964</span>
<span id="1965">1965</span>
<span id="1966">1966</span>
<span id="1967">1967</span>
<span id="1968">1968</span>
<span id="1969">1969</span>
<span id="1970">1970</span>
<span id="1971">1971</span>
<span id="1972">1972</span>
<span id="1973">1973</span>
<span id="1974">1974</span>
<span id="1975">1975</span>
<span id="1976">1976</span>
<span id="1977">1977</span>
<span id="1978">1978</span>
<span id="1979">1979</span>
<span id="1980">1980</span>
<span id="1981">1981</span>
<span id="1982">1982</span>
<span id="1983">1983</span>
<span id="1984">1984</span>
<span id="1985">1985</span>
<span id="1986">1986</span>
<span id="1987">1987</span>
<span id="1988">1988</span>
<span id="1989">1989</span>
<span id="1990">1990</span>
<span id="1991">1991</span>
<span id="1992">1992</span>
<span id="1993">1993</span>
<span id="1994">1994</span>
<span id="1995">1995</span>
<span id="1996">1996</span>
<span id="1997">1997</span>
<span id="1998">1998</span>
<span id="1999">1999</span>
<span id="2000">2000</span>
<span id="2001">2001</span>
<span id="2002">2002</span>
<span id="2003">2003</span>
<span id="2004">2004</span>
<span id="2005">2005</span>
<span id="2006">2006</span>
<span id="2007">2007</span>
<span id="2008">2008</span>
<span id="2009">2009</span>
<span id="2010">2010</span>
<span id="2011">2011</span>
<span id="2012">2012</span>
<span id="2013">2013</span>
<span id="2014">2014</span>
<span id="2015">2015</span>
<span id="2016">2016</span>
<span id="2017">2017</span>
<span id="2018">2018</span>
<span id="2019">2019</span>
<span id="2020">2020</span>
<span id="2021">2021</span>
<span id="2022">2022</span>
<span id="2023">2023</span>
<span id="2024">2024</span>
<span id="2025">2025</span>
<span id="2026">2026</span>
<span id="2027">2027</span>
<span id="2028">2028</span>
<span id="2029">2029</span>
<span id="2030">2030</span>
<span id="2031">2031</span>
<span id="2032">2032</span>
<span id="2033">2033</span>
<span id="2034">2034</span>
<span id="2035">2035</span>
<span id="2036">2036</span>
<span id="2037">2037</span>
<span id="2038">2038</span>
<span id="2039">2039</span>
<span id="2040">2040</span>
<span id="2041">2041</span>
<span id="2042">2042</span>
<span id="2043">2043</span>
<span id="2044">2044</span>
<span id="2045">2045</span>
<span id="2046">2046</span>
<span id="2047">2047</span>
<span id="2048">2048</span>
<span id="2049">2049</span>
<span id="2050">2050</span>
<span id="2051">2051</span>
<span id="2052">2052</span>
<span id="2053">2053</span>
<span id="2054">2054</span>
<span id="2055">2055</span>
<span id="2056">2056</span>
<span id="2057">2057</span>
<span id="2058">2058</span>
<span id="2059">2059</span>
<span id="2060">2060</span>
<span id="2061">2061</span>
<span id="2062">2062</span>
<span id="2063">2063</span>
<span id="2064">2064</span>
<span id="2065">2065</span>
<span id="2066">2066</span>
<span id="2067">2067</span>
<span id="2068">2068</span>
<span id="2069">2069</span>
<span id="2070">2070</span>
<span id="2071">2071</span>
<span id="2072">2072</span>
<span id="2073">2073</span>
<span id="2074">2074</span>
<span id="2075">2075</span>
<span id="2076">2076</span>
<span id="2077">2077</span>
<span id="2078">2078</span>
<span id="2079">2079</span>
<span id="2080">2080</span>
<span id="2081">2081</span>
<span id="2082">2082</span>
<span id="2083">2083</span>
<span id="2084">2084</span>
<span id="2085">2085</span>
<span id="2086">2086</span>
<span id="2087">2087</span>
<span id="2088">2088</span>
<span id="2089">2089</span>
<span id="2090">2090</span>
<span id="2091">2091</span>
<span id="2092">2092</span>
<span id="2093">2093</span>
<span id="2094">2094</span>
<span id="2095">2095</span>
<span id="2096">2096</span>
<span id="2097">2097</span>
<span id="2098">2098</span>
<span id="2099">2099</span>
<span id="2100">2100</span>
<span id="2101">2101</span>
<span id="2102">2102</span>
<span id="2103">2103</span>
<span id="2104">2104</span>
<span id="2105">2105</span>
<span id="2106">2106</span>
<span id="2107">2107</span>
<span id="2108">2108</span>
<span id="2109">2109</span>
<span id="2110">2110</span>
<span id="2111">2111</span>
<span id="2112">2112</span>
<span id="2113">2113</span>
<span id="2114">2114</span>
<span id="2115">2115</span>
<span id="2116">2116</span>
<span id="2117">2117</span>
<span id="2118">2118</span>
<span id="2119">2119</span>
<span id="2120">2120</span>
<span id="2121">2121</span>
<span id="2122">2122</span>
<span id="2123">2123</span>
<span id="2124">2124</span>
<span id="2125">2125</span>
<span id="2126">2126</span>
<span id="2127">2127</span>
<span id="2128">2128</span>
<span id="2129">2129</span>
<span id="2130">2130</span>
<span id="2131">2131</span>
<span id="2132">2132</span>
<span id="2133">2133</span>
<span id="2134">2134</span>
<span id="2135">2135</span>
<span id="2136">2136</span>
<span id="2137">2137</span>
<span id="2138">2138</span>
<span id="2139">2139</span>
<span id="2140">2140</span>
<span id="2141">2141</span>
<span id="2142">2142</span>
<span id="2143">2143</span>
<span id="2144">2144</span>
<span id="2145">2145</span>
<span id="2146">2146</span>
<span id="2147">2147</span>
<span id="2148">2148</span>
<span id="2149">2149</span>
<span id="2150">2150</span>
<span id="2151">2151</span>
<span id="2152">2152</span>
<span id="2153">2153</span>
<span id="2154">2154</span>
<span id="2155">2155</span>
<span id="2156">2156</span>
<span id="2157">2157</span>
<span id="2158">2158</span>
<span id="2159">2159</span>
<span id="2160">2160</span>
<span id="2161">2161</span>
<span id="2162">2162</span>
<span id="2163">2163</span>
<span id="2164">2164</span>
<span id="2165">2165</span>
<span id="2166">2166</span>
<span id="2167">2167</span>
<span id="2168">2168</span>
<span id="2169">2169</span>
<span id="2170">2170</span>
<span id="2171">2171</span>
<span id="2172">2172</span>
<span id="2173">2173</span>
<span id="2174">2174</span>
<span id="2175">2175</span>
<span id="2176">2176</span>
<span id="2177">2177</span>
<span id="2178">2178</span>
<span id="2179">2179</span>
<span id="2180">2180</span>
<span id="2181">2181</span>
<span id="2182">2182</span>
<span id="2183">2183</span>
<span id="2184">2184</span>
<span id="2185">2185</span>
<span id="2186">2186</span>
<span id="2187">2187</span>
<span id="2188">2188</span>
<span id="2189">2189</span>
<span id="2190">2190</span>
<span id="2191">2191</span>
<span id="2192">2192</span>
<span id="2193">2193</span>
<span id="2194">2194</span>
<span id="2195">2195</span>
<span id="2196">2196</span>
<span id="2197">2197</span>
<span id="2198">2198</span>
<span id="2199">2199</span>
<span id="2200">2200</span>
<span id="2201">2201</span>
<span id="2202">2202</span>
<span id="2203">2203</span>
<span id="2204">2204</span>
<span id="2205">2205</span>
<span id="2206">2206</span>
<span id="2207">2207</span>
<span id="2208">2208</span>
<span id="2209">2209</span>
<span id="2210">2210</span>
<span id="2211">2211</span>
<span id="2212">2212</span>
<span id="2213">2213</span>
<span id="2214">2214</span>
<span id="2215">2215</span>
<span id="2216">2216</span>
<span id="2217">2217</span>
<span id="2218">2218</span>
<span id="2219">2219</span>
<span id="2220">2220</span>
<span id="2221">2221</span>
<span id="2222">2222</span>
<span id="2223">2223</span>
<span id="2224">2224</span>
<span id="2225">2225</span>
<span id="2226">2226</span>
<span id="2227">2227</span>
<span id="2228">2228</span>
<span id="2229">2229</span>
<span id="2230">2230</span>
<span id="2231">2231</span>
<span id="2232">2232</span>
<span id="2233">2233</span>
<span id="2234">2234</span>
<span id="2235">2235</span>
<span id="2236">2236</span>
<span id="2237">2237</span>
<span id="2238">2238</span>
<span id="2239">2239</span>
<span id="2240">2240</span>
<span id="2241">2241</span>
<span id="2242">2242</span>
<span id="2243">2243</span>
<span id="2244">2244</span>
<span id="2245">2245</span>
<span id="2246">2246</span>
<span id="2247">2247</span>
<span id="2248">2248</span>
<span id="2249">2249</span>
<span id="2250">2250</span>
<span id="2251">2251</span>
<span id="2252">2252</span>
<span id="2253">2253</span>
<span id="2254">2254</span>
<span id="2255">2255</span>
<span id="2256">2256</span>
<span id="2257">2257</span>
<span id="2258">2258</span>
<span id="2259">2259</span>
<span id="2260">2260</span>
<span id="2261">2261</span>
<span id="2262">2262</span>
<span id="2263">2263</span>
<span id="2264">2264</span>
<span id="2265">2265</span>
<span id="2266">2266</span>
<span id="2267">2267</span>
<span id="2268">2268</span>
<span id="2269">2269</span>
<span id="2270">2270</span>
<span id="2271">2271</span>
<span id="2272">2272</span>
<span id="2273">2273</span>
<span id="2274">2274</span>
<span id="2275">2275</span>
<span id="2276">2276</span>
<span id="2277">2277</span>
<span id="2278">2278</span>
<span id="2279">2279</span>
<span id="2280">2280</span>
<span id="2281">2281</span>
<span id="2282">2282</span>
<span id="2283">2283</span>
<span id="2284">2284</span>
<span id="2285">2285</span>
<span id="2286">2286</span>
<span id="2287">2287</span>
<span id="2288">2288</span>
<span id="2289">2289</span>
<span id="2290">2290</span>
<span id="2291">2291</span>
<span id="2292">2292</span>
<span id="2293">2293</span>
<span id="2294">2294</span>
<span id="2295">2295</span>
<span id="2296">2296</span>
<span id="2297">2297</span>
<span id="2298">2298</span>
<span id="2299">2299</span>
<span id="2300">2300</span>
<span id="2301">2301</span>
<span id="2302">2302</span>
<span id="2303">2303</span>
<span id="2304">2304</span>
<span id="2305">2305</span>
<span id="2306">2306</span>
<span id="2307">2307</span>
<span id="2308">2308</span>
<span id="2309">2309</span>
<span id="2310">2310</span>
<span id="2311">2311</span>
<span id="2312">2312</span>
<span id="2313">2313</span>
<span id="2314">2314</span>
<span id="2315">2315</span>
<span id="2316">2316</span>
<span id="2317">2317</span>
<span id="2318">2318</span>
<span id="2319">2319</span>
<span id="2320">2320</span>
<span id="2321">2321</span>
<span id="2322">2322</span>
<span id="2323">2323</span>
<span id="2324">2324</span>
<span id="2325">2325</span>
<span id="2326">2326</span>
<span id="2327">2327</span>
<span id="2328">2328</span>
<span id="2329">2329</span>
<span id="2330">2330</span>
<span id="2331">2331</span>
<span id="2332">2332</span>
<span id="2333">2333</span>
<span id="2334">2334</span>
<span id="2335">2335</span>
<span id="2336">2336</span>
<span id="2337">2337</span>
<span id="2338">2338</span>
<span id="2339">2339</span>
<span id="2340">2340</span>
<span id="2341">2341</span>
<span id="2342">2342</span>
<span id="2343">2343</span>
<span id="2344">2344</span>
<span id="2345">2345</span>
<span id="2346">2346</span>
<span id="2347">2347</span>
<span id="2348">2348</span>
<span id="2349">2349</span>
<span id="2350">2350</span>
<span id="2351">2351</span>
<span id="2352">2352</span>
<span id="2353">2353</span>
<span id="2354">2354</span>
<span id="2355">2355</span>
<span id="2356">2356</span>
<span id="2357">2357</span>
<span id="2358">2358</span>
<span id="2359">2359</span>
<span id="2360">2360</span>
<span id="2361">2361</span>
<span id="2362">2362</span>
<span id="2363">2363</span>
<span id="2364">2364</span>
<span id="2365">2365</span>
<span id="2366">2366</span>
<span id="2367">2367</span>
<span id="2368">2368</span>
<span id="2369">2369</span>
<span id="2370">2370</span>
<span id="2371">2371</span>
<span id="2372">2372</span>
<span id="2373">2373</span>
<span id="2374">2374</span>
<span id="2375">2375</span>
<span id="2376">2376</span>
<span id="2377">2377</span>
<span id="2378">2378</span>
<span id="2379">2379</span>
<span id="2380">2380</span>
<span id="2381">2381</span>
<span id="2382">2382</span>
<span id="2383">2383</span>
<span id="2384">2384</span>
<span id="2385">2385</span>
<span id="2386">2386</span>
<span id="2387">2387</span>
<span id="2388">2388</span>
<span id="2389">2389</span>
<span id="2390">2390</span>
<span id="2391">2391</span>
<span id="2392">2392</span>
<span id="2393">2393</span>
<span id="2394">2394</span>
<span id="2395">2395</span>
<span id="2396">2396</span>
<span id="2397">2397</span>
<span id="2398">2398</span>
<span id="2399">2399</span>
<span id="2400">2400</span>
<span id="2401">2401</span>
<span id="2402">2402</span>
<span id="2403">2403</span>
<span id="2404">2404</span>
<span id="2405">2405</span>
<span id="2406">2406</span>
<span id="2407">2407</span>
<span id="2408">2408</span>
<span id="2409">2409</span>
<span id="2410">2410</span>
<span id="2411">2411</span>
<span id="2412">2412</span>
<span id="2413">2413</span>
<span id="2414">2414</span>
<span id="2415">2415</span>
<span id="2416">2416</span>
<span id="2417">2417</span>
<span id="2418">2418</span>
<span id="2419">2419</span>
<span id="2420">2420</span>
<span id="2421">2421</span>
<span id="2422">2422</span>
<span id="2423">2423</span>
<span id="2424">2424</span>
<span id="2425">2425</span>
<span id="2426">2426</span>
<span id="2427">2427</span>
<span id="2428">2428</span>
<span id="2429">2429</span>
<span id="2430">2430</span>
<span id="2431">2431</span>
<span id="2432">2432</span>
<span id="2433">2433</span>
<span id="2434">2434</span>
<span id="2435">2435</span>
<span id="2436">2436</span>
<span id="2437">2437</span>
<span id="2438">2438</span>
<span id="2439">2439</span>
<span id="2440">2440</span>
<span id="2441">2441</span>
<span id="2442">2442</span>
<span id="2443">2443</span>
<span id="2444">2444</span>
<span id="2445">2445</span>
<span id="2446">2446</span>
<span id="2447">2447</span>
<span id="2448">2448</span>
<span id="2449">2449</span>
<span id="2450">2450</span>
<span id="2451">2451</span>
<span id="2452">2452</span>
<span id="2453">2453</span>
<span id="2454">2454</span>
<span id="2455">2455</span>
<span id="2456">2456</span>
<span id="2457">2457</span>
<span id="2458">2458</span>
<span id="2459">2459</span>
<span id="2460">2460</span>
<span id="2461">2461</span>
<span id="2462">2462</span>
<span id="2463">2463</span>
<span id="2464">2464</span>
<span id="2465">2465</span>
<span id="2466">2466</span>
<span id="2467">2467</span>
<span id="2468">2468</span>
<span id="2469">2469</span>
<span id="2470">2470</span>
<span id="2471">2471</span>
<span id="2472">2472</span>
<span id="2473">2473</span>
<span id="2474">2474</span>
<span id="2475">2475</span>
<span id="2476">2476</span>
<span id="2477">2477</span>
<span id="2478">2478</span>
<span id="2479">2479</span>
<span id="2480">2480</span>
<span id="2481">2481</span>
<span id="2482">2482</span>
<span id="2483">2483</span>
<span id="2484">2484</span>
<span id="2485">2485</span>
<span id="2486">2486</span>
<span id="2487">2487</span>
<span id="2488">2488</span>
<span id="2489">2489</span>
<span id="2490">2490</span>
<span id="2491">2491</span>
<span id="2492">2492</span>
<span id="2493">2493</span>
<span id="2494">2494</span>
<span id="2495">2495</span>
<span id="2496">2496</span>
<span id="2497">2497</span>
<span id="2498">2498</span>
<span id="2499">2499</span>
<span id="2500">2500</span>
<span id="2501">2501</span>
<span id="2502">2502</span>
<span id="2503">2503</span>
<span id="2504">2504</span>
<span id="2505">2505</span>
<span id="2506">2506</span>
<span id="2507">2507</span>
<span id="2508">2508</span>
<span id="2509">2509</span>
<span id="2510">2510</span>
<span id="2511">2511</span>
<span id="2512">2512</span>
<span id="2513">2513</span>
<span id="2514">2514</span>
<span id="2515">2515</span>
<span id="2516">2516</span>
<span id="2517">2517</span>
<span id="2518">2518</span>
<span id="2519">2519</span>
<span id="2520">2520</span>
<span id="2521">2521</span>
<span id="2522">2522</span>
<span id="2523">2523</span>
<span id="2524">2524</span>
<span id="2525">2525</span>
<span id="2526">2526</span>
<span id="2527">2527</span>
<span id="2528">2528</span>
<span id="2529">2529</span>
<span id="2530">2530</span>
<span id="2531">2531</span>
<span id="2532">2532</span>
<span id="2533">2533</span>
<span id="2534">2534</span>
<span id="2535">2535</span>
<span id="2536">2536</span>
<span id="2537">2537</span>
<span id="2538">2538</span>
<span id="2539">2539</span>
<span id="2540">2540</span>
<span id="2541">2541</span>
<span id="2542">2542</span>
<span id="2543">2543</span>
<span id="2544">2544</span>
<span id="2545">2545</span>
<span id="2546">2546</span>
<span id="2547">2547</span>
<span id="2548">2548</span>
<span id="2549">2549</span>
<span id="2550">2550</span>
<span id="2551">2551</span>
<span id="2552">2552</span>
<span id="2553">2553</span>
<span id="2554">2554</span>
<span id="2555">2555</span>
<span id="2556">2556</span>
<span id="2557">2557</span>
<span id="2558">2558</span>
<span id="2559">2559</span>
<span id="2560">2560</span>
<span id="2561">2561</span>
<span id="2562">2562</span>
<span id="2563">2563</span>
<span id="2564">2564</span>
<span id="2565">2565</span>
<span id="2566">2566</span>
<span id="2567">2567</span>
<span id="2568">2568</span>
<span id="2569">2569</span>
<span id="2570">2570</span>
<span id="2571">2571</span>
<span id="2572">2572</span>
<span id="2573">2573</span>
<span id="2574">2574</span>
<span id="2575">2575</span>
<span id="2576">2576</span>
<span id="2577">2577</span>
<span id="2578">2578</span>
<span id="2579">2579</span>
<span id="2580">2580</span>
<span id="2581">2581</span>
<span id="2582">2582</span>
<span id="2583">2583</span>
<span id="2584">2584</span>
<span id="2585">2585</span>
<span id="2586">2586</span>
<span id="2587">2587</span>
<span id="2588">2588</span>
<span id="2589">2589</span>
<span id="2590">2590</span>
<span id="2591">2591</span>
<span id="2592">2592</span>
<span id="2593">2593</span>
<span id="2594">2594</span>
<span id="2595">2595</span>
<span id="2596">2596</span>
<span id="2597">2597</span>
<span id="2598">2598</span>
<span id="2599">2599</span>
<span id="2600">2600</span>
<span id="2601">2601</span>
<span id="2602">2602</span>
<span id="2603">2603</span>
<span id="2604">2604</span>
<span id="2605">2605</span>
<span id="2606">2606</span>
<span id="2607">2607</span>
<span id="2608">2608</span>
<span id="2609">2609</span>
<span id="2610">2610</span>
<span id="2611">2611</span>
<span id="2612">2612</span>
<span id="2613">2613</span>
<span id="2614">2614</span>
<span id="2615">2615</span>
<span id="2616">2616</span>
<span id="2617">2617</span>
<span id="2618">2618</span>
<span id="2619">2619</span>
<span id="2620">2620</span>
<span id="2621">2621</span>
<span id="2622">2622</span>
<span id="2623">2623</span>
<span id="2624">2624</span>
<span id="2625">2625</span>
<span id="2626">2626</span>
<span id="2627">2627</span>
<span id="2628">2628</span>
<span id="2629">2629</span>
<span id="2630">2630</span>
<span id="2631">2631</span>
<span id="2632">2632</span>
<span id="2633">2633</span>
<span id="2634">2634</span>
<span id="2635">2635</span>
<span id="2636">2636</span>
<span id="2637">2637</span>
<span id="2638">2638</span>
<span id="2639">2639</span>
<span id="2640">2640</span>
<span id="2641">2641</span>
<span id="2642">2642</span>
<span id="2643">2643</span>
<span id="2644">2644</span>
<span id="2645">2645</span>
<span id="2646">2646</span>
<span id="2647">2647</span>
<span id="2648">2648</span>
<span id="2649">2649</span>
<span id="2650">2650</span>
<span id="2651">2651</span>
<span id="2652">2652</span>
<span id="2653">2653</span>
<span id="2654">2654</span>
<span id="2655">2655</span>
<span id="2656">2656</span>
<span id="2657">2657</span>
<span id="2658">2658</span>
<span id="2659">2659</span>
<span id="2660">2660</span>
<span id="2661">2661</span>
<span id="2662">2662</span>
<span id="2663">2663</span>
<span id="2664">2664</span>
<span id="2665">2665</span>
<span id="2666">2666</span>
<span id="2667">2667</span>
<span id="2668">2668</span>
<span id="2669">2669</span>
<span id="2670">2670</span>
<span id="2671">2671</span>
<span id="2672">2672</span>
<span id="2673">2673</span>
<span id="2674">2674</span>
<span id="2675">2675</span>
<span id="2676">2676</span>
<span id="2677">2677</span>
<span id="2678">2678</span>
<span id="2679">2679</span>
<span id="2680">2680</span>
<span id="2681">2681</span>
<span id="2682">2682</span>
<span id="2683">2683</span>
<span id="2684">2684</span>
<span id="2685">2685</span>
<span id="2686">2686</span>
<span id="2687">2687</span>
<span id="2688">2688</span>
<span id="2689">2689</span>
<span id="2690">2690</span>
<span id="2691">2691</span>
<span id="2692">2692</span>
<span id="2693">2693</span>
<span id="2694">2694</span>
<span id="2695">2695</span>
<span id="2696">2696</span>
<span id="2697">2697</span>
<span id="2698">2698</span>
<span id="2699">2699</span>
<span id="2700">2700</span>
<span id="2701">2701</span>
<span id="2702">2702</span>
<span id="2703">2703</span>
<span id="2704">2704</span>
<span id="2705">2705</span>
<span id="2706">2706</span>
<span id="2707">2707</span>
<span id="2708">2708</span>
<span id="2709">2709</span>
<span id="2710">2710</span>
<span id="2711">2711</span>
<span id="2712">2712</span>
<span id="2713">2713</span>
<span id="2714">2714</span>
<span id="2715">2715</span>
<span id="2716">2716</span>
<span id="2717">2717</span>
<span id="2718">2718</span>
<span id="2719">2719</span>
<span id="2720">2720</span>
<span id="2721">2721</span>
<span id="2722">2722</span>
<span id="2723">2723</span>
<span id="2724">2724</span>
<span id="2725">2725</span>
<span id="2726">2726</span>
<span id="2727">2727</span>
<span id="2728">2728</span>
<span id="2729">2729</span>
<span id="2730">2730</span>
<span id="2731">2731</span>
<span id="2732">2732</span>
<span id="2733">2733</span>
<span id="2734">2734</span>
<span id="2735">2735</span>
<span id="2736">2736</span>
<span id="2737">2737</span>
<span id="2738">2738</span>
<span id="2739">2739</span>
<span id="2740">2740</span>
<span id="2741">2741</span>
<span id="2742">2742</span>
<span id="2743">2743</span>
<span id="2744">2744</span>
<span id="2745">2745</span>
<span id="2746">2746</span>
<span id="2747">2747</span>
<span id="2748">2748</span>
<span id="2749">2749</span>
<span id="2750">2750</span>
<span id="2751">2751</span>
<span id="2752">2752</span>
<span id="2753">2753</span>
<span id="2754">2754</span>
<span id="2755">2755</span>
<span id="2756">2756</span>
<span id="2757">2757</span>
<span id="2758">2758</span>
<span id="2759">2759</span>
<span id="2760">2760</span>
<span id="2761">2761</span>
<span id="2762">2762</span>
<span id="2763">2763</span>
<span id="2764">2764</span>
<span id="2765">2765</span>
<span id="2766">2766</span>
<span id="2767">2767</span>
<span id="2768">2768</span>
<span id="2769">2769</span>
<span id="2770">2770</span>
<span id="2771">2771</span>
<span id="2772">2772</span>
<span id="2773">2773</span>
<span id="2774">2774</span>
<span id="2775">2775</span>
<span id="2776">2776</span>
<span id="2777">2777</span>
<span id="2778">2778</span>
<span id="2779">2779</span>
<span id="2780">2780</span>
<span id="2781">2781</span>
<span id="2782">2782</span>
<span id="2783">2783</span>
<span id="2784">2784</span>
<span id="2785">2785</span>
<span id="2786">2786</span>
<span id="2787">2787</span>
<span id="2788">2788</span>
<span id="2789">2789</span>
<span id="2790">2790</span>
<span id="2791">2791</span>
<span id="2792">2792</span>
<span id="2793">2793</span>
<span id="2794">2794</span>
<span id="2795">2795</span>
<span id="2796">2796</span>
<span id="2797">2797</span>
<span id="2798">2798</span>
<span id="2799">2799</span>
<span id="2800">2800</span>
<span id="2801">2801</span>
<span id="2802">2802</span>
<span id="2803">2803</span>
<span id="2804">2804</span>
<span id="2805">2805</span>
<span id="2806">2806</span>
<span id="2807">2807</span>
<span id="2808">2808</span>
<span id="2809">2809</span>
<span id="2810">2810</span>
<span id="2811">2811</span>
<span id="2812">2812</span>
<span id="2813">2813</span>
<span id="2814">2814</span>
<span id="2815">2815</span>
<span id="2816">2816</span>
<span id="2817">2817</span>
<span id="2818">2818</span>
<span id="2819">2819</span>
<span id="2820">2820</span>
<span id="2821">2821</span>
<span id="2822">2822</span>
<span id="2823">2823</span>
<span id="2824">2824</span>
<span id="2825">2825</span>
<span id="2826">2826</span>
<span id="2827">2827</span>
<span id="2828">2828</span>
<span id="2829">2829</span>
<span id="2830">2830</span>
<span id="2831">2831</span>
<span id="2832">2832</span>
<span id="2833">2833</span>
<span id="2834">2834</span>
<span id="2835">2835</span>
<span id="2836">2836</span>
<span id="2837">2837</span>
<span id="2838">2838</span>
<span id="2839">2839</span>
<span id="2840">2840</span>
<span id="2841">2841</span>
<span id="2842">2842</span>
<span id="2843">2843</span>
<span id="2844">2844</span>
<span id="2845">2845</span>
<span id="2846">2846</span>
<span id="2847">2847</span>
<span id="2848">2848</span>
<span id="2849">2849</span>
<span id="2850">2850</span>
<span id="2851">2851</span>
<span id="2852">2852</span>
<span id="2853">2853</span>
<span id="2854">2854</span>
<span id="2855">2855</span>
<span id="2856">2856</span>
<span id="2857">2857</span>
<span id="2858">2858</span>
<span id="2859">2859</span>
<span id="2860">2860</span>
<span id="2861">2861</span>
<span id="2862">2862</span>
<span id="2863">2863</span>
<span id="2864">2864</span>
<span id="2865">2865</span>
<span id="2866">2866</span>
<span id="2867">2867</span>
<span id="2868">2868</span>
<span id="2869">2869</span>
<span id="2870">2870</span>
<span id="2871">2871</span>
<span id="2872">2872</span>
<span id="2873">2873</span>
<span id="2874">2874</span>
<span id="2875">2875</span>
<span id="2876">2876</span>
<span id="2877">2877</span>
<span id="2878">2878</span>
<span id="2879">2879</span>
<span id="2880">2880</span>
<span id="2881">2881</span>
<span id="2882">2882</span>
<span id="2883">2883</span>
<span id="2884">2884</span>
<span id="2885">2885</span>
<span id="2886">2886</span>
<span id="2887">2887</span>
<span id="2888">2888</span>
<span id="2889">2889</span>
<span id="2890">2890</span>
<span id="2891">2891</span>
<span id="2892">2892</span>
<span id="2893">2893</span>
<span id="2894">2894</span>
<span id="2895">2895</span>
<span id="2896">2896</span>
<span id="2897">2897</span>
<span id="2898">2898</span>
<span id="2899">2899</span>
<span id="2900">2900</span>
<span id="2901">2901</span>
<span id="2902">2902</span>
<span id="2903">2903</span>
<span id="2904">2904</span>
<span id="2905">2905</span>
<span id="2906">2906</span>
<span id="2907">2907</span>
<span id="2908">2908</span>
<span id="2909">2909</span>
<span id="2910">2910</span>
<span id="2911">2911</span>
<span id="2912">2912</span>
<span id="2913">2913</span>
<span id="2914">2914</span>
<span id="2915">2915</span>
<span id="2916">2916</span>
<span id="2917">2917</span>
<span id="2918">2918</span>
<span id="2919">2919</span>
<span id="2920">2920</span>
<span id="2921">2921</span>
<span id="2922">2922</span>
<span id="2923">2923</span>
<span id="2924">2924</span>
<span id="2925">2925</span>
<span id="2926">2926</span>
<span id="2927">2927</span>
<span id="2928">2928</span>
<span id="2929">2929</span>
<span id="2930">2930</span>
<span id="2931">2931</span>
<span id="2932">2932</span>
<span id="2933">2933</span>
<span id="2934">2934</span>
<span id="2935">2935</span>
<span id="2936">2936</span>
<span id="2937">2937</span>
<span id="2938">2938</span>
<span id="2939">2939</span>
<span id="2940">2940</span>
<span id="2941">2941</span>
<span id="2942">2942</span>
<span id="2943">2943</span>
<span id="2944">2944</span>
<span id="2945">2945</span>
<span id="2946">2946</span>
<span id="2947">2947</span>
<span id="2948">2948</span>
<span id="2949">2949</span>
<span id="2950">2950</span>
<span id="2951">2951</span>
<span id="2952">2952</span>
<span id="2953">2953</span>
<span id="2954">2954</span>
<span id="2955">2955</span>
<span id="2956">2956</span>
<span id="2957">2957</span>
<span id="2958">2958</span>
<span id="2959">2959</span>
<span id="2960">2960</span>
<span id="2961">2961</span>
<span id="2962">2962</span>
<span id="2963">2963</span>
<span id="2964">2964</span>
<span id="2965">2965</span>
<span id="2966">2966</span>
<span id="2967">2967</span>
<span id="2968">2968</span>
<span id="2969">2969</span>
<span id="2970">2970</span>
<span id="2971">2971</span>
<span id="2972">2972</span>
<span id="2973">2973</span>
<span id="2974">2974</span>
<span id="2975">2975</span>
<span id="2976">2976</span>
<span id="2977">2977</span>
<span id="2978">2978</span>
<span id="2979">2979</span>
<span id="2980">2980</span>
<span id="2981">2981</span>
<span id="2982">2982</span>
<span id="2983">2983</span>
<span id="2984">2984</span>
<span id="2985">2985</span>
<span id="2986">2986</span>
<span id="2987">2987</span>
<span id="2988">2988</span>
<span id="2989">2989</span>
<span id="2990">2990</span>
<span id="2991">2991</span>
<span id="2992">2992</span>
<span id="2993">2993</span>
<span id="2994">2994</span>
<span id="2995">2995</span>
<span id="2996">2996</span>
<span id="2997">2997</span>
<span id="2998">2998</span>
<span id="2999">2999</span>
<span id="3000">3000</span>
<span id="3001">3001</span>
<span id="3002">3002</span>
<span id="3003">3003</span>
<span id="3004">3004</span>
<span id="3005">3005</span>
<span id="3006">3006</span>
<span id="3007">3007</span>
<span id="3008">3008</span>
<span id="3009">3009</span>
<span id="3010">3010</span>
<span id="3011">3011</span>
<span id="3012">3012</span>
<span id="3013">3013</span>
<span id="3014">3014</span>
<span id="3015">3015</span>
<span id="3016">3016</span>
<span id="3017">3017</span>
<span id="3018">3018</span>
<span id="3019">3019</span>
<span id="3020">3020</span>
<span id="3021">3021</span>
<span id="3022">3022</span>
<span id="3023">3023</span>
<span id="3024">3024</span>
<span id="3025">3025</span>
<span id="3026">3026</span>
<span id="3027">3027</span>
<span id="3028">3028</span>
<span id="3029">3029</span>
<span id="3030">3030</span>
<span id="3031">3031</span>
<span id="3032">3032</span>
<span id="3033">3033</span>
<span id="3034">3034</span>
<span id="3035">3035</span>
<span id="3036">3036</span>
<span id="3037">3037</span>
<span id="3038">3038</span>
</pre><pre class="rust"><code><span class="attribute">#![allow(dead_code)]
</span><span class="kw">use </span><span class="kw">super</span>::hash_to_binary_tree::InitializeH10;
<span class="kw">use </span><span class="kw">super</span>::constants::{BROTLI_WINDOW_GAP, BROTLI_CONTEXT_LUT, BROTLI_CONTEXT,
                       BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS, BROTLI_MAX_NPOSTFIX, BROTLI_MAX_NDIRECT};
<span class="kw">use </span><span class="kw">super</span>::backward_references::{BrotliCreateBackwardReferences, Struct1, UnionHasher,
                                 BrotliEncoderParams, BrotliEncoderMode, BrotliHasherParams, H2Sub,
                                 H3Sub, H4Sub, H5Sub, H6Sub, H54Sub, HQ5Sub, HQ7Sub, AdvHasher, BasicHasher, H9,
                                 H9_BUCKET_BITS, H9_BLOCK_SIZE, H9_BLOCK_BITS, H9_NUM_LAST_DISTANCES_TO_CHECK,
                                 AnyHasher, HowPrepared, StoreLookaheadThenStore, AdvHashSpecialization};
<span class="kw">use </span>alloc::Allocator;
<span class="kw">pub use </span><span class="kw">super</span>::parameters::BrotliEncoderParameter;
<span class="kw">use </span><span class="kw">super</span>::combined_alloc::BrotliAlloc;
<span class="kw">use </span><span class="kw">super</span>::interface;
<span class="kw">use </span><span class="kw">super</span>::bit_cost::{BitsEntropy, ShannonEntropy};
<span class="attribute">#[allow(unused_imports)]
</span><span class="kw">use </span><span class="kw">super</span>::block_split::BlockSplit;
<span class="attribute">#[allow(unused_imports)]
</span><span class="kw">use </span><span class="kw">super</span>::brotli_bit_stream::{BrotliBuildAndStoreHuffmanTreeFast, BrotliStoreHuffmanTree,
                               BrotliStoreMetaBlock, BrotliStoreMetaBlockFast,
                               BrotliStoreMetaBlockTrivial, BrotliStoreUncompressedMetaBlock,
                               BrotliWriteEmptyLastMetaBlock, BrotliWriteMetadataMetaBlock,
                               MetaBlockSplit, RecoderState, JumpToByteBoundary};
                               
<span class="kw">use </span>enc::input_pair::InputReferenceMut;
<span class="kw">use </span><span class="kw">super</span>::command::{Command, GetLengthCode, BrotliDistanceParams};
<span class="kw">use </span><span class="kw">super</span>::compress_fragment::BrotliCompressFragmentFast;
<span class="kw">use </span><span class="kw">super</span>::compress_fragment_two_pass::{BrotliCompressFragmentTwoPass, BrotliWriteBits};
<span class="attribute">#[allow(unused_imports)]
</span><span class="kw">use </span><span class="kw">super</span>::entropy_encode::{BrotliConvertBitDepthsToSymbols, BrotliCreateHuffmanTree, HuffmanTree};
<span class="kw">use </span><span class="kw">super</span>::metablock::{BrotliBuildMetaBlock, BrotliBuildMetaBlockGreedy, BrotliOptimizeHistograms, BrotliInitDistanceParams};
<span class="kw">use </span><span class="kw">super</span>::static_dict::{BrotliGetDictionary, kNumDistanceCacheEntries};
<span class="kw">use </span><span class="kw">super</span>::histogram::{ContextType, HistogramLiteral, HistogramCommand, HistogramDistance, CostAccessors};
<span class="kw">use </span><span class="kw">super</span>::<span class="kw">super</span>::alloc;
<span class="kw">use </span><span class="kw">super</span>::<span class="kw">super</span>::alloc::{SliceWrapper, SliceWrapperMut};
<span class="kw">use </span><span class="kw">super</span>::utf8_util::BrotliIsMostlyUTF8;
<span class="kw">use </span><span class="kw">super</span>::util::{brotli_min_size_t, Log2FloorNonZero};
<span class="kw">use </span>core;
<span class="comment">//fn BrotliCreateHqZopfliBackwardReferences(m: &amp;mut [MemoryManager],
//                                          dictionary: &amp;[BrotliDictionary],
//                                          num_bytes: usize,
//                                          position: usize,
//                                          ringbuffer: &amp;[u8],
//                                          ringbuffer_mask: usize,
//                                          params: &amp;[BrotliEncoderParams],
//                                          hasher: &amp;mut [u8],
//                                          dist_cache: &amp;mut [i32],
//                                          last_insert_len: &amp;mut [usize],
//                                          commands: &amp;mut [Command],
//                                          num_commands: &amp;mut [usize],
//                                          num_literals: &amp;mut [usize]);
//fn BrotliCreateZopfliBackwardReferences(m: &amp;mut [MemoryManager],
//                                       dictionary: &amp;[BrotliDictionary],
//                                      num_bytes: usize,
//                                        position: usize,
//                                        ringbuffer: &amp;[u8],
//                                        ringbuffer_mask: usize,
//                                        params: &amp;[BrotliEncoderParams],
//                                        hasher: &amp;mut [u8],
//                                        dist_cache: &amp;mut [i32],
//                                        last_insert_len: &amp;mut [usize],
//                                        commands: &amp;mut [Command],
//                                        num_commands: &amp;mut [usize],
//                                        num_literals: &amp;mut [usize]);
//fn BrotliInitBlockSplit(xself: &amp;mut BlockSplit);
//fn BrotliInitMemoryManager(m: &amp;mut [MemoryManager],
//                           alloc_func: fn(&amp;mut [::std::os::raw::c_void], usize)
//                                          -&gt; *mut ::std::os::raw::c_void,
//                           free_func: fn(*mut ::std::os::raw::c_void,
//                                         *mut ::std::os::raw::c_void),
//                           opaque: *mut ::std::os::raw::c_void);
//fn BrotliInitZopfliNodes(array: &amp;mut [ZopfliNode], length: usize);
//fn BrotliWipeOutMemoryManager(m: &amp;mut [MemoryManager]);



</span><span class="kw">static </span>kCompressFragmentTwoPassBlockSize: usize = (<span class="number">1i32 </span>&lt;&lt; <span class="number">17i32</span>) <span class="kw">as </span>(usize);

<span class="kw">static </span>kMinUTF8Ratio: <span class="kw">super</span>::util::floatX = <span class="number">0.75 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX;



<span class="kw">pub struct </span>RingBuffer&lt;AllocU8: alloc::Allocator&lt;u8&gt;&gt; {
  <span class="kw">pub </span>size_: u32,
  <span class="kw">pub </span>mask_: u32,
  <span class="kw">pub </span>tail_size_: u32,
  <span class="kw">pub </span>total_size_: u32,
  <span class="kw">pub </span>cur_size_: u32,
  <span class="kw">pub </span>pos_: u32,
  <span class="kw">pub </span>data_mo: AllocU8::AllocatedMemory,
  <span class="kw">pub </span>buffer_index: usize,
}


<span class="attribute">#[derive(PartialEq, Eq, Copy, Clone)]
#[repr(i32)]
</span><span class="kw">pub enum </span>BrotliEncoderStreamState {
  BROTLI_STREAM_PROCESSING = <span class="number">0</span>,
  BROTLI_STREAM_FLUSH_REQUESTED = <span class="number">1</span>,
  BROTLI_STREAM_FINISHED = <span class="number">2</span>,
  BROTLI_STREAM_METADATA_HEAD = <span class="number">3</span>,
  BROTLI_STREAM_METADATA_BODY = <span class="number">4</span>,
}

<span class="attribute">#[derive(Clone,Copy,Debug)]
</span><span class="kw">enum </span>NextOut {
    DynamicStorage(u32),
    TinyBuf(u32),
    <span class="prelude-val">None</span>,
}
<span class="kw">fn </span>GetNextOutInternal&lt;<span class="lifetime">&#39;a</span>&gt;(
    next_out :<span class="kw-2">&amp;</span>NextOut,
    storage : <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>[u8],
    tiny_buf : <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>[u8;<span class="number">16</span>],
) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut</span>[u8]{
    <span class="kw">match </span>next_out {
        <span class="kw-2">&amp;</span>NextOut::DynamicStorage(offset) =&gt;
            <span class="kw">return </span><span class="kw-2">&amp;mut </span>storage[offset <span class="kw">as </span>usize..],
        <span class="kw-2">&amp;</span>NextOut::TinyBuf(offset) =&gt;
            <span class="kw">return </span><span class="kw-2">&amp;mut </span>tiny_buf[offset <span class="kw">as </span>usize..],
        <span class="kw-2">&amp;</span>NextOut::None =&gt; <span class="kw-2">&amp;mut </span>[],
    }
}
<span class="macro">macro_rules! </span>GetNextOut {
    (<span class="macro-nonterminal">$s </span>: expr) =&gt; {
        GetNextOutInternal(<span class="kw-2">&amp;</span><span class="macro-nonterminal">$s</span>.next_out_,
                           <span class="macro-nonterminal">$s</span>.storage_.slice_mut(),
                           <span class="kw-2">&amp;mut </span><span class="macro-nonterminal">$s</span>.tiny_buf_)
    };
}
<span class="kw">fn </span>NextOutIncrement(next_out :<span class="kw-2">&amp;</span>NextOut, inc : i32) -&gt; NextOut{
    <span class="kw">match </span>next_out {
        <span class="kw-2">&amp;</span>NextOut::DynamicStorage(offset) =&gt;
            <span class="kw">return </span>NextOut::DynamicStorage((offset <span class="kw">as </span>i32 + inc) <span class="kw">as </span>u32),
        <span class="kw-2">&amp;</span>NextOut::TinyBuf(offset) =&gt;
            <span class="kw">return </span>NextOut::TinyBuf((offset <span class="kw">as </span>i32 + inc) <span class="kw">as </span>u32),
        <span class="kw-2">&amp;</span>NextOut::None =&gt; NextOut::None,
    }
}
<span class="kw">fn </span>IsNextOutNull(next_out :<span class="kw-2">&amp;</span>NextOut) -&gt; bool {
    <span class="kw">match </span>next_out {
        <span class="kw-2">&amp;</span>NextOut::DynamicStorage(<span class="kw">_</span>) =&gt;
            <span class="bool-val">false</span>,
        <span class="kw-2">&amp;</span>NextOut::TinyBuf(<span class="kw">_</span>) =&gt;
            <span class="bool-val">false</span>,
        <span class="kw-2">&amp;</span>NextOut::None =&gt; <span class="bool-val">true</span>,
    }
}

<span class="attribute">#[derive(Clone,Copy,Debug)]
</span><span class="kw">pub enum </span>IsFirst {
  NothingWritten,
  HeaderWritten,
  FirstCatableByteWritten,
  BothCatableBytesWritten,
}

<span class="kw">pub struct </span>BrotliEncoderStateStruct&lt;Alloc: BrotliAlloc&gt;
{
  <span class="kw">pub </span>params: BrotliEncoderParams,
  <span class="kw">pub </span>m8: Alloc,
  <span class="kw">pub </span>hasher_: UnionHasher&lt;Alloc&gt;,
  <span class="kw">pub </span>input_pos_: u64,
  <span class="kw">pub </span>ringbuffer_: RingBuffer&lt;Alloc&gt;,
  <span class="kw">pub </span>cmd_alloc_size_: usize,
  <span class="kw">pub </span>commands_: &lt;Alloc <span class="kw">as </span>Allocator&lt;Command&gt;&gt;::AllocatedMemory, <span class="comment">// not sure about this one
  </span><span class="kw">pub </span>num_commands_: usize,
  <span class="kw">pub </span>num_literals_: usize,
  <span class="kw">pub </span>last_insert_len_: usize,
  <span class="kw">pub </span>last_flush_pos_: u64,
  <span class="kw">pub </span>last_processed_pos_: u64,
  <span class="kw">pub </span>dist_cache_: [i32; <span class="number">16</span>],
  <span class="kw">pub </span>saved_dist_cache_: [i32; kNumDistanceCacheEntries],
  <span class="kw">pub </span>last_bytes_: u16,
  <span class="kw">pub </span>last_bytes_bits_: u8,
  <span class="kw">pub </span>prev_byte_: u8,
  <span class="kw">pub </span>prev_byte2_: u8,
  <span class="kw">pub </span>storage_size_: usize,
  <span class="kw">pub </span>storage_: &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory,
  <span class="kw">pub </span>small_table_: [i32; <span class="number">1024</span>],
  <span class="kw">pub </span>large_table_: &lt;Alloc <span class="kw">as </span>Allocator&lt;i32&gt;&gt;::AllocatedMemory,
<span class="comment">//  pub large_table_size_: usize, // &lt;-- get this by doing large_table_.len()
  </span><span class="kw">pub </span>cmd_depths_: [u8; <span class="number">128</span>],
  <span class="kw">pub </span>cmd_bits_: [u16; <span class="number">128</span>],
  <span class="kw">pub </span>cmd_code_: [u8; <span class="number">512</span>],
  <span class="kw">pub </span>cmd_code_numbits_: usize,
  <span class="kw">pub </span>command_buf_: &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::AllocatedMemory,
  <span class="kw">pub </span>literal_buf_: &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory,
  next_out_: NextOut,
  <span class="kw">pub </span>available_out_: usize,
  <span class="kw">pub </span>total_out_: u64,
  <span class="kw">pub </span>tiny_buf_: [u8; <span class="number">16</span>],
  <span class="kw">pub </span>remaining_metadata_bytes_: u32,
  <span class="kw">pub </span>stream_state_: BrotliEncoderStreamState,
  <span class="kw">pub </span>is_last_block_emitted_: bool,
  <span class="kw">pub </span>is_initialized_: bool,
  <span class="kw">pub </span>is_first_mb: IsFirst,
  <span class="kw">pub </span>literal_scratch_space: &lt;HistogramLiteral <span class="kw">as </span>CostAccessors&gt;::i32vec,
  <span class="kw">pub </span>command_scratch_space: &lt;HistogramCommand <span class="kw">as </span>CostAccessors&gt;::i32vec,
  <span class="kw">pub </span>distance_scratch_space: &lt;HistogramDistance <span class="kw">as </span>CostAccessors&gt;::i32vec,
  <span class="kw">pub </span>recoder_state: RecoderState,
  custom_dictionary: bool,
}

<span class="kw">pub fn </span>set_parameter(params: <span class="kw-2">&amp;mut </span>BrotliEncoderParams,
                     p: BrotliEncoderParameter,
value: u32) -&gt; i32 {
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_MODE <span class="kw">as </span>(i32) {
    params.mode = <span class="kw">match </span>value {
      <span class="number">0 </span>=&gt; BrotliEncoderMode::BROTLI_MODE_GENERIC,
      <span class="number">1 </span>=&gt; BrotliEncoderMode::BROTLI_MODE_TEXT,
      <span class="number">2 </span>=&gt; BrotliEncoderMode::BROTLI_MODE_FONT,
      <span class="number">3 </span>=&gt; BrotliEncoderMode::BROTLI_FORCE_LSB_PRIOR,
      <span class="number">4 </span>=&gt; BrotliEncoderMode::BROTLI_FORCE_MSB_PRIOR,
      <span class="number">5 </span>=&gt; BrotliEncoderMode::BROTLI_FORCE_UTF8_PRIOR,
      <span class="number">6 </span>=&gt; BrotliEncoderMode::BROTLI_FORCE_SIGNED_PRIOR,
      <span class="kw">_ </span>=&gt; BrotliEncoderMode::BROTLI_MODE_GENERIC,
    };
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_QUALITY <span class="kw">as </span>(i32) {
    params.quality = value <span class="kw">as </span>(i32);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_STRIDE_DETECTION_QUALITY <span class="kw">as </span>(i32) {
    params.stride_detection_quality = value <span class="kw">as </span>(u8);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_HIGH_ENTROPY_DETECTION_QUALITY <span class="kw">as </span>(i32) {
    params.high_entropy_detection_quality = value <span class="kw">as </span>(u8);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_CDF_ADAPTATION_DETECTION <span class="kw">as </span>(i32) {
    params.cdf_adaptation_detection = value <span class="kw">as </span>(u8);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_Q9_5 <span class="kw">as </span>(i32) {
    params.q9_5 = (value != <span class="number">0</span>);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_PRIOR_BITMASK_DETECTION <span class="kw">as </span>(i32) {
    params.prior_bitmask_detection = value <span class="kw">as </span>u8;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_SPEED <span class="kw">as </span>(i32) {
    params.literal_adaptation[<span class="number">1</span>].<span class="number">0 </span>= value <span class="kw">as </span>u16;
    <span class="kw">if </span>params.literal_adaptation[<span class="number">0</span>] == (<span class="number">0</span>,<span class="number">0</span>) {
        params.literal_adaptation[<span class="number">0</span>].<span class="number">0 </span>= value <span class="kw">as </span>u16;
    }
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_SPEED_MAX <span class="kw">as </span>(i32) {
    params.literal_adaptation[<span class="number">1</span>].<span class="number">1 </span>= value <span class="kw">as </span>u16;
    <span class="kw">if </span>params.literal_adaptation[<span class="number">0</span>].<span class="number">1 </span>== <span class="number">0 </span>{
        params.literal_adaptation[<span class="number">0</span>].<span class="number">1 </span>= value <span class="kw">as </span>u16;
    }
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_CM_SPEED <span class="kw">as </span>(i32) {
    params.literal_adaptation[<span class="number">3</span>].<span class="number">0 </span>= value <span class="kw">as </span>u16;
    <span class="kw">if </span>params.literal_adaptation[<span class="number">2</span>] == (<span class="number">0</span>,<span class="number">0</span>) {
        params.literal_adaptation[<span class="number">2</span>].<span class="number">0 </span>= value <span class="kw">as </span>u16;
    }
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_CM_SPEED_MAX <span class="kw">as </span>(i32) {
    params.literal_adaptation[<span class="number">3</span>].<span class="number">1 </span>= value <span class="kw">as </span>u16;
    <span class="kw">if </span>params.literal_adaptation[<span class="number">2</span>].<span class="number">1 </span>== <span class="number">0 </span>{
        params.literal_adaptation[<span class="number">2</span>].<span class="number">1 </span>= value <span class="kw">as </span>u16;
    }
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_SPEED_LOW <span class="kw">as </span>(i32) {
    params.literal_adaptation[<span class="number">0</span>].<span class="number">0 </span>= value <span class="kw">as </span>u16;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_SPEED_LOW_MAX <span class="kw">as </span>(i32) {
    params.literal_adaptation[<span class="number">0</span>].<span class="number">1 </span>= value <span class="kw">as </span>u16;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_CM_SPEED_LOW <span class="kw">as </span>(i32) {
    params.literal_adaptation[<span class="number">2</span>].<span class="number">0 </span>= value <span class="kw">as </span>u16;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_CM_SPEED_LOW_MAX <span class="kw">as </span>(i32) {
    params.literal_adaptation[<span class="number">2</span>].<span class="number">1 </span>= value <span class="kw">as </span>u16;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_LITERAL_BYTE_SCORE <span class="kw">as </span>(i32) {
    params.hasher.literal_byte_score = value <span class="kw">as </span>i32;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_METABLOCK_CALLBACK <span class="kw">as </span>(i32) {
    params.log_meta_block = <span class="kw">if </span>value != <span class="number">0 </span>{<span class="bool-val">true</span>} <span class="kw">else </span>{<span class="bool-val">false</span>};
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_LGWIN <span class="kw">as </span>(i32) {
    params.lgwin = value <span class="kw">as </span>(i32);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_LGBLOCK <span class="kw">as </span>(i32) {
    params.lgblock = value <span class="kw">as </span>(i32);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING <span class="kw">as </span>(i32) {
    <span class="kw">if </span>value != <span class="number">0u32 </span>&amp;&amp; (value != <span class="number">1u32</span>) {
      <span class="kw">return </span><span class="number">0i32</span>;
    }
    params.disable_literal_context_modeling = <span class="kw">if </span>!!!(value == <span class="number">0</span>) { <span class="number">1i32 </span>} <span class="kw">else </span>{ <span class="number">0i32 </span>};
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_SIZE_HINT <span class="kw">as </span>(i32) {
    params.size_hint = value <span class="kw">as </span>(usize);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_LARGE_WINDOW <span class="kw">as </span>(i32) {
    params.large_window = value != <span class="number">0</span>;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_AVOID_DISTANCE_PREFIX_SEARCH <span class="kw">as </span>(i32) {
    params.avoid_distance_prefix_search = value != <span class="number">0</span>;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_CATABLE <span class="kw">as </span>(i32) {
    params.catable = value != <span class="number">0</span>;
    <span class="kw">if </span>!params.appendable {
      params.appendable = value != <span class="number">0</span>;
    }
    params.use_dictionary = (value == <span class="number">0</span>);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_APPENDABLE <span class="kw">as </span>(i32) {
    params.appendable = value != <span class="number">0</span>;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_MAGIC_NUMBER <span class="kw">as </span>(i32) {
    params.magic_number = value != <span class="number">0</span>;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>p <span class="kw">as </span>(i32) == BrotliEncoderParameter::BROTLI_PARAM_FAVOR_EFFICIENCY <span class="kw">as </span>(i32) {
    params.favor_cpu_efficiency = value != <span class="number">0</span>;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="number">0i32  
</span>}

<span class="kw">pub fn </span>BrotliEncoderSetParameter&lt;Alloc: BrotliAlloc&gt;
  (state: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
   p: BrotliEncoderParameter,
   value: u32)
   -&gt; i32 {
  <span class="kw">if </span>(<span class="kw-2">*</span>state).is_initialized_ {
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  set_parameter(<span class="kw-2">&amp;mut </span>state.params, p, value)
}
<span class="comment">/* &quot;Large Window Brotli&quot; */
</span><span class="kw">pub const </span>BROTLI_LARGE_MAX_DISTANCE_BITS: u32 = <span class="number">62</span>;
<span class="kw">pub const </span>BROTLI_LARGE_MIN_WBITS: u32 = <span class="number">10</span>;
<span class="kw">pub const </span>BROTLI_LARGE_MAX_WBITS: u32 = <span class="number">30</span>;

<span class="kw">pub const </span>BROTLI_MAX_DISTANCE_BITS:u32 = <span class="number">24</span>;
<span class="kw">pub const </span>BROTLI_MAX_WINDOW_BITS:usize = BROTLI_MAX_DISTANCE_BITS <span class="kw">as </span>usize;
<span class="kw">pub const </span>BROTLI_MAX_DISTANCE:usize = <span class="number">0x3FFFFFC</span>;
<span class="kw">pub const </span>BROTLI_MAX_ALLOWED_DISTANCE:usize = <span class="number">0x7FFFFFC</span>;
<span class="kw">pub const </span>BROTLI_NUM_DISTANCE_SHORT_CODES:u32 = <span class="number">16</span>;
<span class="kw">pub fn </span>BROTLI_DISTANCE_ALPHABET_SIZE(NPOSTFIX: u32, NDIRECT:u32, MAXNBITS: u32) -&gt; u32 {
    BROTLI_NUM_DISTANCE_SHORT_CODES + (NDIRECT) +
        ((MAXNBITS) &lt;&lt; ((NPOSTFIX) + <span class="number">1</span>))
}

<span class="comment">//#define BROTLI_NUM_DISTANCE_SYMBOLS \
//    BROTLI_DISTANCE_ALPHABET_SIZE(  \
//        BROTLI_MAX_NDIRECT, BROTLI_MAX_NPOSTFIX, BROTLI_LARGE_MAX_DISTANCE_BITS)

</span><span class="kw">pub const </span>BROTLI_NUM_DISTANCE_SYMBOLS:usize = <span class="number">1128</span>;

<span class="kw">pub fn </span>BrotliEncoderInitParams() -&gt; BrotliEncoderParams {
    <span class="kw">return </span>BrotliEncoderParams {
           dist: BrotliDistanceParams {
               distance_postfix_bits:<span class="number">0</span>,
               num_direct_distance_codes:<span class="number">0</span>,
               alphabet_size: BROTLI_DISTANCE_ALPHABET_SIZE(<span class="number">0</span>, <span class="number">0</span>, BROTLI_MAX_DISTANCE_BITS),
               max_distance: BROTLI_MAX_DISTANCE,
           },
           mode: BrotliEncoderMode::BROTLI_MODE_GENERIC,
           log_meta_block: <span class="bool-val">false</span>,
           large_window:<span class="bool-val">false</span>,
           avoid_distance_prefix_search:<span class="bool-val">false</span>,
           quality: <span class="number">11</span>,
           q9_5: <span class="bool-val">false</span>,
           lgwin: <span class="number">22i32</span>,
           lgblock: <span class="number">0i32</span>,
           size_hint: <span class="number">0usize</span>,
           disable_literal_context_modeling: <span class="number">0i32</span>,
           stride_detection_quality: <span class="number">0</span>,
           high_entropy_detection_quality: <span class="number">0</span>,
           cdf_adaptation_detection: <span class="number">0</span>,
           prior_bitmask_detection: <span class="number">0</span>,
           literal_adaptation: [(<span class="number">0</span>,<span class="number">0</span>);<span class="number">4</span>],
           catable: <span class="bool-val">false</span>,
           use_dictionary: <span class="bool-val">true</span>,
           appendable: <span class="bool-val">false</span>,
           magic_number: <span class="bool-val">false</span>,
           favor_cpu_efficiency:<span class="bool-val">false</span>,
           hasher: BrotliHasherParams {
             type_: <span class="number">6</span>,
             block_bits: <span class="number">9 </span>- <span class="number">1</span>,
             bucket_bits: <span class="number">15</span>,
             hash_len: <span class="number">5</span>,
             num_last_distances_to_check: <span class="number">16</span>,
             literal_byte_score: <span class="number">0</span>,
           },
         };
}

<span class="kw">fn </span>ExtendLastCommand&lt;Alloc:BrotliAlloc&gt;(
    s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
    bytes: <span class="kw-2">&amp;mut </span>u32,
    wrapped_last_processed_pos: <span class="kw-2">&amp;mut </span>u32
) {
    <span class="kw">let </span>last_command = <span class="kw-2">&amp;mut </span>s.commands_.slice_mut()[s.num_commands_ - <span class="number">1</span>];
   
    <span class="kw">let </span>mask = s.ringbuffer_.mask_;
    <span class="kw">let </span>max_backward_distance:u64 = (<span class="number">1u64 </span>&lt;&lt; s.params.lgwin) - BROTLI_WINDOW_GAP <span class="kw">as </span>u64;
    <span class="kw">let </span>last_copy_len = u64::from(last_command.copy_len_) &amp; <span class="number">0x1ffffff</span>;
    <span class="kw">let </span>last_processed_pos:u64 = s.last_processed_pos_ - last_copy_len;
    <span class="kw">let </span>max_distance:u64 = <span class="kw">if </span>last_processed_pos &lt; max_backward_distance {
        last_processed_pos
    } <span class="kw">else </span>{
        max_backward_distance
    };
    <span class="kw">let </span>cmd_dist:u64 = s.dist_cache_[<span class="number">0</span>] <span class="kw">as </span>u64;
    <span class="kw">let </span>distance_code:u32 = <span class="kw">super</span>::command::CommandRestoreDistanceCode(last_command, <span class="kw-2">&amp;</span>s.params.dist);
    <span class="kw">if </span>(distance_code &lt; BROTLI_NUM_DISTANCE_SHORT_CODES ||
        distance_code <span class="kw">as </span>u64 - (BROTLI_NUM_DISTANCE_SHORT_CODES - <span class="number">1</span>) <span class="kw">as </span>u64 == cmd_dist) {
        <span class="kw">if </span>(cmd_dist &lt;= max_distance) {
            <span class="kw">while </span>(<span class="kw-2">*</span>bytes != <span class="number">0 </span>&amp;&amp;
                   s.ringbuffer_.data_mo.slice()[s.ringbuffer_.buffer_index + (<span class="kw-2">*</span>wrapped_last_processed_pos <span class="kw">as </span>usize &amp; mask <span class="kw">as </span>usize)] ==
                   s.ringbuffer_.data_mo.slice()[s.ringbuffer_.buffer_index + (((<span class="kw-2">*</span>wrapped_last_processed_pos <span class="kw">as </span>usize).wrapping_sub(cmd_dist <span class="kw">as </span>usize)) &amp; mask <span class="kw">as </span>usize)]) {
                last_command.copy_len_+=<span class="number">1</span>;
                (<span class="kw-2">*</span>bytes)-=<span class="number">1</span>;
                (<span class="kw-2">*</span>wrapped_last_processed_pos)+=<span class="number">1</span>;
            }
        }
        <span class="comment">/* The copy length is at most the metablock size, and thus expressible. */
        </span>GetLengthCode(last_command.insert_len_ <span class="kw">as </span>usize,
                      ((last_command.copy_len_ &amp; <span class="number">0x1FFFFFF</span>) <span class="kw">as </span>i32 +
                       (last_command.copy_len_ &gt;&gt; <span class="number">25</span>) <span class="kw">as </span>i32) <span class="kw">as </span>usize,
                      ((last_command.dist_prefix_ &amp; <span class="number">0x3FF</span>) == <span class="number">0</span>) <span class="kw">as </span>i32,
                      <span class="kw-2">&amp;mut </span>last_command.cmd_prefix_);
    }
}


<span class="kw">fn </span>RingBufferInit&lt;AllocU8: alloc::Allocator&lt;u8&gt;&gt;() -&gt; RingBuffer&lt;AllocU8&gt; {
  <span class="kw">return </span>RingBuffer {
           size_: <span class="number">0</span>,
           mask_: <span class="number">0</span>, <span class="comment">// 0xff??
           </span>tail_size_: <span class="number">0</span>,
           total_size_: <span class="number">0</span>,

           cur_size_: <span class="number">0</span>,
           pos_: <span class="number">0</span>,
           data_mo: AllocU8::AllocatedMemory::default(),
           buffer_index: <span class="number">0usize</span>,
         };
}

<span class="kw">pub fn </span>BrotliEncoderCreateInstance&lt;Alloc: BrotliAlloc&gt;
  (m8: Alloc)
   -&gt; BrotliEncoderStateStruct&lt;Alloc&gt; {
  <span class="kw">let </span>cache: [i32; <span class="number">16</span>] = [<span class="number">4</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
  BrotliEncoderStateStruct::&lt;Alloc&gt; {
    params: BrotliEncoderInitParams(),
    input_pos_: <span class="number">0</span>,
    num_commands_: <span class="number">0usize</span>,
    num_literals_: <span class="number">0usize</span>,
    last_insert_len_: <span class="number">0usize</span>,
    last_flush_pos_: <span class="number">0</span>,
    last_processed_pos_: <span class="number">0</span>,
    prev_byte_: <span class="number">0i32 </span><span class="kw">as </span>(u8),
    prev_byte2_: <span class="number">0i32 </span><span class="kw">as </span>(u8),
    storage_size_: <span class="number">0usize</span>,
    storage_: &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory::default(),
    hasher_: UnionHasher::&lt;Alloc&gt;::default(),
    large_table_: &lt;Alloc <span class="kw">as </span>Allocator&lt;i32&gt;&gt;::AllocatedMemory::default(),
<span class="comment">//    large_table_size_: 0usize,
    </span>cmd_code_numbits_: <span class="number">0usize</span>,
    command_buf_: &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::AllocatedMemory::default(),
    literal_buf_: &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory::default(),
    next_out_: NextOut::None,
    available_out_: <span class="number">0usize</span>,
    total_out_: <span class="number">0u64</span>,
    is_first_mb: IsFirst::NothingWritten,
    stream_state_: BrotliEncoderStreamState::BROTLI_STREAM_PROCESSING,
    is_last_block_emitted_: <span class="bool-val">false</span>,
    is_initialized_: <span class="bool-val">false</span>,
    ringbuffer_: RingBufferInit(),
    commands_: &lt;Alloc <span class="kw">as </span>Allocator&lt;Command&gt;&gt;::AllocatedMemory::default(),
    cmd_alloc_size_: <span class="number">0usize</span>,
    dist_cache_: cache,
    saved_dist_cache_: [cache[<span class="number">0</span>], cache[<span class="number">1</span>], cache[<span class="number">2</span>], cache[<span class="number">3</span>]],
    cmd_bits_: [<span class="number">0</span>; <span class="number">128</span>],
    cmd_depths_: [<span class="number">0</span>; <span class="number">128</span>],
    last_bytes_: <span class="number">0</span>,
    last_bytes_bits_: <span class="number">0</span>,
    cmd_code_: [<span class="number">0</span>; <span class="number">512</span>],
    m8: m8,
    remaining_metadata_bytes_: <span class="number">0</span>,
    small_table_: [<span class="number">0</span>; <span class="number">1024</span>],
    tiny_buf_: [<span class="number">0</span>; <span class="number">16</span>],
    literal_scratch_space: HistogramLiteral::make_nnz_storage(),
    command_scratch_space: HistogramCommand::make_nnz_storage(),
    distance_scratch_space: HistogramDistance::make_nnz_storage(),
    recoder_state: RecoderState::new(),
    custom_dictionary: <span class="bool-val">false</span>,
  }
}

<span class="kw">fn </span>RingBufferFree&lt;AllocU8: alloc::Allocator&lt;u8&gt;&gt;(m: <span class="kw-2">&amp;mut </span>AllocU8,
                                                 rb: <span class="kw-2">&amp;mut </span>RingBuffer&lt;AllocU8&gt;) {
  m.free_cell(core::mem::replace(<span class="kw-2">&amp;mut </span>rb.data_mo, AllocU8::AllocatedMemory::default()));
}
<span class="kw">fn </span>DestroyHasher&lt;Alloc:alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;&gt;(
m16: <span class="kw-2">&amp;mut </span>Alloc, handle: <span class="kw-2">&amp;mut </span>UnionHasher&lt;Alloc&gt;){
  handle.free(m16);
}
<span class="comment">/*
fn DestroyHasher&lt;AllocU16:alloc::Allocator&lt;u16&gt;, AllocU32:alloc::Allocator&lt;u32&gt;&gt;(
m16: &amp;mut AllocU16, m32:&amp;mut AllocU32, handle: &amp;mut UnionHasher&lt;AllocU16, AllocU32&gt;){
  match handle {
    &amp;mut UnionHasher::H2(ref mut hasher) =&gt; {
        m32.free_cell(core::mem::replace(&amp;mut hasher.buckets_.buckets_, &lt;Alloc as Allocator&lt;u32&gt;&gt;::AllocatedMemory::default()));
    }
    &amp;mut UnionHasher::H3(ref mut hasher) =&gt; {
        m32.free_cell(core::mem::replace(&amp;mut hasher.buckets_.buckets_, &lt;Alloc as Allocator&lt;u32&gt;&gt;::AllocatedMemory::default()));
    }
    &amp;mut UnionHasher::H4(ref mut hasher) =&gt; {
        m32.free_cell(core::mem::replace(&amp;mut hasher.buckets_.buckets_, &lt;Alloc as Allocator&lt;u32&gt;&gt;::AllocatedMemory::default()));
    }
    &amp;mut UnionHasher::H54(ref mut hasher) =&gt; {
        m32.free_cell(core::mem::replace(&amp;mut hasher.buckets_.buckets_, &lt;Alloc as Allocator&lt;u32&gt;&gt;::AllocatedMemory::default()));
    }
    &amp;mut UnionHasher::H5(ref mut hasher) =&gt; {
      m16.free_cell(core::mem::replace(&amp;mut hasher.num, AllocU16::AllocatedMemory::default()));
      m32.free_cell(core::mem::replace(&amp;mut hasher.buckets, &lt;Alloc as Allocator&lt;u32&gt;&gt;::AllocatedMemory::default()));
    }
    &amp;mut UnionHasher::H6(ref mut hasher) =&gt; {
      m16.free_cell(core::mem::replace(&amp;mut hasher.num, AllocU16::AllocatedMemory::default()));
      m32.free_cell(core::mem::replace(&amp;mut hasher.buckets, &lt;Alloc as Allocator&lt;u32&gt;&gt;::AllocatedMemory::default()));
    }
    &amp;mut UnionHasher::H9(ref mut hasher) =&gt; {
      m16.free_cell(core::mem::replace(&amp;mut hasher.num_, AllocU16::AllocatedMemory::default()));
      m32.free_cell(core::mem::replace(&amp;mut hasher.buckets_, &lt;Alloc as Allocator&lt;u32&gt;&gt;::AllocatedMemory::default()));
    }
    _ =&gt; {}
  }
  *handle = UnionHasher::&lt;AllocU16, AllocU32&gt;::default();
}
*/

</span><span class="kw">fn </span>BrotliEncoderCleanupState&lt;Alloc:BrotliAlloc&gt;
  (s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;) {
  {
    &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::free_cell(<span class="kw-2">&amp;mut </span>s.m8, core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).storage_,
                                                                      &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory::default()));
  }
  {
    &lt;Alloc <span class="kw">as </span>Allocator&lt;Command&gt;&gt;::free_cell(<span class="kw-2">&amp;mut </span>s.m8, core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).commands_,
                                                                           &lt;Alloc <span class="kw">as </span>Allocator&lt;Command&gt;&gt;::AllocatedMemory::default()));
  }
  RingBufferFree(<span class="kw-2">&amp;mut </span>s.m8, <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).ringbuffer_);
  DestroyHasher(<span class="kw-2">&amp;mut </span>s.m8, <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).hasher_);
  {
    &lt;Alloc <span class="kw">as </span>Allocator&lt;i32&gt;&gt;::free_cell(<span class="kw-2">&amp;mut </span>s.m8, core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).large_table_,
                                       &lt;Alloc <span class="kw">as </span>Allocator&lt;i32&gt;&gt;::AllocatedMemory::default()));
  }
  {
    &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::free_cell(<span class="kw-2">&amp;mut </span>s.m8, core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).command_buf_,
                                       &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::AllocatedMemory::default()));
  }
  {
    &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::free_cell(<span class="kw-2">&amp;mut </span>s.m8, core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).literal_buf_, &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory::default()));
  }
}

<span class="kw">pub fn </span>BrotliEncoderDestroyInstance&lt;Alloc: BrotliAlloc&gt;
  (s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;) {
  BrotliEncoderCleanupState(s);
}

<span class="kw">fn </span>brotli_min_int(a: i32, b: i32) -&gt; i32 {
  <span class="kw">if </span>a &lt; b { a } <span class="kw">else </span>{ b }
}

<span class="kw">fn </span>brotli_max_int(a: i32, b: i32) -&gt; i32 {
  <span class="kw">if </span>a &gt; b { a } <span class="kw">else </span>{ b }
}

<span class="attribute">#[cfg(not(feature=<span class="string">&quot;disallow_large_window_size&quot;</span>))]
</span><span class="kw">fn </span>check_large_window_ok() -&gt; bool {
  <span class="bool-val">true
</span>}
<span class="attribute">#[cfg(feature=<span class="string">&quot;disallow_large_window_size&quot;</span>)]
</span><span class="kw">fn </span>check_large_window_ok() -&gt; bool {
  <span class="bool-val">false
</span>}


<span class="kw">pub fn </span>SanitizeParams(params: <span class="kw-2">&amp;mut </span>BrotliEncoderParams) {
  (<span class="kw-2">*</span>params).quality = brotli_min_int(<span class="number">11i32</span>, brotli_max_int(<span class="number">0i32</span>, (<span class="kw-2">*</span>params).quality));
  <span class="kw">if </span>(<span class="kw-2">*</span>params).lgwin &lt; <span class="number">10i32 </span>{
    (<span class="kw-2">*</span>params).lgwin = <span class="number">10i32</span>;
  } <span class="kw">else if </span>(<span class="kw-2">*</span>params).lgwin &gt; <span class="number">24i32 </span>{
    <span class="kw">if </span>params.large_window &amp;&amp; check_large_window_ok() {
      <span class="kw">if </span>(<span class="kw-2">*</span>params).lgwin &gt; <span class="number">30i32 </span>{
        (<span class="kw-2">*</span>params).lgwin = <span class="number">30i32</span>;
      }
    } <span class="kw">else </span>{
      (<span class="kw-2">*</span>params).lgwin = <span class="number">24i32</span>;
    }
  }
  <span class="kw">if </span>params.catable {
      params.appendable = <span class="bool-val">true</span>;
  }
}

<span class="kw">fn </span>ComputeLgBlock(params: <span class="kw-2">&amp;</span>BrotliEncoderParams) -&gt; i32 {
  <span class="kw">let </span><span class="kw-2">mut </span>lgblock: i32 = (<span class="kw-2">*</span>params).lgblock;
  <span class="kw">if </span>(<span class="kw-2">*</span>params).quality == <span class="number">0i32 </span>|| (<span class="kw-2">*</span>params).quality == <span class="number">1i32 </span>{
    lgblock = (<span class="kw-2">*</span>params).lgwin;
  } <span class="kw">else if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">4i32 </span>{
    lgblock = <span class="number">14i32</span>;
  } <span class="kw">else if </span>lgblock == <span class="number">0i32 </span>{
    lgblock = <span class="number">16i32</span>;
    <span class="kw">if </span>(<span class="kw-2">*</span>params).quality &gt;= <span class="number">9i32 </span>&amp;&amp; ((<span class="kw-2">*</span>params).lgwin &gt; lgblock) {
      lgblock = brotli_min_int(<span class="number">18i32</span>, (<span class="kw-2">*</span>params).lgwin);
    }
  } <span class="kw">else </span>{
    lgblock = brotli_min_int(<span class="number">24i32</span>, brotli_max_int(<span class="number">16i32</span>, lgblock));
  }
  lgblock
}

<span class="kw">fn </span>ComputeRbBits(params: <span class="kw-2">&amp;</span>BrotliEncoderParams) -&gt; i32 {
  <span class="number">1i32 </span>+ brotli_max_int((<span class="kw-2">*</span>params).lgwin, (<span class="kw-2">*</span>params).lgblock)
}

<span class="kw">fn </span>RingBufferSetup&lt;AllocU8: alloc::Allocator&lt;u8&gt;&gt;(params: <span class="kw-2">&amp;</span>BrotliEncoderParams,
                                                  rb: <span class="kw-2">&amp;mut </span>RingBuffer&lt;AllocU8&gt;) {
  <span class="kw">let </span>window_bits: i32 = ComputeRbBits(params);
  <span class="kw">let </span>tail_bits: i32 = (<span class="kw-2">*</span>params).lgblock;
  <span class="kw-2">*</span>(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>rb).size_) = <span class="number">1u32 </span>&lt;&lt; window_bits;
  <span class="kw-2">*</span>(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>rb).mask_) = (<span class="number">1u32 </span>&lt;&lt; window_bits).wrapping_sub(<span class="number">1u32</span>);
  <span class="kw-2">*</span>(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>rb).tail_size_) = <span class="number">1u32 </span>&lt;&lt; tail_bits;
  <span class="kw-2">*</span>(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>rb).total_size_) = (<span class="kw-2">*</span>rb).size_.wrapping_add((<span class="kw-2">*</span>rb).tail_size_);
}

<span class="kw">fn </span>EncodeWindowBits(lgwin: i32, large_window: bool, last_bytes: <span class="kw-2">&amp;mut </span>u16, last_bytes_bits: <span class="kw-2">&amp;mut </span>u8) {
    <span class="kw">if </span>large_window {
        <span class="kw-2">*</span>last_bytes = (((lgwin &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">8</span>) | <span class="number">0x11</span>) <span class="kw">as </span>u16;
        <span class="kw-2">*</span>last_bytes_bits = <span class="number">14</span>;
    } <span class="kw">else </span>{
        <span class="kw">if </span>lgwin == <span class="number">16i32 </span>{
            <span class="kw-2">*</span>last_bytes = <span class="number">0i32 </span><span class="kw">as </span>(u16);
            <span class="kw-2">*</span>last_bytes_bits = <span class="number">1i32 </span><span class="kw">as </span>(u8);
        } <span class="kw">else if </span>lgwin == <span class="number">17i32 </span>{
            <span class="kw-2">*</span>last_bytes = <span class="number">1i32 </span><span class="kw">as </span>(u16);
            <span class="kw-2">*</span>last_bytes_bits = <span class="number">7i32 </span><span class="kw">as </span>(u8);
        } <span class="kw">else if </span>lgwin &gt; <span class="number">17i32 </span>{
            <span class="kw-2">*</span>last_bytes = (lgwin - <span class="number">17i32 </span>&lt;&lt; <span class="number">1i32 </span>| <span class="number">1i32</span>) <span class="kw">as </span>(u16);
            <span class="kw-2">*</span>last_bytes_bits = <span class="number">4i32 </span><span class="kw">as </span>(u8);
        } <span class="kw">else </span>{
            <span class="kw-2">*</span>last_bytes = (lgwin - <span class="number">8i32 </span>&lt;&lt; <span class="number">4i32 </span>| <span class="number">1i32</span>) <span class="kw">as </span>(u16);
            <span class="kw-2">*</span>last_bytes_bits = <span class="number">7i32 </span><span class="kw">as </span>(u8);
        }
    }
}

<span class="kw">fn </span>InitCommandPrefixCodes(cmd_depths: <span class="kw-2">&amp;mut </span>[u8],
                          cmd_bits: <span class="kw-2">&amp;mut </span>[u16],
                          cmd_code: <span class="kw-2">&amp;mut </span>[u8],
                          cmd_code_numbits: <span class="kw-2">&amp;mut </span>usize) {
  <span class="kw">static </span>kDefaultCommandDepths: [u8; <span class="number">128</span>] = [
    <span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,
    <span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,
    <span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,
    <span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>];
  <span class="kw">static </span>kDefaultCommandBits: [u16; <span class="number">128</span>] = [
    <span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">35</span>,<span class="number">7</span>,<span class="number">71</span>,<span class="number">39</span>,<span class="number">103</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">175</span>,<span class="number">111</span>,<span class="number">239</span>,<span class="number">31</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">13</span>,<span class="number">29</span>,
    <span class="number">11</span>,<span class="number">43</span>,<span class="number">27</span>,<span class="number">59</span>,<span class="number">87</span>,<span class="number">55</span>,<span class="number">15</span>,<span class="number">79</span>,<span class="number">319</span>,<span class="number">831</span>,<span class="number">191</span>,<span class="number">703</span>,<span class="number">447</span>,<span class="number">959</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">25</span>,<span class="number">5</span>,<span class="number">21</span>,<span class="number">19</span>,<span class="number">51</span>,
    <span class="number">119</span>,<span class="number">159</span>,<span class="number">95</span>,<span class="number">223</span>,<span class="number">479</span>,<span class="number">991</span>,<span class="number">63</span>,<span class="number">575</span>,<span class="number">127</span>,<span class="number">639</span>,<span class="number">383</span>,<span class="number">895</span>,<span class="number">255</span>,<span class="number">767</span>,<span class="number">511</span>,<span class="number">1023</span>,<span class="number">14</span>,
    <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">27</span>,<span class="number">59</span>,<span class="number">7</span>,<span class="number">39</span>,<span class="number">23</span>,<span class="number">55</span>,<span class="number">30</span>,<span class="number">1</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">25</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">12</span>,
    <span class="number">2</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">29</span>,<span class="number">3</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">47</span>,<span class="number">31</span>,<span class="number">95</span>,<span class="number">63</span>,<span class="number">127</span>,<span class="number">255</span>,<span class="number">767</span>,<span class="number">2815</span>,<span class="number">1791</span>,<span class="number">3839</span>,
    <span class="number">511</span>,<span class="number">2559</span>,<span class="number">1535</span>,<span class="number">3583</span>,<span class="number">1023</span>,<span class="number">3071</span>,<span class="number">2047</span>,<span class="number">4095</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>];
  <span class="kw">static </span>kDefaultCommandCode: [u8; <span class="number">57</span>] = [
    <span class="number">0xff</span>,<span class="number">0x77</span>,<span class="number">0xd5</span>,<span class="number">0xbf</span>,<span class="number">0xe7</span>,<span class="number">0xde</span>,<span class="number">0xea</span>,<span class="number">0x9e</span>,<span class="number">0x51</span>,<span class="number">0x5d</span>,<span class="number">0xde</span>,<span class="number">0xc6</span>,<span class="number">0x70</span>,<span class="number">0x57</span>,
    <span class="number">0xbc</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0x58</span>,<span class="number">0xd8</span>,<span class="number">0xd8</span>,<span class="number">0x58</span>,<span class="number">0xd5</span>,<span class="number">0xcb</span>,<span class="number">0x8c</span>,<span class="number">0xea</span>,<span class="number">0xe0</span>,<span class="number">0xc3</span>,<span class="number">0x87</span>,
    <span class="number">0x1f</span>,<span class="number">0x83</span>,<span class="number">0xc1</span>,<span class="number">0x60</span>,<span class="number">0x1c</span>,<span class="number">0x67</span>,<span class="number">0xb2</span>,<span class="number">0xaa</span>,<span class="number">0x6</span>,<span class="number">0x83</span>,<span class="number">0xc1</span>,<span class="number">0x60</span>,<span class="number">0x30</span>,<span class="number">0x18</span>,
    <span class="number">0xcc</span>,<span class="number">0xa1</span>,<span class="number">0xce</span>,<span class="number">0x88</span>,<span class="number">0x54</span>,<span class="number">0x94</span>,<span class="number">0x46</span>,<span class="number">0xe1</span>,<span class="number">0xb0</span>,<span class="number">0xd0</span>,<span class="number">0x4e</span>,<span class="number">0xb2</span>,<span class="number">0xf7</span>,<span class="number">0x4</span>,<span class="number">0x0</span>];
  <span class="kw">static </span>kDefaultCommandCodeNumBits: usize = <span class="number">448usize</span>;
  cmd_depths[..].clone_from_slice(<span class="kw-2">&amp;</span>kDefaultCommandDepths[..]);
  cmd_bits[..].clone_from_slice(<span class="kw-2">&amp;</span>kDefaultCommandBits[..]);
  cmd_code[..kDefaultCommandCode.len()].clone_from_slice(<span class="kw-2">&amp;</span>kDefaultCommandCode[..]);
  <span class="kw-2">*</span>cmd_code_numbits = kDefaultCommandCodeNumBits;
}

<span class="kw">fn </span>EnsureInitialized&lt;Alloc: BrotliAlloc&gt;
  (s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;)
   -&gt; i32 {
  <span class="kw">if </span>(<span class="kw-2">*</span>s).is_initialized_ {
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  SanitizeParams(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).params);
  (<span class="kw-2">*</span>s).params.lgblock = ComputeLgBlock(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).params);
  ChooseDistanceParams(<span class="kw-2">&amp;mut </span>s.params);
  (<span class="kw-2">*</span>s).remaining_metadata_bytes_ = !(<span class="number">0u32</span>);
  RingBufferSetup(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).params, <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).ringbuffer_);
  {
    <span class="kw">let </span><span class="kw-2">mut </span>lgwin: i32 = (<span class="kw-2">*</span>s).params.lgwin;
    <span class="kw">if </span>(<span class="kw-2">*</span>s).params.quality == <span class="number">0i32 </span>|| (<span class="kw-2">*</span>s).params.quality == <span class="number">1i32 </span>{
      lgwin = brotli_max_int(lgwin, <span class="number">18i32</span>);
    }
    EncodeWindowBits(lgwin, s.params.large_window, <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).last_bytes_, <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).last_bytes_bits_);
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).params.quality == <span class="number">0i32 </span>{
    InitCommandPrefixCodes(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_depths_[..],
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_bits_[..],
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_code_[..],
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_code_numbits_);
  }
  <span class="kw">if </span>s.params.catable {
    <span class="comment">// if we want to properly concatenate, then we need to ignore any distances
    // this value 0x7ffffff0 was chosen to be larger than max_distance + gap
    // but small enough so that +/-3 will not overflow (due to distance modifications)
    </span><span class="kw">for </span>item <span class="kw">in </span>s.dist_cache_.iter_mut() {
      <span class="kw-2">*</span>item = <span class="number">0x7ffffff0</span>;
    }
    <span class="kw">for </span>item <span class="kw">in </span>s.saved_dist_cache_.iter_mut() {
      <span class="kw-2">*</span>item = <span class="number">0x7ffffff0</span>;
    }
  }
  (<span class="kw-2">*</span>s).is_initialized_ = <span class="bool-val">true</span>;
  <span class="number">1i32
</span>}

<span class="kw">fn </span>RingBufferInitBuffer&lt;AllocU8: alloc::Allocator&lt;u8&gt;&gt;(m: <span class="kw-2">&amp;mut </span>AllocU8,
                                                       buflen: u32,
                                                       rb: <span class="kw-2">&amp;mut </span>RingBuffer&lt;AllocU8&gt;) {
  <span class="kw">static </span>kSlackForEightByteHashingEverywhere: usize = <span class="number">7usize</span>;
  <span class="kw">let </span><span class="kw-2">mut </span>new_data =
    m.alloc_cell(((<span class="number">2u32</span>).wrapping_add(buflen) <span class="kw">as </span>(usize))
                   .wrapping_add(kSlackForEightByteHashingEverywhere));
  <span class="kw">let </span><span class="kw-2">mut </span>i: usize;
  <span class="kw">if </span>(<span class="kw-2">*</span>rb).data_mo.slice().len() != <span class="number">0 </span>{
    <span class="kw">let </span>lim: usize = ((<span class="number">2u32</span>).wrapping_add((<span class="kw-2">*</span>rb).cur_size_) <span class="kw">as </span>(usize))
      .wrapping_add(kSlackForEightByteHashingEverywhere);
    new_data.slice_mut()[..lim].clone_from_slice(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span>rb).data_mo.slice()[..lim]);
    m.free_cell(core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>rb).data_mo, AllocU8::AllocatedMemory::default()));
  }
  <span class="kw">let _ </span>= core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>rb).data_mo, new_data);
  (<span class="kw-2">*</span>rb).cur_size_ = buflen;
  (<span class="kw-2">*</span>rb).buffer_index = <span class="number">2usize</span>;
  (<span class="kw-2">*</span>rb).data_mo.slice_mut()[((<span class="kw-2">*</span>rb).buffer_index.wrapping_sub(<span class="number">2usize</span>))] = <span class="number">0</span>;
  (<span class="kw-2">*</span>rb).data_mo.slice_mut()[((<span class="kw-2">*</span>rb).buffer_index.wrapping_sub(<span class="number">1usize</span>))] = <span class="number">0</span>;
  i = <span class="number">0usize</span>;
  <span class="kw">while </span>i &lt; kSlackForEightByteHashingEverywhere {
    {
      (<span class="kw-2">*</span>rb).data_mo.slice_mut()[((<span class="kw-2">*</span>rb)
         .buffer_index
         .wrapping_add((<span class="kw-2">*</span>rb).cur_size_ <span class="kw">as </span>(usize))
         .wrapping_add(i) <span class="kw">as </span>(usize))] = <span class="number">0</span>;
    }
    i = i.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
  }
}


<span class="kw">fn </span>RingBufferWriteTail&lt;AllocU8: alloc::Allocator&lt;u8&gt;&gt;(bytes: <span class="kw-2">&amp;</span>[u8],
                                                      n: usize,
                                                      rb: <span class="kw-2">&amp;mut </span>RingBuffer&lt;AllocU8&gt;) {
  <span class="kw">let </span>masked_pos: usize = ((<span class="kw-2">*</span>rb).pos_ &amp; (<span class="kw-2">*</span>rb).mask_) <span class="kw">as </span>(usize);
  <span class="kw">if </span>masked_pos &lt; (<span class="kw-2">*</span>rb).tail_size_ <span class="kw">as </span>(usize) {
    <span class="kw">let </span>p: usize = ((<span class="kw-2">*</span>rb).size_ <span class="kw">as </span>(usize)).wrapping_add(masked_pos);
    <span class="kw">let </span>begin = ((<span class="kw-2">*</span>rb).buffer_index.wrapping_add(p) <span class="kw">as </span>(usize));
    <span class="kw">let </span>lim = brotli_min_size_t(n, ((<span class="kw-2">*</span>rb).tail_size_ <span class="kw">as </span>(usize)).wrapping_sub(masked_pos));
    (<span class="kw-2">*</span>rb).data_mo.slice_mut()[begin..(begin + lim)].clone_from_slice(<span class="kw-2">&amp;</span>bytes[..lim]);
  }
}

<span class="kw">fn </span>RingBufferWrite&lt;AllocU8: alloc::Allocator&lt;u8&gt;&gt;(m: <span class="kw-2">&amp;mut </span>AllocU8,
                                                  bytes: <span class="kw-2">&amp;</span>[u8],
                                                  n: usize,
                                                  rb: <span class="kw-2">&amp;mut </span>RingBuffer&lt;AllocU8&gt;) {
  <span class="kw">if </span>(<span class="kw-2">*</span>rb).pos_ == <span class="number">0u32 </span>&amp;&amp; (n &lt; (<span class="kw-2">*</span>rb).tail_size_ <span class="kw">as </span>(usize)) {
    (<span class="kw-2">*</span>rb).pos_ = n <span class="kw">as </span>(u32);
    RingBufferInitBuffer(m, (<span class="kw-2">*</span>rb).pos_, rb);
    (<span class="kw-2">*</span>rb).data_mo.slice_mut()[((<span class="kw-2">*</span>rb).buffer_index <span class="kw">as </span>(usize))..(((<span class="kw-2">*</span>rb).buffer_index <span class="kw">as </span>(usize)) + n)]
      .clone_from_slice(<span class="kw-2">&amp;</span>bytes[..n]);
    <span class="kw">return</span>;
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>rb).cur_size_ &lt; (<span class="kw-2">*</span>rb).total_size_ {
    RingBufferInitBuffer(m, (<span class="kw-2">*</span>rb).total_size_, rb);
    <span class="kw">if </span>!(<span class="number">0i32 </span>== <span class="number">0</span>) {
      <span class="kw">return</span>;
    }
    (<span class="kw-2">*</span>rb).data_mo.slice_mut()[((<span class="kw-2">*</span>rb)
       .buffer_index
       .wrapping_add((<span class="kw-2">*</span>rb).size_ <span class="kw">as </span>(usize))
       .wrapping_sub(<span class="number">2usize</span>) <span class="kw">as </span>(usize))] = <span class="number">0i32 </span><span class="kw">as </span>(u8);
    (<span class="kw-2">*</span>rb).data_mo.slice_mut()[((<span class="kw-2">*</span>rb)
       .buffer_index
       .wrapping_add((<span class="kw-2">*</span>rb).size_ <span class="kw">as </span>(usize))
       .wrapping_sub(<span class="number">1usize</span>) <span class="kw">as </span>(usize))] = <span class="number">0i32 </span><span class="kw">as </span>(u8);
  }
  {
    <span class="kw">let </span>masked_pos: usize = ((<span class="kw-2">*</span>rb).pos_ &amp; (<span class="kw-2">*</span>rb).mask_) <span class="kw">as </span>(usize);
    RingBufferWriteTail(bytes, n, rb);
    <span class="kw">if </span>masked_pos.wrapping_add(n) &lt;= (<span class="kw-2">*</span>rb).size_ <span class="kw">as </span>(usize) {
      <span class="comment">// a single write fits
      </span><span class="kw">let </span>start = ((<span class="kw-2">*</span>rb).buffer_index.wrapping_add(masked_pos) <span class="kw">as </span>(usize));
      (<span class="kw-2">*</span>rb).data_mo.slice_mut()[start..(start + n)].clone_from_slice(<span class="kw-2">&amp;</span>bytes[..n]);
    } <span class="kw">else </span>{
      {
        <span class="kw">let </span>start = ((<span class="kw-2">*</span>rb).buffer_index.wrapping_add(masked_pos) <span class="kw">as </span>(usize));
        <span class="kw">let </span>mid = brotli_min_size_t(n, ((<span class="kw-2">*</span>rb).total_size_ <span class="kw">as </span>(usize)).wrapping_sub(masked_pos));
        (<span class="kw-2">*</span>rb).data_mo.slice_mut()[start..(start + mid)].clone_from_slice(<span class="kw-2">&amp;</span>bytes[..mid]);
      }
      <span class="kw">let </span>xstart = ((<span class="kw-2">*</span>rb).buffer_index.wrapping_add(<span class="number">0usize</span>) <span class="kw">as </span>(usize));
      <span class="kw">let </span>size = n.wrapping_sub(((<span class="kw-2">*</span>rb).size_ <span class="kw">as </span>(usize)).wrapping_sub(masked_pos));
      <span class="kw">let </span>bytes_start = (((<span class="kw-2">*</span>rb).size_ <span class="kw">as </span>(usize)).wrapping_sub(masked_pos) <span class="kw">as </span>(usize));
      (<span class="kw-2">*</span>rb).data_mo.slice_mut()[xstart..(xstart + size)].clone_from_slice(<span class="kw-2">&amp;</span>bytes[bytes_start..
                                                                         (bytes_start +
                                                                          size)]);
    }
  }
  <span class="kw">let </span>data_2 = (<span class="kw-2">*</span>rb).data_mo.slice()[((<span class="kw-2">*</span>rb)
     .buffer_index
     .wrapping_add((<span class="kw-2">*</span>rb).size_ <span class="kw">as </span>(usize))
     .wrapping_sub(<span class="number">2usize</span>) <span class="kw">as </span>(usize))];
  (<span class="kw-2">*</span>rb).data_mo.slice_mut()[((<span class="kw-2">*</span>rb).buffer_index.wrapping_sub(<span class="number">2usize</span>) <span class="kw">as </span>(usize))] = data_2;
  <span class="kw">let </span>data_1 = (<span class="kw-2">*</span>rb).data_mo.slice()[((<span class="kw-2">*</span>rb)
     .buffer_index
     .wrapping_add((<span class="kw-2">*</span>rb).size_ <span class="kw">as </span>(usize))
     .wrapping_sub(<span class="number">1usize</span>) <span class="kw">as </span>(usize))];
  (<span class="kw-2">*</span>rb).data_mo.slice_mut()[((<span class="kw-2">*</span>rb).buffer_index.wrapping_sub(<span class="number">1usize</span>) <span class="kw">as </span>(usize))] = data_1;
  (<span class="kw-2">*</span>rb).pos_ = (<span class="kw-2">*</span>rb).pos_.wrapping_add(n <span class="kw">as </span>(u32));
  <span class="kw">if </span>(<span class="kw-2">*</span>rb).pos_ &gt; <span class="number">1u32 </span>&lt;&lt; <span class="number">30i32 </span>{
    (<span class="kw-2">*</span>rb).pos_ = (<span class="kw-2">*</span>rb).pos_ &amp; (<span class="number">1u32 </span>&lt;&lt; <span class="number">30i32</span>).wrapping_sub(<span class="number">1u32</span>) | <span class="number">1u32 </span>&lt;&lt; <span class="number">30i32</span>;
  }
}

<span class="kw">fn </span>CopyInputToRingBuffer&lt;Alloc: BrotliAlloc&gt;
  (s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
   input_size: usize,
   input_buffer: <span class="kw-2">&amp;</span>[u8]) {
  <span class="kw">if </span>EnsureInitialized(s) == <span class="number">0 </span>{
    <span class="kw">return</span>;
  }
  RingBufferWrite(<span class="kw-2">&amp;mut </span>s.m8, input_buffer, input_size, <span class="kw-2">&amp;mut </span>s.ringbuffer_);
  <span class="kw">if </span>!(<span class="number">0i32 </span>== <span class="number">0</span>) {
    <span class="kw">return</span>;
  }
  (<span class="kw-2">*</span>s).input_pos_ = (<span class="kw-2">*</span>s).input_pos_.wrapping_add(input_size <span class="kw">as </span>u64);
  <span class="kw">if </span>(s.ringbuffer_).pos_ &lt;= (s.ringbuffer_).mask_ {
    <span class="kw">let </span>start = ((s.ringbuffer_).buffer_index.wrapping_add((s.ringbuffer_).pos_ <span class="kw">as </span>(usize)) <span class="kw">as
                 </span>(usize));
    <span class="kw">for </span>item <span class="kw">in </span>(s.ringbuffer_).data_mo.slice_mut()[start..(start + <span class="number">7</span>)].iter_mut() {
      <span class="kw-2">*</span>item = <span class="number">0</span>;
    }
  }
}


<span class="kw">fn </span>ChooseHasher(params: <span class="kw-2">&amp;mut </span>BrotliEncoderParams) {
  <span class="kw">let </span>hparams = <span class="kw-2">&amp;mut </span>params.hasher;
  <span class="kw">if </span>(<span class="kw-2">*</span>params).quality &gt;= <span class="number">10 </span>&amp;&amp; !params.q9_5{
      (<span class="kw-2">*</span>hparams).type_ = <span class="number">10</span>;
  } <span class="kw">else if </span>(<span class="kw-2">*</span>params).quality == <span class="number">10 </span>{ <span class="comment">// we are using quality 10 as a proxy for &quot;9.5&quot;
      </span>(<span class="kw-2">*</span>hparams).type_ = <span class="number">9</span>;
      (<span class="kw-2">*</span>hparams).num_last_distances_to_check = H9_NUM_LAST_DISTANCES_TO_CHECK <span class="kw">as </span>i32;
      (<span class="kw-2">*</span>hparams).block_bits = H9_BLOCK_BITS <span class="kw">as </span>i32;
      (<span class="kw-2">*</span>hparams).bucket_bits = H9_BUCKET_BITS <span class="kw">as </span>i32;
      (<span class="kw-2">*</span>hparams).hash_len = <span class="number">4</span>;
  } <span class="kw">else if </span>(<span class="kw-2">*</span>params).quality == <span class="number">9 </span>{
      (<span class="kw-2">*</span>hparams).type_ = <span class="number">9</span>;
      (<span class="kw-2">*</span>hparams).num_last_distances_to_check = H9_NUM_LAST_DISTANCES_TO_CHECK <span class="kw">as </span>i32;
      (<span class="kw-2">*</span>hparams).block_bits = H9_BLOCK_BITS <span class="kw">as </span>i32;
      (<span class="kw-2">*</span>hparams).bucket_bits = H9_BUCKET_BITS <span class="kw">as </span>i32;
      (<span class="kw-2">*</span>hparams).hash_len = <span class="number">4</span>;    
  } <span class="kw">else if </span>(<span class="kw-2">*</span>params).quality == <span class="number">4 </span>&amp;&amp; ((<span class="kw-2">*</span>params).size_hint &gt;= (<span class="number">1i32 </span>&lt;&lt; <span class="number">20i32</span>) <span class="kw">as </span>(usize)) {
    (<span class="kw-2">*</span>hparams).type_ = <span class="number">54i32</span>;
  } <span class="kw">else if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">5 </span>{
    (<span class="kw-2">*</span>hparams).type_ = (<span class="kw-2">*</span>params).quality;
  } <span class="kw">else if </span>(<span class="kw-2">*</span>params).lgwin &lt;= <span class="number">16 </span>{
    (<span class="kw-2">*</span>hparams).type_ = <span class="kw">if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">7 </span>{
      <span class="number">40i32
    </span>} <span class="kw">else if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">9 </span>{
      <span class="number">41i32
    </span>} <span class="kw">else </span>{
      <span class="number">42i32
    </span>};
  } <span class="kw">else if </span>((params.q9_5 &amp;&amp; (<span class="kw-2">*</span>params).size_hint &gt; (<span class="number">1usize </span>&lt;&lt; <span class="number">20i32</span>))
             || (<span class="kw-2">*</span>params).size_hint &gt; (<span class="number">1usize </span>&lt;&lt; <span class="number">22i32</span>)) &amp;&amp; ((<span class="kw-2">*</span>params).lgwin &gt;= <span class="number">19i32</span>) {
    (<span class="kw-2">*</span>hparams).type_ = <span class="number">6i32</span>;
    (<span class="kw-2">*</span>hparams).block_bits = core::cmp::min((<span class="kw-2">*</span>params).quality - <span class="number">1</span>, <span class="number">9</span>);
    (<span class="kw-2">*</span>hparams).bucket_bits = <span class="number">15i32</span>;
    (<span class="kw-2">*</span>hparams).hash_len = <span class="number">5i32</span>;
    (<span class="kw-2">*</span>hparams).num_last_distances_to_check = <span class="kw">if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">7 </span>{
      <span class="number">4i32
    </span>} <span class="kw">else if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">9 </span>{
      <span class="number">10i32
    </span>} <span class="kw">else </span>{
      <span class="number">16i32
    </span>};
  } <span class="kw">else </span>{
    (<span class="kw-2">*</span>hparams).type_ = <span class="number">5i32</span>;
    (<span class="kw-2">*</span>hparams).block_bits = core::cmp::min((<span class="kw-2">*</span>params).quality - <span class="number">1</span>, <span class="number">9</span>);
    (<span class="kw-2">*</span>hparams).bucket_bits = <span class="kw">if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">7 </span>&amp;&amp; (<span class="kw-2">*</span>params).size_hint &lt;= (<span class="number">1usize </span>&lt;&lt; <span class="number">20i32</span>) {
      <span class="number">14i32
    </span>} <span class="kw">else </span>{
      <span class="number">15i32
    </span>};
    (<span class="kw-2">*</span>hparams).num_last_distances_to_check = <span class="kw">if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">7 </span>{
      <span class="number">4i32
    </span>} <span class="kw">else if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">9 </span>{
      <span class="number">10i32
    </span>} <span class="kw">else </span>{
      <span class="number">16i32
    </span>};
  }
}

<span class="kw">fn </span>InitializeH2&lt;AllocU32:alloc::Allocator&lt;u32&gt;&gt;(m32: <span class="kw-2">&amp;mut </span>AllocU32, params : <span class="kw-2">&amp;</span>BrotliEncoderParams) -&gt; BasicHasher&lt;H2Sub&lt;AllocU32&gt;&gt; {
    BasicHasher {
        GetHasherCommon:Struct1{
            params:params.hasher,
            is_prepared_:<span class="number">1</span>,
            dict_num_lookups:<span class="number">0</span>,
            dict_num_matches:<span class="number">0</span>,
        },
        buckets_:H2Sub{buckets_:m32.alloc_cell(<span class="number">65537 </span>+ <span class="number">8</span>)},
        h9_opts: <span class="kw">super</span>::backward_references::H9Opts::new(<span class="kw-2">&amp;</span>params.hasher),
    }
}
<span class="kw">fn </span>InitializeH3&lt;AllocU32:alloc::Allocator&lt;u32&gt;&gt;(m32: <span class="kw-2">&amp;mut </span>AllocU32, params : <span class="kw-2">&amp;</span>BrotliEncoderParams) -&gt; BasicHasher&lt;H3Sub&lt;AllocU32&gt;&gt; {
    BasicHasher {
        GetHasherCommon:Struct1{
            params:params.hasher,
            is_prepared_:<span class="number">1</span>,
            dict_num_lookups:<span class="number">0</span>,
            dict_num_matches:<span class="number">0</span>,
        },
        buckets_:H3Sub{buckets_:m32.alloc_cell(<span class="number">65538 </span>+ <span class="number">8</span>)},
        h9_opts: <span class="kw">super</span>::backward_references::H9Opts::new(<span class="kw-2">&amp;</span>params.hasher),
    }
}
<span class="kw">fn </span>InitializeH4&lt;AllocU32:alloc::Allocator&lt;u32&gt;&gt;(m32: <span class="kw-2">&amp;mut </span>AllocU32, params : <span class="kw-2">&amp;</span>BrotliEncoderParams) -&gt; BasicHasher&lt;H4Sub&lt;AllocU32&gt;&gt; {
    BasicHasher {
        GetHasherCommon:Struct1{
            params:params.hasher,
            is_prepared_:<span class="number">1</span>,
            dict_num_lookups:<span class="number">0</span>,
            dict_num_matches:<span class="number">0</span>,
        },
        buckets_:H4Sub{buckets_:m32.alloc_cell(<span class="number">131072 </span>+ <span class="number">8</span>)},
        h9_opts: <span class="kw">super</span>::backward_references::H9Opts::new(<span class="kw-2">&amp;</span>params.hasher),
    }
}
<span class="kw">fn </span>InitializeH54&lt;AllocU32:alloc::Allocator&lt;u32&gt;&gt;(m32: <span class="kw-2">&amp;mut </span>AllocU32, params : <span class="kw-2">&amp;</span>BrotliEncoderParams) -&gt; BasicHasher&lt;H54Sub&lt;AllocU32&gt;&gt; {
    BasicHasher {
        GetHasherCommon:Struct1{
            params:params.hasher,
            is_prepared_:<span class="number">1</span>,
            dict_num_lookups:<span class="number">0</span>,
            dict_num_matches:<span class="number">0</span>,
        },
        buckets_:H54Sub{buckets_:m32.alloc_cell(<span class="number">1048580 </span>+ <span class="number">8</span>)},
        h9_opts: <span class="kw">super</span>::backward_references::H9Opts::new(<span class="kw-2">&amp;</span>params.hasher),
    }
}

<span class="kw">fn </span>InitializeH9&lt;Alloc:alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;&gt;(m16: <span class="kw-2">&amp;mut </span>Alloc,
                                                                     params : <span class="kw-2">&amp;</span>BrotliEncoderParams) -&gt; H9&lt;Alloc&gt; {
    H9 {
        dict_search_stats_:Struct1{
            params:params.hasher,
            is_prepared_:<span class="number">1</span>,
            dict_num_lookups:<span class="number">0</span>,
            dict_num_matches:<span class="number">0</span>,
        },
        num_:&lt;Alloc <span class="kw">as </span>Allocator&lt;u16&gt;&gt;::alloc_cell(m16, <span class="number">1</span>&lt;&lt;H9_BUCKET_BITS),
        buckets_:&lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::alloc_cell(m16, H9_BLOCK_SIZE&lt;&lt;H9_BUCKET_BITS),
        h9_opts: <span class="kw">super</span>::backward_references::H9Opts::new(<span class="kw-2">&amp;</span>params.hasher),
    }
}

<span class="kw">fn </span>InitializeH5&lt;Alloc: alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;&gt;
  (m16: <span class="kw-2">&amp;mut </span>Alloc,
   params: <span class="kw-2">&amp;</span>BrotliEncoderParams,
) -&gt; UnionHasher&lt;Alloc&gt; {
  <span class="kw">let </span>block_size = <span class="number">1u64 </span>&lt;&lt; params.hasher.block_bits;
  <span class="kw">let </span>bucket_size = <span class="number">1u64 </span>&lt;&lt; params.hasher.bucket_bits;
  <span class="kw">let </span>buckets : &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::AllocatedMemory = &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::alloc_cell(m16, (bucket_size * block_size) <span class="kw">as </span>usize);
  <span class="kw">let </span>num : &lt;Alloc <span class="kw">as </span>Allocator&lt;u16&gt;&gt;::AllocatedMemory = &lt;Alloc <span class="kw">as </span>Allocator&lt;u16&gt;&gt;::alloc_cell(m16, bucket_size <span class="kw">as </span>usize);

  <span class="kw">if </span>params.hasher.block_bits == (HQ5Sub{}).block_bits() &amp;&amp; (<span class="number">1</span>&lt;&lt;params.hasher.bucket_bits) == (HQ5Sub{}).bucket_size() {
    <span class="kw">return </span>UnionHasher::H5q5(AdvHasher {
      buckets: buckets,
      h9_opts: <span class="kw">super</span>::backward_references::H9Opts::new(<span class="kw-2">&amp;</span>params.hasher),
      num: num,
      GetHasherCommon: Struct1 {
        params: params.hasher,
        is_prepared_: <span class="number">1</span>,
        dict_num_lookups: <span class="number">0</span>,
        dict_num_matches: <span class="number">0</span>,
      },
      specialization: HQ5Sub {}
    })
  }
  <span class="kw">if </span>params.hasher.block_bits == (HQ7Sub{}).block_bits() &amp;&amp; (<span class="number">1 </span>&lt;&lt;params.hasher.bucket_bits) == (HQ7Sub{}).bucket_size() {
    <span class="kw">return </span>UnionHasher::H5q7(AdvHasher {
      buckets: buckets,
      h9_opts: <span class="kw">super</span>::backward_references::H9Opts::new(<span class="kw-2">&amp;</span>params.hasher),
      num: num,
      GetHasherCommon: Struct1 {
        params: params.hasher,
        is_prepared_: <span class="number">1</span>,
        dict_num_lookups: <span class="number">0</span>,
        dict_num_matches: <span class="number">0</span>,
      },
      specialization: HQ7Sub {}
    })
  }
  UnionHasher::H5(AdvHasher {
    buckets: buckets,
    h9_opts: <span class="kw">super</span>::backward_references::H9Opts::new(<span class="kw-2">&amp;</span>params.hasher),
    num: num,
    GetHasherCommon: Struct1 {
      params: params.hasher,
      is_prepared_: <span class="number">1</span>,
      dict_num_lookups: <span class="number">0</span>,
      dict_num_matches: <span class="number">0</span>,
    },
    specialization: H5Sub {
      hash_shift_: <span class="number">32i32 </span>- params.hasher.bucket_bits,
      bucket_size_: bucket_size <span class="kw">as </span>u32,
      block_bits_: params.hasher.block_bits <span class="kw">as </span>i32,
      block_mask_: block_size.wrapping_sub(<span class="number">1u64</span>) <span class="kw">as </span>u32,
    }
  })
}
<span class="kw">fn </span>InitializeH6&lt;Alloc: alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;&gt;
  (m16: <span class="kw-2">&amp;mut </span>Alloc,
   params: <span class="kw-2">&amp;</span>BrotliEncoderParams)
   -&gt; UnionHasher&lt;Alloc&gt; {
  <span class="kw">let </span>block_size = <span class="number">1u64 </span>&lt;&lt; params.hasher.block_bits;
  <span class="kw">let </span>bucket_size = <span class="number">1u64 </span>&lt;&lt; params.hasher.bucket_bits;
  <span class="kw">let </span>buckets: &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::AllocatedMemory = &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::alloc_cell(m16, (bucket_size * block_size) <span class="kw">as </span>usize);
  <span class="kw">let </span>num: &lt;Alloc <span class="kw">as </span>Allocator&lt;u16&gt;&gt;::AllocatedMemory = &lt;Alloc <span class="kw">as </span>Allocator&lt;u16&gt;&gt;::alloc_cell(m16, bucket_size <span class="kw">as </span>usize);
   UnionHasher::H6(AdvHasher {
    buckets: buckets,
    num: num,
    h9_opts: <span class="kw">super</span>::backward_references::H9Opts::new(<span class="kw-2">&amp;</span>params.hasher),
    GetHasherCommon: Struct1 {
      params: params.hasher,
      is_prepared_: <span class="number">1</span>,
      dict_num_lookups: <span class="number">0</span>,
      dict_num_matches: <span class="number">0</span>,
    },
    specialization: H6Sub {
      bucket_size_: <span class="number">1u32 </span>&lt;&lt; params.hasher.bucket_bits,
      block_bits_: params.hasher.block_bits,
      block_mask_: block_size.wrapping_sub(<span class="number">1</span>) <span class="kw">as </span>u32,
      hash_mask: <span class="number">0xffffffffffffffffu64 </span>&gt;&gt; <span class="number">64i32 </span>- <span class="number">8i32 </span>* params.hasher.hash_len,
      hash_shift_: <span class="number">64i32 </span>- params.hasher.bucket_bits,
    },
  })
}

<span class="kw">fn </span>BrotliMakeHasher&lt;Alloc: alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;&gt;
  (m: <span class="kw-2">&amp;mut </span>Alloc,
   params: <span class="kw-2">&amp;</span>BrotliEncoderParams)
   -&gt; UnionHasher&lt;Alloc&gt; {
  <span class="kw">let </span>hasher_type: i32 = params.hasher.type_;
  <span class="kw">if </span>hasher_type == <span class="number">2i32 </span>{
    <span class="kw">return </span>UnionHasher::H2(InitializeH2(m, params));
  }
  <span class="kw">if </span>hasher_type == <span class="number">3i32 </span>{
    <span class="kw">return </span>UnionHasher::H3(InitializeH3(m, params));
  }
  <span class="kw">if </span>hasher_type == <span class="number">4i32 </span>{
    <span class="kw">return </span>UnionHasher::H4(InitializeH4(m, params));
  }
  <span class="kw">if </span>hasher_type == <span class="number">5i32 </span>{
    <span class="kw">return </span>InitializeH5(m, params);
  }
  <span class="kw">if </span>hasher_type == <span class="number">6i32 </span>{
    <span class="kw">return </span>InitializeH6(m, params);
  }
  <span class="kw">if </span>hasher_type == <span class="number">9i32 </span>{
    <span class="kw">return </span>UnionHasher::H9(InitializeH9(m, params));
  }
  <span class="comment">/*
    if hasher_type == 40i32 {
      return InitializeH40(params);
    }
    if hasher_type == 41i32 {
      return InitializeH41(params);
    }
    if hasher_type == 42i32 {
      return InitializeH42(params);
    }
*/
  </span><span class="kw">if </span>hasher_type == <span class="number">54i32 </span>{
    <span class="kw">return </span>UnionHasher::H54(InitializeH54(m, params));
  }
    <span class="kw">if </span>hasher_type == <span class="number">10i32 </span>{
      <span class="kw">return </span>UnionHasher::H10(InitializeH10(m, <span class="bool-val">false</span>, params, <span class="number">0</span>));
  }
  <span class="comment">// since we don&#39;t support all of these, fall back to something sane
  </span><span class="kw">return </span>InitializeH6(m, params);
      
<span class="comment">//  return UnionHasher::Uninit;
</span>}
<span class="kw">fn </span>HasherReset&lt;Alloc:alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;,&gt;(t: <span class="kw-2">&amp;mut </span>UnionHasher&lt;Alloc&gt;){
  <span class="kw">match </span>t {
    <span class="kw-2">&amp;mut </span>UnionHasher::Uninit =&gt; {}
    <span class="kw">_ </span>=&gt; (t.GetHasherCommon()).is_prepared_ = <span class="number">0i32</span>,
  };
}
<span class="kw">fn </span>GetHasherCommon&lt;Alloc: alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;&gt;
  (t: <span class="kw-2">&amp;mut </span>UnionHasher&lt;Alloc&gt;)
   -&gt; <span class="kw-2">&amp;mut </span>Struct1 {
  t.GetHasherCommon()
}

<span class="kw">pub fn </span>HasherSetup&lt;Alloc:alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;&gt;(m16: <span class="kw-2">&amp;mut </span>Alloc,
                                                                    handle: <span class="kw-2">&amp;mut </span>UnionHasher&lt;Alloc&gt;,
                                                                    params: <span class="kw-2">&amp;mut </span>BrotliEncoderParams,
                                                                    data: <span class="kw-2">&amp;</span>[u8],
                                                                    position: usize,
                                                                    input_size: usize,
                                                                    is_last: i32){
  <span class="kw">let </span>one_shot: i32 = (position == <span class="number">0usize </span>&amp;&amp; (is_last != <span class="number">0</span>)) <span class="kw">as </span>(i32);
  <span class="kw">let </span>is_uninit = <span class="kw">match </span>(handle) {
    <span class="kw-2">&amp;mut </span>UnionHasher::Uninit =&gt; <span class="bool-val">true</span>,
    <span class="kw">_ </span>=&gt; <span class="bool-val">false</span>,
  };
  <span class="kw">if </span>is_uninit {
    <span class="comment">//let alloc_size: usize;
    </span>ChooseHasher(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>params));
    <span class="comment">//alloc_size = HasherSize(params, one_shot, input_size);
    //xself = BrotliAllocate(m, alloc_size.wrapping_mul(::std::mem::size_of::&lt;u8&gt;()))
    </span><span class="kw-2">*</span>handle = BrotliMakeHasher(m16, params);
    handle.GetHasherCommon().params = (<span class="kw-2">*</span>params).hasher;
    HasherReset(handle); <span class="comment">// this sets everything to zero, unlike in C
    </span>handle.GetHasherCommon().is_prepared_ = <span class="number">1</span>;
  } <span class="kw">else </span>{
    <span class="kw">match </span>handle.Prepare(one_shot != <span class="number">0</span>, input_size, data) {
      HowPrepared::ALREADY_PREPARED =&gt; {}
      HowPrepared::NEWLY_PREPARED =&gt; {
        <span class="kw">if </span>position == <span class="number">0usize </span>{
          <span class="kw">let </span><span class="kw-2">mut </span>common = handle.GetHasherCommon();
          (<span class="kw-2">*</span>common).dict_num_lookups = <span class="number">0usize</span>;
          (<span class="kw-2">*</span>common).dict_num_matches = <span class="number">0usize</span>;
        }
      }
    }
  }
}

<span class="kw">fn </span>HasherPrependCustomDictionary&lt;Alloc: alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;&gt;
  (m: <span class="kw-2">&amp;mut </span>Alloc,
   handle: <span class="kw-2">&amp;mut </span>UnionHasher&lt;Alloc&gt;,
   params: <span class="kw-2">&amp;mut </span>BrotliEncoderParams,
   size: usize,
   dict: <span class="kw-2">&amp;</span>[u8]) {
  HasherSetup(m, handle, params, dict, <span class="number">0usize</span>, size, <span class="number">0i32</span>);
  <span class="kw">match </span>handle {
    <span class="kw-2">&amp;mut </span>UnionHasher::H2(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::H3(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::H4(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::H5(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::H5q7(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::H5q5(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::H6(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::H9(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::H54(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::H10(<span class="kw-2">ref mut </span>hasher) =&gt; StoreLookaheadThenStore(hasher, size, dict),
    <span class="kw-2">&amp;mut </span>UnionHasher::Uninit =&gt; <span class="macro">panic!</span>(<span class="string">&quot;Uninitialized&quot;</span>),
  }
}

<span class="kw">pub fn </span>BrotliEncoderSetCustomDictionary&lt;Alloc: BrotliAlloc&gt;
  (s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
   size: usize,
   dict: <span class="kw-2">&amp;</span>[u8]) {
    BrotliEncoderSetCustomDictionaryWithOptionalPrecomputedHasher(s, size, dict, UnionHasher::Uninit)
}

                                                          
<span class="kw">pub fn </span>BrotliEncoderSetCustomDictionaryWithOptionalPrecomputedHasher&lt;Alloc: BrotliAlloc&gt;
  (s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
   size: usize,
   <span class="kw-2">mut </span>dict: <span class="kw-2">&amp;</span>[u8],
   opt_hasher: UnionHasher&lt;Alloc&gt;,
) {
  <span class="kw">let </span>has_optional_hasher = <span class="kw">if let </span>UnionHasher::Uninit = opt_hasher { <span class="bool-val">false </span>} <span class="kw">else </span>{<span class="bool-val">true</span>};
  <span class="kw">let </span>max_dict_size: usize = (<span class="number">1usize </span>&lt;&lt; (<span class="kw-2">*</span>s).params.lgwin).wrapping_sub(<span class="number">16usize</span>);
  s.hasher_ = opt_hasher;
  <span class="kw">let </span><span class="kw-2">mut </span>dict_size: usize = size;
  <span class="kw">if </span>EnsureInitialized(s) == <span class="number">0 </span>{
    <span class="kw">return</span>;
  }
  <span class="kw">if </span>dict_size == <span class="number">0usize </span>|| (<span class="kw-2">*</span>s).params.quality == <span class="number">0i32 </span>|| (<span class="kw-2">*</span>s).params.quality == <span class="number">1i32 </span>|| size &lt;= <span class="number">1 </span>{
    (<span class="kw-2">*</span>s).params.catable = <span class="bool-val">true</span>; <span class="comment">// don&#39;t risk a too-short dictionary
    </span>(<span class="kw-2">*</span>s).params.appendable = <span class="bool-val">true</span>; <span class="comment">// don&#39;t risk a too-short dictionary
    </span><span class="kw">return</span>;
  }
  s.custom_dictionary = <span class="bool-val">true</span>;
  <span class="kw">if </span>size &gt; max_dict_size {
    dict = <span class="kw-2">&amp;</span>dict[(size.wrapping_sub(max_dict_size) <span class="kw">as </span>(usize))..];
    dict_size = max_dict_size;
  }
  CopyInputToRingBuffer(s, dict_size, dict);
  (<span class="kw-2">*</span>s).last_flush_pos_ = dict_size <span class="kw">as </span>u64;
  (<span class="kw-2">*</span>s).last_processed_pos_ = dict_size <span class="kw">as </span>u64;
  <span class="kw">if </span>dict_size &gt; <span class="number">0 </span>{
    (<span class="kw-2">*</span>s).prev_byte_ = dict[(dict_size.wrapping_sub(<span class="number">1usize</span>) <span class="kw">as </span>(usize))];
  }
  <span class="kw">if </span>dict_size &gt; <span class="number">1usize </span>{
    (<span class="kw-2">*</span>s).prev_byte2_ = dict[(dict_size.wrapping_sub(<span class="number">2usize</span>) <span class="kw">as </span>(usize))];
  }
  <span class="kw">let </span>m16 = <span class="kw-2">&amp;mut </span>s.m8;
  <span class="kw">if </span><span class="macro">cfg!</span>(debug_assertions) || !has_optional_hasher {
    <span class="kw">let </span><span class="kw-2">mut </span>orig_hasher = UnionHasher::Uninit;
    <span class="kw">if </span>has_optional_hasher {
      orig_hasher = core::mem::replace(<span class="kw-2">&amp;mut </span>s.hasher_, UnionHasher::Uninit);
    }
    HasherPrependCustomDictionary(m16,
                                  <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).hasher_,
                                  <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).params,
                                  dict_size,
                                  dict);
    <span class="kw">if </span>has_optional_hasher {
      <span class="macro">debug_assert!</span>(orig_hasher == s.hasher_);
      DestroyHasher(m16, <span class="kw-2">&amp;mut </span>orig_hasher);
    }
  }
}
<span class="kw">pub fn </span>BrotliEncoderMaxCompressedSizeMulti(input_size: usize, num_threads: usize) -&gt; usize {
  BrotliEncoderMaxCompressedSize(input_size) + num_threads * <span class="number">8
</span>}

<span class="kw">pub fn </span>BrotliEncoderMaxCompressedSize(input_size: usize) -&gt; usize {
  <span class="kw">let </span>magic_size = <span class="number">16usize</span>;
  <span class="kw">let </span>num_large_blocks: usize = input_size &gt;&gt; <span class="number">14i32</span>;
  <span class="kw">let </span>tail: usize = input_size.wrapping_sub(num_large_blocks &lt;&lt; <span class="number">24i32</span>);
  <span class="kw">let </span>tail_overhead: usize = (<span class="kw">if </span>tail &gt; (<span class="number">1i32 </span>&lt;&lt; <span class="number">20i32</span>) <span class="kw">as </span>(usize) {
                                    <span class="number">4i32
                                  </span>} <span class="kw">else </span>{
                                    <span class="number">3i32
                                  </span>}) <span class="kw">as </span>(usize);
  <span class="kw">let </span>overhead: usize = (<span class="number">2usize</span>)
    .wrapping_add((<span class="number">4usize</span>).wrapping_mul(num_large_blocks))
    .wrapping_add(tail_overhead)
    .wrapping_add(<span class="number">1usize</span>);
  <span class="kw">let </span>result: usize = input_size.wrapping_add(overhead);
  <span class="kw">if </span>input_size == <span class="number">0usize </span>{
    <span class="kw">return </span><span class="number">1usize </span>+ magic_size;
  }
  <span class="kw">if </span>result &lt; input_size { <span class="number">0usize </span>} <span class="kw">else </span>{ result + magic_size }
}

<span class="kw">fn </span>InitOrStitchToPreviousBlock&lt;Alloc: alloc::Allocator&lt;u16&gt; + alloc::Allocator&lt;u32&gt;&gt;
  (m: <span class="kw-2">&amp;mut </span>Alloc,
   handle: <span class="kw-2">&amp;mut </span>UnionHasher&lt;Alloc&gt;,
   data: <span class="kw-2">&amp;</span>[u8],
   mask: usize,
   params: <span class="kw-2">&amp;mut </span>BrotliEncoderParams,
   position: usize,
   input_size: usize,
   is_last: i32) {
  HasherSetup(m,
              handle,
              params,
              data,
              position,
              input_size,
              is_last);
  handle.StitchToPreviousBlock(input_size, position, data, mask);
}

<span class="kw">pub fn </span>InitInsertCommand(xself: <span class="kw-2">&amp;mut </span>Command, insertlen: usize) {
  (<span class="kw-2">*</span>xself).insert_len_ = insertlen <span class="kw">as </span>(u32);
  (<span class="kw-2">*</span>xself).copy_len_ = (<span class="number">4i32 </span>&lt;&lt; <span class="number">25i32</span>) <span class="kw">as </span>(u32);
  (<span class="kw-2">*</span>xself).dist_extra_ = <span class="number">0u32</span>;
  (<span class="kw-2">*</span>xself).dist_prefix_ = (<span class="number">1u16 </span>&lt;&lt; <span class="number">10</span>) | BROTLI_NUM_DISTANCE_SHORT_CODES <span class="kw">as </span>(u16);
  GetLengthCode(insertlen, <span class="number">4usize</span>, <span class="number">0i32</span>, <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>xself).cmd_prefix_);
}



<span class="kw">fn </span>ShouldCompress(data: <span class="kw-2">&amp;</span>[u8],
                  mask: usize,
                  last_flush_pos: u64,
                  bytes: usize,
                  num_literals: usize,
                  num_commands: usize)
                  -&gt; i32 {
  <span class="kw">if </span>num_commands &lt; (bytes &gt;&gt; <span class="number">8i32</span>).wrapping_add(<span class="number">2usize</span>) {
    <span class="kw">if </span>num_literals <span class="kw">as </span>(<span class="kw">super</span>::util::floatX) &gt; <span class="number">0.99 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX * bytes <span class="kw">as </span>(<span class="kw">super</span>::util::floatX) {
      <span class="kw">let </span><span class="kw-2">mut </span>literal_histo: [u32; <span class="number">256</span>] =
        [<span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
         <span class="number">0u32</span>];
      <span class="kw">static </span>kSampleRate: u32 = <span class="number">13u32</span>;
      <span class="kw">static </span>kMinEntropy: <span class="kw">super</span>::util::floatX = <span class="number">7.92 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX;
      <span class="kw">let </span>bit_cost_threshold: <span class="kw">super</span>::util::floatX = bytes <span class="kw">as </span>(<span class="kw">super</span>::util::floatX) * kMinEntropy / kSampleRate <span class="kw">as </span>(<span class="kw">super</span>::util::floatX);
      <span class="kw">let </span>t: usize = bytes.wrapping_add(kSampleRate <span class="kw">as </span>(usize))
        .wrapping_sub(<span class="number">1usize</span>)
        .wrapping_div(kSampleRate <span class="kw">as </span>(usize));
      <span class="kw">let </span><span class="kw-2">mut </span>pos: u32 = last_flush_pos <span class="kw">as </span>(u32);
      <span class="kw">let </span><span class="kw-2">mut </span>i: usize;
      i = <span class="number">0usize</span>;
      <span class="kw">while </span>i &lt; t {
        {
          {
            <span class="kw">let </span>_rhs = <span class="number">1</span>;
            <span class="kw">let </span>_lhs = <span class="kw-2">&amp;mut </span>literal_histo[data[((pos <span class="kw">as </span>(usize) &amp; mask) <span class="kw">as </span>(usize))] <span class="kw">as </span>(usize)];
            <span class="kw-2">*</span>_lhs = (<span class="kw-2">*</span>_lhs).wrapping_add(_rhs <span class="kw">as </span>(u32));
          }
          pos = pos.wrapping_add(kSampleRate);
        }
        i = i.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
      }
      <span class="kw">if </span>BitsEntropy(<span class="kw-2">&amp;</span>literal_histo[..], <span class="number">256usize</span>) &gt; bit_cost_threshold {
        <span class="kw">return </span><span class="number">0i32</span>;
      }
    }
  }
  <span class="number">1i32
</span>}

<span class="comment">/* Chooses the literal context mode for a metablock */
</span><span class="kw">fn </span>ChooseContextMode(params: <span class="kw-2">&amp;</span>BrotliEncoderParams,
    data: <span class="kw-2">&amp;</span>[u8], pos: usize, mask: usize,
    length: usize) -&gt; ContextType{
  <span class="comment">/* We only do the computation for the option of something else than
    CONTEXT_UTF8 for the highest qualities */
  </span><span class="kw">match </span>params.mode {
      BrotliEncoderMode::BROTLI_FORCE_LSB_PRIOR =&gt; <span class="kw">return </span>ContextType::CONTEXT_LSB6,
      BrotliEncoderMode::BROTLI_FORCE_MSB_PRIOR =&gt; <span class="kw">return </span>ContextType::CONTEXT_MSB6,
      BrotliEncoderMode::BROTLI_FORCE_UTF8_PRIOR =&gt; <span class="kw">return </span>ContextType::CONTEXT_UTF8,
      BrotliEncoderMode::BROTLI_FORCE_SIGNED_PRIOR =&gt; <span class="kw">return </span>ContextType::CONTEXT_SIGNED,
      <span class="kw">_ </span>=&gt; {},
  }
  <span class="kw">if </span>(params.quality &gt;= <span class="number">10 </span>&amp;&amp;
      BrotliIsMostlyUTF8(data, pos, mask, length, kMinUTF8Ratio) == <span class="number">0</span>) {
    <span class="kw">return </span>ContextType::CONTEXT_SIGNED;
  }
  <span class="kw">return </span>ContextType::CONTEXT_UTF8;
}


<span class="attribute">#[derive(PartialEq, Eq, Copy, Clone)]
</span><span class="kw">pub enum </span>BrotliEncoderOperation {
  BROTLI_OPERATION_PROCESS = <span class="number">0</span>,
  BROTLI_OPERATION_FLUSH = <span class="number">1</span>,
  BROTLI_OPERATION_FINISH = <span class="number">2</span>,
  BROTLI_OPERATION_EMIT_METADATA = <span class="number">3</span>,
}

<span class="kw">fn </span>MakeUncompressedStream(input: <span class="kw-2">&amp;</span>[u8], input_size: usize, output: <span class="kw-2">&amp;mut </span>[u8]) -&gt; usize {
  <span class="kw">let </span><span class="kw-2">mut </span>size: usize = input_size;
  <span class="kw">let </span><span class="kw-2">mut </span>result: usize = <span class="number">0usize</span>;
  <span class="kw">let </span><span class="kw-2">mut </span>offset: usize = <span class="number">0usize</span>;
  <span class="kw">if </span>input_size == <span class="number">0usize </span>{
    output[(<span class="number">0usize</span>)] = <span class="number">6i32 </span><span class="kw">as </span>(u8);
    <span class="kw">return </span><span class="number">1usize</span>;
  }
  output[({
     <span class="kw">let </span>_old = result;
     result = result.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
     _old
   } <span class="kw">as </span>(usize))] = <span class="number">0x21i32 </span><span class="kw">as </span>(u8);
  output[({
     <span class="kw">let </span>_old = result;
     result = result.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
     _old
   } <span class="kw">as </span>(usize))] = <span class="number">0x3i32 </span><span class="kw">as </span>(u8);
  <span class="kw">while </span>size &gt; <span class="number">0usize </span>{
    <span class="kw">let </span><span class="kw-2">mut </span>nibbles: u32 = <span class="number">0u32</span>;
    <span class="kw">let </span>chunk_size: u32;
    <span class="kw">let </span>bits: u32;
    chunk_size = <span class="kw">if </span>size &gt; (<span class="number">1u32 </span>&lt;&lt; <span class="number">24i32</span>) <span class="kw">as </span>(usize) {
      <span class="number">1u32 </span>&lt;&lt; <span class="number">24i32
    </span>} <span class="kw">else </span>{
      size <span class="kw">as </span>(u32)
    };
    <span class="kw">if </span>chunk_size &gt; <span class="number">1u32 </span>&lt;&lt; <span class="number">16i32 </span>{
      nibbles = <span class="kw">if </span>chunk_size &gt; <span class="number">1u32 </span>&lt;&lt; <span class="number">20i32 </span>{
        <span class="number">2i32
      </span>} <span class="kw">else </span>{
        <span class="number">1i32
      </span>} <span class="kw">as </span>(u32);
    }
    bits = nibbles &lt;&lt; <span class="number">1i32 </span>| chunk_size.wrapping_sub(<span class="number">1u32</span>) &lt;&lt; <span class="number">3i32 </span>|
           <span class="number">1u32 </span>&lt;&lt; (<span class="number">19u32</span>).wrapping_add((<span class="number">4u32</span>).wrapping_mul(nibbles));
    output[({
       <span class="kw">let </span>_old = result;
       result = result.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
       _old
     } <span class="kw">as </span>(usize))] = bits <span class="kw">as </span>(u8);
    output[({
       <span class="kw">let </span>_old = result;
       result = result.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
       _old
     } <span class="kw">as </span>(usize))] = (bits &gt;&gt; <span class="number">8i32</span>) <span class="kw">as </span>(u8);
    output[({
       <span class="kw">let </span>_old = result;
       result = result.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
       _old
     } <span class="kw">as </span>(usize))] = (bits &gt;&gt; <span class="number">16i32</span>) <span class="kw">as </span>(u8);
    <span class="kw">if </span>nibbles == <span class="number">2u32 </span>{
      output[({
         <span class="kw">let </span>_old = result;
         result = result.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
         _old
       } <span class="kw">as </span>(usize))] = (bits &gt;&gt; <span class="number">24i32</span>) <span class="kw">as </span>(u8);
    }
    output[(result <span class="kw">as </span>usize)..(result + chunk_size <span class="kw">as </span>usize)].clone_from_slice(
           <span class="kw-2">&amp;</span>input[offset .. (offset + chunk_size <span class="kw">as </span>usize)]);
    result = result.wrapping_add(chunk_size <span class="kw">as </span>(usize));
    offset = offset.wrapping_add(chunk_size <span class="kw">as </span>(usize));
    size = size.wrapping_sub(chunk_size <span class="kw">as </span>(usize));
  }
  output[({
     <span class="kw">let </span>_old = result;
     result = result.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
     _old
   } <span class="kw">as </span>(usize))] = <span class="number">3i32 </span><span class="kw">as </span>(u8);
  result
}
<span class="kw">pub fn </span>BrotliEncoderCompress&lt;Alloc: BrotliAlloc,
                             MetablockCallback: FnMut(<span class="kw-2">&amp;mut </span>interface::PredictionModeContextMap&lt;InputReferenceMut&gt;,
                                                      <span class="kw-2">&amp;mut </span>[interface::StaticCommand],
                                                      interface::InputPair, <span class="kw-2">&amp;mut </span>Alloc)&gt;(
    empty_m8: Alloc,
    m8: <span class="kw-2">&amp;mut </span>Alloc,
    quality: i32,
    lgwin: i32,
    mode: BrotliEncoderMode,
    input_size: usize,
    input_buffer: <span class="kw-2">&amp;</span>[u8],
    encoded_size: <span class="kw-2">&amp;mut </span>usize,
    encoded_buffer: <span class="kw-2">&amp;mut </span>[u8],
    metablock_callback: <span class="kw-2">&amp;mut </span>MetablockCallback)
            -&gt; i32 {
  <span class="kw">let </span>out_size: usize = <span class="kw-2">*</span>encoded_size;
  <span class="kw">let </span>input_start = input_buffer;
  <span class="kw">let </span>output_start = encoded_buffer;
  <span class="kw">let </span>max_out_size: usize = BrotliEncoderMaxCompressedSize(input_size);
  <span class="kw">if </span>out_size == <span class="number">0usize </span>{
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">if </span>input_size == <span class="number">0usize </span>{
    <span class="kw-2">*</span>encoded_size = <span class="number">1</span>;
    output_start[<span class="number">0</span>] = <span class="number">6</span>;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">let </span><span class="kw-2">mut </span>is_fallback: i32 = <span class="number">0i32</span>;
  <span class="kw">if </span>quality == <span class="number">10i32 </span>{
    <span class="macro">panic!</span>(<span class="string">&quot;Unimplemented: need to set 9.5 here&quot;</span>);
  }
  <span class="kw">if </span>is_fallback == <span class="number">0 </span>{
    
    <span class="kw">let </span><span class="kw-2">mut </span>s_orig = BrotliEncoderCreateInstance(core::mem::replace(m8, empty_m8));
    <span class="kw">let </span><span class="kw-2">mut </span>result: i32;
    {
      <span class="kw">let </span>s = <span class="kw-2">&amp;mut </span>s_orig;
      <span class="kw">let </span><span class="kw-2">mut </span>available_in: usize = input_size;
      <span class="kw">let </span><span class="kw-2">mut </span>next_in_array: <span class="kw-2">&amp;</span>[u8] = input_buffer;
      <span class="kw">let </span><span class="kw-2">mut </span>next_in_offset: usize = <span class="number">0</span>;  
      <span class="kw">let </span><span class="kw-2">mut </span>available_out: usize = <span class="kw-2">*</span>encoded_size;
      <span class="kw">let </span><span class="kw-2">mut </span>next_out_array: <span class="kw-2">&amp;mut </span>[u8] = output_start;
      <span class="kw">let </span><span class="kw-2">mut </span>next_out_offset: usize = <span class="number">0</span>;
      <span class="kw">let </span><span class="kw-2">mut </span>total_out = <span class="prelude-val">Some</span>(<span class="number">0usize</span>);
      BrotliEncoderSetParameter(s,
                                BrotliEncoderParameter::BROTLI_PARAM_QUALITY,
                                quality <span class="kw">as </span>(u32));
      BrotliEncoderSetParameter(s,
                                BrotliEncoderParameter::BROTLI_PARAM_LGWIN,
                                lgwin <span class="kw">as </span>(u32));
      BrotliEncoderSetParameter(s, BrotliEncoderParameter::BROTLI_PARAM_MODE, mode <span class="kw">as </span>(u32));
      BrotliEncoderSetParameter(s,
                                BrotliEncoderParameter::BROTLI_PARAM_SIZE_HINT,
                                input_size <span class="kw">as </span>(u32));
      <span class="kw">if </span>lgwin &gt; BROTLI_MAX_WINDOW_BITS <span class="kw">as </span>i32 {
          BrotliEncoderSetParameter(s, BrotliEncoderParameter::BROTLI_PARAM_LARGE_WINDOW, <span class="number">1</span>);
      }
      result = BrotliEncoderCompressStream(s,
                                             BrotliEncoderOperation::BROTLI_OPERATION_FINISH,
                                             <span class="kw-2">&amp;mut </span>available_in,
                                             <span class="kw-2">&amp;mut </span>next_in_array,
                                             <span class="kw-2">&amp;mut </span>next_in_offset,  
                                             <span class="kw-2">&amp;mut </span>available_out,
                                             <span class="kw-2">&amp;mut </span>next_out_array,
                                             <span class="kw-2">&amp;mut </span>next_out_offset,
                                             <span class="kw-2">&amp;mut </span>total_out,
                                             metablock_callback);
      <span class="kw">if </span>BrotliEncoderIsFinished(s) == <span class="number">0 </span>{
        result = <span class="number">0i32</span>;
      }
       
      <span class="kw-2">*</span>encoded_size = total_out.unwrap();
      BrotliEncoderDestroyInstance(s);
    }
    <span class="kw">let _ </span>= core::mem::replace(m8, s_orig.m8);
    <span class="kw">if </span>result == <span class="number">0 </span>|| max_out_size != <span class="number">0 </span>&amp;&amp; (<span class="kw-2">*</span>encoded_size &gt; max_out_size) {
        is_fallback = <span class="number">1i32</span>;
    } <span class="kw">else </span>{
      <span class="kw">return </span><span class="number">1i32</span>;
    }
  }
  <span class="macro">assert!</span>(is_fallback != <span class="number">0</span>);
  <span class="kw-2">*</span>encoded_size = <span class="number">0usize</span>;
  <span class="kw">if </span>max_out_size == <span class="number">0 </span>{
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">if </span>out_size &gt;= max_out_size {
    <span class="kw-2">*</span>encoded_size = MakeUncompressedStream(input_start, input_size, output_start);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="number">0i32
</span>}

<span class="kw">fn </span>InjectBytePaddingBlock&lt;Alloc: BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;) {
  <span class="kw">let </span><span class="kw-2">mut </span>seal: u32 = (<span class="kw-2">*</span>s).last_bytes_ <span class="kw">as </span>(u32);
  <span class="kw">let </span><span class="kw-2">mut </span>seal_bits: usize = (<span class="kw-2">*</span>s).last_bytes_bits_ <span class="kw">as </span>(usize);
  <span class="kw">let </span>destination: <span class="kw-2">&amp;mut </span>[u8];
  (<span class="kw-2">*</span>s).last_bytes_ = <span class="number">0</span>;
  (<span class="kw-2">*</span>s).last_bytes_bits_ = <span class="number">0</span>;
  seal = seal | <span class="number">0x6u32 </span>&lt;&lt; seal_bits;
  seal_bits = seal_bits.wrapping_add(<span class="number">6usize</span>);
  <span class="kw">if </span>!IsNextOutNull(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span>s).next_out_) {
    destination = <span class="kw-2">&amp;mut </span><span class="macro">GetNextOut!</span>(<span class="kw-2">*</span>s)[((<span class="kw-2">*</span>s).available_out_ <span class="kw">as </span>(usize))..];
  } <span class="kw">else </span>{
    destination = <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).tiny_buf_[..];
    (<span class="kw-2">*</span>s).next_out_ = NextOut::TinyBuf(<span class="number">0</span>);
  }
  destination[(<span class="number">0usize</span>)] = seal <span class="kw">as </span>(u8);
  <span class="kw">if </span>seal_bits &gt; <span class="number">8usize </span>{
    destination[(<span class="number">1usize</span>)] = (seal &gt;&gt; <span class="number">8i32</span>) <span class="kw">as </span>(u8);
  }
  <span class="kw">if </span>seal_bits &gt; <span class="number">16usize </span>{
    destination[(<span class="number">2usize</span>)] = (seal &gt;&gt; <span class="number">16i32</span>) <span class="kw">as </span>(u8);
  }
  (<span class="kw-2">*</span>s).available_out_ = (<span class="kw-2">*</span>s).available_out_.wrapping_add(seal_bits.wrapping_add(<span class="number">7usize</span>) &gt;&gt; <span class="number">3i32</span>);
}
<span class="kw">fn </span>InjectFlushOrPushOutput&lt;Alloc: BrotliAlloc&gt;(
    s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
    available_out: <span class="kw-2">&amp;mut </span>usize,
    next_out_array: <span class="kw-2">&amp;mut </span>[u8],
    next_out_offset: <span class="kw-2">&amp;mut </span>usize,
    total_out: <span class="kw-2">&amp;mut </span><span class="prelude-ty">Option</span>&lt;usize&gt;)
            -&gt; i32 {
  <span class="kw">if </span>(<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) ==
     BrotliEncoderStreamState::BROTLI_STREAM_FLUSH_REQUESTED <span class="kw">as </span>(i32) &amp;&amp;
     ((<span class="kw-2">*</span>s).last_bytes_bits_ <span class="kw">as </span>(i32) != <span class="number">0i32</span>) {
    InjectBytePaddingBlock(s);
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).available_out_ != <span class="number">0usize </span>&amp;&amp; (<span class="kw-2">*</span>available_out != <span class="number">0usize</span>) {
    <span class="kw">let </span>copy_output_size: usize = brotli_min_size_t((<span class="kw-2">*</span>s).available_out_, <span class="kw-2">*</span>available_out);
    (<span class="kw-2">*</span>next_out_array)[(<span class="kw-2">*</span>next_out_offset)..(<span class="kw-2">*</span>next_out_offset + copy_output_size)].clone_from_slice(<span class="kw-2">&amp;</span><span class="macro">GetNextOut!</span>(s)[..copy_output_size]);
    <span class="comment">//memcpy(*next_out, (*s).next_out_, copy_output_size);
    </span><span class="kw-2">*</span>next_out_offset = (<span class="kw-2">*</span>next_out_offset).wrapping_add(copy_output_size);
    <span class="kw-2">*</span>available_out = (<span class="kw-2">*</span>available_out).wrapping_sub(copy_output_size);
    (<span class="kw-2">*</span>s).next_out_ = NextOutIncrement(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span>s).next_out_, (copy_output_size <span class="kw">as </span>(i32)));
    (<span class="kw-2">*</span>s).available_out_ = (<span class="kw-2">*</span>s).available_out_.wrapping_sub(copy_output_size);
    (<span class="kw-2">*</span>s).total_out_ = (<span class="kw-2">*</span>s).total_out_.wrapping_add(copy_output_size <span class="kw">as </span>u64);
    <span class="kw">if let </span><span class="kw-2">&amp;mut </span><span class="prelude-val">Some</span>(<span class="kw-2">ref mut </span>total_out_inner) = total_out {
      <span class="kw-2">*</span>total_out_inner = (<span class="kw-2">*</span>s).total_out_ <span class="kw">as </span>usize;
    }
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  <span class="number">0i32
</span>}

<span class="kw">fn </span>UnprocessedInputSize&lt;Alloc:BrotliAlloc&gt;(
                            s: <span class="kw-2">&amp;</span>BrotliEncoderStateStruct&lt;Alloc&gt;) -&gt; u64 {
  (<span class="kw-2">*</span>s).input_pos_.wrapping_sub((<span class="kw-2">*</span>s).last_processed_pos_)
}

<span class="kw">fn </span>UpdateSizeHint&lt;Alloc: BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
                        available_in: usize) {
  <span class="kw">if </span>(<span class="kw-2">*</span>s).params.size_hint == <span class="number">0usize </span>{
    <span class="kw">let </span>delta: u64 = UnprocessedInputSize(s);
    <span class="kw">let </span>tail: u64 = available_in <span class="kw">as </span>u64;
    <span class="kw">let </span>limit: u32 = <span class="number">1u32 </span>&lt;&lt; <span class="number">30i32</span>;
    <span class="kw">let </span>total: u32;
    <span class="kw">if </span>delta &gt;= u64::from(limit) || tail &gt;= u64::from(limit) ||
       delta.wrapping_add(tail) &gt;= u64::from(limit) {
      total = limit;
    } <span class="kw">else </span>{
      total = delta.wrapping_add(tail) <span class="kw">as </span>(u32);
    }
    (<span class="kw-2">*</span>s).params.size_hint = total <span class="kw">as </span>(usize);
  }
}


<span class="kw">fn </span>WrapPosition(position: u64) -&gt; u32 {
  <span class="kw">let </span><span class="kw-2">mut </span>result: u32 = position <span class="kw">as </span>(u32);
  <span class="kw">let </span>gb: u64 = position &gt;&gt; <span class="number">30i32</span>;
  <span class="kw">if </span>gb &gt; <span class="number">2 </span>{
    result = result &amp; (<span class="number">1u32 </span>&lt;&lt; <span class="number">30i32</span>).wrapping_sub(<span class="number">1u32</span>) |
             ((gb.wrapping_sub(<span class="number">1</span>) &amp; <span class="number">1</span>) <span class="kw">as </span>(u32)).wrapping_add(<span class="number">1u32</span>) &lt;&lt; <span class="number">30i32</span>;
  }
  result
}

<span class="kw">fn </span>InputBlockSize&lt;Alloc: BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;) -&gt; usize {
  <span class="kw">if </span>EnsureInitialized(s) == <span class="number">0 </span>{
    <span class="kw">return </span><span class="number">0usize</span>;
  }
  <span class="number">1usize </span>&lt;&lt; (<span class="kw-2">*</span>s).params.lgblock
}

<span class="kw">fn </span>GetBrotliStorage&lt;Alloc:BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
                                       size: usize) {
  <span class="kw">if </span>(<span class="kw-2">*</span>s).storage_size_ &lt; size {
    &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::free_cell(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).m8, core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).storage_, &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory::default()));
    (<span class="kw-2">*</span>s).storage_ = &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::alloc_cell(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).m8, size);
    (<span class="kw-2">*</span>s).storage_size_ = size;
  }
}

<span class="kw">fn </span>MaxHashTableSize(quality: i32) -&gt; usize {
  (<span class="kw">if </span>quality == <span class="number">0i32 </span>{
     <span class="number">1i32 </span>&lt;&lt; <span class="number">15i32
   </span>} <span class="kw">else </span>{
     <span class="number">1i32 </span>&lt;&lt; <span class="number">17i32
   </span>}) <span class="kw">as </span>(usize)
}

<span class="kw">fn </span>HashTableSize(max_table_size: usize, input_size: usize) -&gt; usize {
  <span class="kw">let </span><span class="kw-2">mut </span>htsize: usize = <span class="number">256usize</span>;
  <span class="kw">while </span>htsize &lt; max_table_size &amp;&amp; (htsize &lt; input_size) {
    htsize = htsize &lt;&lt; <span class="number">1i32</span>;
  }
  htsize
}

<span class="macro">macro_rules! </span>GetHashTable {
    (<span class="macro-nonterminal">$s </span>: expr, <span class="macro-nonterminal">$quality</span>: expr, <span class="macro-nonterminal">$input_size </span>: expr, <span class="macro-nonterminal">$table_size </span>: expr) =&gt; {
        GetHashTableInternal(<span class="kw-2">&amp;mut </span><span class="macro-nonterminal">$s</span>.m8, <span class="kw-2">&amp;mut </span><span class="macro-nonterminal">$s</span>.small_table_, <span class="kw-2">&amp;mut </span><span class="macro-nonterminal">$s</span>.large_table_,
                             <span class="macro-nonterminal">$quality</span>, <span class="macro-nonterminal">$input_size</span>, <span class="macro-nonterminal">$table_size</span>)
    };
}
<span class="kw">fn </span>GetHashTableInternal&lt;<span class="lifetime">&#39;a</span>, AllocI32: alloc::Allocator&lt;i32&gt;&gt;(mi32: <span class="kw-2">&amp;mut </span>AllocI32,
                                                             small_table_: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>[i32; <span class="number">1024</span>],
                                                             large_table_: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>AllocI32::AllocatedMemory,
                                                             quality: i32,
                                                             input_size: usize,
                                                             table_size: <span class="kw-2">&amp;mut </span>usize)
                                                                 -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>[i32] {
  <span class="kw">let </span>max_table_size: usize = MaxHashTableSize(quality);
  <span class="kw">let </span><span class="kw-2">mut </span>htsize: usize = HashTableSize(max_table_size, input_size);
  <span class="kw">let </span>table: <span class="kw-2">&amp;mut </span>[i32];
  <span class="kw">if </span>quality == <span class="number">0i32 </span>{
    <span class="kw">if </span>htsize &amp; <span class="number">0xaaaaausize </span>== <span class="number">0usize </span>{
      htsize = htsize &lt;&lt; <span class="number">1i32</span>;
    }
  }
  <span class="kw">if </span>htsize &lt;= small_table_.len() {
    table = <span class="kw-2">&amp;mut </span>small_table_[..];
  } <span class="kw">else </span>{
    <span class="kw">if </span>htsize &gt; large_table_.slice().len() {
      <span class="comment">//(*s).large_table_size_ = htsize;
      </span>{
          mi32.free_cell(core::mem::replace(large_table_,
                                            AllocI32::AllocatedMemory::default()));
      }
      <span class="kw-2">*</span>large_table_ = mi32.alloc_cell(htsize);
    }
    table = large_table_.slice_mut();
  }
  <span class="kw-2">*</span>table_size = htsize;
  <span class="kw">for </span>item <span class="kw">in </span>table[..htsize].iter_mut() {
      <span class="kw-2">*</span>item = <span class="number">0</span>;
  }
  table <span class="comment">// FIXME: probably need a macro to do this without borrowing the whole EncoderStateStruct
</span>}
<span class="kw">fn </span>UpdateLastProcessedPos&lt;Alloc:BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;) -&gt; i32 {
  <span class="kw">let </span>wrapped_last_processed_pos: u32 = WrapPosition((<span class="kw-2">*</span>s).last_processed_pos_);
  <span class="kw">let </span>wrapped_input_pos: u32 = WrapPosition((<span class="kw-2">*</span>s).input_pos_);
  (<span class="kw-2">*</span>s).last_processed_pos_ = (<span class="kw-2">*</span>s).input_pos_;
  <span class="kw">if </span>!!(wrapped_input_pos &lt; wrapped_last_processed_pos) {
    <span class="number">1i32
  </span>} <span class="kw">else </span>{
    <span class="number">0i32
  </span>}
}

<span class="kw">fn </span>MaxMetablockSize(params: <span class="kw-2">&amp;</span>BrotliEncoderParams) -&gt; usize {
  <span class="kw">let </span>bits: i32 = brotli_min_int(ComputeRbBits(params), <span class="number">24i32</span>);
  <span class="number">1usize </span>&lt;&lt; bits
}



<span class="kw">fn </span>ChooseContextMap(quality: i32,
                    bigram_histo: <span class="kw-2">&amp;mut </span>[u32],
                    num_literal_contexts: <span class="kw-2">&amp;mut </span>usize,
                    literal_context_map: <span class="kw-2">&amp;mut &amp;</span>[u32]) {
  <span class="kw">static </span>kStaticContextMapContinuation: [u32; <span class="number">64</span>] =
    [<span class="number">1u32</span>, <span class="number">1u32</span>, <span class="number">2u32</span>, <span class="number">2u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
     <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
     <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
     <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
     <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>];
  <span class="kw">static </span>kStaticContextMapSimpleUTF8: [u32; <span class="number">64</span>] =
    [<span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">1u32</span>, <span class="number">1u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
     <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
     <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
     <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>,
     <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>];
  <span class="kw">let </span><span class="kw-2">mut </span>monogram_histo: [u32; <span class="number">3</span>] = [<span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>];
  <span class="kw">let </span><span class="kw-2">mut </span>two_prefix_histo: [u32; <span class="number">6</span>] = [<span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>];
  <span class="kw">let </span>total: usize;
  <span class="kw">let </span><span class="kw-2">mut </span>i: usize;
  <span class="kw">let </span><span class="kw-2">mut </span>dummy: usize = <span class="number">0</span>;
  <span class="kw">let </span><span class="kw-2">mut </span>entropy: [<span class="kw">super</span>::util::floatX; <span class="number">4</span>] = [<span class="number">0.0 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX;<span class="number">4</span>];
  i = <span class="number">0usize</span>;
  <span class="kw">while </span>i &lt; <span class="number">9usize </span>{
    {
      {
        <span class="kw">let </span>_rhs = bigram_histo[(i <span class="kw">as </span>(usize))];
        <span class="kw">let </span>_lhs = <span class="kw-2">&amp;mut </span>monogram_histo[i.wrapping_rem(<span class="number">3usize</span>)];
        <span class="kw-2">*</span>_lhs = (<span class="kw-2">*</span>_lhs).wrapping_add(_rhs);
      }
      {
        <span class="kw">let </span>_rhs = bigram_histo[(i <span class="kw">as </span>(usize))];
        <span class="kw">let </span>_lhs = <span class="kw-2">&amp;mut </span>two_prefix_histo[i.wrapping_rem(<span class="number">6usize</span>)];
        <span class="kw-2">*</span>_lhs = (<span class="kw-2">*</span>_lhs).wrapping_add(_rhs);
      }
    }
    i = i.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
  }
  entropy[<span class="number">1usize</span>] = ShannonEntropy(<span class="kw-2">&amp;</span>monogram_histo[..], <span class="number">3usize</span>, <span class="kw-2">&amp;mut </span>dummy);
  entropy[<span class="number">2usize</span>] = ShannonEntropy(<span class="kw-2">&amp;</span>two_prefix_histo[..], <span class="number">3usize</span>, <span class="kw-2">&amp;mut </span>dummy) +
                    ShannonEntropy(<span class="kw-2">&amp;</span>two_prefix_histo[<span class="number">3i32 </span><span class="kw">as </span>(usize)..],
                                   <span class="number">3usize</span>,
                                   <span class="kw-2">&amp;mut </span>dummy);
  entropy[<span class="number">3usize</span>] = <span class="number">0i32 </span><span class="kw">as </span>(<span class="kw">super</span>::util::floatX);
  i = <span class="number">0usize</span>;
  <span class="kw">while </span>i &lt; <span class="number">3usize </span>{
    {
      <span class="kw">let </span>_rhs = ShannonEntropy(<span class="kw-2">&amp;</span>bigram_histo[((<span class="number">3usize</span>).wrapping_mul(i) <span class="kw">as </span>(usize))..],
                                <span class="number">3usize</span>,
                                <span class="kw-2">&amp;mut </span>dummy);
      <span class="kw">let </span>_lhs = <span class="kw-2">&amp;mut </span>entropy[<span class="number">3usize</span>];
      <span class="kw-2">*</span>_lhs = <span class="kw-2">*</span>_lhs + _rhs;
    }
    i = i.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
  }
  total = monogram_histo[<span class="number">0usize</span>]
    .wrapping_add(monogram_histo[<span class="number">1usize</span>])
    .wrapping_add(monogram_histo[<span class="number">2usize</span>]) <span class="kw">as </span>(usize);
  <span class="number">0i32</span>;
  entropy[<span class="number">0usize</span>] = <span class="number">1.0 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX / total <span class="kw">as </span>(<span class="kw">super</span>::util::floatX);
  {
    <span class="kw">let </span>_rhs = entropy[<span class="number">0usize</span>];
    <span class="kw">let </span>_lhs = <span class="kw-2">&amp;mut </span>entropy[<span class="number">1usize</span>];
    <span class="kw-2">*</span>_lhs = <span class="kw-2">*</span>_lhs * _rhs;
  }
  {
    <span class="kw">let </span>_rhs = entropy[<span class="number">0usize</span>];
    <span class="kw">let </span>_lhs = <span class="kw-2">&amp;mut </span>entropy[<span class="number">2usize</span>];
    <span class="kw-2">*</span>_lhs = <span class="kw-2">*</span>_lhs * _rhs;
  }
  {
    <span class="kw">let </span>_rhs = entropy[<span class="number">0usize</span>];
    <span class="kw">let </span>_lhs = <span class="kw-2">&amp;mut </span>entropy[<span class="number">3usize</span>];
    <span class="kw-2">*</span>_lhs = <span class="kw-2">*</span>_lhs * _rhs;
  }
  <span class="kw">if </span>quality &lt; <span class="number">7i32 </span>{
    entropy[<span class="number">3usize</span>] = entropy[<span class="number">1usize</span>] * <span class="number">10i32 </span><span class="kw">as </span>(<span class="kw">super</span>::util::floatX);
  }
  <span class="kw">if </span>entropy[<span class="number">1usize</span>] - entropy[<span class="number">2usize</span>] &lt; <span class="number">0.2 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX &amp;&amp; (entropy[<span class="number">1usize</span>] - entropy[<span class="number">3usize</span>] &lt; <span class="number">0.2 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX) {
    <span class="kw-2">*</span>num_literal_contexts = <span class="number">1usize</span>;
  } <span class="kw">else if </span>entropy[<span class="number">2usize</span>] - entropy[<span class="number">3usize</span>] &lt; <span class="number">0.02 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX {
    <span class="kw-2">*</span>num_literal_contexts = <span class="number">2usize</span>;
    <span class="kw-2">*</span>literal_context_map = <span class="kw-2">&amp;</span>kStaticContextMapSimpleUTF8[..];
  } <span class="kw">else </span>{
    <span class="kw-2">*</span>num_literal_contexts = <span class="number">3usize</span>;
    <span class="kw-2">*</span>literal_context_map = <span class="kw-2">&amp;</span>kStaticContextMapContinuation[..];
  }
}

<span class="kw">static </span>kStaticContextMapComplexUTF8: [u32; <span class="number">64</span>] = [
    <span class="number">11</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="comment">/* 0 special */
    </span><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">/* 4 lf */
    </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="comment">/* 8 space */
    </span><span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="comment">/* !, first after space/lf and after something else. */
    </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="comment">/* &quot; */
    </span><span class="number">8</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="comment">/* % */
    </span><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="comment">/* ({[ */
    </span><span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="comment">/* }]) */
    </span><span class="number">8</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="comment">/* :; */
    </span><span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="comment">/* . */
    </span><span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">/* &gt; */
    </span><span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="comment">/* [0..9] */
    </span><span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="comment">/* [A-Z] */
    </span><span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>,
    <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="comment">/* [a-z] */
    </span><span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>,
  ];
<span class="comment">/* Decide if we want to use a more complex static context map containing 13
   context values, based on the entropy reduction of histograms over the
   first 5 bits of literals. */
</span><span class="kw">fn </span>ShouldUseComplexStaticContextMap(input: <span class="kw-2">&amp;</span>[u8],
    <span class="kw-2">mut </span>start_pos: usize, length : usize, mask : usize, quality: i32,
    size_hint: usize,
    num_literal_contexts: <span class="kw-2">&amp;mut </span>usize, literal_context_map: <span class="kw-2">&amp;mut &amp;</span>[u32]) -&gt; bool {
  <span class="kw">let _ </span>= quality;
  <span class="comment">//BROTLI_UNUSED(quality);
  /* Try the more complex static context map only for long data. */
  </span><span class="kw">if </span>(size_hint &lt; (<span class="number">1 </span>&lt;&lt; <span class="number">20</span>)) {
    <span class="kw">return </span><span class="bool-val">false</span>;
  } <span class="kw">else </span>{
    <span class="kw">let </span>end_pos = start_pos + length;
    <span class="comment">/* To make entropy calculations faster and to fit on the stack, we collect
       histograms over the 5 most significant bits of literals. One histogram
       without context and 13 additional histograms for each context value. */
    </span><span class="kw">let </span><span class="kw-2">mut </span>combined_histo:[u32; <span class="number">32</span>] = [<span class="number">0</span>;<span class="number">32</span>];
    <span class="kw">let </span><span class="kw-2">mut </span>context_histo:[[u32;<span class="number">32</span>]; <span class="number">13</span>] = [[<span class="number">0</span>;<span class="number">32</span>];<span class="number">13</span>];
    <span class="kw">let </span><span class="kw-2">mut </span>total = <span class="number">0u32</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>entropy = [<span class="number">0.0 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX;<span class="number">3</span>];
    <span class="kw">let </span><span class="kw-2">mut </span>dummy = <span class="number">0usize</span>;
    <span class="kw">let </span>utf8_lut = BROTLI_CONTEXT_LUT(ContextType::CONTEXT_UTF8);
    <span class="kw">while </span>start_pos + <span class="number">64 </span>&lt;= end_pos {
      <span class="kw">let </span>stride_end_pos = start_pos + <span class="number">64</span>;
      <span class="kw">let </span><span class="kw-2">mut </span>prev2 = input[start_pos &amp; mask];
      <span class="kw">let </span><span class="kw-2">mut </span>prev1 = input[(start_pos + <span class="number">1</span>) &amp; mask];

      <span class="comment">/* To make the analysis of the data faster we only examine 64 byte long
         strides at every 4kB intervals. */
      </span><span class="kw">for </span>pos <span class="kw">in </span>start_pos + <span class="number">2</span>..stride_end_pos {
        <span class="kw">let </span>literal = input[pos &amp; mask];
        <span class="kw">let </span>context = kStaticContextMapComplexUTF8[
            BROTLI_CONTEXT(prev1, prev2, utf8_lut) <span class="kw">as </span>usize] <span class="kw">as </span>u8;
        total += <span class="number">1</span>;
        combined_histo[(literal &gt;&gt; <span class="number">3</span>) <span class="kw">as </span>usize] += <span class="number">1</span>;
        context_histo[context <span class="kw">as </span>usize][(literal &gt;&gt; <span class="number">3</span>) <span class="kw">as </span>usize] += <span class="number">1</span>;
        prev2 = prev1;
        prev1 = literal;
      }
      start_pos += <span class="number">4096</span>;
    }
    entropy[<span class="number">1</span>] = ShannonEntropy(<span class="kw-2">&amp;</span>combined_histo[..], <span class="number">32</span>, <span class="kw-2">&amp;mut </span>dummy);
    entropy[<span class="number">2</span>] = <span class="number">0.0 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX;
    <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">13 </span>{
      <span class="macro">assert!</span>(i &lt; <span class="number">13</span>);
      entropy[<span class="number">2</span>] += ShannonEntropy(<span class="kw-2">&amp;</span>context_histo[i][..], <span class="number">32</span>, <span class="kw-2">&amp;mut </span>dummy);
    }
    entropy[<span class="number">0</span>] = (<span class="number">1.0 </span><span class="kw">as </span><span class="kw">super</span>::util::floatX) / (total <span class="kw">as </span><span class="kw">super</span>::util::floatX);
    entropy[<span class="number">1</span>] <span class="kw-2">*</span>= entropy[<span class="number">0</span>];
    entropy[<span class="number">2</span>] <span class="kw-2">*</span>= entropy[<span class="number">0</span>];
    <span class="comment">/* The triggering heuristics below were tuned by compressing the individual
       files of the silesia corpus. If we skip this kind of context modeling
       for not very well compressible input (i.e. entropy using context modeling
       is 60% of maximal entropy) or if expected savings by symbol are less
       than 0.2 bits, then in every case when it triggers, the final compression
       ratio is improved. Note however that this heuristics might be too strict
       for some cases and could be tuned further. */
    </span><span class="kw">if </span>(entropy[<span class="number">2</span>] &gt; <span class="number">3.0 </span>|| entropy[<span class="number">1</span>] - entropy[<span class="number">2</span>] &lt; <span class="number">0.2</span>) {
      <span class="kw">return </span><span class="bool-val">false</span>;
    } <span class="kw">else </span>{
      <span class="kw-2">*</span>num_literal_contexts = <span class="number">13</span>;
      <span class="kw-2">*</span>literal_context_map = <span class="kw-2">&amp;</span>kStaticContextMapComplexUTF8;
      <span class="kw">return </span><span class="bool-val">true</span>;
    }
  }
}

<span class="kw">fn </span>DecideOverLiteralContextModeling(input: <span class="kw-2">&amp;</span>[u8],
                                    <span class="kw-2">mut </span>start_pos: usize,
                                    length: usize,
                                    mask: usize,
                                    quality: i32,
                                    size_hint: usize,
                                    num_literal_contexts: <span class="kw-2">&amp;mut </span>usize,
                                    literal_context_map: <span class="kw-2">&amp;mut &amp;</span>[u32]) {
    
  <span class="kw">if </span>quality &lt; <span class="number">5i32 </span>|| length &lt; <span class="number">64usize </span>{
  } <span class="kw">else if </span>ShouldUseComplexStaticContextMap(input, start_pos, length, mask, quality, size_hint,
     num_literal_contexts, literal_context_map) {
  } <span class="kw">else </span>{
    <span class="kw">let </span>end_pos: usize = start_pos.wrapping_add(length);
    <span class="kw">let </span><span class="kw-2">mut </span>bigram_prefix_histo: [u32; <span class="number">9</span>] = [<span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>, <span class="number">0u32</span>];
    <span class="kw">while </span>start_pos.wrapping_add(<span class="number">64usize</span>) &lt;= end_pos {
      {
        <span class="kw">static </span>lut: [i32; <span class="number">4</span>] = [<span class="number">0i32</span>, <span class="number">0i32</span>, <span class="number">1i32</span>, <span class="number">2i32</span>];
        <span class="kw">let </span>stride_end_pos: usize = start_pos.wrapping_add(<span class="number">64usize</span>);
        <span class="kw">let </span><span class="kw-2">mut </span>prev: i32 = lut[(input[((start_pos &amp; mask) <span class="kw">as </span>(usize))] <span class="kw">as </span>(i32) &gt;&gt; <span class="number">6i32</span>) <span class="kw">as
        </span>(usize)] * <span class="number">3i32</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>pos: usize;
        pos = start_pos.wrapping_add(<span class="number">1usize</span>);
        <span class="kw">while </span>pos &lt; stride_end_pos {
          {
            <span class="kw">let </span>literal: u8 = input[((pos &amp; mask) <span class="kw">as </span>(usize))];
            {
              <span class="kw">let </span>_rhs = <span class="number">1</span>;
              <span class="kw">let </span>cur_ind = (prev + lut[(literal <span class="kw">as </span>(i32) &gt;&gt; <span class="number">6i32</span>) <span class="kw">as </span>(usize)]);
              <span class="kw">let </span>_lhs = <span class="kw-2">&amp;mut </span>bigram_prefix_histo[cur_ind <span class="kw">as
                              </span>(usize)];
              <span class="kw-2">*</span>_lhs = (<span class="kw-2">*</span>_lhs).wrapping_add(_rhs <span class="kw">as </span>(u32));
            }
            prev = lut[(literal <span class="kw">as </span>(i32) &gt;&gt; <span class="number">6i32</span>) <span class="kw">as </span>(usize)] * <span class="number">3i32</span>;
          }
          pos = pos.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
        }
      }
      start_pos = start_pos.wrapping_add(<span class="number">4096usize</span>);
    }
    ChooseContextMap(quality,
                     <span class="kw-2">&amp;mut </span>bigram_prefix_histo[..],
                     num_literal_contexts,
                     literal_context_map);
  }
}
<span class="kw">fn </span>WriteMetaBlockInternal&lt;Alloc: BrotliAlloc,
                          Cb&gt;
            (alloc: <span class="kw-2">&amp;mut </span>Alloc,
             data: <span class="kw-2">&amp;</span>[u8],
             mask: usize,
             last_flush_pos: u64,
             bytes: usize,
             <span class="kw-2">mut </span>is_last: i32,
             literal_context_mode: ContextType,
             params: <span class="kw-2">&amp;</span>BrotliEncoderParams,
             lit_scratch_space: <span class="kw-2">&amp;mut </span>&lt;HistogramLiteral <span class="kw">as </span>CostAccessors&gt;::i32vec,
             cmd_scratch_space: <span class="kw-2">&amp;mut </span>&lt;HistogramCommand <span class="kw">as </span>CostAccessors&gt;::i32vec,
             dst_scratch_space: <span class="kw-2">&amp;mut </span>&lt;HistogramDistance <span class="kw">as </span>CostAccessors&gt;::i32vec,
             prev_byte: u8,
             prev_byte2: u8,
             num_literals: usize,
             num_commands: usize,
             commands: <span class="kw-2">&amp;mut </span>[Command],
             saved_dist_cache: <span class="kw-2">&amp;</span>[i32;kNumDistanceCacheEntries],
             dist_cache: <span class="kw-2">&amp;mut </span>[i32;<span class="number">16</span>],
             recoder_state: <span class="kw-2">&amp;mut </span>RecoderState,
             storage_ix: <span class="kw-2">&amp;mut </span>usize,
             storage: <span class="kw-2">&amp;mut </span>[u8],
            cb: <span class="kw-2">&amp;mut </span>Cb) <span class="kw">where </span>Cb: FnMut(<span class="kw-2">&amp;mut </span>interface::PredictionModeContextMap&lt;InputReferenceMut&gt;,
                                         <span class="kw-2">&amp;mut </span>[interface::StaticCommand],
                                         interface::InputPair, <span class="kw-2">&amp;mut </span>Alloc) {
  <span class="kw">let </span>actual_is_last = is_last;
  <span class="kw">if </span>params.appendable {
    is_last = <span class="number">0</span>;
  } <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(params.catable, <span class="bool-val">false</span>); <span class="comment">// Sanitize Params senforces this constraint
  </span>}
  <span class="kw">let </span>wrapped_last_flush_pos: u32 = WrapPosition(last_flush_pos);
  <span class="kw">let </span>last_bytes: u16;
  <span class="kw">let </span>last_bytes_bits: u8;
  <span class="kw">let </span>literal_context_lut = BROTLI_CONTEXT_LUT(literal_context_mode);
  <span class="kw">let </span><span class="kw-2">mut </span>block_params = params.clone();
  <span class="kw">if </span>bytes == <span class="number">0usize </span>{
    BrotliWriteBits(<span class="number">2usize</span>, <span class="number">3</span>, storage_ix, storage);
    <span class="kw-2">*</span>storage_ix = (<span class="kw-2">*</span>storage_ix).wrapping_add(<span class="number">7u32 </span><span class="kw">as </span>(usize)) &amp; !<span class="number">7u32 </span><span class="kw">as </span>(usize);
    <span class="kw">return</span>;
  }
  <span class="kw">if </span>ShouldCompress(data,
                    mask,
                    last_flush_pos,
                    bytes,
                    num_literals,
                    num_commands) == <span class="number">0 </span>{
    dist_cache[..<span class="number">4</span>].clone_from_slice(<span class="kw-2">&amp;</span>saved_dist_cache[..<span class="number">4</span>]);
    BrotliStoreUncompressedMetaBlock(alloc,
                                     is_last,
                                     data,
                                     wrapped_last_flush_pos <span class="kw">as </span>(usize),
                                     mask,
                                     params,
                                     bytes,
                                     recoder_state,
                                     storage_ix,
                                     storage,
                                     <span class="bool-val">false</span>,
                                     cb);
    <span class="kw">if </span>actual_is_last != is_last {
      BrotliWriteEmptyLastMetaBlock(storage_ix, storage)
    }
    <span class="kw">return</span>;
  }
  <span class="kw">let </span>saved_byte_location = (<span class="kw-2">*</span>storage_ix) &gt;&gt; <span class="number">3</span>;
  last_bytes = ((storage[saved_byte_location + <span class="number">1</span>] <span class="kw">as </span>u16) &lt;&lt; <span class="number">8</span>) | storage[saved_byte_location] <span class="kw">as </span>u16;
  last_bytes_bits = <span class="kw-2">*</span>storage_ix <span class="kw">as </span>u8;
  <span class="comment">/*if params.dist.num_direct_distance_codes != 0 ||
                    params.dist.distance_postfix_bits != 0 {
    RecomputeDistancePrefixes(commands,
                              num_commands,
                              params.dist.num_direct_distance_codes,
                              params.dist.distance_postfix_bits);
  }*/ // why was this removed??
  </span><span class="kw">if </span>(<span class="kw-2">*</span>params).quality &lt;= <span class="number">2i32 </span>{
    BrotliStoreMetaBlockFast(alloc,
                             data,
                             wrapped_last_flush_pos <span class="kw">as </span>(usize),
                             bytes,
                             mask,
                             is_last,
                             params,
                             saved_dist_cache,
                             commands,
                             num_commands,
                             recoder_state,
                             storage_ix,
                             storage,
                             cb);
  } <span class="kw">else if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">4i32 </span>{
    BrotliStoreMetaBlockTrivial(alloc,
                                data,
                                wrapped_last_flush_pos <span class="kw">as </span>(usize),
                                bytes,
                                mask,
                                is_last,
                                params,
                                saved_dist_cache,
                                commands,
                                num_commands,
                                recoder_state,
                                storage_ix,
                                storage,
                                cb);
  } <span class="kw">else </span>{
    <span class="comment">//let mut literal_context_mode: ContextType = ContextType::CONTEXT_UTF8;
    
    </span><span class="kw">let </span><span class="kw-2">mut </span>mb = MetaBlockSplit::&lt;Alloc&gt;::new();
    <span class="kw">if </span>(<span class="kw-2">*</span>params).quality &lt; <span class="number">10i32 </span>{
      <span class="kw">let </span><span class="kw-2">mut </span>num_literal_contexts: usize = <span class="number">1usize</span>;
      <span class="kw">let </span><span class="kw-2">mut </span>literal_context_map: <span class="kw-2">&amp;</span>[u32] = <span class="kw-2">&amp;</span>[];
      <span class="kw">if </span>(<span class="kw-2">*</span>params).disable_literal_context_modeling == <span class="number">0 </span>{
        DecideOverLiteralContextModeling(data,
                                         wrapped_last_flush_pos <span class="kw">as </span>(usize),
                                         bytes,
                                         mask,
                                         (<span class="kw-2">*</span>params).quality,
                                         (<span class="kw-2">*</span>params).size_hint,
                                         <span class="kw-2">&amp;mut </span>num_literal_contexts,
                                         <span class="kw-2">&amp;mut </span>literal_context_map);
      }
      BrotliBuildMetaBlockGreedy(alloc,
                                 data,
                                 wrapped_last_flush_pos <span class="kw">as </span>(usize),
                                 mask,
                                 prev_byte,
                                 prev_byte2,
                                 literal_context_mode,
                                 literal_context_lut,
                                 num_literal_contexts,
                                 literal_context_map,
                                 commands,
                                 num_commands,
                                 <span class="kw-2">&amp;mut </span>mb);
    } <span class="kw">else </span>{
      BrotliBuildMetaBlock(alloc,
                           data,
                           wrapped_last_flush_pos <span class="kw">as </span>(usize),
                           mask,
                           <span class="kw-2">&amp;mut </span>block_params,
                           prev_byte,
                           prev_byte2,
                           commands,
                           num_commands,
                           literal_context_mode,
                           lit_scratch_space,
                           cmd_scratch_space,
                           dst_scratch_space,
                           <span class="kw-2">&amp;mut </span>mb);
    }
    <span class="kw">if </span>(<span class="kw-2">*</span>params).quality &gt;= <span class="number">4i32 </span>{
        <span class="kw">let </span><span class="kw-2">mut </span>num_effective_dist_codes = block_params.dist.alphabet_size;
        <span class="kw">if </span>num_effective_dist_codes &gt; BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS <span class="kw">as </span>u32 {
            num_effective_dist_codes = BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS <span class="kw">as </span>u32;
        }
        BrotliOptimizeHistograms(num_effective_dist_codes <span class="kw">as </span>usize,
                               <span class="kw-2">&amp;mut </span>mb);
    }
    BrotliStoreMetaBlock(alloc,
                         data,
                         wrapped_last_flush_pos <span class="kw">as </span>(usize),
                         bytes,
                         mask,
                         prev_byte,
                         prev_byte2,
                         is_last,
                         <span class="kw-2">&amp;</span>block_params,
                         literal_context_mode,
                         saved_dist_cache,
                         commands,
                         num_commands,
                         <span class="kw-2">&amp;mut </span>mb,
                         recoder_state,
                         storage_ix,
                         storage,
                         cb);
    mb.destroy(alloc);
  }
  <span class="kw">if </span>bytes + <span class="number">4 </span>+ saved_byte_location &lt; (<span class="kw-2">*</span>storage_ix &gt;&gt; <span class="number">3i32</span>) {
      dist_cache[..<span class="number">4</span>].clone_from_slice(<span class="kw-2">&amp;</span>saved_dist_cache[..<span class="number">4</span>]);
      <span class="comment">//memcpy(dist_cache,
      //     saved_dist_cache,
      //     (4usize).wrapping_mul(::std::mem::size_of::&lt;i32&gt;()));
      </span>storage[saved_byte_location] = last_bytes <span class="kw">as </span>u8;
      storage[saved_byte_location + <span class="number">1</span>] = (last_bytes &gt;&gt; <span class="number">8</span>) <span class="kw">as </span>u8;
      <span class="kw-2">*</span>storage_ix = last_bytes_bits <span class="kw">as </span>(usize);
      BrotliStoreUncompressedMetaBlock(alloc,
                                       is_last,
                                       data,
                                       wrapped_last_flush_pos <span class="kw">as </span>(usize),
                                       mask,
                                       params,
                                       bytes,
                                       recoder_state,
                                       storage_ix,
                                       storage,
                                       <span class="bool-val">true</span>,
                                       cb);
  }
  <span class="kw">if </span>actual_is_last != is_last {
    BrotliWriteEmptyLastMetaBlock(storage_ix, storage)
  }
}

<span class="kw">fn </span>ChooseDistanceParams(params: <span class="kw-2">&amp;mut </span>BrotliEncoderParams) {
    <span class="kw">let </span><span class="kw-2">mut </span>num_direct_distance_codes = <span class="number">0u32</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>distance_postfix_bits = <span class="number">0u32</span>;

    <span class="kw">if </span>params.quality &gt;= <span class="number">4 </span>{
        <span class="kw">let </span>ndirect_msb;
        <span class="kw">if </span>params.mode == BrotliEncoderMode::BROTLI_MODE_FONT {
            distance_postfix_bits = <span class="number">1</span>;
            num_direct_distance_codes = <span class="number">12</span>;
        } <span class="kw">else </span>{
            distance_postfix_bits = params.dist.distance_postfix_bits;
            num_direct_distance_codes = params.dist.num_direct_distance_codes;
        }
        ndirect_msb = (num_direct_distance_codes &gt;&gt; distance_postfix_bits) &amp; <span class="number">0x0f</span>;
        <span class="kw">if </span>distance_postfix_bits &gt; BROTLI_MAX_NPOSTFIX <span class="kw">as </span>u32 || num_direct_distance_codes &gt; BROTLI_MAX_NDIRECT <span class="kw">as </span>u32 || (ndirect_msb &lt;&lt; distance_postfix_bits) != num_direct_distance_codes {
            distance_postfix_bits = <span class="number">0</span>;
            num_direct_distance_codes = <span class="number">0</span>;
        }
    }
    BrotliInitDistanceParams(params, distance_postfix_bits, num_direct_distance_codes);
    <span class="comment">/*(
    if (params.large_window) {
        max_distance = BROTLI_MAX_ALLOWED_DISTANCE;
        if (num_direct_distance_codes != 0 || distance_postfix_bits != 0) {
            max_distance = (3 &lt;&lt; 29) - 4;
        }
        alphabet_size = BROTLI_DISTANCE_ALPHABET_SIZE(
            num_direct_distance_codes, distance_postfix_bits,
            BROTLI_LARGE_MAX_DISTANCE_BITS);
    } else {
        alphabet_size = BROTLI_DISTANCE_ALPHABET_SIZE(
            num_direct_distance_codes, distance_postfix_bits,
            BROTLI_MAX_DISTANCE_BITS);

    }

    params.dist.num_direct_distance_codes = num_direct_distance_codes;
    params.dist.distance_postfix_bits = distance_postfix_bits;
    params.dist.alphabet_size = alphabet_size;
    params.dist.max_distance = max_distance;*/
</span>}
        

<span class="kw">fn </span>EncodeData&lt;Alloc: BrotliAlloc,
              MetablockCallback&gt;(
    s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
    is_last: i32,
    force_flush: i32,
    out_size: <span class="kw-2">&amp;mut </span>usize,
    callback: <span class="kw-2">&amp;mut </span>MetablockCallback
<span class="comment">//              mut output: &amp;&#39;a mut &amp;&#39;a mut [u8]
</span>) -&gt; i32 <span class="kw">where </span>MetablockCallback: FnMut(<span class="kw-2">&amp;mut </span>interface::PredictionModeContextMap&lt;InputReferenceMut&gt;,
                                        <span class="kw-2">&amp;mut </span>[interface::StaticCommand],
                                        interface::InputPair, <span class="kw-2">&amp;mut </span>Alloc){
  <span class="kw">let </span><span class="kw-2">mut </span>delta: u64 = UnprocessedInputSize(s);
  <span class="kw">let </span><span class="kw-2">mut </span>bytes: u32 = delta <span class="kw">as </span>(u32);
  <span class="kw">let </span>mask = (<span class="kw-2">*</span>s).ringbuffer_.mask_;
  <span class="kw">if </span>EnsureInitialized(s) == <span class="number">0 </span>{
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">let </span>dictionary = BrotliGetDictionary();
  <span class="kw">if </span>(<span class="kw-2">*</span>s).is_last_block_emitted_ {
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">if </span>is_last != <span class="number">0 </span>{
    (<span class="kw-2">*</span>s).is_last_block_emitted_ = <span class="bool-val">true</span>;
  }
  <span class="kw">if </span>delta &gt; InputBlockSize(s) <span class="kw">as </span>u64 {
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">let </span><span class="kw-2">mut </span>storage_ix: usize = usize::from((<span class="kw-2">*</span>s).last_bytes_bits_);
  {
    <span class="kw">let </span>meta_size = core::cmp::max(bytes <span class="kw">as </span>usize,
                                   (<span class="kw-2">*</span>s).input_pos_.wrapping_sub((<span class="kw-2">*</span>s).last_flush_pos_) <span class="kw">as </span>usize);
    GetBrotliStorage(s,
                     (<span class="number">2usize</span>).wrapping_mul(meta_size).wrapping_add(<span class="number">503 </span>+ <span class="number">24</span>));
  }
  {
    (<span class="kw-2">*</span>s).storage_.slice_mut()[<span class="number">0</span>] = (<span class="kw-2">*</span>s).last_bytes_ <span class="kw">as </span>u8;
    (<span class="kw-2">*</span>s).storage_.slice_mut()[<span class="number">1</span>] = ((<span class="kw-2">*</span>s).last_bytes_ &gt;&gt; <span class="number">8</span>) <span class="kw">as </span>u8;
  }
  <span class="kw">let </span><span class="kw-2">mut </span>catable_header_size = <span class="number">0</span>;
  <span class="kw">if let </span>IsFirst::NothingWritten = s.is_first_mb {
    <span class="kw">if </span>s.params.magic_number {
      BrotliWriteMetadataMetaBlock(<span class="kw-2">&amp;</span>s.params, <span class="kw-2">&amp;mut </span>storage_ix, (<span class="kw-2">*</span>s).storage_.slice_mut());
      (<span class="kw-2">*</span>s).last_bytes_ = (<span class="kw-2">*</span>s).storage_.slice()[((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize))] <span class="kw">as </span>u16 | (
        ((<span class="kw-2">*</span>s).storage_.slice()[<span class="number">1 </span>+ ((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize))] <span class="kw">as </span>u16)&lt;&lt;<span class="number">8</span>);
      (<span class="kw-2">*</span>s).last_bytes_bits_ = (storage_ix &amp; <span class="number">7u32 </span><span class="kw">as </span>(usize)) <span class="kw">as </span>(u8);
      (<span class="kw-2">*</span>s).next_out_ = NextOut::DynamicStorage(<span class="number">0</span>);
      catable_header_size = storage_ix &gt;&gt; <span class="number">3</span>;
      <span class="kw-2">*</span>out_size = catable_header_size;
      s.is_first_mb = IsFirst::HeaderWritten;
    }
  }
  <span class="kw">if let </span>IsFirst::BothCatableBytesWritten = s.is_first_mb {
    <span class="comment">// nothing to do here, move along
  </span>} <span class="kw">else if </span>!s.params.catable {
    s.is_first_mb = IsFirst::BothCatableBytesWritten;
  } <span class="kw">else if </span>bytes != <span class="number">0 </span>{
    <span class="macro">assert!</span>(s.last_processed_pos_ &lt; <span class="number">2 </span>|| s.custom_dictionary);
    <span class="kw">let </span>num_bytes_to_write_uncompressed:usize = core::cmp::min(<span class="number">2</span>, bytes <span class="kw">as </span>usize);
    {
      <span class="kw">let </span>data = <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).ringbuffer_.data_mo.slice_mut ()[((<span class="kw-2">*</span>s).ringbuffer_.buffer_index <span class="kw">as </span>(usize))..];
      BrotliStoreUncompressedMetaBlock(<span class="kw-2">&amp;mut </span>s.m8,
                                       <span class="number">0</span>,
                                       data,
                                       s.last_flush_pos_ <span class="kw">as </span>usize,
                                       mask <span class="kw">as </span>usize,
                                       <span class="kw-2">&amp;</span>s.params,
                                       num_bytes_to_write_uncompressed,
                                       <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).recoder_state,
                                       <span class="kw-2">&amp;mut </span>storage_ix,
                                       (<span class="kw-2">*</span>s).storage_.slice_mut(),
                                       <span class="bool-val">false </span><span class="comment">/* suppress meta-block logging */</span>,
                                       callback);
      (<span class="kw-2">*</span>s).last_bytes_ = (<span class="kw-2">*</span>s).storage_.slice()[((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize))] <span class="kw">as </span>u16 | (
        ((<span class="kw-2">*</span>s).storage_.slice()[<span class="number">1 </span>+ ((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize))] <span class="kw">as </span>u16)&lt;&lt;<span class="number">8</span>);
      (<span class="kw-2">*</span>s).last_bytes_bits_ = (storage_ix &amp; <span class="number">7u32 </span><span class="kw">as </span>(usize)) <span class="kw">as </span>(u8);
      s.prev_byte2_ = s.prev_byte_;
      s.prev_byte_ = data[s.last_flush_pos_ <span class="kw">as </span>usize &amp; mask <span class="kw">as </span>usize];
      <span class="kw">if </span>num_bytes_to_write_uncompressed == <span class="number">2 </span>{
        s.prev_byte2_ = s.prev_byte_;
        s.prev_byte_ = data[(s.last_flush_pos_ + <span class="number">1</span>) <span class="kw">as </span>usize &amp; mask <span class="kw">as </span>usize];
      }
    }
    s.last_flush_pos_ += num_bytes_to_write_uncompressed <span class="kw">as </span>u64;
    bytes -= num_bytes_to_write_uncompressed <span class="kw">as </span>u32;
    (<span class="kw-2">*</span>s).last_processed_pos_ += num_bytes_to_write_uncompressed <span class="kw">as </span>u64;
    <span class="kw">if </span>num_bytes_to_write_uncompressed &gt;= <span class="number">2 </span>{
      s.is_first_mb = IsFirst::BothCatableBytesWritten;
    } <span class="kw">else if </span>num_bytes_to_write_uncompressed == <span class="number">1 </span>{
      <span class="kw">if let </span>IsFirst::FirstCatableByteWritten = s.is_first_mb {
        s.is_first_mb = IsFirst::BothCatableBytesWritten;
      } <span class="kw">else </span>{
        s.is_first_mb = IsFirst::FirstCatableByteWritten;
      }
    }
    catable_header_size = storage_ix &gt;&gt; <span class="number">3</span>;
    (<span class="kw-2">*</span>s).next_out_ = NextOut::DynamicStorage(<span class="number">0</span>);
    <span class="kw-2">*</span>out_size = catable_header_size;
    delta = UnprocessedInputSize(s);
  }
  <span class="kw">let </span><span class="kw-2">mut </span>wrapped_last_processed_pos: u32 = WrapPosition((<span class="kw-2">*</span>s).last_processed_pos_);
  <span class="kw">if </span>(<span class="kw-2">*</span>s).params.quality == <span class="number">1i32 </span>&amp;&amp; (<span class="kw-2">*</span>s).command_buf_.slice().len() == <span class="number">0 </span>{
    <span class="kw">let </span>new_buf = &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::alloc_cell(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).m8, kCompressFragmentTwoPassBlockSize);
    (<span class="kw-2">*</span>s).command_buf_ = new_buf;
    <span class="kw">let </span>new_buf8 = &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::alloc_cell(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).m8, kCompressFragmentTwoPassBlockSize);
    (<span class="kw-2">*</span>s).literal_buf_ = new_buf8;
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).params.quality == <span class="number">0i32 </span>|| (<span class="kw-2">*</span>s).params.quality == <span class="number">1i32 </span>{
    <span class="kw">let </span><span class="kw-2">mut </span>table_size: usize = <span class="number">0</span>;
    {
    <span class="kw">let </span>table: <span class="kw-2">&amp;mut </span>[i32];
    <span class="kw">if </span>delta == <span class="number">0 </span>&amp;&amp; (is_last == <span class="number">0</span>) {
      <span class="kw-2">*</span>out_size = catable_header_size;
      <span class="kw">return </span><span class="number">1i32</span>;
    }
    <span class="kw">let </span>data = <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).ringbuffer_.data_mo.slice_mut ()[((<span class="kw-2">*</span>s).ringbuffer_.buffer_index <span class="kw">as </span>(usize))..];
        
      <span class="comment">//(*s).storage_.slice_mut()[0] = (*s).last_bytes_ as u8;
      //        (*s).storage_.slice_mut()[1] = ((*s).last_bytes_ &gt;&gt; 8) as u8;

    </span>table = <span class="macro">GetHashTable!</span>(s, (<span class="kw-2">*</span>s).params.quality, bytes <span class="kw">as </span>(usize), <span class="kw-2">&amp;mut </span>table_size);
        
    <span class="kw">if </span>(<span class="kw-2">*</span>s).params.quality == <span class="number">0i32 </span>{
      BrotliCompressFragmentFast(<span class="kw-2">&amp;mut </span>s.m8,
                                 <span class="kw-2">&amp;mut </span>data[((wrapped_last_processed_pos &amp; mask) <span class="kw">as </span>(usize))..],
                                 bytes <span class="kw">as </span>(usize),
                                 is_last,
                                 table,
                                 table_size,
                                 <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_depths_[..],
                                 <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_bits_[..],
                                 <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_code_numbits_,
                                 <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_code_[..],
                                 <span class="kw-2">&amp;mut </span>storage_ix,
                                 (<span class="kw-2">*</span>s).storage_.slice_mut());
    } <span class="kw">else </span>{
      BrotliCompressFragmentTwoPass(<span class="kw-2">&amp;mut </span>s.m8,
                                    <span class="kw-2">&amp;mut </span>data[((wrapped_last_processed_pos &amp; mask) <span class="kw">as </span>(usize))..],
                                    bytes <span class="kw">as </span>(usize),
                                    is_last,
                                    (<span class="kw-2">*</span>s).command_buf_.slice_mut(),
                                    (<span class="kw-2">*</span>s).literal_buf_.slice_mut(),
                                    table,
                                    table_size,
                                    <span class="kw-2">&amp;mut </span>storage_ix,
                                    (<span class="kw-2">*</span>s).storage_.slice_mut());
    }
    (<span class="kw-2">*</span>s).last_bytes_ = (<span class="kw-2">*</span>s).storage_.slice()[((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize))] <span class="kw">as </span>u16 | ((
        (<span class="kw-2">*</span>s).storage_.slice()[((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize)) + <span class="number">1</span>] <span class="kw">as </span>u16) &lt;&lt; <span class="number">8</span>);
    (<span class="kw-2">*</span>s).last_bytes_bits_ = (storage_ix &amp; <span class="number">7u32 </span><span class="kw">as </span>(usize)) <span class="kw">as </span>(u8);
    }
    UpdateLastProcessedPos(s);
    <span class="comment">// *output = &amp;mut (*s).storage_.slice_mut();
    </span>(<span class="kw-2">*</span>s).next_out_ = NextOut::DynamicStorage(<span class="number">0</span>); <span class="comment">// this always returns that
    </span><span class="kw-2">*</span>out_size = storage_ix &gt;&gt; <span class="number">3i32</span>;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  {
    <span class="kw">let </span><span class="kw-2">mut </span>newsize: usize =
      (<span class="kw-2">*</span>s).num_commands_.wrapping_add(bytes.wrapping_div(<span class="number">2u32</span>) <span class="kw">as </span>(usize)).wrapping_add(<span class="number">1usize</span>);
    <span class="kw">if </span>newsize &gt; (<span class="kw-2">*</span>s).cmd_alloc_size_ {
      newsize = newsize.wrapping_add(bytes.wrapping_div(<span class="number">4u32</span>).wrapping_add(<span class="number">16u32</span>) <span class="kw">as </span>(usize));
      (<span class="kw-2">*</span>s).cmd_alloc_size_ = newsize;
      <span class="kw">let </span><span class="kw-2">mut </span>new_commands = &lt;Alloc <span class="kw">as </span>Allocator&lt;Command&gt;&gt;::alloc_cell(<span class="kw-2">&amp;mut </span>s.m8, newsize);
      <span class="kw">if </span>(<span class="kw-2">*</span>s).commands_.slice().len() != <span class="number">0 </span>{
        new_commands.slice_mut()[..(<span class="kw-2">*</span>s).num_commands_].clone_from_slice(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span>s).commands_.slice()[..(<span class="kw-2">*</span>s).num_commands_]);
        &lt;Alloc <span class="kw">as </span>Allocator&lt;Command&gt;&gt;::free_cell(<span class="kw-2">&amp;mut </span>s.m8, core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).commands_, &lt;Alloc <span class="kw">as </span>Allocator&lt;Command&gt;&gt;::AllocatedMemory::default()));
      }
      (<span class="kw-2">*</span>s).commands_ = new_commands;
    }
  }
  InitOrStitchToPreviousBlock(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).m8,
                              <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).hasher_,
                              <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).ringbuffer_.data_mo.slice_mut()[((<span class="kw-2">*</span>s).ringbuffer_.buffer_index <span class="kw">as </span>(usize))..],
                              mask <span class="kw">as </span>(usize),
                              <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).params,
                              wrapped_last_processed_pos <span class="kw">as </span>(usize),
                              bytes <span class="kw">as </span>(usize),
                              is_last);
  <span class="kw">let </span>literal_context_mode = ChooseContextMode(
      <span class="kw-2">&amp;</span>s.params, (<span class="kw-2">*</span>s).ringbuffer_.data_mo.slice(), WrapPosition(s.last_flush_pos_) <span class="kw">as </span>usize,
      mask <span class="kw">as </span>usize, (s.input_pos_.wrapping_sub(s.last_flush_pos_)) <span class="kw">as </span>usize);
  <span class="kw">if </span>s.num_commands_ != <span class="number">0 </span>&amp;&amp; s.last_insert_len_ == <span class="number">0 </span>{
      ExtendLastCommand(s, <span class="kw-2">&amp;mut </span>bytes, <span class="kw-2">&amp;mut </span>wrapped_last_processed_pos);
  }
  <span class="kw">if </span><span class="bool-val">false </span>{ <span class="comment">// we are remapping 10 as quality=9.5 since Zopfli doesn&#39;t seem to offer much benefits here
    </span><span class="macro">panic!</span>(<span class="string">r####&quot;
    BrotliCreateZopfliBackwardReferences(m,
                                         dictionary,
                                         bytes as (usize),
                                         wrapped_last_processed_pos as (usize),
                                         data,
                                         mask as (usize),
                                         &amp;mut (*s).params,
                                         (*s).hasher_,
                                         (*s).dist_cache_.as_mut_ptr(),
                                         &amp;mut (*s).last_insert_len_,
                                         &amp;mut *(*s).commands_[((*s).num_commands_ as (usize))..],
                                         &amp;mut (*s).num_commands_,
                                         &amp;mut (*s).num_literals_);&quot;####</span>);
  } <span class="kw">else if </span><span class="bool-val">false </span>&amp;&amp; (<span class="kw-2">*</span>s).params.quality == <span class="number">11i32 </span>{
    <span class="macro">panic!</span>(<span class="string">r####&quot;BrotliCreateHqZopfliBackwardReferences(m,
                                           dictionary,
                                           bytes as (usize),
                                           wrapped_last_processed_pos as (usize),
                                           data,
                                           mask as (usize),
                                           &amp;mut (*s).params,
                                           (*s).hasher_,
                                           (*s).dist_cache_.as_mut_ptr(),
                                           &amp;mut (*s).last_insert_len_,
                                           &amp;mut *(*s).commands_[((*s).num_commands_ as (usize))..],
                                           &amp;mut (*s).num_commands_,
                                           &amp;mut (*s).num_literals_);&quot;####</span>);
  } <span class="kw">else </span>{
    BrotliCreateBackwardReferences(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).m8, <span class="kw-2">&amp;</span>dictionary,
                                   bytes <span class="kw">as </span>(usize),
                                   wrapped_last_processed_pos <span class="kw">as </span>(usize),
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).ringbuffer_.data_mo.slice_mut()[((<span class="kw-2">*</span>s).ringbuffer_.buffer_index <span class="kw">as </span>usize)..],
                                   mask <span class="kw">as </span>(usize),
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).params,
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).hasher_,
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).dist_cache_,
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).last_insert_len_,
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).commands_.slice_mut()[((<span class="kw-2">*</span>s).num_commands_ <span class="kw">as </span>(usize))..],
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).num_commands_,
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).num_literals_);
  }
  {
    <span class="kw">let </span>max_length: usize = MaxMetablockSize(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).params);
    <span class="kw">let </span>max_literals: usize = max_length.wrapping_div(<span class="number">8usize</span>);
    <span class="kw">let </span>max_commands: usize = max_length.wrapping_div(<span class="number">8usize</span>);
    <span class="kw">let </span>processed_bytes: usize = (<span class="kw-2">*</span>s).input_pos_.wrapping_sub((<span class="kw-2">*</span>s).last_flush_pos_) <span class="kw">as </span>usize;
    <span class="kw">let </span>next_input_fits_metablock: i32 = <span class="kw">if </span>!!(processed_bytes.wrapping_add(InputBlockSize(s)) &lt;=
                                               max_length) {
      <span class="number">1i32
    </span>} <span class="kw">else </span>{
      <span class="number">0i32
    </span>};
    <span class="kw">let </span>should_flush: i32 = <span class="kw">if </span>!!((<span class="kw-2">*</span>s).params.quality &lt; <span class="number">4i32 </span>&amp;&amp;
                                  ((<span class="kw-2">*</span>s).num_literals_.wrapping_add((<span class="kw-2">*</span>s).num_commands_) &gt;=
                                   <span class="number">0x2fffusize</span>)) {
      <span class="number">1i32
    </span>} <span class="kw">else </span>{
      <span class="number">0i32
    </span>};
    <span class="kw">if </span>is_last == <span class="number">0 </span>&amp;&amp; (force_flush == <span class="number">0</span>) &amp;&amp; (should_flush == <span class="number">0</span>) &amp;&amp;
       (next_input_fits_metablock != <span class="number">0</span>) &amp;&amp; ((<span class="kw-2">*</span>s).num_literals_ &lt; max_literals) &amp;&amp;
       ((<span class="kw-2">*</span>s).num_commands_ &lt; max_commands) {
      <span class="kw">if </span>UpdateLastProcessedPos(s) != <span class="number">0 </span>{
        HasherReset(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).hasher_);
      }
      <span class="kw-2">*</span>out_size = catable_header_size;
      <span class="kw">return </span><span class="number">1i32</span>;
    }
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).last_insert_len_ &gt; <span class="number">0usize </span>{
    InitInsertCommand(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).commands_.slice_mut()[({
                               <span class="kw">let </span>_old = (<span class="kw-2">*</span>s).num_commands_;
                               (<span class="kw-2">*</span>s).num_commands_ = (<span class="kw-2">*</span>s).num_commands_.wrapping_add(<span class="number">1 </span><span class="kw">as </span>(usize));
                               _old
                             } <span class="kw">as </span>(usize))],
                      (<span class="kw-2">*</span>s).last_insert_len_);
    (<span class="kw-2">*</span>s).num_literals_ = (<span class="kw-2">*</span>s).num_literals_.wrapping_add((<span class="kw-2">*</span>s).last_insert_len_);
    (<span class="kw-2">*</span>s).last_insert_len_ = <span class="number">0usize</span>;
  }
  <span class="kw">if </span>is_last == <span class="number">0 </span>&amp;&amp; ((<span class="kw-2">*</span>s).input_pos_ == (<span class="kw-2">*</span>s).last_flush_pos_) {
    <span class="kw-2">*</span>out_size = catable_header_size;
    <span class="kw">return </span><span class="number">1i32</span>;
  }
  {
    <span class="kw">let </span>metablock_size: u32 = (<span class="kw-2">*</span>s).input_pos_.wrapping_sub((<span class="kw-2">*</span>s).last_flush_pos_) <span class="kw">as </span>(u32);
    <span class="comment">//let mut storage_ix: usize = (*s).last_bytes_bits_ as (usize);
    //(*s).storage_.slice_mut()[(0usize)] = (*s).last_bytes_ as u8;
    //(*s).storage_.slice_mut()[(1usize)] = ((*s).last_bytes_ &gt;&gt; 8) as u8;

    </span>WriteMetaBlockInternal(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).m8,
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).ringbuffer_.data_mo.slice_mut()[((<span class="kw-2">*</span>s).ringbuffer_.buffer_index <span class="kw">as </span>usize)..],
                           mask <span class="kw">as </span>(usize),
                           (<span class="kw-2">*</span>s).last_flush_pos_,
                           metablock_size <span class="kw">as </span>(usize),
                           is_last,
                           literal_context_mode,
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).params,
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).literal_scratch_space,
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).command_scratch_space,
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).distance_scratch_space,
                           (<span class="kw-2">*</span>s).prev_byte_,
                           (<span class="kw-2">*</span>s).prev_byte2_,
                           (<span class="kw-2">*</span>s).num_literals_,
                           (<span class="kw-2">*</span>s).num_commands_,
                           (<span class="kw-2">*</span>s).commands_.slice_mut(),
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).saved_dist_cache_,
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).dist_cache_,
                           <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).recoder_state,
                           <span class="kw-2">&amp;mut </span>storage_ix,
                           (<span class="kw-2">*</span>s).storage_.slice_mut(),
                           callback);

    (<span class="kw-2">*</span>s).last_bytes_ = (<span class="kw-2">*</span>s).storage_.slice()[((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize))] <span class="kw">as </span>u16 | (
          ((<span class="kw-2">*</span>s).storage_.slice()[<span class="number">1 </span>+ ((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize))] <span class="kw">as </span>u16)&lt;&lt;<span class="number">8</span>);
    (<span class="kw-2">*</span>s).last_bytes_bits_ = (storage_ix &amp; <span class="number">7u32 </span><span class="kw">as </span>(usize)) <span class="kw">as </span>(u8);
    (<span class="kw-2">*</span>s).last_flush_pos_ = (<span class="kw-2">*</span>s).input_pos_;
    <span class="kw">if </span>UpdateLastProcessedPos(s) != <span class="number">0 </span>{
      HasherReset(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).hasher_);
    }
    <span class="kw">let </span>data = <span class="kw-2">&amp;</span>(<span class="kw-2">*</span>s).ringbuffer_.data_mo.slice()[(<span class="kw-2">*</span>s).ringbuffer_.buffer_index <span class="kw">as </span>usize..];
    <span class="kw">if </span>(<span class="kw-2">*</span>s).last_flush_pos_ &gt; <span class="number">0 </span>{
      (<span class="kw-2">*</span>s).prev_byte_ = data[((((<span class="kw-2">*</span>s).last_flush_pos_ <span class="kw">as </span>(u32)).wrapping_sub(<span class="number">1u32</span>) &amp; mask) <span class="kw">as
       </span>(usize))];
    }
    <span class="kw">if </span>(<span class="kw-2">*</span>s).last_flush_pos_ &gt; <span class="number">1 </span>{
      (<span class="kw-2">*</span>s).prev_byte2_ = data[(((<span class="kw-2">*</span>s).last_flush_pos_.wrapping_sub(<span class="number">2</span>) <span class="kw">as </span>(u32) &amp; mask) <span class="kw">as
       </span>(usize))];
    }
    (<span class="kw-2">*</span>s).num_commands_ = <span class="number">0usize</span>;
    (<span class="kw-2">*</span>s).num_literals_ = <span class="number">0usize</span>;
    (<span class="kw-2">*</span>s).saved_dist_cache_.clone_from_slice(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span>s).dist_cache_.split_at(<span class="number">4</span>).<span class="number">0</span>);
    (<span class="kw-2">*</span>s).next_out_ = NextOut::DynamicStorage(<span class="number">0</span>); <span class="comment">// this always returns that
    </span><span class="kw-2">*</span>out_size = storage_ix &gt;&gt; <span class="number">3i32</span>;
    <span class="number">1i32
  </span>}
}

<span class="kw">fn </span>WriteMetadataHeader&lt;Alloc:BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;)
                       -&gt; usize {
  <span class="kw">let </span>block_size = (<span class="kw-2">*</span>s).remaining_metadata_bytes_ <span class="kw">as </span>(usize);
  <span class="kw">let </span>header = <span class="macro">GetNextOut!</span>(<span class="kw-2">*</span>s);
  <span class="kw">let </span><span class="kw-2">mut </span>storage_ix: usize;
  storage_ix = (<span class="kw-2">*</span>s).last_bytes_bits_ <span class="kw">as </span>(usize);
  header[(<span class="number">0usize</span>)] = (<span class="kw-2">*</span>s).last_bytes_ <span class="kw">as </span>u8;
  header[(<span class="number">1usize</span>)] = ((<span class="kw-2">*</span>s).last_bytes_ &gt;&gt; <span class="number">8</span>) <span class="kw">as </span>u8;
  (<span class="kw-2">*</span>s).last_bytes_ = <span class="number">0</span>;
  (<span class="kw-2">*</span>s).last_bytes_bits_ = <span class="number">0</span>;
  BrotliWriteBits(<span class="number">1usize</span>, <span class="number">0</span>, <span class="kw-2">&amp;mut </span>storage_ix, header);
  BrotliWriteBits(<span class="number">2usize</span>, <span class="number">3</span>, <span class="kw-2">&amp;mut </span>storage_ix, header);
  BrotliWriteBits(<span class="number">1usize</span>, <span class="number">0</span>, <span class="kw-2">&amp;mut </span>storage_ix, header);
  <span class="kw">if </span>block_size == <span class="number">0usize </span>{
    BrotliWriteBits(<span class="number">2usize</span>, <span class="number">0</span>, <span class="kw-2">&amp;mut </span>storage_ix, header);
  } <span class="kw">else </span>{
    <span class="kw">let </span>nbits: u32 = <span class="kw">if </span>block_size == <span class="number">1usize </span>{
      <span class="number">0u32
    </span>} <span class="kw">else </span>{
      Log2FloorNonZero((block_size <span class="kw">as </span>(u32)).wrapping_sub(<span class="number">1u32</span>) <span class="kw">as </span>(u64)).wrapping_add(<span class="number">1u32</span>)
    };
    <span class="kw">let </span>nbytes: u32 = nbits.wrapping_add(<span class="number">7u32</span>).wrapping_div(<span class="number">8u32</span>);
    BrotliWriteBits(<span class="number">2usize</span>, nbytes <span class="kw">as </span>(u64), <span class="kw-2">&amp;mut </span>storage_ix, header);
    BrotliWriteBits((<span class="number">8u32</span>).wrapping_mul(nbytes) <span class="kw">as </span>(usize),
                    block_size.wrapping_sub(<span class="number">1usize</span>) <span class="kw">as </span>u64,
                    <span class="kw-2">&amp;mut </span>storage_ix,
                    header);
  }
  storage_ix.wrapping_add(<span class="number">7u32 </span><span class="kw">as </span>(usize)) &gt;&gt; <span class="number">3i32
</span>}

<span class="kw">fn </span>brotli_min_uint32_t(a: u32, b: u32) -&gt; u32 {
  <span class="kw">if </span>a &lt; b { a } <span class="kw">else </span>{ b }
}
<span class="kw">fn </span>ProcessMetadata&lt;Alloc: BrotliAlloc,
                   MetaBlockCallback:FnMut(<span class="kw-2">&amp;mut </span>interface::PredictionModeContextMap&lt;InputReferenceMut&gt;,
                                           <span class="kw-2">&amp;mut </span>[interface::StaticCommand],
                                           interface::InputPair, <span class="kw-2">&amp;mut </span>Alloc)&gt;(
    s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
    available_in: <span class="kw-2">&amp;mut </span>usize,
    next_in_array: <span class="kw-2">&amp;</span>[u8],
    next_in_offset: <span class="kw-2">&amp;mut </span>usize,
    available_out: <span class="kw-2">&amp;mut </span>usize,
    next_out_array: <span class="kw-2">&amp;mut</span>[u8],
    next_out_offset: <span class="kw-2">&amp;mut </span>usize,
    total_out: <span class="kw-2">&amp;mut </span><span class="prelude-ty">Option</span>&lt;usize&gt;,
    metablock_callback: <span class="kw-2">&amp;mut </span>MetaBlockCallback)
                   -&gt; i32 {
  <span class="kw">if </span><span class="kw-2">*</span>available_in &gt; (<span class="number">1u32 </span>&lt;&lt; <span class="number">24i32</span>) <span class="kw">as </span>(usize) {
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) == BrotliEncoderStreamState::BROTLI_STREAM_PROCESSING <span class="kw">as </span>(i32) {
    (<span class="kw-2">*</span>s).remaining_metadata_bytes_ = <span class="kw-2">*</span>available_in <span class="kw">as </span>(u32);
    (<span class="kw-2">*</span>s).stream_state_ = BrotliEncoderStreamState::BROTLI_STREAM_METADATA_HEAD;
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) !=
     BrotliEncoderStreamState::BROTLI_STREAM_METADATA_HEAD <span class="kw">as </span>(i32) &amp;&amp;
     ((<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) !=
      BrotliEncoderStreamState::BROTLI_STREAM_METADATA_BODY <span class="kw">as </span>(i32)) {
    <span class="kw">return </span><span class="number">0i32</span>;
     }
  <span class="kw">while </span><span class="number">1i32 </span>!= <span class="number">0 </span>{
    <span class="kw">if </span>InjectFlushOrPushOutput(s, available_out, next_out_array, next_out_offset, total_out) != <span class="number">0 </span>{
      {
        <span class="kw">continue</span>;
      }
    }
    <span class="kw">if </span>(<span class="kw-2">*</span>s).available_out_ != <span class="number">0usize </span>{
      {
        <span class="kw">break</span>;
      }
    }
    <span class="kw">if </span>(<span class="kw-2">*</span>s).input_pos_ != (<span class="kw-2">*</span>s).last_flush_pos_ {
      <span class="kw">let </span><span class="kw-2">mut </span>avail_out : usize = (<span class="kw-2">*</span>s).available_out_;
      <span class="kw">let </span>result: i32 =
            EncodeData(s, <span class="number">0i32</span>, <span class="number">1i32</span>, <span class="kw-2">&amp;mut </span>avail_out, metablock_callback);
      (<span class="kw-2">*</span>s).available_out_ = avail_out;
      <span class="kw">if </span>result == <span class="number">0 </span>{
        <span class="kw">return </span><span class="number">0i32</span>;
      }
      {
        {
          <span class="kw">continue</span>;
        }
      }
    }
    <span class="kw">if </span>(<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) ==
       BrotliEncoderStreamState::BROTLI_STREAM_METADATA_HEAD <span class="kw">as </span>(i32) {
      (<span class="kw-2">*</span>s).next_out_ = NextOut::TinyBuf(<span class="number">0</span>);
      (<span class="kw-2">*</span>s).available_out_ = WriteMetadataHeader(s);
      (<span class="kw-2">*</span>s).stream_state_ = BrotliEncoderStreamState::BROTLI_STREAM_METADATA_BODY;
      {
        {
          <span class="kw">continue</span>;
        }
      }
    } <span class="kw">else </span>{
      <span class="kw">if </span>(<span class="kw-2">*</span>s).remaining_metadata_bytes_ == <span class="number">0u32 </span>{
        (<span class="kw-2">*</span>s).remaining_metadata_bytes_ = !(<span class="number">0u32</span>);
        (<span class="kw-2">*</span>s).stream_state_ = BrotliEncoderStreamState::BROTLI_STREAM_PROCESSING;
        {
          {
            <span class="kw">break</span>;
          }
        }
      }
      <span class="kw">if </span><span class="kw-2">*</span>available_out != <span class="number">0 </span>{
        <span class="kw">let </span>copy: u32 = brotli_min_size_t((<span class="kw-2">*</span>s).remaining_metadata_bytes_ <span class="kw">as </span>(usize),
                                              <span class="kw-2">*</span>available_out) <span class="kw">as </span>(u32);
        next_out_array[<span class="kw-2">*</span>next_out_offset .. (<span class="kw-2">*</span>next_out_offset + copy <span class="kw">as </span>usize)].clone_from_slice(
            <span class="kw-2">&amp;</span>next_in_array[<span class="kw-2">*</span>next_in_offset ..(<span class="kw-2">*</span>next_in_offset + copy <span class="kw">as </span>usize)]);
        <span class="comment">//memcpy(*next_out, *next_in, copy as (usize));
        // *next_in = (*next_in).offset(copy as (isize));
        </span><span class="kw-2">*</span>next_in_offset += copy <span class="kw">as </span>usize;
        <span class="kw-2">*</span>available_in = (<span class="kw-2">*</span>available_in).wrapping_sub(copy <span class="kw">as </span>(usize));
        (<span class="kw-2">*</span>s).remaining_metadata_bytes_ = (<span class="kw-2">*</span>s).remaining_metadata_bytes_.wrapping_sub(copy);
        <span class="kw-2">*</span>next_out_offset += copy <span class="kw">as </span>usize;
        <span class="comment">// *next_out = (*next_out).offset(copy as (isize));
        </span><span class="kw-2">*</span>available_out = (<span class="kw-2">*</span>available_out).wrapping_sub(copy <span class="kw">as </span>(usize));
      } <span class="kw">else </span>{
        <span class="kw">let </span>copy: u32 = brotli_min_uint32_t((<span class="kw-2">*</span>s).remaining_metadata_bytes_, <span class="number">16u32</span>);
        (<span class="kw-2">*</span>s).next_out_ = NextOut::TinyBuf(<span class="number">0</span>);
        <span class="macro">GetNextOut!</span>(s)[..(copy <span class="kw">as </span>usize)].clone_from_slice(
            <span class="kw-2">&amp;</span>next_in_array[<span class="kw-2">*</span>next_in_offset ..(<span class="kw-2">*</span>next_in_offset + copy <span class="kw">as </span>usize)]);
        <span class="comment">//memcpy((*s).next_out_, *next_in, copy as (usize));
        // *next_in = (*next_in).offset(copy as (isize));
        </span><span class="kw-2">*</span>next_in_offset += copy <span class="kw">as </span>usize;
        <span class="kw-2">*</span>available_in = (<span class="kw-2">*</span>available_in).wrapping_sub(copy <span class="kw">as </span>(usize));
        (<span class="kw-2">*</span>s).remaining_metadata_bytes_ = (<span class="kw-2">*</span>s).remaining_metadata_bytes_.wrapping_sub(copy);
        (<span class="kw-2">*</span>s).available_out_ = copy <span class="kw">as </span>(usize);
      }
      {
        {
          <span class="kw">continue</span>;
        }
      }
    }
  }
  <span class="number">1i32
</span>}
<span class="kw">fn </span>CheckFlushCompleteInner(stream_state: <span class="kw-2">&amp;mut </span>BrotliEncoderStreamState,
                           available_out: usize,
                           next_out: <span class="kw-2">&amp;mut </span>NextOut) {

    <span class="kw">if </span><span class="kw-2">*</span>stream_state ==
     BrotliEncoderStreamState::BROTLI_STREAM_FLUSH_REQUESTED &amp;&amp;
     (available_out == <span class="number">0</span>) {
    <span class="kw-2">*</span>stream_state = BrotliEncoderStreamState::BROTLI_STREAM_PROCESSING;
    <span class="kw-2">*</span>next_out = NextOut::None;
  }
}

<span class="kw">fn </span>CheckFlushComplete&lt;Alloc: BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;) {
    CheckFlushCompleteInner(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).stream_state_,
                            (<span class="kw-2">*</span>s).available_out_,
                            <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).next_out_);
}


<span class="kw">fn </span>BrotliEncoderCompressStreamFast&lt;Alloc: BrotliAlloc&gt;(
    s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
    op: BrotliEncoderOperation,
    available_in: <span class="kw-2">&amp;mut </span>usize,
    next_in_array: <span class="kw-2">&amp;</span>[u8],
    next_in_offset: <span class="kw-2">&amp;mut </span>usize,
    available_out: <span class="kw-2">&amp;mut </span>usize,
    next_out_array: <span class="kw-2">&amp;mut </span>[u8],
    next_out_offset: <span class="kw-2">&amp;mut </span>usize,
    total_out: <span class="kw-2">&amp;mut </span><span class="prelude-ty">Option</span>&lt;usize&gt;)
            -&gt; i32 {
  <span class="kw">let </span>block_size_limit: usize = <span class="number">1usize </span>&lt;&lt; (<span class="kw-2">*</span>s).params.lgwin;
  <span class="kw">let </span>buf_size: usize = brotli_min_size_t(kCompressFragmentTwoPassBlockSize,
                                          brotli_min_size_t(<span class="kw-2">*</span>available_in, block_size_limit));
  <span class="kw">let </span><span class="kw-2">mut </span>command_buf = &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::AllocatedMemory::default();
  <span class="kw">let </span><span class="kw-2">mut </span>literal_buf = &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory::default();
  <span class="kw">if </span>(<span class="kw-2">*</span>s).params.quality != <span class="number">0i32 </span>&amp;&amp; ((<span class="kw-2">*</span>s).params.quality != <span class="number">1i32</span>) {
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).params.quality == <span class="number">1i32 </span>{
    <span class="kw">if </span>(<span class="kw-2">*</span>s).command_buf_.slice().len() == <span class="number">0 </span>&amp;&amp; (buf_size == kCompressFragmentTwoPassBlockSize) {
      (<span class="kw-2">*</span>s).command_buf_ = &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::alloc_cell(<span class="kw-2">&amp;mut </span>s.m8, kCompressFragmentTwoPassBlockSize);
      (<span class="kw-2">*</span>s).literal_buf_ = &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::alloc_cell(<span class="kw-2">&amp;mut </span>s.m8, kCompressFragmentTwoPassBlockSize);
    }
    <span class="kw">if </span>(<span class="kw-2">*</span>s).command_buf_.slice().len() != <span class="number">0 </span>{
      command_buf = core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).command_buf_, &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::AllocatedMemory::default());
      literal_buf = core::mem::replace(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).literal_buf_, &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory::default());
    } <span class="kw">else </span>{
      command_buf = &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::alloc_cell(<span class="kw-2">&amp;mut </span>s.m8, buf_size);
      literal_buf = &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::alloc_cell(<span class="kw-2">&amp;mut </span>s.m8, buf_size);
    }
  }
  <span class="kw">while </span><span class="number">1i32 </span>!= <span class="number">0 </span>{
    <span class="kw">if </span>InjectFlushOrPushOutput(s, available_out, next_out_array, next_out_offset, total_out) != <span class="number">0 </span>{
      {
        <span class="kw">continue</span>;
      }
    }
    <span class="kw">if </span>(<span class="kw-2">*</span>s).available_out_ == <span class="number">0usize </span>&amp;&amp;
       ((<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) ==
        BrotliEncoderStreamState::BROTLI_STREAM_PROCESSING <span class="kw">as </span>(i32)) &amp;&amp;
       (<span class="kw-2">*</span>available_in != <span class="number">0usize </span>||
        op <span class="kw">as </span>(i32) != BrotliEncoderOperation::BROTLI_OPERATION_PROCESS <span class="kw">as </span>(i32)) {
      <span class="kw">let </span>block_size: usize = brotli_min_size_t(block_size_limit, <span class="kw-2">*</span>available_in);
      <span class="kw">let </span>is_last: i32 = (<span class="kw-2">*</span>available_in == block_size &amp;&amp;
                              (op <span class="kw">as </span>(i32) ==
                               BrotliEncoderOperation::BROTLI_OPERATION_FINISH <span class="kw">as </span>(i32))) <span class="kw">as
                             </span>(i32);
      <span class="kw">let </span>force_flush: i32 =
        (<span class="kw-2">*</span>available_in == block_size &amp;&amp;
         (op <span class="kw">as </span>(i32) == BrotliEncoderOperation::BROTLI_OPERATION_FLUSH <span class="kw">as </span>(i32))) <span class="kw">as </span>(i32);
      <span class="kw">let </span>max_out_size: usize = (<span class="number">2usize</span>).wrapping_mul(block_size).wrapping_add(<span class="number">503usize</span>);
      <span class="kw">let </span><span class="kw-2">mut </span>inplace: i32 = <span class="number">1i32</span>;
      <span class="kw">let </span>storage: <span class="kw-2">&amp;mut </span>[u8];
      <span class="kw">let </span><span class="kw-2">mut </span>storage_ix: usize = (<span class="kw-2">*</span>s).last_bytes_bits_ <span class="kw">as </span>(usize);
      <span class="kw">let </span><span class="kw-2">mut </span>table_size: usize = <span class="number">0</span>;
      <span class="kw">let </span>table: <span class="kw-2">&amp;mut </span>[i32];
      <span class="kw">if </span>force_flush != <span class="number">0 </span>&amp;&amp; (block_size == <span class="number">0usize</span>) {
        (<span class="kw-2">*</span>s).stream_state_ = BrotliEncoderStreamState::BROTLI_STREAM_FLUSH_REQUESTED;
        {
          {
            <span class="kw">continue</span>;
          }
        }
      }
      <span class="kw">if </span>max_out_size &lt;= <span class="kw-2">*</span>available_out {
        storage = <span class="kw-2">&amp;mut </span>next_out_array[<span class="kw-2">*</span>next_out_offset..];<span class="comment">//GetNextOut!(s);
      </span>} <span class="kw">else </span>{
        inplace = <span class="number">0i32</span>;
        GetBrotliStorage(s, max_out_size);
        storage = (<span class="kw-2">*</span>s).storage_.slice_mut();
      }
      storage[(<span class="number">0usize</span>)] = (<span class="kw-2">*</span>s).last_bytes_ <span class="kw">as </span>u8;
      storage[(<span class="number">1usize</span>)] = ((<span class="kw-2">*</span>s).last_bytes_  &gt;&gt; <span class="number">8</span>) <span class="kw">as </span>u8;
      table = <span class="macro">GetHashTable!</span>(s, (<span class="kw-2">*</span>s).params.quality, block_size, <span class="kw-2">&amp;mut </span>table_size);
      <span class="kw">if </span>(<span class="kw-2">*</span>s).params.quality == <span class="number">0i32 </span>{
        BrotliCompressFragmentFast(<span class="kw-2">&amp;mut </span>s.m8,
                                   <span class="kw-2">&amp;</span>(next_in_array)[<span class="kw-2">*</span>next_in_offset..],
                                   block_size,
                                   is_last,
                                   table,
                                   table_size,
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_depths_[..],
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_bits_[..],
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_code_numbits_,
                                   <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).cmd_code_[..],
                                   <span class="kw-2">&amp;mut </span>storage_ix,
                                   storage);
      } <span class="kw">else </span>{
        BrotliCompressFragmentTwoPass(<span class="kw-2">&amp;mut </span>s.m8,
                                      <span class="kw-2">&amp;</span>(next_in_array)[<span class="kw-2">*</span>next_in_offset..],
                                      block_size,
                                      is_last,
                                      command_buf.slice_mut(),
                                      literal_buf.slice_mut(),
                                      table,
                                      table_size,
                                      <span class="kw-2">&amp;mut </span>storage_ix,
                                      storage);
      }
      <span class="kw-2">*</span>next_in_offset += block_size <span class="kw">as </span>usize;
      <span class="kw-2">*</span>available_in = (<span class="kw-2">*</span>available_in).wrapping_sub(block_size);
      <span class="kw">if </span>inplace != <span class="number">0 </span>{
        <span class="kw">let </span>out_bytes: usize = storage_ix &gt;&gt; <span class="number">3i32</span>;
        <span class="number">0i32</span>;
        <span class="number">0i32</span>;
        <span class="kw-2">*</span>next_out_offset += out_bytes <span class="kw">as </span>(usize);
        <span class="kw-2">*</span>available_out = (<span class="kw-2">*</span>available_out).wrapping_sub(out_bytes);
        (<span class="kw-2">*</span>s).total_out_ = (<span class="kw-2">*</span>s).total_out_.wrapping_add(out_bytes <span class="kw">as </span>u64);
        <span class="kw">if let </span><span class="kw-2">&amp;mut </span><span class="prelude-val">Some</span>(<span class="kw-2">ref mut </span>total_out_inner) = total_out {
          <span class="kw-2">*</span>total_out_inner = (<span class="kw-2">*</span>s).total_out_ <span class="kw">as </span>usize;
        }
      } <span class="kw">else </span>{
        <span class="kw">let </span>out_bytes: usize = storage_ix &gt;&gt; <span class="number">3i32</span>;
        (<span class="kw-2">*</span>s).next_out_ = NextOut::DynamicStorage(<span class="number">0</span>);
        (<span class="kw-2">*</span>s).available_out_ = out_bytes;
      }
      (<span class="kw-2">*</span>s).last_bytes_ = storage[((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize))] <span class="kw">as </span>u16 | (
          ((storage[<span class="number">1 </span>+ ((storage_ix &gt;&gt; <span class="number">3i32</span>) <span class="kw">as </span>(usize))] <span class="kw">as </span>u16)&lt;&lt; <span class="number">8</span>));
      (<span class="kw-2">*</span>s).last_bytes_bits_ = (storage_ix &amp; <span class="number">7u32 </span><span class="kw">as </span>(usize)) <span class="kw">as </span>(u8);
      <span class="kw">if </span>force_flush != <span class="number">0 </span>{
        (<span class="kw-2">*</span>s).stream_state_ = BrotliEncoderStreamState::BROTLI_STREAM_FLUSH_REQUESTED;
      }
      <span class="kw">if </span>is_last != <span class="number">0 </span>{
        (<span class="kw-2">*</span>s).stream_state_ = BrotliEncoderStreamState::BROTLI_STREAM_FINISHED;
      }
      {
        {
          <span class="kw">continue</span>;
        }
      }
    }
    {
      {
        <span class="kw">break</span>;
      }
    }
  }
  <span class="kw">if </span>command_buf.slice().len() == kCompressFragmentTwoPassBlockSize &amp;&amp; s.command_buf_.slice().len() == <span class="number">0 </span>{
      <span class="comment">// undo temporary aliasing of command_buf and literal_buf
      </span>(<span class="kw-2">*</span>s).command_buf_ = core::mem::replace(<span class="kw-2">&amp;mut </span>command_buf, &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::AllocatedMemory::default());
      (<span class="kw-2">*</span>s).literal_buf_ = core::mem::replace(<span class="kw-2">&amp;mut </span>literal_buf, &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::AllocatedMemory::default());
  } <span class="kw">else </span>{
      &lt;Alloc <span class="kw">as </span>Allocator&lt;u32&gt;&gt;::free_cell(<span class="kw-2">&amp;mut </span>s.m8, command_buf);
      &lt;Alloc <span class="kw">as </span>Allocator&lt;u8&gt;&gt;::free_cell(<span class="kw-2">&amp;mut </span>s.m8, literal_buf);
  }
  CheckFlushComplete(s);
  <span class="number">1i32
</span>}
<span class="kw">fn </span>RemainingInputBlockSize&lt;Alloc: BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;) -&gt; usize {
  <span class="kw">let </span>delta: u64 = UnprocessedInputSize(s);
  <span class="kw">let </span>block_size: usize = InputBlockSize(s);
  <span class="kw">if </span>delta &gt;= block_size <span class="kw">as </span>u64 {
    <span class="kw">return </span><span class="number">0usize</span>;
  }
  (block_size <span class="kw">as </span>u64).wrapping_sub(delta) <span class="kw">as </span>usize
}

<span class="kw">pub fn </span>BrotliEncoderCompressStream&lt;Alloc: BrotliAlloc,
                                   MetablockCallback:FnMut(<span class="kw-2">&amp;mut </span>interface::PredictionModeContextMap&lt;InputReferenceMut&gt;,
                                                           <span class="kw-2">&amp;mut </span>[interface::StaticCommand],
                                                           interface::InputPair, <span class="kw-2">&amp;mut </span>Alloc)&gt;(
    s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
    op: BrotliEncoderOperation,
    available_in: <span class="kw-2">&amp;mut </span>usize,
    next_in_array: <span class="kw-2">&amp;</span>[u8],
    next_in_offset: <span class="kw-2">&amp;mut </span>usize,
    available_out: <span class="kw-2">&amp;mut </span>usize,
    next_out_array: <span class="kw-2">&amp;mut </span>[u8],
    next_out_offset: <span class="kw-2">&amp;mut </span>usize,
    total_out: <span class="kw-2">&amp;mut </span><span class="prelude-ty">Option</span>&lt;usize&gt;,
    metablock_callback: <span class="kw-2">&amp;mut </span>MetablockCallback)
            -&gt; i32 {
  <span class="kw">if </span>EnsureInitialized(s) == <span class="number">0 </span>{
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).remaining_metadata_bytes_ != !(<span class="number">0u32</span>) {
    <span class="kw">if </span><span class="kw-2">*</span>available_in != (<span class="kw-2">*</span>s).remaining_metadata_bytes_ <span class="kw">as </span>(usize) {
      <span class="kw">return </span><span class="number">0i32</span>;
    }
    <span class="kw">if </span>op <span class="kw">as </span>(i32) != BrotliEncoderOperation::BROTLI_OPERATION_EMIT_METADATA <span class="kw">as </span>(i32) {
      <span class="kw">return </span><span class="number">0i32</span>;
    }
  }
  <span class="kw">if </span>op <span class="kw">as </span>(i32) == BrotliEncoderOperation::BROTLI_OPERATION_EMIT_METADATA <span class="kw">as </span>(i32) {
    UpdateSizeHint(s, <span class="number">0usize</span>);
    <span class="kw">return </span>ProcessMetadata(s, available_in, next_in_array, next_in_offset, available_out, next_out_array, next_out_offset, total_out, metablock_callback);
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) ==
     BrotliEncoderStreamState::BROTLI_STREAM_METADATA_HEAD <span class="kw">as </span>(i32) ||
     (<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) == BrotliEncoderStreamState::BROTLI_STREAM_METADATA_BODY <span class="kw">as </span>(i32) {
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">if </span>(<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) !=
     BrotliEncoderStreamState::BROTLI_STREAM_PROCESSING <span class="kw">as </span>(i32) &amp;&amp; (<span class="kw-2">*</span>available_in != <span class="number">0usize</span>) {
    <span class="kw">return </span><span class="number">0i32</span>;
  }
  <span class="kw">if </span>((<span class="kw-2">*</span>s).params.quality == <span class="number">0i32 </span>|| (<span class="kw-2">*</span>s).params.quality == <span class="number">1i32</span>) &amp;&amp; !s.params.catable { <span class="comment">// this part of the code does not support concatability
    </span><span class="kw">return </span>BrotliEncoderCompressStreamFast(s,
                                           op,
                                           available_in,
                                           next_in_array,
                                           next_in_offset,
                                           available_out,
                                           next_out_array,
                                           next_out_offset,
                                           total_out);
  }
  <span class="kw">while </span><span class="number">1i32 </span>!= <span class="number">0 </span>{
    <span class="kw">let </span>remaining_block_size: usize = RemainingInputBlockSize(s);
    <span class="kw">if </span>remaining_block_size != <span class="number">0usize </span>&amp;&amp; (<span class="kw-2">*</span>available_in != <span class="number">0usize</span>) {
      <span class="kw">let </span>copy_input_size: usize = brotli_min_size_t(remaining_block_size, <span class="kw-2">*</span>available_in);
      CopyInputToRingBuffer(s, copy_input_size, <span class="kw-2">&amp;</span>next_in_array[<span class="kw-2">*</span>next_in_offset..]);
      <span class="kw-2">*</span>next_in_offset += copy_input_size <span class="kw">as </span>(usize);
      <span class="kw-2">*</span>available_in = (<span class="kw-2">*</span>available_in).wrapping_sub(copy_input_size);
      {
        {
          <span class="kw">continue</span>;
        }
      }
    }
    <span class="kw">if </span>InjectFlushOrPushOutput(s, available_out, next_out_array, next_out_offset, total_out) != <span class="number">0 </span>{
      {
        <span class="kw">continue</span>;
      }
    }
    <span class="kw">if </span>(<span class="kw-2">*</span>s).available_out_ == <span class="number">0usize </span>&amp;&amp;
       ((<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) ==
        BrotliEncoderStreamState::BROTLI_STREAM_PROCESSING <span class="kw">as </span>(i32)) {
      <span class="kw">if </span>remaining_block_size == <span class="number">0usize </span>||
         op <span class="kw">as </span>(i32) != BrotliEncoderOperation::BROTLI_OPERATION_PROCESS <span class="kw">as </span>(i32) {
        <span class="kw">let </span>is_last: i32 = <span class="kw">if </span>!!(<span class="kw-2">*</span>available_in == <span class="number">0usize </span>&amp;&amp;
                                 (op <span class="kw">as </span>(i32) ==
                                  BrotliEncoderOperation::BROTLI_OPERATION_FINISH <span class="kw">as </span>(i32))) {
          <span class="number">1i32
        </span>} <span class="kw">else </span>{
          <span class="number">0i32
        </span>};
        <span class="kw">let </span>force_flush: i32 =
          <span class="kw">if </span>!!(<span class="kw-2">*</span>available_in == <span class="number">0usize </span>&amp;&amp;
                (op <span class="kw">as </span>(i32) == BrotliEncoderOperation::BROTLI_OPERATION_FLUSH <span class="kw">as </span>(i32))) {
            <span class="number">1i32
          </span>} <span class="kw">else </span>{
            <span class="number">0i32
          </span>};
        <span class="kw">let </span>result: i32;
        UpdateSizeHint(s, <span class="kw-2">*</span>available_in);
        <span class="kw">let </span><span class="kw-2">mut </span>avail_out = (<span class="kw-2">*</span>s).available_out_;
        result = EncodeData(s,
                            is_last,
                            force_flush,
                            <span class="kw-2">&amp;mut </span>avail_out,
                            metablock_callback);
        (<span class="kw-2">*</span>s).available_out_ = avail_out;
        <span class="comment">//this function set next_out to &amp;storage[0]
        </span><span class="kw">if </span>result == <span class="number">0 </span>{
          <span class="kw">return </span><span class="number">0i32</span>;
        }
        <span class="kw">if </span>force_flush != <span class="number">0 </span>{
          (<span class="kw-2">*</span>s).stream_state_ = BrotliEncoderStreamState::BROTLI_STREAM_FLUSH_REQUESTED;
        }
        <span class="kw">if </span>is_last != <span class="number">0 </span>{
          (<span class="kw-2">*</span>s).stream_state_ = BrotliEncoderStreamState::BROTLI_STREAM_FINISHED;
        }
        {
          {
            <span class="kw">continue</span>;
          }
        }
      }
    }
    {
      {
        <span class="kw">break</span>;
      }
    }
  }
  CheckFlushComplete(s);
  <span class="number">1i32
</span>}

<span class="kw">pub fn </span>BrotliEncoderIsFinished&lt;Alloc:BrotliAlloc&gt;(s: <span class="kw-2">&amp;</span>BrotliEncoderStateStruct&lt;Alloc&gt;) -&gt; i32 {
  <span class="kw">if </span>!!((<span class="kw-2">*</span>s).stream_state_ <span class="kw">as </span>(i32) == BrotliEncoderStreamState::BROTLI_STREAM_FINISHED <span class="kw">as </span>(i32) &amp;&amp;
        (BrotliEncoderHasMoreOutput(s) == <span class="number">0</span>)) {
    <span class="number">1i32
  </span>} <span class="kw">else </span>{
    <span class="number">0i32
  </span>}
}


<span class="kw">pub fn </span>BrotliEncoderHasMoreOutput&lt;Alloc: BrotliAlloc&gt;(
    s: <span class="kw-2">&amp;</span>BrotliEncoderStateStruct&lt;Alloc&gt;) -&gt; i32 {
  <span class="kw">if </span>!!((<span class="kw-2">*</span>s).available_out_ != <span class="number">0usize</span>) {
    <span class="number">1i32
  </span>} <span class="kw">else </span>{
    <span class="number">0i32
  </span>}
}


<span class="kw">pub fn </span>BrotliEncoderTakeOutput&lt;<span class="lifetime">&#39;a</span>, Alloc:BrotliAlloc&gt;(s: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
                               size: <span class="kw-2">&amp;mut </span>usize)
                               -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[u8] {
  <span class="kw">let </span><span class="kw-2">mut </span>consumed_size: usize = (<span class="kw-2">*</span>s).available_out_;
  <span class="kw">let </span><span class="kw-2">mut </span>result: <span class="kw-2">&amp;</span>[u8] = <span class="macro">GetNextOut!</span>(<span class="kw-2">*</span>s);
  <span class="kw">if </span><span class="kw-2">*</span>size != <span class="number">0 </span>{
    consumed_size = brotli_min_size_t(<span class="kw-2">*</span>size, (<span class="kw-2">*</span>s).available_out_);
  }
  <span class="kw">if </span>consumed_size != <span class="number">0 </span>{
    (<span class="kw-2">*</span>s).next_out_ = NextOutIncrement(<span class="kw-2">&amp;</span>(<span class="kw-2">*</span>s).next_out_, consumed_size <span class="kw">as </span>i32);
    (<span class="kw-2">*</span>s).available_out_ = (<span class="kw-2">*</span>s).available_out_.wrapping_sub(consumed_size);
    (<span class="kw-2">*</span>s).total_out_ = (<span class="kw-2">*</span>s).total_out_.wrapping_add(consumed_size <span class="kw">as </span>u64);
    CheckFlushCompleteInner(<span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).stream_state_,
                            (<span class="kw-2">*</span>s).available_out_,
                            <span class="kw-2">&amp;mut </span>(<span class="kw-2">*</span>s).next_out_);
    <span class="kw-2">*</span>size = consumed_size;
  } <span class="kw">else </span>{
    <span class="kw-2">*</span>size = <span class="number">0usize</span>;
    result = <span class="kw-2">&amp;</span>[];
  }
  result
}


<span class="kw">pub fn </span>BrotliEncoderVersion() -&gt; u32 {
  <span class="number">0x1000f01u32
</span>}


<span class="kw">pub fn </span>BrotliEncoderInputBlockSize&lt;Alloc:BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;) -&gt; usize {
  InputBlockSize(s)
}


<span class="kw">pub fn </span>BrotliEncoderCopyInputToRingBuffer&lt;Alloc: BrotliAlloc&gt;(s: <span class="kw-2">&amp;mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
                                          input_size: usize,
                                          input_buffer: <span class="kw-2">&amp;</span>[u8]) {
  CopyInputToRingBuffer(s, input_size, input_buffer);
}


<span class="kw">pub fn </span>BrotliEncoderWriteData&lt;<span class="lifetime">&#39;a</span>, Alloc: BrotliAlloc,
                              MetablockCallback:FnMut(<span class="kw-2">&amp;mut </span>interface::PredictionModeContextMap&lt;InputReferenceMut&gt;,
                                                       <span class="kw-2">&amp;mut </span>[interface::StaticCommand],
                                                       interface::InputPair, <span class="kw-2">&amp;mut </span>Alloc)&gt;(
    s: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>BrotliEncoderStateStruct&lt;Alloc&gt;,
    is_last: i32,
    force_flush: i32,
    out_size: <span class="kw-2">&amp;mut </span>usize,
    output: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut &amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>[u8],
    metablock_callback: <span class="kw-2">&amp;mut </span>MetablockCallback)
                              -&gt; i32 {
    <span class="kw">let </span>ret = EncodeData(s, is_last, force_flush, out_size, metablock_callback);
    <span class="kw-2">*</span>output = (<span class="kw-2">*</span>s).storage_.slice_mut();
    ret
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="brotli" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>