<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `utils/src/folder_checksum.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>folder_checksum.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../headless_lms_utils/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../headless_lms_utils/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../headless_lms_utils/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
</pre><pre class="rust"><code><span class="doccomment">/*!
Provides functionality for checksumming directory trees.

This is meant for checking whether a exercise in a exercise template repository
has changed after a refresh.
*/

</span><span class="attribute">#[cfg(unix)]
</span><span class="kw">use </span>std::os::unix::fs::PermissionsExt;
<span class="kw">use </span>std::{fs::Permissions, path::Path, u32};

<span class="kw">use </span><span class="kw">crate</span>::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>blake3::Hash;
<span class="kw">use </span>futures::StreamExt;
<span class="kw">use </span>tokio::{fs::File, io::BufReader};
<span class="kw">use </span>tokio_util::io::ReaderStream;
<span class="kw">use </span>walkdir::WalkDir;

<span class="doccomment">/**
Recursively hashes a folder returning a checksum.

The hashing function takes into account all files, folders, and symlinks. All
contents, the file type, and the unix file mode are included as well.

Please note that if you have very large files in the directory, the running time
might take a while since reading a lot of data from disk is not fast.
*/
</span><span class="kw">pub async fn </span>hash_folder(root_path: <span class="kw-2">&amp;</span>Path) -&gt; UtilResult&lt;Hash&gt; {
    <span class="comment">// Blake3 hasher lets us build the hash incrementally, avoiding the need to load everything to be hashed to memory at once.
    </span><span class="kw">let </span><span class="kw-2">mut </span>hasher = blake3::Hasher::new();

    <span class="kw">let </span>walker = WalkDir::new(root_path)
        <span class="comment">// Instead of following a symbolic link, we just hash the link itself.
        // Following the link would lead to recursion problems.
        </span>.follow_links(<span class="bool-val">false</span>)
        .max_open(<span class="number">10</span>)
        .contents_first(<span class="bool-val">false</span>)
        <span class="comment">// Paths are sorted to make sure we process them in the same order on all systems.
        </span>.sort_by_file_name();
    <span class="comment">// Note that the filesystem operations used for walking the tree are executed synchronously.
    // This is because the walkdir library has no async support at the moment.
    </span><span class="kw">for </span>entry <span class="kw">in </span>walker {
        <span class="kw">let </span>entry = entry<span class="question-mark">?</span>;
        <span class="kw">let </span>metadata = entry.metadata()<span class="question-mark">?</span>;
        <span class="kw">let </span>file_type = metadata.file_type();
        <span class="kw">let </span>permissions = metadata.permissions();
        <span class="kw">let </span>full_path = entry.path();

        <span class="comment">// Metadata to be included in the hash
        </span><span class="kw">let </span>directory = file_type.is_dir();
        <span class="kw">let </span>file = file_type.is_file();
        <span class="kw">let </span>symlink = file_type.is_symlink();
        <span class="kw">let </span>permissions_mode = determine_permissions_mode_for_hashing(<span class="kw-2">&amp;</span>permissions);
        <span class="kw">let </span>relative_path = full_path.strip_prefix(root_path)<span class="question-mark">?</span>;

        <span class="comment">// The extra separators at the end and at the beginning are to prevent
        // accidental collisions in the hashed string.
        </span><span class="kw">let </span>serialized_metadata = <span class="macro">format!</span>(
            <span class="string">&quot;-{}{}{}{}{:?}-&quot;</span>,
            directory <span class="kw">as </span>u8, file <span class="kw">as </span>u8, symlink <span class="kw">as </span>u8, <span class="kw-2">&amp;</span>permissions_mode, <span class="kw-2">&amp;</span>relative_path
        );

        hasher.update(serialized_metadata.as_bytes());

        <span class="kw">if </span>file {
            <span class="kw">let </span>file = File::open(full_path).<span class="kw">await</span><span class="question-mark">?</span>;
            <span class="comment">// We read the file contents with a bufreader so that handling really big files wouldn&#39;t cause us problems.
            </span><span class="kw">let </span>reader = BufReader::new(file);
            <span class="kw">let </span><span class="kw-2">mut </span>stream = ReaderStream::new(reader);
            <span class="kw">while let </span><span class="prelude-val">Some</span>(chunk) = stream.next().<span class="kw">await </span>{
                hasher.update(<span class="kw-2">&amp;</span>chunk<span class="question-mark">?</span>);
            }
        }
        <span class="kw">if </span>symlink {
            <span class="kw">let </span>res = tokio::fs::read_link(full_path).<span class="kw">await</span><span class="question-mark">?</span>;
            <span class="comment">// Only relative links would work here since the files should origitate from a remote repository
            // so relativizing this would be pointless.
            </span>hasher.update(res.display().to_string().as_bytes());
        }
    }
    <span class="kw">let </span>hash = hasher.finalize();
    <span class="prelude-val">Ok</span>(hash)
}

<span class="kw">fn </span>determine_permissions_mode_for_hashing(permissions: <span class="kw-2">&amp;</span>Permissions) -&gt; u32 {
    <span class="kw">if </span><span class="macro">cfg!</span>(unix) {
        <span class="kw">return </span>permissions.mode();
    }
    <span class="comment">// Default implementation for mostly windows that has no unix like modes.
    // Another approach here could be to pull the file mode from git.
    </span><span class="kw">if </span>permissions.readonly() {
        <span class="number">0o444
    </span>} <span class="kw">else </span>{
        <span class="number">0o644
    </span>}
}

<span class="attribute">#[cfg(test)]
</span><span class="kw">mod </span>tests {
    <span class="kw">use </span>tempdir::TempDir;
    <span class="kw">use </span>tokio::{
        fs::{<span class="self">self</span>, create_dir, remove_dir, symlink},
        io::AsyncWriteExt,
    };

    <span class="kw">use super</span>::<span class="kw-2">*</span>;

    <span class="kw">async fn </span>do_the_test() {
        <span class="kw">let </span>dir = TempDir::new(<span class="string">&quot;test-folder-checksum&quot;</span>).expect(<span class="string">&quot;Failed to create a temp dir&quot;</span>);
        File::open(dir.path())
            .<span class="kw">await
            </span>.unwrap()
            .set_permissions(Permissions::from_mode(<span class="number">0o755</span>))
            .<span class="kw">await
            </span>.unwrap();
        <span class="kw">let </span>first_hash = hash_folder(dir.path()).<span class="kw">await</span>.unwrap();
        <span class="macro">assert_eq!</span>(
            first_hash.to_hex().to_string(),
            <span class="string">&quot;01444ae9678097d0214e449568b68eb351c4743b2697bfc3d517b5c601535823&quot;
        </span>);
        <span class="kw">let </span><span class="kw-2">mut </span>file = File::create(dir.path().join(<span class="string">&quot;test-file&quot;</span>)).<span class="kw">await</span>.unwrap();
        file.set_permissions(Permissions::from_mode(<span class="number">0o644</span>))
            .<span class="kw">await
            </span>.unwrap();
        file.write_all(<span class="string">b&quot;Test file&quot;</span>).<span class="kw">await</span>.unwrap();

        <span class="kw">let </span>second_hash = hash_folder(dir.path()).<span class="kw">await</span>.unwrap();

        <span class="macro">assert_eq!</span>(
            second_hash.to_hex().to_string(),
            <span class="string">&quot;c2f4caaaafeb41dfd5e5381ea9c1583ccaa7d09378745def8c979b1e1f0e5c2a&quot;
        </span>);

        fs::set_permissions(dir.path().join(<span class="string">&quot;test-file&quot;</span>), Permissions::from_mode(<span class="number">0o444</span>))
            .<span class="kw">await
            </span>.unwrap();

        <span class="kw">let </span>third_hash = hash_folder(dir.path()).<span class="kw">await</span>.unwrap();

        <span class="macro">assert_eq!</span>(
            third_hash.to_hex().to_string(),
            <span class="string">&quot;1b1820abcb400974e0eb751c103303864f7b0ae7ad387c5135521d9968dbb4de&quot;
        </span>);

        <span class="kw">let </span>inner_dir_path = dir.path().join(<span class="string">&quot;directory&quot;</span>);
        create_dir(<span class="kw-2">&amp;</span>inner_dir_path).<span class="kw">await</span>.unwrap();
        File::open(inner_dir_path)
            .<span class="kw">await
            </span>.unwrap()
            .set_permissions(Permissions::from_mode(<span class="number">0o755</span>))
            .<span class="kw">await
            </span>.unwrap();

        <span class="kw">let </span>fourth_hash = hash_folder(dir.path()).<span class="kw">await</span>.unwrap();

        <span class="macro">assert_eq!</span>(
            fourth_hash.to_hex().to_string(),
            <span class="string">&quot;f1113337a98c5fe5d7ed0f2a9fc17490993b1149ea44784a027e53d1a1884c9e&quot;
        </span>);

        remove_dir(<span class="kw-2">&amp;</span>dir.path().join(<span class="string">&quot;directory&quot;</span>)).<span class="kw">await</span>.unwrap();

        <span class="kw">let </span>fifth_hash = hash_folder(dir.path()).<span class="kw">await</span>.unwrap();

        <span class="macro">assert_eq!</span>(
            fifth_hash.to_hex().to_string(),
            <span class="string">&quot;1b1820abcb400974e0eb751c103303864f7b0ae7ad387c5135521d9968dbb4de&quot;
        </span>);

        <span class="comment">// Should not have the same checksum as with the directory created before
        </span><span class="kw">let </span>file = File::create(<span class="kw-2">&amp;</span>dir.path().join(<span class="string">&quot;directory&quot;</span>)).<span class="kw">await</span>.unwrap();
        file.set_permissions(Permissions::from_mode(<span class="number">0o755</span>))
            .<span class="kw">await
            </span>.unwrap();
        <span class="kw">let </span>sixth_hash = hash_folder(dir.path()).<span class="kw">await</span>.unwrap();

        <span class="comment">// Tells if we can tell folders apart from files
        </span><span class="macro">assert_ne!</span>(
            fifth_hash.to_hex().to_string(),
            sixth_hash.to_hex().to_string()
        );
        <span class="macro">assert_eq!</span>(
            sixth_hash.to_hex().to_string(),
            <span class="string">&quot;4b9255096a4b233be4a24b0fb74fa5e955a0261a422c8e9cfbe7ac11f1256030&quot;
        </span>);
        <span class="kw">let </span>symlink_path = <span class="kw-2">&amp;</span>dir.path().join(<span class="string">&quot;symlink&quot;</span>);
        symlink(Path::new(<span class="string">&quot;directory&quot;</span>), <span class="kw-2">&amp;</span>symlink_path)
            .<span class="kw">await
            </span>.unwrap();
        File::open(symlink_path)
            .<span class="kw">await
            </span>.unwrap()
            .set_permissions(Permissions::from_mode(<span class="number">0o644</span>))
            .<span class="kw">await
            </span>.unwrap();

        <span class="kw">let </span>seventh_hash = hash_folder(dir.path()).<span class="kw">await</span>.unwrap();
        <span class="macro">assert_eq!</span>(
            seventh_hash.to_hex().to_string(),
            <span class="string">&quot;5144015ff90807ec6448a0b6bfcc470de495182441e0af019c6483da8edaa05c&quot;
        </span>);
    }

    <span class="attribute">#[cfg(not(target_os = <span class="string">&quot;windows&quot;</span>))]
    #[tokio::test]
    </span><span class="kw">async fn </span>it_works() {
        <span class="kw">let </span>res = std::panic::catch_unwind(|| {
            futures::executor::block_on(do_the_test());
        });
        <span class="kw">if </span>res.is_ok() {
            <span class="kw">return</span>;
        }

        <span class="macro">warn!</span>(<span class="string">&quot;First attempt at the folder checksum test failed. Retrying in case there was a file corruption issue on this machine.&quot;</span>);
        do_the_test().<span class="kw">await</span>;
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="headless_lms_utils" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>