<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/hex-0.4.3/src/lib.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lib.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../hex/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../hex/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../hex/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
</pre><pre class="rust"><code><span class="comment">// Copyright (c) 2013-2014 The Rust Project Developers.
// Copyright (c) 2015-2020 The rust-hex Developers.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
</span><span class="doccomment">//! Encoding and decoding hex strings.
//!
//! For most cases, you can simply use the [`decode`], [`encode`] and
//! [`encode_upper`] functions. If you need a bit more control, use the traits
//! [`ToHex`] and [`FromHex`] instead.
//!
//! # Example
//!
//! ```
//! # #[cfg(not(feature = &quot;alloc&quot;))]
//! # let mut output = [0; 0x18];
//! #
//! # #[cfg(not(feature = &quot;alloc&quot;))]
//! # hex::encode_to_slice(b&quot;Hello world!&quot;, &amp;mut output).unwrap();
//! #
//! # #[cfg(not(feature = &quot;alloc&quot;))]
//! # let hex_string = ::core::str::from_utf8(&amp;output).unwrap();
//! #
//! # #[cfg(feature = &quot;alloc&quot;)]
//! let hex_string = hex::encode(&quot;Hello world!&quot;);
//!
//! println!(&quot;{}&quot;, hex_string); // Prints &quot;48656c6c6f20776f726c6421&quot;
//!
//! # assert_eq!(hex_string, &quot;48656c6c6f20776f726c6421&quot;);
//! ```

</span><span class="attribute">#![doc(html_root_url = <span class="string">&quot;https://docs.rs/hex/0.4.3&quot;</span>)]
#![cfg_attr(not(feature = <span class="string">&quot;std&quot;</span>), no_std)]
#![cfg_attr(docsrs, feature(doc_cfg))]
#![allow(clippy::unreadable_literal)]

#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
</span><span class="kw">extern crate </span>alloc;
<span class="attribute">#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
</span><span class="kw">use </span>alloc::{string::String, vec::Vec};

<span class="kw">use </span>core::iter;

<span class="kw">mod </span>error;
<span class="kw">pub use </span><span class="kw">crate</span>::error::FromHexError;

<span class="attribute">#[cfg(feature = <span class="string">&quot;serde&quot;</span>)]
#[cfg_attr(docsrs, doc(cfg(feature = <span class="string">&quot;serde&quot;</span>)))]
</span><span class="kw">pub mod </span>serde;
<span class="attribute">#[cfg(feature = <span class="string">&quot;serde&quot;</span>)]
</span><span class="kw">pub use </span><span class="kw">crate</span>::serde::deserialize;
<span class="attribute">#[cfg(all(feature = <span class="string">&quot;alloc&quot;</span>, feature = <span class="string">&quot;serde&quot;</span>))]
</span><span class="kw">pub use </span><span class="kw">crate</span>::serde::{serialize, serialize_upper};

<span class="doccomment">/// Encoding values as hex string.
///
/// This trait is implemented for all `T` which implement `AsRef&lt;[u8]&gt;`. This
/// includes `String`, `str`, `Vec&lt;u8&gt;` and `[u8]`.
///
/// # Example
///
/// ```
/// use hex::ToHex;
///
/// println!(&quot;{}&quot;, &quot;Hello world!&quot;.encode_hex::&lt;String&gt;());
/// # assert_eq!(&quot;Hello world!&quot;.encode_hex::&lt;String&gt;(), &quot;48656c6c6f20776f726c6421&quot;.to_string());
/// ```
///
/// *Note*: instead of using this trait, you might want to use [`encode()`].
</span><span class="kw">pub trait </span>ToHex {
    <span class="doccomment">/// Encode the hex strict representing `self` into the result. Lower case
    /// letters are used (e.g. `f9b4ca`)
    </span><span class="kw">fn </span>encode_hex&lt;T: iter::FromIterator&lt;char&gt;&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; T;

    <span class="doccomment">/// Encode the hex strict representing `self` into the result. Upper case
    /// letters are used (e.g. `F9B4CA`)
    </span><span class="kw">fn </span>encode_hex_upper&lt;T: iter::FromIterator&lt;char&gt;&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; T;
}

<span class="kw">const </span>HEX_CHARS_LOWER: <span class="kw-2">&amp;</span>[u8; <span class="number">16</span>] = <span class="string">b&quot;0123456789abcdef&quot;</span>;
<span class="kw">const </span>HEX_CHARS_UPPER: <span class="kw-2">&amp;</span>[u8; <span class="number">16</span>] = <span class="string">b&quot;0123456789ABCDEF&quot;</span>;

<span class="kw">struct </span>BytesToHexChars&lt;<span class="lifetime">&#39;a</span>&gt; {
    inner: ::core::slice::Iter&lt;<span class="lifetime">&#39;a</span>, u8&gt;,
    table: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>[u8; <span class="number">16</span>],
    next: <span class="prelude-ty">Option</span>&lt;char&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; BytesToHexChars&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>new(inner: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[u8], table: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>[u8; <span class="number">16</span>]) -&gt; BytesToHexChars&lt;<span class="lifetime">&#39;a</span>&gt; {
        BytesToHexChars {
            inner: inner.iter(),
            table,
            next: <span class="prelude-val">None</span>,
        }
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Iterator <span class="kw">for </span>BytesToHexChars&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">type </span>Item = char;

    <span class="kw">fn </span>next(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="self">Self</span>::Item&gt; {
        <span class="kw">match </span><span class="self">self</span>.next.take() {
            <span class="prelude-val">Some</span>(current) =&gt; <span class="prelude-val">Some</span>(current),
            <span class="prelude-val">None </span>=&gt; <span class="self">self</span>.inner.next().map(|byte| {
                <span class="kw">let </span>current = <span class="self">self</span>.table[(byte &gt;&gt; <span class="number">4</span>) <span class="kw">as </span>usize] <span class="kw">as </span>char;
                <span class="self">self</span>.next = <span class="prelude-val">Some</span>(<span class="self">self</span>.table[(byte &amp; <span class="number">0x0F</span>) <span class="kw">as </span>usize] <span class="kw">as </span>char);
                current
            }),
        }
    }

    <span class="kw">fn </span>size_hint(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; (usize, <span class="prelude-ty">Option</span>&lt;usize&gt;) {
        <span class="kw">let </span>length = <span class="self">self</span>.len();
        (length, <span class="prelude-val">Some</span>(length))
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; iter::ExactSizeIterator <span class="kw">for </span>BytesToHexChars&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>len(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="kw">let </span><span class="kw-2">mut </span>length = <span class="self">self</span>.inner.len() * <span class="number">2</span>;
        <span class="kw">if </span><span class="self">self</span>.next.is_some() {
            length += <span class="number">1</span>;
        }
        length
    }
}

<span class="attribute">#[inline]
</span><span class="kw">fn </span>encode_to_iter&lt;T: iter::FromIterator&lt;char&gt;&gt;(table: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>[u8; <span class="number">16</span>], source: <span class="kw-2">&amp;</span>[u8]) -&gt; T {
    BytesToHexChars::new(source, table).collect()
}

<span class="kw">impl</span>&lt;T: AsRef&lt;[u8]&gt;&gt; ToHex <span class="kw">for </span>T {
    <span class="kw">fn </span>encode_hex&lt;U: iter::FromIterator&lt;char&gt;&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; U {
        encode_to_iter(HEX_CHARS_LOWER, <span class="self">self</span>.as_ref())
    }

    <span class="kw">fn </span>encode_hex_upper&lt;U: iter::FromIterator&lt;char&gt;&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; U {
        encode_to_iter(HEX_CHARS_UPPER, <span class="self">self</span>.as_ref())
    }
}

<span class="doccomment">/// Types that can be decoded from a hex string.
///
/// This trait is implemented for `Vec&lt;u8&gt;` and small `u8`-arrays.
///
/// # Example
///
/// ```
/// use core::str;
/// use hex::FromHex;
///
/// let buffer = &lt;[u8; 12]&gt;::from_hex(&quot;48656c6c6f20776f726c6421&quot;)?;
/// let string = str::from_utf8(&amp;buffer).expect(&quot;invalid buffer length&quot;);
///
/// println!(&quot;{}&quot;, string); // prints &quot;Hello world!&quot;
/// # assert_eq!(&quot;Hello world!&quot;, string);
/// # Ok::&lt;(), hex::FromHexError&gt;(())
/// ```
</span><span class="kw">pub trait </span>FromHex: Sized {
    <span class="kw">type </span>Error;

    <span class="doccomment">/// Creates an instance of type `Self` from the given hex string, or fails
    /// with a custom error type.
    ///
    /// Both, upper and lower case characters are valid and can even be
    /// mixed (e.g. `f9b4ca`, `F9B4CA` and `f9B4Ca` are all valid strings).
    </span><span class="kw">fn </span>from_hex&lt;T: AsRef&lt;[u8]&gt;&gt;(hex: T) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Error&gt;;
}

<span class="kw">fn </span>val(c: u8, idx: usize) -&gt; <span class="prelude-ty">Result</span>&lt;u8, FromHexError&gt; {
    <span class="kw">match </span>c {
        <span class="string">b&#39;A&#39;</span>..=<span class="string">b&#39;F&#39; </span>=&gt; <span class="prelude-val">Ok</span>(c - <span class="string">b&#39;A&#39; </span>+ <span class="number">10</span>),
        <span class="string">b&#39;a&#39;</span>..=<span class="string">b&#39;f&#39; </span>=&gt; <span class="prelude-val">Ok</span>(c - <span class="string">b&#39;a&#39; </span>+ <span class="number">10</span>),
        <span class="string">b&#39;0&#39;</span>..=<span class="string">b&#39;9&#39; </span>=&gt; <span class="prelude-val">Ok</span>(c - <span class="string">b&#39;0&#39;</span>),
        <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(FromHexError::InvalidHexCharacter {
            c: c <span class="kw">as </span>char,
            index: idx,
        }),
    }
}

<span class="attribute">#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
</span><span class="kw">impl </span>FromHex <span class="kw">for </span>Vec&lt;u8&gt; {
    <span class="kw">type </span>Error = FromHexError;

    <span class="kw">fn </span>from_hex&lt;T: AsRef&lt;[u8]&gt;&gt;(hex: T) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Error&gt; {
        <span class="kw">let </span>hex = hex.as_ref();
        <span class="kw">if </span>hex.len() % <span class="number">2 </span>!= <span class="number">0 </span>{
            <span class="kw">return </span><span class="prelude-val">Err</span>(FromHexError::OddLength);
        }

        hex.chunks(<span class="number">2</span>)
            .enumerate()
            .map(|(i, pair)| <span class="prelude-val">Ok</span>(val(pair[<span class="number">0</span>], <span class="number">2 </span>* i)<span class="question-mark">? </span>&lt;&lt; <span class="number">4 </span>| val(pair[<span class="number">1</span>], <span class="number">2 </span>* i + <span class="number">1</span>)<span class="question-mark">?</span>))
            .collect()
    }
}

<span class="comment">// Helper macro to implement the trait for a few fixed sized arrays. Once Rust
// has type level integers, this should be removed.
</span><span class="macro">macro_rules! </span>from_hex_array_impl {
    ($(<span class="macro-nonterminal">$len</span>:expr)+) =&gt; {$(
        <span class="kw">impl </span>FromHex <span class="kw">for </span>[u8; <span class="macro-nonterminal">$len</span>] {
            <span class="kw">type </span>Error = FromHexError;

            <span class="kw">fn </span>from_hex&lt;T: AsRef&lt;[u8]&gt;&gt;(hex: T) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Error&gt; {
                <span class="kw">let </span><span class="kw-2">mut </span>out = [<span class="number">0_u8</span>; <span class="macro-nonterminal">$len</span>];
                decode_to_slice(hex, <span class="kw-2">&amp;mut </span>out <span class="kw">as </span><span class="kw-2">&amp;mut </span>[u8])<span class="question-mark">?</span>;
                <span class="prelude-val">Ok</span>(out)
            }
        }
    )+}
}

<span class="macro">from_hex_array_impl! </span>{
    <span class="number">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
    17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
    33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
    49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
    65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80
    81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96
    97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112
    113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128
    160 192 200 224 256 384 512 768 1024 2048 4096 8192 16384 32768
</span>}

<span class="attribute">#[cfg(any(target_pointer_width = <span class="string">&quot;32&quot;</span>, target_pointer_width = <span class="string">&quot;64&quot;</span>))]
</span><span class="macro">from_hex_array_impl! </span>{
    <span class="number">65536 131072 262144 524288 1048576 2097152 4194304 8388608
    16777216 33554432 67108864 134217728 268435456 536870912
    1073741824 2147483648
</span>}

<span class="attribute">#[cfg(target_pointer_width = <span class="string">&quot;64&quot;</span>)]
</span><span class="macro">from_hex_array_impl! </span>{
    <span class="number">4294967296
</span>}

<span class="doccomment">/// Encodes `data` as hex string using lowercase characters.
///
/// Lowercase characters are used (e.g. `f9b4ca`). The resulting string&#39;s
/// length is always even, each byte in `data` is always encoded using two hex
/// digits. Thus, the resulting string contains exactly twice as many bytes as
/// the input data.
///
/// # Example
///
/// ```
/// assert_eq!(hex::encode(&quot;Hello world!&quot;), &quot;48656c6c6f20776f726c6421&quot;);
/// assert_eq!(hex::encode(vec![1, 2, 3, 15, 16]), &quot;0102030f10&quot;);
/// ```
</span><span class="attribute">#[must_use]
#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
</span><span class="kw">pub fn </span>encode&lt;T: AsRef&lt;[u8]&gt;&gt;(data: T) -&gt; String {
    data.encode_hex()
}

<span class="doccomment">/// Encodes `data` as hex string using uppercase characters.
///
/// Apart from the characters&#39; casing, this works exactly like `encode()`.
///
/// # Example
///
/// ```
/// assert_eq!(hex::encode_upper(&quot;Hello world!&quot;), &quot;48656C6C6F20776F726C6421&quot;);
/// assert_eq!(hex::encode_upper(vec![1, 2, 3, 15, 16]), &quot;0102030F10&quot;);
/// ```
</span><span class="attribute">#[must_use]
#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
</span><span class="kw">pub fn </span>encode_upper&lt;T: AsRef&lt;[u8]&gt;&gt;(data: T) -&gt; String {
    data.encode_hex_upper()
}

<span class="doccomment">/// Decodes a hex string into raw bytes.
///
/// Both, upper and lower case characters are valid in the input string and can
/// even be mixed (e.g. `f9b4ca`, `F9B4CA` and `f9B4Ca` are all valid strings).
///
/// # Example
///
/// ```
/// assert_eq!(
///     hex::decode(&quot;48656c6c6f20776f726c6421&quot;),
///     Ok(&quot;Hello world!&quot;.to_owned().into_bytes())
/// );
///
/// assert_eq!(hex::decode(&quot;123&quot;), Err(hex::FromHexError::OddLength));
/// assert!(hex::decode(&quot;foo&quot;).is_err());
/// ```
</span><span class="attribute">#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
</span><span class="kw">pub fn </span>decode&lt;T: AsRef&lt;[u8]&gt;&gt;(data: T) -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;u8&gt;, FromHexError&gt; {
    FromHex::from_hex(data)
}

<span class="doccomment">/// Decode a hex string into a mutable bytes slice.
///
/// Both, upper and lower case characters are valid in the input string and can
/// even be mixed (e.g. `f9b4ca`, `F9B4CA` and `f9B4Ca` are all valid strings).
///
/// # Example
///
/// ```
/// let mut bytes = [0u8; 4];
/// assert_eq!(hex::decode_to_slice(&quot;6b697769&quot;, &amp;mut bytes as &amp;mut [u8]), Ok(()));
/// assert_eq!(&amp;bytes, b&quot;kiwi&quot;);
/// ```
</span><span class="kw">pub fn </span>decode_to_slice&lt;T: AsRef&lt;[u8]&gt;&gt;(data: T, out: <span class="kw-2">&amp;mut </span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(), FromHexError&gt; {
    <span class="kw">let </span>data = data.as_ref();

    <span class="kw">if </span>data.len() % <span class="number">2 </span>!= <span class="number">0 </span>{
        <span class="kw">return </span><span class="prelude-val">Err</span>(FromHexError::OddLength);
    }
    <span class="kw">if </span>data.len() / <span class="number">2 </span>!= out.len() {
        <span class="kw">return </span><span class="prelude-val">Err</span>(FromHexError::InvalidStringLength);
    }

    <span class="kw">for </span>(i, byte) <span class="kw">in </span>out.iter_mut().enumerate() {
        <span class="kw-2">*</span>byte = val(data[<span class="number">2 </span>* i], <span class="number">2 </span>* i)<span class="question-mark">? </span>&lt;&lt; <span class="number">4 </span>| val(data[<span class="number">2 </span>* i + <span class="number">1</span>], <span class="number">2 </span>* i + <span class="number">1</span>)<span class="question-mark">?</span>;
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="comment">// generates an iterator like this
// (0, 1)
// (2, 3)
// (4, 5)
// (6, 7)
// ...
</span><span class="attribute">#[inline]
</span><span class="kw">fn </span>generate_iter(len: usize) -&gt; <span class="kw">impl </span>Iterator&lt;Item = (usize, usize)&gt; {
    (<span class="number">0</span>..len).step_by(<span class="number">2</span>).zip((<span class="number">0</span>..len).skip(<span class="number">1</span>).step_by(<span class="number">2</span>))
}

<span class="comment">// the inverse of `val`.
</span><span class="attribute">#[inline]
#[must_use]
</span><span class="kw">fn </span>byte2hex(byte: u8, table: <span class="kw-2">&amp;</span>[u8; <span class="number">16</span>]) -&gt; (u8, u8) {
    <span class="kw">let </span>high = table[((byte &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>) <span class="kw">as </span>usize];
    <span class="kw">let </span>low = table[(byte &amp; <span class="number">0x0f</span>) <span class="kw">as </span>usize];

    (high, low)
}

<span class="doccomment">/// Encodes some bytes into a mutable slice of bytes.
///
/// The output buffer, has to be able to hold at least `input.len() * 2` bytes,
/// otherwise this function will return an error.
///
/// # Example
///
/// ```
/// # use hex::FromHexError;
/// # fn main() -&gt; Result&lt;(), FromHexError&gt; {
/// let mut bytes = [0u8; 4 * 2];
///
/// hex::encode_to_slice(b&quot;kiwi&quot;, &amp;mut bytes)?;
/// assert_eq!(&amp;bytes, b&quot;6b697769&quot;);
/// # Ok(())
/// # }
/// ```
</span><span class="kw">pub fn </span>encode_to_slice&lt;T: AsRef&lt;[u8]&gt;&gt;(input: T, output: <span class="kw-2">&amp;mut </span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(), FromHexError&gt; {
    <span class="kw">if </span>input.as_ref().len() * <span class="number">2 </span>!= output.len() {
        <span class="kw">return </span><span class="prelude-val">Err</span>(FromHexError::InvalidStringLength);
    }

    <span class="kw">for </span>(byte, (i, j)) <span class="kw">in </span>input
        .as_ref()
        .iter()
        .zip(generate_iter(input.as_ref().len() * <span class="number">2</span>))
    {
        <span class="kw">let </span>(high, low) = byte2hex(<span class="kw-2">*</span>byte, HEX_CHARS_LOWER);
        output[i] = high;
        output[j] = low;
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="attribute">#[cfg(test)]
</span><span class="kw">mod </span>test {
    <span class="kw">use super</span>::<span class="kw-2">*</span>;
    <span class="attribute">#[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">use </span>alloc::string::ToString;
    <span class="kw">use </span>pretty_assertions::assert_eq;

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">fn </span>test_gen_iter() {
        <span class="kw">let </span>result = <span class="macro">vec!</span>[(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>)];

        <span class="macro">assert_eq!</span>(generate_iter(<span class="number">5</span>).collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;(), result);
    }

    <span class="attribute">#[test]
    </span><span class="kw">fn </span>test_encode_to_slice() {
        <span class="kw">let </span><span class="kw-2">mut </span>output_1 = [<span class="number">0</span>; <span class="number">4 </span>* <span class="number">2</span>];
        encode_to_slice(<span class="string">b&quot;kiwi&quot;</span>, <span class="kw-2">&amp;mut </span>output_1).unwrap();
        <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>output_1, <span class="string">b&quot;6b697769&quot;</span>);

        <span class="kw">let </span><span class="kw-2">mut </span>output_2 = [<span class="number">0</span>; <span class="number">5 </span>* <span class="number">2</span>];
        encode_to_slice(<span class="string">b&quot;kiwis&quot;</span>, <span class="kw-2">&amp;mut </span>output_2).unwrap();
        <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>output_2, <span class="string">b&quot;6b69776973&quot;</span>);

        <span class="kw">let </span><span class="kw-2">mut </span>output_3 = [<span class="number">0</span>; <span class="number">100</span>];

        <span class="macro">assert_eq!</span>(
            encode_to_slice(<span class="string">b&quot;kiwis&quot;</span>, <span class="kw-2">&amp;mut </span>output_3),
            <span class="prelude-val">Err</span>(FromHexError::InvalidStringLength)
        );
    }

    <span class="attribute">#[test]
    </span><span class="kw">fn </span>test_decode_to_slice() {
        <span class="kw">let </span><span class="kw-2">mut </span>output_1 = [<span class="number">0</span>; <span class="number">4</span>];
        decode_to_slice(<span class="string">b&quot;6b697769&quot;</span>, <span class="kw-2">&amp;mut </span>output_1).unwrap();
        <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>output_1, <span class="string">b&quot;kiwi&quot;</span>);

        <span class="kw">let </span><span class="kw-2">mut </span>output_2 = [<span class="number">0</span>; <span class="number">5</span>];
        decode_to_slice(<span class="string">b&quot;6b69776973&quot;</span>, <span class="kw-2">&amp;mut </span>output_2).unwrap();
        <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>output_2, <span class="string">b&quot;kiwis&quot;</span>);

        <span class="kw">let </span><span class="kw-2">mut </span>output_3 = [<span class="number">0</span>; <span class="number">4</span>];

        <span class="macro">assert_eq!</span>(
            decode_to_slice(<span class="string">b&quot;6&quot;</span>, <span class="kw-2">&amp;mut </span>output_3),
            <span class="prelude-val">Err</span>(FromHexError::OddLength)
        );
    }

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">fn </span>test_encode() {
        <span class="macro">assert_eq!</span>(encode(<span class="string">&quot;foobar&quot;</span>), <span class="string">&quot;666f6f626172&quot;</span>);
    }

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">fn </span>test_decode() {
        <span class="macro">assert_eq!</span>(
            decode(<span class="string">&quot;666f6f626172&quot;</span>),
            <span class="prelude-val">Ok</span>(String::from(<span class="string">&quot;foobar&quot;</span>).into_bytes())
        );
    }

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">pub fn </span>test_from_hex_okay_str() {
        <span class="macro">assert_eq!</span>(Vec::from_hex(<span class="string">&quot;666f6f626172&quot;</span>).unwrap(), <span class="string">b&quot;foobar&quot;</span>);
        <span class="macro">assert_eq!</span>(Vec::from_hex(<span class="string">&quot;666F6F626172&quot;</span>).unwrap(), <span class="string">b&quot;foobar&quot;</span>);
    }

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">pub fn </span>test_from_hex_okay_bytes() {
        <span class="macro">assert_eq!</span>(Vec::from_hex(<span class="string">b&quot;666f6f626172&quot;</span>).unwrap(), <span class="string">b&quot;foobar&quot;</span>);
        <span class="macro">assert_eq!</span>(Vec::from_hex(<span class="string">b&quot;666F6F626172&quot;</span>).unwrap(), <span class="string">b&quot;foobar&quot;</span>);
    }

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">pub fn </span>test_invalid_length() {
        <span class="macro">assert_eq!</span>(Vec::from_hex(<span class="string">&quot;1&quot;</span>).unwrap_err(), FromHexError::OddLength);
        <span class="macro">assert_eq!</span>(
            Vec::from_hex(<span class="string">&quot;666f6f6261721&quot;</span>).unwrap_err(),
            FromHexError::OddLength
        );
    }

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">pub fn </span>test_invalid_char() {
        <span class="macro">assert_eq!</span>(
            Vec::from_hex(<span class="string">&quot;66ag&quot;</span>).unwrap_err(),
            FromHexError::InvalidHexCharacter { c: <span class="string">&#39;g&#39;</span>, index: <span class="number">3 </span>}
        );
    }

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">pub fn </span>test_empty() {
        <span class="macro">assert_eq!</span>(Vec::from_hex(<span class="string">&quot;&quot;</span>).unwrap(), <span class="string">b&quot;&quot;</span>);
    }

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">pub fn </span>test_from_hex_whitespace() {
        <span class="macro">assert_eq!</span>(
            Vec::from_hex(<span class="string">&quot;666f 6f62617&quot;</span>).unwrap_err(),
            FromHexError::InvalidHexCharacter { c: <span class="string">&#39; &#39;</span>, index: <span class="number">4 </span>}
        );
    }

    <span class="attribute">#[test]
    </span><span class="kw">pub fn </span>test_from_hex_array() {
        <span class="macro">assert_eq!</span>(
            &lt;[u8; <span class="number">6</span>] <span class="kw">as </span>FromHex&gt;::from_hex(<span class="string">&quot;666f6f626172&quot;</span>),
            <span class="prelude-val">Ok</span>([<span class="number">0x66</span>, <span class="number">0x6f</span>, <span class="number">0x6f</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x72</span>])
        );

        <span class="macro">assert_eq!</span>(
            &lt;[u8; <span class="number">5</span>] <span class="kw">as </span>FromHex&gt;::from_hex(<span class="string">&quot;666f6f626172&quot;</span>),
            <span class="prelude-val">Err</span>(FromHexError::InvalidStringLength)
        );
    }

    <span class="attribute">#[test]
    #[cfg(feature = <span class="string">&quot;alloc&quot;</span>)]
    </span><span class="kw">fn </span>test_to_hex() {
        <span class="macro">assert_eq!</span>(
            [<span class="number">0x66</span>, <span class="number">0x6f</span>, <span class="number">0x6f</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x72</span>].encode_hex::&lt;String&gt;(),
            <span class="string">&quot;666f6f626172&quot;</span>.to_string(),
        );

        <span class="macro">assert_eq!</span>(
            [<span class="number">0x66</span>, <span class="number">0x6f</span>, <span class="number">0x6f</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x72</span>].encode_hex_upper::&lt;String&gt;(),
            <span class="string">&quot;666F6F626172&quot;</span>.to_string(),
        );
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="hex" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>