initSidebarItems({"attr":[["ast_node","Alias for `#[derive(Spanned, Fold, Clone, Debug, PartialEq)]` for a struct and `#[derive(Spanned, Fold, Clone, Debug, PartialEq, FromVariant)]` for an enum."],["ast_serde","Derives `serde::Serialize` and `serde::Deerialize`."]],"constant":[["DUMMY_SP","Dummy span, both position and length are zero, syntax context is zero as well."],["NO_EXPANSION",""]],"derive":[["DeserializeEnum",""],["EqIgnoreSpan","Fields annotated with `#[not_panned]` or `#[use_eq]` will use` ==` instead of `eq_ignore_span`."],["FromVariant",""],["Spanned",""],["TypeEq","Field annotated with `#[use_eq]` will be compared using `==`.Field annotated with `#[not_type]` will be ignored"]],"enum":[["FileName","Differentiates between real files and common virtual files."],["SpanLinesError",""],["SpanSnippetError",""]],"macro":[["add_bitflags","rustfmt-friendly version of `bitflags!`."],["chain","Chains multiple visitor."],["impl_stable_hash_via_hash",""]],"mod":[["comments",""],["errors",""],["hygiene","Machinery for hygienic macros, inspired by the `MTWT[1]` paper."],["input",""],["iter",""],["macros",""],["pass","This module reexports items from `swc_visit` with some swc-specific traits."],["serializer",""],["source_map","The SourceMap tracks all the source code used within a single crate, mapping from integer byte positions to the original source code location. Each bit of source parsed during crate parsing (typically files, in-memory strings, or various bits of macro expansion) cover a continuous range of bytes in the SourceMap and are represented by SourceFiles. Byte positions are stored in `spans` and used pervasively in the compiler. They are absolute positions within the SourceMap, which upon request can be converted to line and column information, source code snippets, etc."],["sync","This module defines types which are thread safe if `cfg!(feature = \"concurrent\")` is true."],["util",""]],"static":[["GLOBALS","Storage for span hygiene data."]],"struct":[["BytePos","A byte offset. Keep this small (currently 32-bits), as AST contains a lot of them."],["CharPos","A character offset. Because of multibyte utf8 characters, a byte offset is not equivalent to a character offset. The SourceMap will convert BytePos values to CharPos values as necessary."],["FileLines",""],["Globals",""],["LineCol","Used to create a `.map` file."],["Loc","A source code location used for error reporting"],["LocWithOpt","A source code location used as the result of `lookup_char_pos_adj`"],["Mark","A mark is a unique id associated with a macro expansion."],["MultiSpan","A collection of spans. Spans have two orthogonal attributes:"],["SourceFile","A single source in the SourceMap."],["SourceFileAndBytePos",""],["SourceFileAndLine",""],["Span","Spans represent a region of code, used for error reporting. Positions in spans are absolute positions from the beginning of the `source_map`, not positions relative to `SourceFile`s. Methods on the `SourceMap` can be used to relate spans back to the original source. You must be careful if the span crosses more than one file - you will not be able to use many of the functions on spans in `source_map` and you cannot assume that the length of the `span = hi - lo`; there may be space in the `BytePos` range between files."],["SyntaxContext","A SyntaxContext represents a chain of macro expansions (represented by marks)."]],"trait":[["AstNode","A trait for ast nodes."],["EqIgnoreSpan","Derive with `#[derive(EqIgnoreSpan)]`."],["Spanned","Derive"],["TypeEq","Derive with `#[derive(TypeEq)]`."]]});